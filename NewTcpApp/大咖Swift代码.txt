//
//  BaseRequest.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/2.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
let manager = AFHTTPSessionManager.init(sessionConfiguration: URLSessionConfiguration.default)
class BaseRequest: NSObject {
    
   
    
   
    //MARK:----------------------AF网络请求相关----------------------
    
    public static func initManager()->(AFHTTPSessionManager)
    {
        
        manager.requestSerializer = AFHTTPRequestSerializer()
        manager.responseSerializer = AFHTTPResponseSerializer()
        manager.responseSerializer.acceptableContentTypes = NSSet(object: "text/html") as? Set<String>
//            [NSSet setWithObject:@"text/html"]
        return manager
    }
    
    //MARK:----------------------POST请求先关----------------------
    /// post请求
    ///
    /// - Parameters:
    ///   - url: 请求地址
    ///   - params: 请求参数
    ///   - hadToast: 是否添加提醒
    ///   - fail: 失败返回闭包(返回空闭包)
    ///   - success: 成功返回闭包
    public static func basePost(url:String,params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
       let manager = self.initManager()
        let task:URLSessionDataTask? =  manager.post(url, parameters: params, headers: nil, progress: nil, success: { (task:URLSessionDataTask, any:Any) in
         if any is Dictionary<String, Any>{
            
             //TODO:(harry标注)-- 等接口能用的时候 考虑是否只返回 data中的数据
             success(any as! Dictionary<String, Any>)
         }else{
            let str = String.init(data: any as! Data, encoding: String.Encoding.utf8)
            print(str ?? "")
            let dic = try?JSONSerialization.jsonObject(with: any as! Data, options: JSONSerialization.ReadingOptions.allowFragments) as! Dictionary<String, Any>
            if String.changeToString(inValue: dic?["code"] ?? "2") == "1" {
                if dic?["data"] is Dictionary<String, Any>{
                    success(dic?["data"] as! Dictionary<String, Any>)
                }else{
                    success(dic!)
                }
            }else{
                print(String.changeToString(inValue: dic?["msg"] ?? "错了"))
                if (dic != nil){
                    fail(dic!)
                }
                
                if hadToast == true{
                    SVProgressHUD.showError(withStatus: String.changeToString(inValue: dic?["msg"] ?? "出现错误"))
                    SVProgressHUD.dismiss(withDelay: 0.5)
                }
                
            }
//            [[NSString alloc] initWithData:data  encoding:NSUTF8StringEncoding]
            
        }
        }) { (task:URLSessionDataTask?,err:Error) in
            
            if hadToast == true{
             SVProgressHUD.showError(withStatus: "网络出现错误")
             SVProgressHUD.dismiss(withDelay: 0.5)
            }
            let view = UIApplication.shared.keyWindow?.viewWithTag(10086)
            if view is UITableView {
                (view as! UITableView).mj_header?.endRefreshing()
            }
           print(err.localizedDescription.description )
        }
        task?.resume()
    }
    
    
    
    
    //MARK:----------------------Json 与 String 互转----------------------
    
    /// 将类转化为json串
    ///
    /// - Parameter object: 需要转化的类
    /// - Returns: 返回转换后的json串
    public static func makeJsonStringWithObject(object:Any)->(String)
    {
        let result :Data = try! JSONSerialization.data(withJSONObject: object, options: JSONSerialization.WritingOptions.prettyPrinted)
        let jsonStr:String = String.init(data: result, encoding: .utf8)!
       return jsonStr
    }
    
    
    /// 将json串转成类
    ///
    /// - Parameter jsonStr: 需要转化的json串
    /// - Returns: 返回转换后的类
    public static func makeJsonWithString(jsonStr:String)->(Any)
    {
        let data:Data = jsonStr.data(using: .utf8)!
        let result = try! JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions.mutableContainers)
        return result
    }
    
    
    
    //MARK:----------------------MD5加密----------------------
    
    /// MD5 加密
    ///
    /// - Parameter str: 需要加密的字符串
    /// - Returns: MD5加密后的字符串
    public static func md5StringFromString(str:String)->(String?)
    {
        guard !str.isEmpty  else {
            return nil
        }
        
        let cStr = str.cString(using: String.Encoding.utf8);
        let buffer = UnsafeMutablePointer<UInt8>.allocate(capacity: 16)
        CC_MD5(cStr!,(CC_LONG)(strlen(cStr!)), buffer)
        let md5String = NSMutableString();
        for i in 0 ..< 16{
            md5String.appendFormat("%02x", buffer[i])
        }
        free(buffer)
        return md5String as String
    }
    
    
    
   //MARK:----------------------其他相关----------------------
    
   /// 获取当前所在的最前边的UIViewController
   ///
   /// - Returns: 返回
   public static func appTopController() ->(UIViewController)
    {
        let appRoot = UIApplication.shared.keyWindow?.rootViewController
        var topVC = appRoot
    while ((topVC?.children) != nil) {
            if topVC! is UITabBarController {
                topVC = (topVC! as! UITabBarController).selectedViewController
            }
            else if topVC! is UINavigationController
            {
               topVC = (topVC! as! UINavigationController).visibleViewController
            }
            else
            {
                break
            }
        }
        
        return topVC!
    }
    
    
    
    /// 错误提醒
    ///
    /// - Parameters:
    ///   - code: 错误码
    ///   - message: 错误具体信息
    public static func analysisFailMessage(code:String,message:String)->()
    {
    
    
    }
}
//
//  GroupRequest.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/3.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
//关于群组相关的请求
class GroupRequest: BaseRequest {
    
    /// 入群申请
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID msg:申请说明
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func groupJoinApply(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_JoinApply), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 批准入群申请
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token applyid:申请ID status:审核结果（1:同意入群;2:拒绝入群）
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func groupJoinApplyAudit(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_JoinApplyAudit), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 使用验证码加入群组
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID auth_code:群组验证码
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func groupJoinByCode(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_JoinByCode), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 扫描二维码加入群组
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID verify_code:群组验证码
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func groupJoinByQr(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_JoinByQr), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    /// 创建群组
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func creat(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Create), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
        
//        self.basePost(url: "", params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    
    
    /// 修改群组
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID group_name:群组名称
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func update(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Update), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 是否开放
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID is_open:公开状态（0不公开，1公开）
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func setOpen(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_SetOpen), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 退出群组
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func quit(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Quit), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 解散群组
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回{"code":1,"msg":"","data":null}
    public static func dismiss(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
         self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Dismiss), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 群组成员
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func userList(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: "", params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 删除群组成员
    ///
    /// - Parameters:
    ///   - params: 请求参数 appToken:App登录Token groupId:群组ID userIdStr:删除的用户ID（,分割）
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func delUser(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_DelUser), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 获取加入群组
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func myGroupList(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: "", params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 访问服务端获取用户信息
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func getUserByIds(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: "", params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 搜索群组
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func search(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Search), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 置顶群组
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func setTop(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: "", params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 获取群组信息
    ///
    /// - Parameters:
    ///   - params: 请求参数  app_token:App登录Token groupid:群组ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func info(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Info), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 邀请加入
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID userid_str:邀请用户ID字符串（,分割）
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func inviteUser(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_InviteUser), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 接受邀请加入
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token inviteid:邀请ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func acceptInvite(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        //group_AcceptInvite
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_AcceptInvite), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 主动加入
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func requestJoin(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: "", params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 验证码加入
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func joinByAuthCode(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: "", params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 二维码加入
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func join(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: "", params: params, hadToast: hadToast, fail: fail, success: success);
    }
    /// 获取二维码
    ///
    /// - Parameters:
    ///   - params: 请求参数 appToken:App登录Token groupId:群组ID authCode:群组验证码
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func getQrCode(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Qr_code), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    /// 加入公共群组
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token 
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func joinPublicGroup(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_JoinPublicGroup), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    /// 获取话题列表
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID keyword:关键词(非必填) is_join是否加入（默认:-1不限;0:未加入;1:加入)(非必填） offset当前页（默认:1）(非必填) length每页记录数（默认:-1不限）(非必填)
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func getSubjectList(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_SubjectList), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: DataOperation.saveSimpleListDataWithTable(table: GroupModel.self, success: success));
    }
    
    /// 创建话题
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token groupid:群组ID title:标题(必填) msg_uid消息UID(非必填） file_json话题图片数据(非必填)
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func createGroupSubject(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Create_subject), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 修改话题
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token sub_groupid:话题ID title:标题(必填)
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func updateGroupSubject(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Update_subject), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    /// 解散话题
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token sub_groupid:话题ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func dismissGroupSubject(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Dismiss_subject), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 多选消息
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token sub_groupid:话题ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func forwardGroupSubject(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Forward_Subject), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
 
    /// 退出话题
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token sub_groupid:话题ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func quitGroupSubject(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Quit_subject), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 结束辅导
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token sub_groupid:话题ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func finishOnlineConsult(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Finish_Online_Consult), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 获取话题信息
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token sub_groupid:话题ID 
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func getGroupSubjectInfo(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Subject_info), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: DataOperation.saveThemeInfoData(success: success));
    }
    
    /// 加入话题
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token sub_groupid:话题ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func joinGroupSubject(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Join_subject), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    /// 查看话题历史记录
    ///
    /// - Parameters:
    ///   - params: 请求参数 app_token:App登录Token sub_groupid:话题ID  lasttime:最近获取消息时间 length:取消息记录数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func getGroupSubjectHistorymsg(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: group_Subject_msg_history), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    /// 图片上传（仅限图片类型）
    ///
    /// - Parameters:
    ///   - image: 图片
    ///   - params: 请求参数 groupid:群组ID ,maxLimit : int 是否尺寸限制（可选，1：有限制，0：无限制，默认0）,maxWidth： int 最大高度（可选，maxLimit为true时有效、必传）,maxHeight： int 最大宽度（可选，maxLimit为true时有效、必传）,thumb： int 是否要缩略图（可选，1：缩略，0：无缩略，默认0）,thumbWidht： int 缩略图宽度（可选，thumb为true时有效、必传）,thumbHeight： int 缩略图高度（可选，thumb为true时有效、必传）
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func uploadImage(image: UIImage, params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        let manager = BaseRequest.initManager()
        //HEADER 参数（用于服务端接口识别APP）：
        manager.requestSerializer.setValue("app", forHTTPHeaderField: "xslpdevice")
        manager.requestSerializer.setValue(sharePublicDataSingle.token as String, forHTTPHeaderField: "token")
        
//        let postTask: URLSessionDataTask? = manager.post("http://tcp.xslp.cn/index.php/Api/Im/uploadImg", parameters: params, constructingBodyWith: { (formData:AFMultipartFormData) in //正式
        let postTask: URLSessionDataTask? = manager.post(kBASE_URL + "index.php/Api/Im/uploadImg", parameters: params, headers: nil, constructingBodyWith: { (formData:AFMultipartFormData) in
            
            var imageData = image.jpegData(compressionQuality: 1)
            if (imageData?.count)! > 1024*1024 { //1M以及以上
                imageData = image.jpegData(compressionQuality: 0.1)
            }else if (imageData?.count)! > 512*1024 { //0.5M-1M
                imageData = image.jpegData(compressionQuality: 0.5)
            }else  if (imageData?.count)! > 200*1024 { //0.25M-0.5M
                imageData = image.jpegData(compressionQuality: 0.9)
            }
            
            let interval : TimeInterval = Date().timeIntervalSince1970 * 1000
            formData.appendPart(withFileData: imageData!, name: "uploadfile", fileName: "\(interval)-image.jpg", mimeType: "image/jpg")
        }, progress: { (uploadProgress:Progress) in
            
        }, success: { (task:URLSessionDataTask, responseObject:Any?) in
            if responseObject is Dictionary<String, Any>{
                
                //TODO:(harry标注)-- 等接口能用的时候 考虑是否只返回 data中的数据
                success(responseObject as! Dictionary<String, Any>)
            }else{
                let str = String.init(data: responseObject as! Data, encoding: String.Encoding.utf8)
                print(str ?? "")
                let dic = try?JSONSerialization.jsonObject(with: responseObject as! Data, options: JSONSerialization.ReadingOptions.allowFragments) as! Dictionary<String, Any>
                if String.changeToString(inValue: dic?["errcode"] ?? "1") == "0" {
                    if dic?["data"] is Dictionary<String, Any>{
                        success(dic?["data"] as! Dictionary<String, Any>)
                    }else{
                        success(dic!)
                    }
                }else{
                    print(String.changeToString(inValue: dic?["msg"] ?? "某张图片上传失败，请注意查看！"))
                    if (dic != nil){
                        fail(dic!)
                    }
                    
                    if hadToast == true{
                        SVProgressHUD.showError(withStatus: String.changeToString(inValue: dic?["msg"] ?? "某张图片上传失败，请注意查看！"))
                        SVProgressHUD.dismiss(withDelay: 0.5)
                    }
                }
            }
        }, failure: { (task:URLSessionDataTask?, error:Error) in
            if hadToast {
                SVProgressHUD.showError(withStatus: "网络出现错误")
                SVProgressHUD.dismiss(withDelay: 0.5)
            }
            print(error.localizedDescription.description )
        })
        postTask?.resume()
    }
}
//
//  UserRequest.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/3.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
//用户管理相关
class UserRequest: BaseRequest {
    /// 获取用户Token
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func getToken(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: im_GetToken), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
//        self.basePost(url: data_Init, params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 获取初始化数据
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func initData(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        
        if sharePublicDataSingle.updateTime == (params["updatetime"] as! String) {
            sharePublicDataSingle.addSuccesB(success: success)
            print("addSucc:\(sharePublicDataSingle.successNum)")
            return
        }else{
            sharePublicDataSingle.updateTime = (params["updatetime"] as! String)
//            sharePublicDataSingle.successList.removeAll()
//            sharePublicDataSingle.successB = nil
            sharePublicDataSingle.addSuccesB(success: success)
            
            print("NewSucc:\(sharePublicDataSingle.successNum)")
        }
        print("NewSuccB:\(sharePublicDataSingle.successB == nil) \n \(params)")
        if sharePublicDataSingle.successB == nil {
            UserRequest.initData(params: params, hadToast: hadToast, fail: fail, success: success)
            return
        }else{
            self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: im_InitData), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: DataOperation.saveInitData(success: sharePublicDataSingle.successB!));
        }
        //        self.basePost(url: data_Init, params: params, hadToast: hadToast, fail: fail, success: success);
    }
    
    
    /// 获取用户信息
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func userInfo(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: im_UserInfo), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    
    
    
    /// 获取用户信息列表
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func userList(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrl(params: params, methodName: im_UserList), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success);
    }
    
    /// 获取好友列表
    ///
    /// - Parameters:
    ///   - params: 请求参数  app_token:App登录Token
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func friends(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: im_Friends), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: DataOperation.saveFriendsData(success: success));
    }
    /// 查找用户
    ///
    /// - Parameters:
    ///   - params: 请求参数  app_token:App登录Token keyword:关键词（匹配用户名、邮箱、手机)
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func searchUser(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: im_Search_user), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: DataOperation.saveFriendsData(success: success))
    }
    /// 撤回消息
    ///
    /// - Parameters:
    ///   - params: 请求参数  app_token:App登录Token msg_uid:融云消息ID  groupid:群组/话题ID
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func withdraw_message(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: im_Withdraw_message), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success)
    }
    
    
    // 获取部门/其他部分成员
    ///
    /// - Parameters:
    ///   - params: 请求参数  app_token:App登录Token
    ///   - hadToast: 是否提醒
    ///   - fail: 失败返回
    ///   - success: 成功返回
    public static func coachSearchUser(params:Dictionary<String, Any>,hadToast:Bool,fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->())
    {
        self.basePost(url: SignTool.getSignUrlNotoken(params: params, methodName: im_Coach_Search_User), params: ["param_json":SignTool.makeJsonStrWith(object: params)], hadToast: hadToast, fail: fail, success: success)
    }
}
//
//  URL.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/3.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
// t-gw.xslp.cn 
//MARK:----------------------初始化----------------------
//测试环境
//let kBASE_URL = "http://t-tcp.xs815.com/"
//内测环境
//let kBASE_URL = "http://ka.xslp.cn/"
//生产环境
let kBASE_URL = "http://tcp.xslp.cn/"
//融云App_key
let kRCIM_APPKEY = "sfci50a7sqloi" //正式环境
//let kRCIM_APPKEY = "qf3d5gbjqpxeh" //测试环境
//let host_url = "http://t-c-gw.xslp.cn/index.php?" //网络接口
let host_url = "http://api.xslp.com/index.php?" //网络接口 //正式
//let host_url = "http://192.168.1.100/" //网络接口 192.168.1.100
let data_Init = "index.php" //初始化数据
//MARK:----------------------群组相关----------------------
let group_Create = "tcp.group.create"   //创建群组
let group_Update = "tcp.group.update"   //修改群组
let group_SetOpen = "tcp.group.set_open" //设置群组是否开放
let group_Quit = "tcp.group.quit"       //退出群组
let group_Dismiss = "tcp.group.dismiss"  //解散群组
let group_UserList = "tcp.group.userList"  //群组成员
let group_DelUser = "tcp.group.del_user"  //删除群组成员
let group_MyGroupList = "tcp.group.myGroupList"  //获取加入的群组信息
let group_GetUserByIds = "tcp.group.getUserByIds"  //访问服务端获取用户信息
let group_Search = "tcp.group.search"  //搜索群组
let group_SetTop = "tcp.group.setTop"  //置顶
let group_Info = "tcp.group.info"  //获取群组信息
let group_InviteUser = "tcp.group.cloud_coach_invite"  //邀请加入群
let group_AcceptInvite = "tcp.group.accept"  //接收邀请加入
let group_RequestJoin = "tcp.group.requestJoin"  //主动加入
let group_JoinByQr = "tcp.group.join_by_qr"  //二维码加入
let group_JoinApply = "tcp.group.join_apply"  //入群申请
let group_JoinApplyAudit = "tcp.group.join_audit"  //批准入群申请
let group_JoinByCode = "tcp.group.join_by_code"  //使用验证码加入群
let group_Qr_code   = "tcp.group.qr_code"  //获取二维码
let group_JoinPublicGroup   = "tcp.group.join_public_group"  //加入公共群组
//MARK:----------------------话题相关----------------------
let group_SubjectList = "tcp.group.subject_list" //话题列表
let group_Create_subject = "tcp.group.create_subject" //创建话题
let group_Quit_subject = "tcp.group.quit_subject" //退出话题
let group_Subject_info = "tcp.group.subject_info" //话题信息
let group_Join_subject = "tcp.group.join_subject" //加入话题
let group_Finish_Online_Consult = "tcp.group.finish_online_consult" //结束辅导
let group_Update_subject = "tcp.group.update_subject" //修改话题
let group_Dismiss_subject = "tcp.group.dismiss_subject" //解散话题
let group_Forward_Subject = "tcp.group.forward_group_msg"//转推组群
let group_Subject_msg_history = "tcp.group.subject_msg_history"//查看话题历史记录
//MARK:----------------------用户管理相关----------------------
let im_GetToken = "tcp.im.get_token"  //获取token
let im_InitData = "tcp.im.sync"  //初始化数据
let im_UserInfo = "tcp.im.user_info"  //获取用户信息
let im_UserList = "tcp.im.user_list"  //获取多个用户信息
let im_Friends = "tcp.im.friends"  //获取好友列表
let im_Search_user = "tcp.im.search_user"  //查找用户
let im_Withdraw_message = "tcp.im.withdraw_message"  //撤回消息
let im_Coach_Search_User = "tcp.im.cloud_coach_search_user" //搜索部门/其它部门成员
//
//  SignTool.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/15.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
let KSecret = "f0c5ccf7d9b775bb8a92664522b03f02"
let KAppKey = "106"
class SignTool: NSObject {
    
    
}
//MARK: - ---------------------对外接口----------------------
extension SignTool{
    
    
    /// 获取签名后的Url  不要添加token
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - methodName: 请求方法名
    /// - Returns: 返回签名后的url
    public static func getSignUrlNotoken(params:Dictionary<String, Any>,methodName:String)->(String)
    {
       var url = String()
        url = host_url + self.signWith(params: params , methodName: methodName, needToken: false)
       return url
    }
    
    
    /// 获取签名后的url  需要token
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - methodName: 方法名称
    /// - Returns: 返回签名后的url
    public static func getSignUrl(params:Dictionary<String, Any>,methodName:String)->(String)
    {
        var url = String()
        url = host_url + self.signWith(params: params , methodName: methodName, needToken: true)
        return url
    }
    
    
    
    
    /// 做签名加密
    ///
    /// - Parameters:
    ///   - params: 请求参数
    ///   - methodName: 请求接口名称
    ///   - needToken: 是否需要加入token
    /// - Returns: 返回加密后的签名
    public static func signWith(params:Dictionary<String, Any>,methodName:String,needToken:Bool)->(String)
    {
       
        if needToken == true {
           //需要token
          let signDic:NSDictionary = ["app_key":KAppKey,
                                        "method":methodName,
                                        "access_token":sharePublicDataSingle.publicData.access_token,
                                        "timestamp":self.timeStamp(),
                                        "v":"V10",
                                        
            ]
          
         let md5SignStr = self.md5SignWith(params: signDic, paramsJsonStr: self.makeJsonStrWith(object: params)).uppercased()
            
            let finalStr = String.init(format: "app_key=%@&v=%@&method=%@&timestamp=%@&sign=%@&access_token=%@",signDic["app_key"] as! String, signDic["v"] as! String, signDic["method"] as! String,signDic["timestamp"] as! String, md5SignStr,signDic["access_token"] as! String)
         return finalStr
        }
        else
        {
          
            let signDic:NSDictionary = ["app_key":KAppKey,
                                        "method":methodName,
//                                        "access_token":self.getToken(),
                                        "timestamp":self.timeStamp(),
                                        "v":"V10",
                                        "access_token":"",
                                        ]
            
            let md5SignStr = self.md5SignWith(params: signDic, paramsJsonStr: self.makeJsonStrWith(object: params)).uppercased()
            
            
            let finalStr = String.init(format: "app_key=%@&v=%@&method=%@&timestamp=%@&sign=%@&access_token=",signDic["app_key"] as! String, signDic["v"] as! String, signDic["method"] as! String, signDic["timestamp"] as! String, md5SignStr)
            return finalStr
            
        }
        
     
    }
    
}
//MARK: - ---------------------本类内部方法，不对外提供----------------------
extension SignTool
{
    
    /// 获取token
    ///
    /// - Returns: 返回token
    fileprivate static func getToken()->(String)
    {
       return "123"
    }
    
    
    /// 做MD5加密
    ///
    /// - Parameters:
    ///   - params: <#params description#>
    ///   - paramsJsonStr: <#paramsJsonStr description#>
    /// - Returns: <#return value description#>
    fileprivate static func md5SignWith(params:NSDictionary,paramsJsonStr:String)->(String)
    {
//        if params["access_token"] == nil {
//            let str = String.init().appending(KSecret)
//                .appending("access_token")
//                .appending("app_key")
//                .appending(KAppKey)
//                .appending("method")
//                .appending(params["method"] as! String)
//                .appending("param_json")
//                .appending(paramsJsonStr)
//                .appending("timestamp")
//                .appending(params["timestamp"] as! String)
//                .appending("v")
//                .appending(params["v"] as! String)
//                .appending(KSecret);
//            
//            
////            let str = String.init(format: "%@app_key%@method%@param_json%@timestamp%@v%@%@", KSecret,params["app_key"] as! String,params["method"] as! String,paramsJsonStr,params["timestamp"] as! String,params["v"] as! String,KSecret)
//            return BaseRequest.md5StringFromString(str: str)!
//        }
//        else
//        {
//            let str = String.init(format: "%@access_token%@app_key%@method%@param_json%@timestamp%@v%@%@", KSecret,params["access_token"] as! String,params["app_key"] as! String,params["method"] as! String,paramsJsonStr,params["timestamp"] as! String,params["v"] as! String,KSecret)
//            return BaseRequest.md5StringFromString(str: str)!
//            
//        }
        var str = String.init().appending(KSecret)
            .appending("access_token")
            
        if params["access_token"] as! String != "" {
            str = str.appending(params["access_token"] as! String)
        }
        str = str.appending("app_key")
            .appending(KAppKey)
            .appending("method")
            .appending(params["method"] as! String)
            .appending("param_json")
            .appending(paramsJsonStr)
            .appending("timestamp")
            .appending(params["timestamp"] as! String)
            .appending("v")
            .appending(params["v"] as! String)
            .appending(KSecret);
        
        
        //            let str = String.init(format: "%@app_key%@method%@param_json%@timestamp%@v%@%@", KSecret,params["app_key"] as! String,params["method"] as! String,paramsJsonStr,params["timestamp"] as! String,params["v"] as! String,KSecret)
        return BaseRequest.md5StringFromString(str: str)!
    
    }
    
    
    /// 做json串处理
    ///
    /// - Parameter object: <#object description#>
    static func makeJsonStrWith(object:Any)->(String)
    {
      return  BaseRequest.makeJsonStringWithObject(object: object)
    }
    
    
    /// 获取时间戳
    ///
    /// - Returns: <#return value description#>
    fileprivate static func timeStamp()->(String)
    {
       let timeStamp = NSDate.timeIntervalSinceReferenceDate
       return String.init(format: "%0.f", timeStamp)
        
    }
    
}
//
//  PrivateListViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2018/2/13.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class PrivateListViewController: RCConversationListViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Do any additional setup after loading the view.
        self.configNav()
        view.backgroundColor = UIColor.white
        self.title = "单聊列表"
        
        self.isShowNetworkIndicatorView = true
        self.setDisplayConversationTypes([RCConversationType.ConversationType_PRIVATE.rawValue])
        //        self.setCollectionConversationType([RCConversationType.ConversationType_PRIVATE.rawValue])
        self.showConnectingStatusOnNavigatorBar = true
        self.conversationListTableView.mj_header? = MJRefreshNormalHeader(refreshingTarget: self, refreshingAction:#selector(headerRefresh))
        self.progressShow()
        self.getRemoteMessage(success: {
            self.progressDismiss()
        }, error: {
            self.progressDismiss()
        })
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    @objc func headerRefresh(){
        self.progressShow()
        self.getRemoteMessage(success: {
            self.progressDismiss()
        }, error: {
            self.progressDismiss()
        })
    }
    
    /*
     // MARK: - Navigation
     
     // In a storyboard-based application, you will often want to do a little preparation before navigation
     override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
     // Get the new view controller using segue.destinationViewController.
     // Pass the selected object to the new view controller.
     }
     */
    
    override func willReloadTableData(_ dataSource: NSMutableArray!) -> NSMutableArray! {
        let arr = super.willReloadTableData(dataSource)
        let data = RCIMClient.shared().getConversationList([RCConversationType.ConversationType_PRIVATE.rawValue])
        print(arr)
        print(data)
        return arr
    }
    
    //重写RCConversationListViewController的onSelectedTableRow事件
    override func onSelectedTableRow(_ conversationModelType: RCConversationModelType, conversationModel model: RCConversationModel!, at indexPath: IndexPath!) {
        //打开会话界面
        print(model)
        //        RCConversationViewController * rcc = [[RCConversationViewController alloc] initWithConversationType:ConversationType_PRIVATE targetId:command.arguments[0]];
        //        rcc.title = command.arguments[1];
//        let rcc = RCConversationViewController.init(conversationType: model.conversationType, targetId: model.targetId)
        let rcc = SingleChatVC.init(conversationType: model.conversationType, targetId: model.targetId)
        self.navigationController?.pushViewController(rcc!, animated: true)
    }
    func getRemoteMessage(success: (() -> ())!, error: (() -> ())!) {
        let plist = PrivateUserModel.allObjects()
        var realArr : Array<String> = []
        for i in 0..<plist.count {
            realArr.append((plist[i] as! PrivateUserModel).id)
        }
        self.getRemoteHistoryMessages(from: 0, plist: realArr,successCount:0)
    }
    
    func getRemoteHistoryMessages(from:Int ,plist:Array<String>, successCount:Int) {
        
        if from == plist.count { //全部获取一遍并且有成功的(不能保证全部成功)
            self.progressDismiss()
            self.conversationListTableView.mj_header?.endRefreshing()
            if  successCount > 0 {//有成功的(不能保证全部成功)
                let arr = RCIMClient.shared().getConversationList([RCConversationType.ConversationType_PRIVATE.rawValue]) as NSArray
                for conversation in arr {
                    self.conversationListDataSource.add(RCConversationModel.init(conversation: (conversation as! RCConversation), extend: nil))
                }
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                UserDefaults.standard.set(false, forKey: getRemoteKey + username)
                self.refreshConversationTableViewIfNeeded()
            }
            return
        }
        let pId : String = plist[from]
        DispatchQueue.main.async {
            RCIMClient.shared().getRemoteHistoryMessages(.ConversationType_PRIVATE, targetId: pId, recordTime: 0, count: 5, success: { [weak self](array,success) in
                if let strongSelf = self {strongSelf.getRemoteHistoryMessages(from: from + 1, plist: plist,successCount:successCount + 1)}
                }, error: { [weak self](errorCode) in
                    if let strongSelf = self {
                        strongSelf.getRemoteHistoryMessages(from: from + 1, plist: plist,successCount:successCount)
                    }
            })
        }
    }
    
}
//
//  GroupCreateVC.swift
//  NewTcpApp
//
//  Created by xslp on 2020/7/23.
//  Copyright © 2020 xslpiOS. All rights reserved.
//
import UIKit
class GroupCreateVC: BaseViewController, UISearchBarDelegate, UITableViewDelegate, UITableViewDataSource, BaseCellDelegate {
    
    //部门数据数据源
    var departDataArray:Array<RLMObject>?
    
    //其他部门的数据源
    var otherDepartDataArray:Array<RLMObject>?
    
    //选择的数据源
    var seleDepartArray:Array<RLMObject> = []
    var seleOtherDepartArray:Array<RLMObject> = []
    //群组名称
    var groupName:String = ""
    //是否是部门数据
    var isDepartmentData:Bool = true
    
    var isLoadDepartData  = false
    var isLoadOtherDepartData = false
    @objc override func rightBtnClick(button: UIButton) {
        
        if isDepartmentData {
            if self.seleDepartArray.count == 0 {return}
        }
        
        if !isDepartmentData {
            if self.seleOtherDepartArray.count == 0 {return}
        }
        
        let alert = UIAlertController.init(title: "群组名称", message: "请输入创建的群组名称", preferredStyle: .alert)
        alert.addTextField { [self] (textField) in
                textField.placeholder = "请输入群组名称"
                textField.text = groupName
        }
                   
        let cancelAction = UIAlertAction.init(title: "取消", style: .cancel) { (cancelAction) in
            let isOpenVC = GroupIsOpenVC()
            self.groupName = ""
            isOpenVC.userArray = self.isDepartmentData ? self.seleDepartArray : self.seleOtherDepartArray
            self.navigationController?.pushViewController(isOpenVC, animated: true)
        }
                   
                   let okAction = UIAlertAction.init(title: "确认", style: .default) { (okAction) in
                  let isOpenVC = GroupIsOpenVC()
                    isOpenVC.groupName = alert.textFields?.first?.text
                    self.groupName = (alert.textFields?.first?.text)!
                      isOpenVC.userArray = self.isDepartmentData ? self.seleDepartArray : self.seleOtherDepartArray
                      self.navigationController?.pushViewController(isOpenVC, animated: true)
                   }
                   
                   alert.addAction(cancelAction)
                   alert.addAction(okAction)
                   self.present(alert, animated: true, completion: nil)
    
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        
        self.title = "选择成员"
        
        view.backgroundColor = UIColor.white
        self.setRightBtnWithArray(items: ["确定"])
        
        self.createUI()
        
        
        //加载数据
        self.loadData()
    }
    
    
    func createUI() {
        
        view.addSubview(topBtnView)
        topBtnView.addSubview(departmentBtn)
        topBtnView.addSubview(otherDepartmentBtn)
        topBtnView.addSubview(topBtmLine)
        view.addSubview(searchView)
        view.addSubview(listTable)
        
        topBtnView.mas_makeConstraints { (make) in
            make?.left.right().equalTo()(view)
            make?.top.equalTo()(NAV_HEIGHT+heightOfAddtionalHeader)
            make?.height.equalTo()(55.0)
        }
        
        departmentBtn.mas_makeConstraints { (make) in
            make?.top.left().equalTo()(topBtnView)
            make?.width.equalTo()(topBtnView.mas_width)?.multipliedBy()(0.5)
            make?.bottom.equalTo()(-5.0)
        }
        
        otherDepartmentBtn.mas_makeConstraints { (make) in
            make!.top.centerY().width().height().equalTo()(departmentBtn)
            make?.right.equalTo()(topBtnView)
        }
        
        topBtmLine.mas_makeConstraints { (make) in
            make?.width.equalTo()(departmentBtn)
            make?.height.equalTo()(3)
            make?.bottom.equalTo()(topBtnView)?.offset()(-5)
        }
        searchView.mas_makeConstraints { (make) in
            make?.left.centerX()?.right()?.equalTo()(view)
            make?.height.equalTo()(50.0)
            make?.top.equalTo()(topBtnView.mas_bottom)
        }
        
        
        listTable.mas_makeConstraints { (make) in
            make?.top.equalTo()(searchView.mas_bottom)
            make?.left.right()?.centerX()?.equalTo()(view)
            make?.bottom.equalTo()(view)
        }
    }
    
   func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        
    if !isDepartmentData {
        return otherDepartDataArray != nil ?Int((otherDepartDataArray?.count)!): 0
    }
    return departDataArray != nil ?Int((departDataArray?.count)!): 0
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
      
        var cell:UITableViewCell? = tableView.dequeueReusableCell(withIdentifier: "cell")
        if cell == nil
        {
           
            let path:String? = Bundle.main.path(forResource: "BaseTableCell", ofType: "nib")
            if path == nil {
               let  aClass  = getClassWitnClassName("BaseTableCell") as! UITableViewCell.Type
                cell = aClass.init(style: .default, reuseIdentifier: "BaseTableCell")
            }
            else
            {
                cell = Bundle.main.loadNibNamed("BaseTableCell", owner: self, options: nil)?.last as! UITableViewCell?
                
            }
        }
        
        var model:RLMObject?
            
        if isDepartmentData {
            
            model = departDataArray![Int(indexPath.row)]
        }else {
            
            model = otherDepartDataArray![Int(indexPath.row)]
        }
            
        
    
        let bCell = cell as! BaseTableCell
        
        bCell.model = model
        bCell.delegate = self
        bCell.rightBtn.isHidden = true
        bCell.rightBtn.isHidden = true
        
        var seleMemberArray:Array<RLMObject>?
        if isDepartmentData {
            seleMemberArray = self.seleDepartArray
        }else {
            seleMemberArray = self.seleOtherDepartArray
        }
        
        bCell.selectImage.image = UIImage.init(named: "logic_normal")
        
        if seleMemberArray?.count ?? 0 > 0 {
            if (seleMemberArray?.contains(where: { (m) -> Bool in
                return (m as! FriendsModel).userid == (model as! FriendsModel).userid
            }))!{
                
                bCell.selectImage.image = UIImage.init(named: "logic_select")
            }
        }
        
//        if ((isDepartmentData ? seleDepartArray : seleOtherDepartArray)?.contains(where: { (m) -> Bool in
//            return (m as! FriendsModel).userid == (model as! FriendsModel).userid
//        }))!{
//            bCell.selectImage.backgroundColor = UIColor.green
//        }
//        else
//        {
//            bCell.selectImage.backgroundColor = UIColor.red
//            bCell.selectImage.image = UIImage.init(named: "logic_normal")
//        }
        
        return cell!
    }
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let model:FriendsModel = (isDepartmentData ? departDataArray : otherDepartDataArray)?[Int(indexPath.row)] as! FriendsModel
        
        let index = (isDepartmentData ? seleDepartArray : seleOtherDepartArray).firstIndex(where: { (m) -> Bool in
             return (m as! FriendsModel).userid == model.userid
         })
         if (index != nil) {
            
            if isDepartmentData {
                seleDepartArray.remove(at: index!)
            }else {
                seleOtherDepartArray.remove(at: index!)
            }
            
         }
         else
         {
            if isDepartmentData {
                seleDepartArray.append(model)
            }else {
                seleOtherDepartArray.append(model)
            }
             
         }
        
        tableView.reloadRows(at: [indexPath], with: .none)
    }
    
    //点击申请加入按钮
    func cellRightBtnClick(model: RLMObject) {
        
    }
    
    fileprivate lazy var topBtnView: UIView = {
        var topBtnView = UIView()
        topBtnView.backgroundColor = UIColor.groupTableViewBackground
        return topBtnView
    }()
    
     lazy var searchView: UISearchBar = {
        var searchView = UISearchBar.init()
        
        searchView.placeholder = "请输入用户名（邮箱/手机号）"
        searchView.returnKeyType = .search
        searchView.delegate = self
        if #available(iOS 13.0, *) {
            searchView.searchTextField.font = FONT_14
        }
        return searchView
    }()
    
    fileprivate lazy var departmentBtn: UIButton = {
        var departmentBtn = UIButton.init()
        departmentBtn.setTitleColor(UIColor.hexString(hexString: "333333"), for: .normal)
        departmentBtn.setTitleColor(UIColor.hexString(hexString: "1972D8"), for: .selected)
        departmentBtn.titleLabel?.font = FONT_14
        departmentBtn.setTitle("搜本部门", for: .normal)
        departmentBtn.addTarget(self, action: #selector(searchBtnClick(_ :)), for: .touchUpInside)
        departmentBtn.isSelected = true
        departmentBtn.tag = 100
        return departmentBtn
    }()
    
    
    fileprivate lazy var otherDepartmentBtn: UIButton = {
        var otherDepartmentBtn = UIButton.init()
        otherDepartmentBtn.setTitleColor(UIColor.hexString(hexString: "333333"), for: .normal)
        otherDepartmentBtn.setTitleColor(UIColor.hexString(hexString: "1972D8"),for: .selected)
        otherDepartmentBtn.titleLabel?.font = FONT_14
        otherDepartmentBtn.setTitle("搜其他部门", for: .normal)
        otherDepartmentBtn.addTarget(self, action: #selector(searchBtnClick(_ :)), for: .touchUpInside)
        otherDepartmentBtn.tag = 101
        return otherDepartmentBtn
    }()
    
    fileprivate lazy var topBtmLine: UIView = {
        var topBtmLine = UIView.init()
        topBtmLine.backgroundColor = UIColor.hexString(hexString: "1972D8")
        
        return topBtmLine
    }()
    
    lazy var  listTable: UITableView = {
        var listTable = UITableView.init(frame: .zero, style: .plain)
        listTable.delegate = self
        listTable.dataSource = self
        
        listTable.tableFooterView = UIView.init()
        self.automaticallyAdjustsScrollViewInsets = false
        listTable.backgroundColor = UIColor.groupTableViewBackground
        let path:String? = Bundle.main.path(forResource: "BaseTableCell", ofType: "nib")
               
               
               if path == nil {
                   
                   listTable.register(NSClassFromString("BaseTableCell"), forCellReuseIdentifier: "BaseTableCell")
               }
               else
               {
                   listTable.register(UINib.init(nibName: "BaseTableCell", bundle: Bundle.main), forCellReuseIdentifier: "cell")
               }
               
               listTable.rowHeight = 50
        return listTable
    }()
    
    
    //MARK: 搜索按钮点击
    @objc func searchBtnClick(_ btn:UIButton) {
        self.view.endEditing(true)
        
        departmentBtn.isSelected = false
        otherDepartmentBtn.isSelected = false
        btn.isSelected = true
        
        UIView.animate(withDuration: 0.25) {
            self.topBtmLine.mas_updateConstraints { (make) in
                make?.left.equalTo()(CGFloat((btn.tag-100))*kScreenW/2.0)
            }
            
            self.topBtmLine.superview?.layoutIfNeeded()
        }
        
        if btn.tag == 100 {
            //部门人员
            if isDepartmentData {
                return;
            }
            
            isDepartmentData = true
            if !isLoadDepartData {
                self.loadData()
            }
            
        }else {
            //其他部门人员
            if !isDepartmentData {
                return;
            }
            
            isDepartmentData = false
            if !isLoadOtherDepartData {
                self.loadData()
            }
            
        }
        
        listTable.reloadData()
    }
    //MARK: 请求列表数据
    /**
     type 查询类型（0:不限；1：本部门；2：非本部门）
     */
    func loadData()  {
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        params["keyword"] = searchView.text ?? ""
        params["type"] = (isDepartmentData) ? 1 : 2
        UserRequest.coachSearchUser(params: params, hadToast: true, fail: { (Error) in
                    print(Error.description)
                }) {[weak self] (success) in
                    
                    print("获取部门列表\(success)");
                    
                    if let code = success["code"] {
                        if "\(code)" != "1" {
                            SVProgressHUD.showError(withStatus: success["msg"] as? String)
                            return
                        }
                    }
                    
//                    获取部门列表["user_list": <__NSArray0 0x7fff8062d570>(
//
//                    )
//                    , "keyword": , "count": 0]
                    
                    let user_list = success["user_list"] as! [Dictionary<String, Any>]
                    
                    var list:Array<RLMObject> = []
                    let userid:String = sharePublicDataSingle.publicData.userid as String
                    for any in user_list {
                        if any["userid"] as! String !=  userid {
                            let model = FriendsModel.init(value: any)
                            list.append(model)
                        }
                        
                    }
                    
                    
                    if !self!.isDepartmentData {
                        self?.isLoadOtherDepartData = true
                        self?.otherDepartDataArray =  list 
                    }else {
                        self?.isLoadDepartData = true
                        self?.departDataArray =  list
                    }
                    
                    self?.listTable.reloadData()
                    
                }
    }
    
    
    
    //刘海屏额外的高度
    let heightOfAddtionalHeader:CGFloat = {
        var heightOfAddtionalHeader = 0.0
        
        if UIDevice.current.isiPhoneXorLater() {
            heightOfAddtionalHeader = 24.0
        }
        return CGFloat(heightOfAddtionalHeader)
    }()
    
    //MARK:UISearchBarDelegate
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        self.view.endEditing(true)
        
        if searchBar.text!.count > 0 {
            self.loadData()
        }
    }
    
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        self.view.endEditing(true)
    }
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destination.
        // Pass the selected object to the new view controller.
    }
    */
}
extension UIDevice {
    //判断设备是不是iPhoneX以及以上
    
    public func isiPhoneXorLater() ->Bool {
        let screenHieght = UIScreen.main.nativeBounds.size.height
        
        if screenHieght == 2436 || screenHieght == 1792 || screenHieght == 2688 || screenHieght == 1624 {
            return true
        }
        
        return false
    }
}
//
//  SearchHistotyVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/16.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class SearchHistotyVC: BaseViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Do any additional setup after loading the view.
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */
}
//
//  GroupMemberVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/16.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import Realm
enum SearchType {
    case friend
    case stranger
}
class GroupMemberVC: BaseTableVC {
    
    //创建群组和添加成员共用  但是数据处理和UI还是有一些小区别 因此添加了一个字段 isCreatGroup
    //是否是创建群组
    var isCreatGroup:Bool?
    var rightBtn:UIButton?
    var isAddMember:Bool? //是添加 还是删除
    var groudId:String?
    
    typealias back = (_ resultArray:Array<Any>)->()
    fileprivate var resultBlock : back?
    //------------以下参数只在区分搜索类型的页面用到-----------
    fileprivate var searchType: SearchType! = .friend
    var searchText_friend : String? = ""
    var searchText_stranger : String? = ""//记录搜索框的内容
    var strangersArr : RLMResults<RLMObject>?//记录之前搜索的陌生人
    var isFirstCard : Bool? = true //第一次切换至陌生人
    override func viewDidLoad() {
        super.viewDidLoad()
        self.configNav()
        DataBaseOperation.removeDataWithArray(rlmObjects: FriendsModel.allObjects())
        if isCreatGroup == true {
            configUIWithCreatGroup()
            self.configUIWith(fromCellName: "BaseTableCell", fromIsShowSearch: true,fromSearchType: true ,fromCellHeight: 44)
        }
        else
        {
            configUIWithAddMember()
            if self.isAddMember == false {
                super.configUIWith(fromCellName: "BaseTableCell", fromIsShowSearch: true,fromSearchType: true ,fromCellHeight: 44)
            }else{
                self.addCardView()
                
                self.configUIWith(fromCellName: "BaseTableCell", fromIsShowSearch: true,fromSearchType: true ,fromCellHeight: 44)
            }
        }
   
    }
    override func configUIWith(fromCellName: String, fromIsShowSearch: Bool, fromSearchType: Bool, fromCellHeight: CGFloat) {
        super.configUIWith(fromCellName: fromCellName, fromIsShowSearch: fromIsShowSearch, fromSearchType: fromSearchType, fromCellHeight: fromCellHeight)
        searchView?.frame = CGRect.init(x: 0, y: NAV_HEIGHT+cardView_height, width: kScreenW, height: 50)
        
        self.table?.frame = CGRect.init(x: 0, y:50+NAV_HEIGHT+cardView_height, width: kScreenW, height:MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT-50-cardView_height)
    }
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        
        if self.isAddMember == false{
            
            /// 删除成员
            var array = NSArray.init(array: (self.memberArray)!)
            if self.memberArray?.count == 0 {
                return
            }
            let model :GroupUserModel = array.firstObject as! GroupUserModel
            self.memberArray?.removeAll()
            array = array.value(forKeyPath: "userid") as! NSArray
            
            let predicate = NSPredicate(format:"userid in %@ AND groupid ==%@ AND userid != %@ AND is_delete == '0'", array,model.groupid,sharePublicDataSingle.publicData.userid)
            self.allDataArray =  GroupUserModel.allObjects().objects(with: predicate) as? RLMResults<RLMObject>
            self.setDataArray(dataArray:(self.allDataArray!))
            
            return
        }
        else{
            
            if self.searchType == .stranger {//在陌生人页面时不需要更新好友
                return
            }
            //添加成员  必须得更新自己的好友  保证数据是最新的
            self.updateFriend()
        }
        
    }
    
    
    /// 更新好友列表
    func updateFriend(){
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        self.progressShow()
        
        UserRequest.friends(params: params, hadToast: true, fail: { [weak self](Error) in
            print("出现错误")
            if let strongSelf = self{
                strongSelf.progressDismiss()
            }
        }) {[weak self] (sucess) in
            
            //
            if let strongSelf = self{
                DispatchQueue.main.async{
                    strongSelf.progressDismiss()
                    strongSelf.allDataArray =  FriendsModel.objects(with: NSPredicate.init(format: "type == 1 || type == 2")) as? RLMResults<RLMObject>
                    if (strongSelf.searchText_friend?.count)! > 0{
                        let pre = NSPredicate.init(format: "realname CONTAINS %@", (strongSelf.searchView?.searchView.text)!)
                        strongSelf.setDataArray(dataArray:(strongSelf.allDataArray?.objects(with: pre))!)
                    }else{
                        strongSelf.setDataArray(dataArray:strongSelf.allDataArray!)
                    }
                    strongSelf.table?.reloadData()
                    if strongSelf.allDataArray?.count == 0{
                        
                        strongSelf.creatMind()
                        if strongSelf.isCreatGroup == true {
                            
                            
                            strongSelf.navigationItem.rightBarButtonItem?.isEnabled = true
                            strongSelf.rightBtn?.setTitleColor(UIColor.white, for: .normal)
                            
                        }
//                        else{
//                            self?.getImageWithGroup(id:strongSelf.groudId!)
//                        }
                    }
                }
                
            }
            
        }
        
    }
    
    /// 查找用户
    func searchUser(keyword: String?){
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        params["keyword"] = keyword
        
        self.progressShow()
        
        UserRequest.searchUser(params: params, hadToast: true, fail: { [weak self](Error) in
            print("出现错误")
            if let strongSelf = self{
                strongSelf.progressDismiss()
            }
            
        }) { [weak self](sucess) in
            
            if let strongSelf = self{
                strongSelf.progressDismiss()
                
                strongSelf.strangersArr = FriendsModel.objects(with: NSPredicate.init(format: "type == 3 || type == 4 AND userid IN %@",(sucess["list"] as! NSArray).value(forKeyPath: "userid") as! CVarArg)) as? RLMResults<RLMObject>
                strongSelf.setDataArray(dataArray:(strongSelf.strangersArr)!)
                strongSelf.table?.reloadData()
                strongSelf.showRemind()
            }
            
        }
        
    }
  
    
    /// 获取群组的二维码
    ///
    /// - Parameter id: 群组id
    func getImageWithGroup(id:String){
    
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        params["groupid"] = id
        GroupRequest.getQrCode(params: params, hadToast: true, fail: { [weak self](error) in
            if let strongSelf = self {
                strongSelf.progressDismiss()
            }
        }) {[weak self] (success) in
           
            self?.progressDismiss()
            self?.creatSweep(url: success["qr_url"] as! String)
        }
    }
    
    
    /// 创建群组二维码显示界面
    ///
    /// - Parameter url: 二维码图片地址
    func creatSweep(url:String)
    {
      let sweep = GroupSweepView.initWithImage(url: url)
      self.view.addSubview(sweep)
    }
    
    /// 创建群组UI
    func configUIWithCreatGroup()
    {
        self.title = "选择联系人"
        rightBtn = UIButton.init(type: .custom)
        rightBtn?.frame = CGRect.init(x: 0, y: 100, width: 60, height: 30)
        rightBtn?.setTitle("确定", for:.normal)
          rightBtn?.setTitleColor(UIColor.white, for: .normal)
        rightBtn?.sizeToFit()
        let rightItem  = UIBarButtonItem.init(customView: rightBtn!)
        rightBtn?.addTarget(self, action: #selector(rightClick), for: .touchUpInside)
//         rightItem.isEnabled = false
        self.navigationItem.rightBarButtonItem = rightItem
        self.addCardView()
    }
    
    
    /// 添加成员UI
    func configUIWithAddMember()
    {
        self.view.backgroundColor = UIColor.hexString(hexString: "272727")
        let titleLable = UILabel.init(frame: CGRect(x: (kScreenW-100)/2, y: 27, width: 100, height: 30))
        titleLable.text = "选择联系人"
        titleLable.textColor = UIColor.white
        self.view.addSubview(titleLable)
        
        
        
        
        let leftBtn = UIButton.init(type: .custom)
        leftBtn.frame = CGRect.init(x: 15, y: 27, width: 40, height: 30)
        leftBtn.setTitle("取消", for:.normal)
        self.view.addSubview(leftBtn)
        leftBtn.addTarget(self, action: #selector(leftClick), for: .touchUpInside)
        
        
        rightBtn = UIButton.init(type: .custom)
        rightBtn?.frame = CGRect.init(x: kScreenW-70, y: 27, width: 60, height: 30)
        rightBtn?.isEnabled = false
        rightBtn?.setTitle("确定", for:.normal)
        rightBtn?.setTitleColor(UIColor.lightGray, for: .normal)
        rightBtn?.sizeToFit()
        self.view.addSubview(rightBtn!)
        rightBtn?.addTarget(self, action: #selector(rightClick), for: .touchUpInside)
    }
    
    func addCardView(){
    
        let cardView = CardView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT, width: self.view.frame.size.width, height: cardView_height))
        cardView.creatBtnsWithTitles(titlesArr: ["好友","陌生人"])
        cardView.btnClickBlock = ({ (btn) in
            switch btn.tag {
            case 10:
                self.searchType = .friend
                self.searchView?.searchView.placeholder = "搜索"
                self.searchView?.searchView.text = self.searchText_friend
                if (self.searchView?.searchView.text?.count)! > 0 {
                    
                    let pre = NSPredicate.init(format: "realname CONTAINS %@", (self.searchView?.searchView.text)!)
                    self.dataArray = self.allDataArray?.objects(with: pre)
                }else{
                    self.dataArray = self.allDataArray
                }
                if self.dataArray != nil{
                    self.setDataArray(dataArray:self.dataArray!)
                }
                
            case 11:
                self.searchType = .stranger
                self.searchView?.searchView.placeholder = "请输入用户名（邮箱/手机号）"
                self.searchView?.searchView.text = self.searchText_stranger
                if self.isFirstCard! {
                    self.strangersArr = FriendsModel.objects(with: NSPredicate.init(format: "type == 3 || type == 4")) as? RLMResults<RLMObject>
                    self.isFirstCard = false
                }
                if self.strangersArr != nil{
                    self.setDataArray(dataArray:self.strangersArr!)
                }
            default:
                break
            }
            self.table?.reloadData()
            self.showRemind()
            self.creatMind()
            
        })
        
        self.view.addSubview(cardView)
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        super.touchesBegan(touches, with: event)
        self.searchView?.searchView.resignFirstResponder()
    }
    
    
    @objc func leftClick(){
        
        self.dismiss(animated: true, completion: nil)
    }
    
    @objc func rightClick(){
        
       
        if isCreatGroup == true {
            
            let isOpenVC = GroupIsOpenVC(nibName: "GroupIsOpenVC", bundle: nil)
            isOpenVC.userArray = selectedArray
            self.navigationController?.pushViewController(isOpenVC, animated: true)
            
        }
        else if (isAddMember == false){
            self.addAlertView(title: "您确定要移除该成员吗?", message: "", actionTitles: ["确定","取消"], okAction: { (okAction) in
                var params = Dictionary<String, Any>()
                
                params["app_token"] = sharePublicDataSingle.token
                let idStr = (NSArray.init(array: self.selectedArray!).value(forKeyPath: "userid") as! NSArray).componentsJoined(by: ",")
                params["userid_str"] = idStr
                params["groupid"] = self.groudId!
                self.progressShow()
                GroupRequest.delUser(params: params, hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                }, success: { (dic) in
                    
                    
                    let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                    let time = UserDefaults.standard.object(forKey: username) as! String
                    
                    UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { [weak self](error) in
                        if let strongSelf = self {
                            strongSelf.progressDismiss()
                        }
                    }, success: {[weak self] (dic) in
                        
                        self?.progressDismiss()
                        //删除成员
                        self?.resultBlock?((self?.selectedArray!)!)
                        self?.dismiss(animated: true, completion: nil)
                        }
                    )
                    
                })
                
            }, cancleAction: { (cancleAction) in
                
            })
        }
        else
        {
            
            //增加成员
            
            var params = Dictionary<String, Any>()
            
            params["app_token"] = sharePublicDataSingle.token
            let idStr = (NSArray.init(array: selectedArray!).value(forKeyPath: "userid") as! NSArray).componentsJoined(by: ",")
            params["userid_str"] = idStr
            params["groupid"] = groudId!
            self.progressShow()
            GroupRequest.inviteUser(params: params, hadToast: true, fail: { [weak self](error) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                }
            }, success: { (dic) in
                
                
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                let time = UserDefaults.standard.object(forKey: username) as! String
                
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                }, success: {[weak self] (dic) in
                    
                    self?.progressDismiss()
                    
                if self?.resultBlock != nil  {
                    
                    var resultArray = Array<Any>()
                    for i in 0..<(self?.selectedArray?.count)! {
                        
                        let fModel = self?.selectedArray?[i] as! FriendsModel
                        let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", fModel.userid)).firstObject() as! UserModel?
                        let gModel = GroupUserModel()
                        gModel.userid = fModel.userid
                        if  userModel?.avater != nil {
                            gModel.avater = (userModel?.avater)!
                        }
                        if userModel?.realname != nil {
                            gModel.realname = (userModel?.realname)!
                        }
                        resultArray.append(gModel)
                    }
                    
                    
                    self?.resultBlock?(resultArray)
                    self?.dismiss(animated: true, completion: nil)
                    }
                    }
                )
            
            })
            
         }
        
    }
    
    
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        if (self.searchView?.searchView.isFirstResponder)! {
            self.searchView?.searchView.resignFirstResponder()
        }
    }
    
    
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        
        if (self.searchView?.searchView.isFirstResponder)! {
            self.searchView?.searchView.resignFirstResponder()
        }
        
        if self.isAddMember == false{
            let model:GroupUserModel = self.dataArray![UInt(indexPath.row)] as! GroupUserModel
            
            if (self.memberArray?.contains(where: { (m) -> Bool in
                
                return m.userid == model.userid
                
            }) == true) {
                
                return
            }
            
            
            
            
            let index = self.selectedArray?.index(where: { (m) -> Bool in
                return (m as! GroupUserModel).userid == model.userid
            })
            if (index != nil) {
                self.selectedArray?.remove(at: index!)
            }
            else
            {
                self.selectedArray?.append(model)
                
            }
        }
        else{
        
            let model:FriendsModel = self.dataArray![UInt(indexPath.row)] as! FriendsModel
            
            if (self.memberArray?.contains(where: { (m) -> Bool in
                
                return m.userid == model.userid
                
            }) == true) {
                
                return
            }
            
            
            
            
            let index = self.selectedArray?.index(where: { (m) -> Bool in
                return (m as! FriendsModel).userid == model.userid
            })
            if (index != nil) {
                self.selectedArray?.remove(at: index!)
            }
            else
            {
                self.selectedArray?.append(model)
                
            }
        }
        
        
        if self.isShowSearch! {
            
            searchView?.configWithDataArray(array:selectedArray!)
            
        }
        tableView.reloadData()
        
        
        changeRightBtnStatus()
        
        
        
    }
    
    
    /// 改变右边按钮状态
    func changeRightBtnStatus(){
        if selectedArray?.count != 0 {
            let countStr = String.init(format: "确定(%d)", (selectedArray?.count)!)
            self.navigationItem.rightBarButtonItem?.isEnabled = true
            rightBtn?.setTitleColor(UIColor.white, for: .normal)
            rightBtn?.isEnabled = true
            rightBtn?.setTitle(countStr, for: .normal)
            rightBtn?.sizeToFit()
        }
        else
        {
            
            if isCreatGroup == true {
                rightBtn?.setTitle("确定", for: .normal)
            }
            else{
                self.navigationItem.rightBarButtonItem?.isEnabled = false
                rightBtn?.isEnabled = false
                rightBtn?.setTitleColor(UIColor.lightGray, for: .normal)
                rightBtn?.setTitle("确定", for: .normal)
            }
        }
        
    }
   
    
    
    override func searchDeleteItem(item: RLMObject) {
        
        if isAddMember == false {
            let model = item as! GroupUserModel
            
            if (self.memberArray?.contains(where: { (m) -> Bool in
                
                return m.userid == model.userid
                
            }) == true) {
                
                return
            }
            
            
            
            let index = self.selectedArray?.index(where: { (m) -> Bool in
                return (m as! GroupUserModel).userid == model.userid
            })
            if (index != nil) {
                self.selectedArray?.remove(at: index!)
            }
 
        }
        else{
            let model = item as! FriendsModel
            
            if (self.memberArray?.contains(where: { (m) -> Bool in
                
                return m.userid == model.userid
                
            }) == true) {
                
                return
            }
            
            
            
            let index = self.selectedArray?.index(where: { (m) -> Bool in
                return (m as! FriendsModel).userid == model.userid
            })
            if (index != nil) {
                self.selectedArray?.remove(at: index!)
            }
            
        }
        
        table?.reloadData()
        changeRightBtnStatus()
    }
    
    
    
    //MARK: - ---------------------添加 或 删除 给上一个界面返回的数据----------------------
    public func resultWithArray(resultArray:@escaping back)
    {
       resultBlock = resultArray
    }
    
    
    
    //MARK: - ---------------------搜索内容发生变化的响应----------------------
    override func searchBarTextChangedWith(nowText:String)
    {
        if self.searchType == .stranger {
            return
        }
        if self.allDataArray?.count == 0 {
            return
        }
        if self.searchType == .friend {
            self.searchText_friend = nowText
        }
        if nowText.isEmpty {
            self.dataArray = self.allDataArray
        }
        else{
            
           let pre = NSPredicate.init(format: "realname CONTAINS %@", nowText)
           self.dataArray = self.allDataArray?.objects(with: pre)
        }
        table?.reloadData()
        self.showRemind()
    }
    
    override func searchBarSearchButtonClicked(nowText: String) {
        if self.searchType == .stranger {
            self.searchText_stranger = nowText
            self.searchUser(keyword: nowText)
        }
    }
    
    func creatMind(){
        if self.allDataArray != nil {
            
            if self.allDataArray?.count == 0{
                noDatamind.isHidden = false
            }else{
                noDatamind.isHidden = true
            }
        }
        if self.searchType == .stranger{
            noDatamind.isHidden = true
        }
    }
    lazy var noDatamind : UILabel = {
    
        var noDatamind = UILabel.init(frame: CGRect.init(x: 0, y: 200, width: 150, height: 20))
        noDatamind.textAlignment = .center
        noDatamind.center = self.view.center
        noDatamind.text = "暂时没有好友"
        self.view.addSubview(noDatamind)
        return noDatamind
    }()
}
//
//  GroupChooseMemberVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/4/5.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupChooseMemberVC: BaseTableVC {
    typealias backBlock = (_ user:GroupUserModel)->()
    var groupId :String?
    var block : backBlock?
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.title = "选择提醒的人"
       let leftBtn = UIButton.init(type: .custom)
        leftBtn.frame = CGRect.init(x: 0, y: 100, width: 60, height: 30)
      
        leftBtn.setTitle("取消", for:.normal)
        leftBtn.setTitleColor(UIColor.white, for: .normal)
        leftBtn.sizeToFit()
        let leftItem  = UIBarButtonItem.init(customView: leftBtn)
        leftBtn.addTarget(self, action: #selector(leftClick), for: .touchUpInside)
        self.navigationItem.leftBarButtonItem = leftItem
        self.hidenChooseIcon = true
        
        
        self.configUIWith(fromCellName: "BaseTableCell", fromIsShowSearch: true,fromSearchType: false ,fromCellHeight: 44)
        let predicate = NSPredicate(format:"groupid == %@ AND userid != %@ AND is_delete == '0'", groupId!,sharePublicDataSingle.publicData.userid)
        self.allDataArray =  GroupUserModel.allObjects().objects(with: predicate) as? RLMResults<RLMObject>
        self.setDataArray(dataArray:(self.allDataArray!))
    }
    @objc func leftClick(){
       self.navigationController?.popViewController(animated: true)
    }
    
    
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        super.touchesBegan(touches, with: event)
        self.searchView?.searchView.resignFirstResponder()
    }
    
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        
        let model = self.allDataArray?.object(at: UInt(indexPath.row))
        block?(model as! GroupUserModel)
        self.navigationController?.popViewController(animated: true)
    }
    
    
    override func searchBarTextChangedWith(nowText: String) {
        if nowText.isEmpty {
            self.dataArray = self.allDataArray
        }
        else{
            
            let pre = NSPredicate.init(format: "realname CONTAINS %@", nowText)
            self.dataArray = self.allDataArray?.objects(with: pre)
        }
        
        table?.reloadData()
    }
    
    
    func backWithUserName(username:@escaping backBlock){
      block = username
    }
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */
}
//
//  GroupIsOpenVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/23.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupIsOpenVC: BaseViewController {
    
    var userArray:Array<RLMObject>?
    var groupName:String?
    var isOpen = true
    @IBAction func btnClick(_ sender: UIButton) {
        rightImage.image = UIImage.init(named: "isClose_normal")
        leftImage.image = UIImage.init(named: "isOpen_normal")
        
        if sender.tag == 101 {
            isOpen = false
            rightImage.image = UIImage.init(named: "isClose_select")
        }else {
            isOpen = true
            leftImage.image = UIImage.init(named: "isOpen_select")
        }
    }
    
    
    @IBOutlet weak var rightBtn: UIButton!
    @IBOutlet weak var leftBtn: UIButton!
    @IBOutlet weak var deslable: UILabel!
    @IBOutlet weak var rightImage: UIImageView!
    @IBOutlet weak var leftImage: UIImageView!
    override func viewDidLoad() {
        super.viewDidLoad()
        
       self.view.backgroundColor = UIColor.groupTableViewBackground
       self.title = "创建群组"
       self.setRightBtnWithArray(items: ["确定"])
       
       self.deslable.layer.cornerRadius = 6
       self.deslable.clipsToBounds = true
        
       self.deslable.text = "\n提示：若您设置为【开放】，则企业成员可查找到该群组，并申请加入；若您设置为【私有】，则企业内部其他成员无法查找到该群，仅能通过扫描群二维码加入。               \n "
        
        // 设置行间距
        let style = NSMutableParagraphStyle()
        // 间隙
        style.lineSpacing = 5
        self.deslable.attributedText = NSAttributedString(string: self.deslable.text!,
                                    attributes: [NSAttributedString.Key.paragraphStyle: style])
        let bgView = UIView.init()
        bgView.backgroundColor = UIColor.white
        bgView.layer.cornerRadius = 6
        view.addSubview(bgView)
        
        bgView.mas_makeConstraints { [unowned self](make) in
            make?.left.equalTo()(self.deslable)?.offset()(-10)
            make?.right.equalTo()(self.deslable)?.offset()(10)
            make?.top.centerX()?.centerY()?.height()?.equalTo()(self.deslable)
        }
        
        view.sendSubviewToBack(bgView)
        
        leftImage.image = UIImage.init(named: "isOpen_select")
    }
    override func rightBtnClick(button: UIButton) {
       
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        
        params["group_name"] = ""
        if groupName != nil {
            params["group_name"] = groupName!
        }
        
        let idStr = (NSArray.init(array: userArray!).value(forKeyPath: "im_userid") as! NSArray).componentsJoined(by: ",")
        params["userid_str"] = idStr
        
        if isOpen {
            params["is_open"] = "1"
        } else {
           params["is_open"] = "0"
        }
        
        SVProgressHUD.show()
       GroupRequest.creat(params: params, hadToast: true, fail: { (error)  in
       }, success: {[weak self] (success)  in
        if let code = success["code"] {
            if "\(code)" != "1" {
                SVProgressHUD.showError(withStatus: success["msg"] as? String)
                return
            }
            
           
        }
        
        print("创建群组成功",success)
        
        if let gorupid = success["groupId"] {
            
            
//            let groupidStr = "\(gorupid)"
//            let group:RCGroup = (RCIM.shared()?.getGroupInfoCache(groupidStr))!
//
//            print(group.groupName ?? "")
            
            self?.sygnGruopInfo()
        }
        
       })
        
    }
    
    func sygnGruopInfo() {
        
        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
        var time:String? = UserDefaults.standard.object(forKey: username) as! String?
        if time == nil{
            time = "0"
        }
        UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { (error) in
            SVProgressHUD.dismiss()
        }, success: { (dic) in
            print(dic)
            SVProgressHUD.dismiss()
            self.navigationController?.popToRootViewController(animated: true)
        })
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */
}
//
//  WebViewController.swift
//  NewTcpApp
//
//  Created by xslp on 2020/9/28.
//  Copyright © 2020 xslpiOS. All rights reserved.
//
import UIKit
class WebViewController: BaseViewController {
    
    var webUrl = ""
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }
    
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destination.
        // Pass the selected object to the new view controller.
    }
    */
}
//
//  GroupSettingViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/9.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupSettingViewController: BaseViewController {
    fileprivate var dataSourceArr = Array<Array<Dictionary<String, Any>>>()
    fileprivate var usersDataSourceArr  = Array<GroupUserModel>()
    var header : GroupSettingTableViewHeader!
    var headerView : UIView!
    var groupModel:GroupModel?
    var groupUserModel:GroupUserModel? //当前登录用户的groupUserModel
    var ownUserModel:GroupUserModel? //群主的groupUserModel
    var is_owner : Bool? //是否是群组
    var targetId:String?{
        
        didSet {
            groupModel = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",targetId!)).firstObject() as! GroupModel?
            groupUserModel = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,(groupModel?.groupid)!)).firstObject() as! GroupUserModel?
            is_owner = (groupModel?.owner_id)! == sharePublicDataSingle.publicData.userid as String
            self.configData()
            self.configUI()
        }
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = UIColor.white
        self.title = "群组信息"
        self.configNav()
    }
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.configData()
        self.tableView.reloadData()
    }
    func configData() {
        usersDataSourceArr.removeAll()
        ownUserModel = GroupUserModel.objects(with: NSPredicate.init(format: "groupid == %@ AND userid == %@ AND is_delete == '0'",(groupModel?.groupid)!,(groupModel?.owner_id)!)).firstObject() as! GroupUserModel?
        if ownUserModel != nil {
            usersDataSourceArr.append(ownUserModel!)
        }
        let groupUserModels = GroupUserModel.objects(with: NSPredicate.init(format: "groupid == %@ AND userid != %@ AND is_delete == '0'",(groupModel?.groupid)!, (groupModel?.owner_id)!)).sortedResults(usingKeyPath: "inputtime", ascending: true)
        for i in 0..<groupUserModels.count {
            let groupUserModel : GroupUserModel = groupUserModels[i] as! GroupUserModel
            usersDataSourceArr.append(groupUserModel)
        }
        let conversation  = RCIMClient.shared().getConversation(.ConversationType_GROUP, targetId: targetId)
        if is_owner! {
          
//            if String.noNilStr(str:  groupModel?.project_id) != ""{
//
//                dataSourceArr = [
//                    [["群组名称":groupModel?.group_name],["群组验证码":groupModel?.auth_code],["群组开放性":groupModel?.is_open]],
//                    [["置顶聊天":conversation?.isTop.hashValue],["查找聊天内容":""]]
//                ]
//
//            }else{
                dataSourceArr = [
                    [["群组名称":groupModel?.group_name],["群组验证码":groupModel?.auth_code],["群组开放性":groupModel?.is_open]],
                    [["置顶聊天":conversation?.isTop.hashValue],["查找聊天内容":""]]
                ]
//            }
            
            
        }else{
//            if String.noNilStr(str:  groupModel?.project_id) != ""{
//                dataSourceArr = [
//                    [["群组名称":groupModel?.group_name],["群组验证码":groupModel?.auth_code]],
//                    [["置顶聊天":conversation?.isTop.hashValue],["查找聊天内容":""]]
//                ]
//            }else{
            dataSourceArr = [
                [["群组名称":groupModel?.group_name],["群组验证码":groupModel?.auth_code]],
                [["置顶聊天":conversation?.isTop.hashValue],["查找聊天内容":""]]
            ]
//            }
        }
    }
    
    func configUI() {
        if usersDataSourceArr.count > 0 {
            
            header = GroupSettingTableViewHeader.init()
            header.myDelegate = self
            header.users = usersDataSourceArr
            header.isAllowedDeleteMember = is_owner
            header.isAllowedInviteMember = groupModel?.is_delete == "0" && groupUserModel?.is_delete == "0"
            headerView = UIView.init(frame: CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height: header.collectionViewLayout.collectionViewContentSize.height))
            headerView.addSubview(header)
            header.mas_makeConstraints { (make) in
                make!.top.left().bottom().right().equalTo()(headerView)
            }
            self.tableView.tableHeaderView = headerView
        }
        
        let footerView = UIView.init(frame: CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height: 70))
        footerView.backgroundColor = UIColor.clear
        let delAndExitBtn = UIButton.init(frame: CGRect.init(x: 20, y: 20, width: SCREEN_WIDTH - 20 * 2, height: 40))
        delAndExitBtn.addTarget(self, action: #selector(exitBtnClick), for: .touchUpInside)
        delAndExitBtn.backgroundColor = UIColor.hexString(hexString: "2183DE")
        delAndExitBtn.layer.cornerRadius = 5.0
        delAndExitBtn.clipsToBounds = true
        if is_owner! {
            
            delAndExitBtn.setTitle("解散群组", for: .normal)
        }else{
            delAndExitBtn.setTitle("删除并退出", for: .normal)
        }
        delAndExitBtn.titleLabel?.textColor = UIColor.white
        delAndExitBtn.titleLabel?.font = FONT_16
        footerView.addSubview(delAndExitBtn)
        
        self.tableView.tableFooterView = footerView
        
        self.view.addSubview(self.tableView)
        
    }
    
    func reloadHeaderData() {
        self.configData()
        if usersDataSourceArr.count == 0 {
            self.tableView.tableHeaderView = nil
            return
        }
        self.header.users = usersDataSourceArr
        self.header.isAllowedInviteMember = groupModel?.is_delete == "0" && groupUserModel?.is_delete == "0"
        self.header.reloadData()
        self.headerView.frame = CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height:
            self.header.collectionViewLayout.collectionViewContentSize.height)
        self.tableView.tableHeaderView = self.headerView
        self.tableView.reloadData()
    }
    @objc func exitBtnClick() {
        if is_owner! {
            self.addAlertView(title: "您确定要解散该群组吗?", message: "", actionTitles: ["确定","取消"], okAction: { (action) in
                self.progressShow()
                GroupRequest.dismiss(params: ["app_token":sharePublicDataSingle.token,"groupid":self.groupModel?.groupid], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                }, success: {  [weak self](dic) in
                    if let strongSelf = self{
                        strongSelf.progressDismiss()
                        let realm:RLMRealm = RLMRealm.default()
                        realm.beginWriteTransaction()
                        strongSelf.groupModel?.setValue("1", forKey: "is_delete")
                        try? realm.commitWriteTransaction()
//                        RCIMClient.shared().clearMessages((strongSelf.conversationModel?.conversationType)!, targetId: strongSelf.conversationModel?.targetId)
//                        RCIMClient.shared().remove((strongSelf.conversationModel?.conversationType)!, targetId: strongSelf.conversationModel?.targetId)
                        strongSelf.navigationController?.popToRootViewController(animated: true)
                    }
                })
                
            }, cancleAction: { (action) in
                
            })
            
        }else{
            self.addAlertView(title: "您确定要退出该群组吗?", message: "", actionTitles: ["确定","取消"], okAction: { (action) in
                self.progressShow()
                GroupRequest.quit(params: ["app_token":sharePublicDataSingle.token,"groupid":self.groupModel?.groupid], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                }, success: { [weak self](dic) in
                    if let strongSelf = self{
                        strongSelf.progressDismiss()
                        let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,(strongSelf.groupModel?.groupid)!)).firstObject() as! GroupUserModel?
                        let realm:RLMRealm = RLMRealm.default()
                        realm.beginWriteTransaction()
                        groupUserModel?.setValue("1", forKey: "is_delete")
                        try? realm.commitWriteTransaction()
                        RCIMClient.shared().clearMessages(.ConversationType_GROUP, targetId: strongSelf.targetId)
                        RCIMClient.shared().remove(.ConversationType_GROUP, targetId: strongSelf.targetId)
                        strongSelf.navigationController?.popToRootViewController(animated: true)
                    }
                })
                
            }, cancleAction: { (action) in
                
            })
            
        }
    }
    //MARK: --------------------------- Getter and Setter --------------------------
    lazy var tableView: UITableView = {
        var tableView : UITableView = UITableView.init(frame: CGRect(x: 0, y: NAV_HEIGHT, width: SCREEN_WIDTH, height: SCREEN_HEIGHT - NAV_HEIGHT))
        tableView.backgroundColor = UIColor.groupTableViewBackground
        tableView.dataSource  = self
        tableView.delegate    = self
        return tableView
    }()
}
//MARK: - UITableViewDataSource, UITableViewDelegate
extension GroupSettingViewController : UITableViewDataSource, UITableViewDelegate {
    func numberOfSections(in tableView: UITableView) -> Int {
        return dataSourceArr.count
    }
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return dataSourceArr[section].count
    }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        if (indexPath.section == 0 && indexPath.row != 2) || (indexPath.section == 1 && indexPath.row != 0) {
            let cell = GroupSettingWithArrowCell.cell(withTableView: tableView)
            
            cell.selectionStyle = .none
//            if indexPath.section == 0 && indexPath.row == 1 {
//                cell.selectionStyle = .none
//            }else{
//                cell.selectionStyle = .default
//            }
            if indexPath.section == 0 && indexPath.row == 1 {
//                if String.noNilStr(str:  groupModel?.project_id) == "" {
//                    cell.detailLabel.isHidden = true
//                    cell.detailImage.isHidden = false
//                }
//                else{
                    cell.detailLabel.isHidden = false
                    cell.detailImage.isHidden = true
//                }
            }else{
                cell.detailLabel.isHidden = false
                cell.detailImage.isHidden = true
            }
            if indexPath.section == 0 && indexPath.row == 1 || !is_owner! && indexPath.section == 0 && indexPath.row == 0{
                cell.rightArrow.isHidden = true
            }else{
                cell.rightArrow.isHidden = false
            }
            
            cell.model = dataSourceArr[indexPath.section][indexPath.row]
            return cell
        }else{
            let cell = GroupSettingWithSwitchCell.cell(withTableView: tableView)
            cell.delegate = self
            cell.model = dataSourceArr[indexPath.section][indexPath.row]
            return cell
        }
    }
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
//        if indexPath.section == 0 && indexPath.row == 3 {
//            let detailStr = (dataSourceArr[indexPath.section][indexPath.row] ).first?.value as! String?
//            if detailStr == "未设置" {
//                return 44
//            }else{
//                let height = ((detailStr?.getTextHeight(font: FONT_14, width: SCREEN_WIDTH - LEFT_PADDING_GS * 2 - 15))! + 0.4) > 60 ? 50.5 : ((detailStr?.getTextHeight(font: FONT_14, width: SCREEN_WIDTH - LEFT_PADDING_GS * 2 - 15))! + 0.4)
//                return 44 + height + 5
//            }
//        }else{
            return 44
//        }
    }
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let view = UIView.init()
        view.backgroundColor = UIColor.clear
        return view
    }
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return 20
    }
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        switch indexPath.section {
        case 0:
            switch indexPath.row {
            case 0:
                if is_owner! {
                    let groupNameEditVC = GroupNameEditViewController()
                    groupNameEditVC.groupModel = groupModel
                    self.navigationController?.pushViewController(groupNameEditVC, animated: true)
                }else{
                    self.addAlertView(title: "提示", message: "只有群主"+(ownUserModel?.realname)!+"才能修改群组名称", actionTitles: ["确定"], okAction: { (okAlertAction) in
                        
                    }, cancleAction: { (cancleAlertAction) in
                        
                    })
                }
//            case 1:
//                
//                if String.noNilStr(str:  groupModel?.project_id) == "" {
//                    let groupQRCodeVC = GroupQRCodeViewController()
//                    groupQRCodeVC.groupModel = groupModel
//                    self.navigationController?.pushViewController(groupQRCodeVC, animated: true)
//                }
                
               
                
            default:
                break
            }
        case 1:
            switch indexPath.row {
            case 1:
                
                let chatContent = ChatContentSearchVC()
                chatContent.targetId = self.groupModel?.groupid
                self.navigationController?.pushViewController(chatContent, animated: true)
                
                
            default:
                break
            }
        default:
            break
        }
    }
}
//MARK: - GroupSettingTableViewHeaderDelegate
extension GroupSettingViewController : GroupSettingTableViewHeaderDelegate {
    func userItemDidClick(userId: String) {
        print("点击了用户--userid == " + userId)
    }
    func addBtnDidClick() {
        
        var memberIdsArr = Array<String>()
        for i in 0..<header.users.count {
            let groupUserModel = header.users[i]
            memberIdsArr.append(groupUserModel.userid)
        }
        let groupManage = GroupMemberManageVC()
        groupManage.isAddMember = true
        groupManage.groupid = targetId ?? ""
        groupManage.existMember = memberIdsArr
        groupManage.resultBlock = { [weak self]  (resultArray) in
            if let strongHSelf = self{
                for userModel in resultArray
                {
                   let fModel = userModel as! FriendsModel
                   let gModel = GroupUserModel()
                   gModel.userid = fModel.userid
                   gModel.avater = fModel.avater
                   gModel.realname = fModel.realname
                    
                    strongHSelf.header.users.append(gModel)
                }
                strongHSelf.header.reloadData()
                strongHSelf.headerView.frame = CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height:
                    strongHSelf.header.collectionViewLayout.collectionViewContentSize.height)
                strongHSelf.tableView.reloadData()
                
            }
        }
        
        self.navigationController?.pushViewController(groupManage, animated: true)
        return
        
        let addMemeberVc = GroupMemberVC()
        // 数组 header.users 包含群组成员model
//        addMemeberVc.mem
        addMemeberVc.isAddMember = true
        addMemeberVc.groudId = groupModel?.groupid
        addMemeberVc.memberArray = header.users
        addMemeberVc.resultWithArray { [weak self]  (resultArray) in
            if let strongHSelf = self{
                strongHSelf.reloadHeaderData()
            }
        }
        self.present(addMemeberVc, animated: true, completion: nil)
    }
    func delBtnDidClick() {
        var memberIdsArr = Array<String>()
        for i in 0..<header.users.count {
            let groupUserModel = header.users[i]
            memberIdsArr.append(groupUserModel.userid)
        }
        
        let groupManage = GroupMemberManageVC()
        groupManage.groupid = targetId ?? ""
        groupManage.existMember = memberIdsArr
        groupManage.resultBlock = { [weak self]  (resultArray) in
            
            if let strongHSelf = self{
                
                var tempUserIdsArr = Array<String>()
                var tempResultIdsArr = Array<String>()
                var tempDelArr = Array<Int>()
                
                for userModel in resultArray
                {
                    tempResultIdsArr.append((userModel as! FriendsModel).userid)
                }
                
                
                for i in 0..<strongHSelf.header.users.count
                {
                    let userModel = strongHSelf.header.users[i]
                    if tempResultIdsArr.contains(userModel.userid){
                        tempDelArr.append(i)
                    }
                    tempUserIdsArr.append(userModel.userid)
                }
                for index in tempDelArr.reversed(){
                    strongHSelf.header.users.remove(at: index)
                }
                strongHSelf.header.reloadData()
                strongHSelf.headerView.frame = CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height:
                    strongHSelf.header.collectionViewLayout.collectionViewContentSize.height)
                strongHSelf.tableView.reloadData()
 
            }
            
        }
        
        self.navigationController?.pushViewController(groupManage, animated: true)
        return
        
        let addMemeberVc = GroupMemberVC()
        addMemeberVc.isAddMember = false
        addMemeberVc.groudId = groupModel?.groupid
        addMemeberVc.memberArray = header.users
        addMemeberVc.resultWithArray { [weak self]  (resultArray) in
            if let strongHSelf = self{
                strongHSelf.reloadHeaderData()
            }
            
        }
        self.present(addMemeberVc, animated: true, completion: nil)
    }
}
extension GroupSettingViewController : GroupSettingWithSwitchCellDelegate {
    
    func onClickSwitchButton(swich: UIButton, title: String) {
        switch title {
        case "群组开放性":
            self.progressShow()
            GroupRequest.setOpen(params: ["app_token":sharePublicDataSingle.token,"groupid":groupModel?.groupid,"is_open":swich.isSelected ? "0" : "1"], hadToast: true, fail: { [weak self](error) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                }
            }) { [weak self](dic) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                    swich.isSelected = !swich.isSelected
                    let realm:RLMRealm = RLMRealm.default()
                    realm.beginWriteTransaction()
                    strongSelf.groupModel?.setValue(swich.isSelected ? "1" : "0", forKey: "is_open")
                    try? realm.commitWriteTransaction()
//                    self?.tableView.reloadData()
                }
            }
        case "置顶聊天":
            let setTopSuccess = RCIMClient.shared().setConversationToTop(.ConversationType_GROUP, targetId: targetId, isTop: !swich.isSelected)
            if setTopSuccess {
                swich.isSelected = !swich.isSelected
            }
        default:
            break
        }
    }
}
//
//  GroupSearchVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/22.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
let pageNum = 20
class GroupSearchVC: BaseViewController {
    var table:UITableView?
    var dataArray:Array<GroupModel>?
    var allDataArray:Array<GroupModel>? //记录已经加载的数据
    var searchView:UISearchBar?
    var pageCount = 1 //当前页数
    var allPageCount = 1 //记录已经加载的页数
    var total : Int? = 0 //总数据个数
    var first : Bool?
    override func viewDidLoad() {
        super.viewDidLoad()
        self.title = "搜索群组"
        dataArray = Array()
        allDataArray = Array()
        first = true
//        configData(keyword: "")
        configUI()
    }
    
    
    
    fileprivate func configUI()
    {
        searchView = UISearchBar.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: 50))
        searchView!.setBackgroundImage(UIImage.init(named: "backGray")!, for: .any, barMetrics: .default)
        searchView!.delegate = self
        searchView!.placeholder = "搜索"
        searchView?.becomeFirstResponder()
        self.view.addSubview(searchView!)
        
        
        table = UITableView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT+50, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT-50))
        self.view.addSubview(table!)
        table?.delegate = self;
        table?.dataSource = self;
        table?.tableFooterView = UIView.init()
       
    }
    
    fileprivate func configData(keyword : String) {
        
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        if keyword.count > 0 {
            params["keyword"] = keyword
        }
        params["is_join"] = 0 //未加入
        params["is_open"] = 1 // 公开
        params["offset"] = pageCount // 当前页
        params["length"] = pageNum // 每页记录数
        self.progressShow()
        GroupRequest.search(params: params, hadToast: true, fail: {[weak self](error) in
            if let strongSelf = self {
                strongSelf.progressDismiss()
            }
        }, success: {[weak self] (sdic) in
            if let strongSelf = self{
                strongSelf.progressDismiss()
                
                DispatchQueue.main.async {
                    var array : Array<Dictionary<String, Any>>! = []
                    if sdic["list"] != nil{
                        array = sdic["list"] as! Array<Dictionary<String, Any>>
                    }
                    if (strongSelf.first)!{
                        strongSelf.first = false
                        if array.isEmpty{
                            //                    self?.progressDismissWith(str: "没有找到符合的群组")
                            strongSelf.table?.reloadData()
                            strongSelf.showRemind()
                            return
                        }
                    }
                    //普通带文字上拉加载的定义
                    if strongSelf.table?.mj_footer == nil{
                        strongSelf.table?.mj_footer? = MJRefreshAutoNormalFooter(refreshingTarget: strongSelf, refreshingAction: #selector(strongSelf.footerRefresh))
                    }
                    strongSelf.table?.mj_footer?.endRefreshing()
                    if array.count == pageNum {
                        strongSelf.table?.mj_footer?.isHidden = false
                    }else if array.count < pageNum {
                        strongSelf.table?.mj_footer?.isHidden = true
                    }
                    for i in 0..<array.count  {
                        let model = GroupModel()
                        let dic:Dictionary = array[i]
                        model.setValuesForKeys(dic)
                        strongSelf.dataArray?.append(model)
                    }
                    if keyword.count == 0{
                        strongSelf.allDataArray = strongSelf.dataArray
                        strongSelf.allPageCount = strongSelf.pageCount
                        strongSelf.total = Int(String.changeToString(inValue: sdic["total"] as Any))
                    }
                    strongSelf.table?.reloadData()
                    strongSelf.showRemind()
                }
            }
            
        })
        
    }
    //上拉加载操作
    @objc func footerRefresh(){
        pageCount += 1
        self.configData(keyword: (searchView?.text)!)
//            table?.reloadData()
//        }
    }
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.searchView?.resignFirstResponder()
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    
    /// 提醒个数
    func showRemind(){
        
        let fView = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 50))
        
        let line = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 1))
        line.backgroundColor = UIColor.groupTableViewBackground
        fView.addSubview(line)
        
        let numberLable = UILabel.init(frame: CGRect.init(x: 0, y: 10, width: kScreenW, height: 30))
        numberLable.textAlignment = NSTextAlignment.center
        numberLable.font = UIFont.systemFont(ofSize: 14)
        
        numberLable.text = "没有查找到相关的群组"
        fView.addSubview(numberLable)
        
        if (self.dataArray?.count)! == 0 {
            table?.tableFooterView = fView
        }else{
            table?.tableFooterView = UIView.init()
        }
        
    }
}
extension GroupSearchVC:UITableViewDelegate,UITableViewDataSource{
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        
        return 75
    }
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        
        return dataArray != nil ? (dataArray?.count)! : 0
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        var cell:BaseTableCell? = tableView.dequeueReusableCell(withIdentifier: "cell") as! BaseTableCell?
        if cell == nil
        {
            cell = Bundle.main.loadNibNamed("BaseTableCell", owner: self, options: nil)?.last as! UITableViewCell? as! BaseTableCell?
        }
        
        let model:RLMObject = self.dataArray![indexPath.row]
        let bCell = cell! as BaseTableCell
        bCell.model = model
//        cell?.setValue(model, forKey: "model")
        cell?.delegate = self
        return cell!
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
    {
        if (searchView?.isFirstResponder)! {
            searchView?.resignFirstResponder()
        }
        
    }
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        if (searchView?.isFirstResponder)! {
            searchView?.resignFirstResponder()
        }
    }
    
}
extension GroupSearchVC:UISearchBarDelegate{
    func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
        searchView?.showsCancelButton = true
    }
    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
        searchView?.showsCancelButton = false
        searchView?.text = nil
        searchBar.resignFirstResponder()
        dataArray = allDataArray //点击取消按钮显示已经加载过的所有数据
        pageCount = allPageCount
        if self.table?.mj_footer != nil {
            
            if dataArray?.count == total {
                self.table?.mj_footer?.isHidden = true
            }else {
                self.table?.mj_footer?.isHidden = false
            }
        }
//        showRemind()
        table?.reloadData()
    }
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        searchBar.resignFirstResponder()
        
        pageCount = 1
        dataArray?.removeAll()
        configData(keyword: searchBar.text!)
    }
  
}
extension GroupSearchVC:BaseCellDelegate{
   
    
 
    
    func cellRightBtnClick(model: RLMObject) {
        
        
        let applyJoinGroupVc = ApplyJoinGroupViewController()
        applyJoinGroupVc.groupModel = model as? GroupModel
        self.navigationController?.pushViewController(applyJoinGroupVc, animated: true)
    }
    
}
//
//  GroupMemberManageVC.swift
//  NewTcpApp
//
//  Created by xslp on 2020/8/13.
//  Copyright © 2020 xslpiOS. All rights reserved.
//
import UIKit
class GroupMemberManageVC: GroupCreateVC {
    var isAddMember = false
    var existMember:Array<String>?//已存在成员id
    var groupid:String = ""
    typealias back = (_ resultArray:Array<Any>)->()
    var resultBlock : back?
    override func rightBtnClick(button: UIButton) {
        
        if isDepartmentData {
                   if self.seleDepartArray.count == 0 {return}
               }
               
       if !isDepartmentData {
           if self.seleOtherDepartArray.count == 0 {return}
       }
        
        if isAddMember {
            addGroupMember()
        }else {
            deleteGroupMember()
        }
        
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.title = "删除成员"
        if isAddMember {
            self.title = "邀请成员"
        }
        // Do any additional setup after loading the view.
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
          
            var cell:UITableViewCell? = tableView.dequeueReusableCell(withIdentifier: "cell")
            if cell == nil
            {
               
                let path:String? = Bundle.main.path(forResource: "BaseTableCell", ofType: "nib")
                if path == nil {
                   let  aClass  = getClassWitnClassName("BaseTableCell") as! UITableViewCell.Type
                    cell = aClass.init(style: .default, reuseIdentifier: "BaseTableCell")
                }
                else
                {
                    cell = Bundle.main.loadNibNamed("BaseTableCell", owner: self, options: nil)?.last as! UITableViewCell?
                    
                }
            }
            
            var model:RLMObject?
                
            if isDepartmentData {
                
                model = departDataArray![Int(indexPath.row)]
            }else {
                
                model = otherDepartDataArray![Int(indexPath.row)]
            }
                
            
        
            let bCell = cell as! BaseTableCell
        
            bCell.model = model
            bCell.delegate = self
            bCell.rightBtn.isHidden = true
            bCell.rightBtn.isHidden = true
            
            var seleMemberArray:Array<RLMObject>?
            if isDepartmentData {
                seleMemberArray = self.seleDepartArray
            }else {
                seleMemberArray = self.seleOtherDepartArray
            }
            
            bCell.selectImage.image = UIImage.init(named: "logic_normal")
            
            if seleMemberArray?.count ?? 0 > 0 {
                if (seleMemberArray?.contains(where: { (m) -> Bool in
                    return (m as! FriendsModel).userid == (model as! FriendsModel).userid
                }))!{
                    
                    bCell.selectImage.image = UIImage.init(named: "logic_select")
                }
            }
            
        if (existMember?.contains((model as! FriendsModel).userid))! && isAddMember {
            bCell.selectImage.image = UIImage.init(named: "logic_disable")
        }
            
            return cell!
        }
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
            let model:FriendsModel = (isDepartmentData ? departDataArray : otherDepartDataArray)?[Int(indexPath.row)] as! FriendsModel
            
            if (existMember?.contains(model.userid))! && isAddMember {
                    return
            }
        
            let index = (isDepartmentData ? seleDepartArray : seleOtherDepartArray).firstIndex(where: { (m) -> Bool in
                 return (m as! FriendsModel).userid == model.userid
             })
             if (index != nil) {
                
                if isDepartmentData {
                    seleDepartArray.remove(at: index!)
                }else {
                    seleOtherDepartArray.remove(at: index!)
                }
                
             }
             else
             {
                if isDepartmentData {
                    seleDepartArray.append(model)
                }else {
                    seleOtherDepartArray.append(model)
                }
                 
             }
            
            tableView.reloadRows(at: [indexPath], with: .none)
        }
    
    //MARK: 请求列表数据
        /**
         type 查询类型（0:不限；1：本部门；2：非本部门）
         */
    override func loadData()  {
            var params = Dictionary<String, Any>()
            params["app_token"] = sharePublicDataSingle.token
            params["keyword"] = searchView.text ?? ""
            params["type"] = (isDepartmentData) ? 1 : 2
            UserRequest.coachSearchUser(params: params, hadToast: true, fail: { (error) in
                print(error.description)
                    }) {[weak self] (success) in
                        
                        print("获取部门列表\(success)");
                        
                        if let code = success["code"] {
                            if "\(code)" != "1" {
                                SVProgressHUD.showError(withStatus: success["msg"] as? String)
                                return
                            }
                        }
                        
    //                    获取部门列表["user_list": <__NSArray0 0x7fff8062d570>(
    //
    //                    )
    //                    , "keyword": , "count": 0]
                        
                        let user_list = success["user_list"] as! [Dictionary<String, Any>]
                        
                        var list:Array<RLMObject> = []
                        let userid:String = sharePublicDataSingle.publicData.userid as String
                
                        for any in user_list {
                            
                            if any["userid"] as! String !=  userid {
                                let model = FriendsModel.init(value: any)
                                
                                if self!.isAddMember == false {
                                    if (self?.existMember?.contains(model.userid))! {
                                         list.append(model)
                                    }
                                }else {
                                     list.append(model)
                                }
                            }
                            
                           
                        }
                        
                        
                        if !self!.isDepartmentData {
                            self?.isLoadOtherDepartData = true
                            self?.otherDepartDataArray =  list
                        }else {
                            self?.isLoadDepartData = true
                            self?.departDataArray =  list
                        }
                        
                        self?.listTable.reloadData()
                        
                    }
        }
    
    func deleteGroupMember()  {
        
        var params = Dictionary<String, Any>()
        
        let userArray = self.isDepartmentData ? self.seleDepartArray : self.seleOtherDepartArray
        
        let idStr = (NSArray.init(array: userArray).value(forKeyPath: "userid") as! NSArray).componentsJoined(by: ",")
        
            //appToken:App登录Token groupId:群组ID userIdStr:删除的用户ID（,分割）
        params["app_token"] = sharePublicDataSingle.token
        params["groupid"] = groupid
        params["userid_str"] = idStr
        GroupRequest.delUser(params: params, hadToast: true, fail: { (Error) in
                    print(Error.description)
                }) {[weak self] (success) in
                    
                    print("删除群组列表\(success)");
                    
                    if let code = success["code"] {
                        if "\(code)" != "1" {
                            SVProgressHUD.showError(withStatus: success["msg"] as? String)
                            return
                        }
                    }
            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            var time:String? = UserDefaults.standard.object(forKey: username) as! String?
            if time == nil{
                time = "0"
            }
            UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { (error) in
    
            }, success: { (dic) in
                print(dic)
                self?.resultBlock?(userArray)
                self?.navigationController?.popViewController(animated: true)
            })
                    
                }
        }
    
    func addGroupMember()  {
    
    var params = Dictionary<String, Any>()
    
    let userArray = self.isDepartmentData ? self.seleDepartArray : self.seleOtherDepartArray
    
    let idStr = (NSArray.init(array: userArray).value(forKeyPath: "userid") as! NSArray).componentsJoined(by: ",")
    
        //appToken:App登录Token groupId:群组ID userIdStr:删除的用户ID（,分割）
    params["app_token"] = sharePublicDataSingle.token
    params["groupid"] = groupid
    params["userid_str"] = idStr
        
//    self.resultBlock?(userArray)
//    self.navigationController?.popViewController(animated: true)
//    return
    GroupRequest.inviteUser(params: params, hadToast: true, fail: { (Error) in
        print(Error.description)
            }) {[weak self] (success) in
                
                print("邀请群组列表\(success)");
                
                if let code = success["code"] {
                    if "\(code)" != "1" {
                        SVProgressHUD.showError(withStatus: success["msg"] as? String)
                        return
                    }
                }
        
        
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                if time == nil{
                    time = "0"
                }
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { (error) in
        
                }, success: { (dic) in
                    print(dic)
                    self?.resultBlock?(userArray)
                    self?.navigationController?.popViewController(animated: true)
                })
      
                
        }
    }
    
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destination.
        // Pass the selected object to the new view controller.
    }
    */
}
//
//  GroupNameEditViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/14.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
fileprivate let maxTextLength = 10
class GroupNameEditViewController: BaseViewController {
    var groupModel:GroupModel?{
    
        didSet {
            
            inputTextField.text = (groupModel?.group_name.count)! > maxTextLength ? groupModel?.group_name.substring(to: (groupModel?.group_name.index((groupModel?.group_name.startIndex)!, offsetBy: maxTextLength))!) : groupModel?.group_name
            countLabel.text = "\((inputTextField.text?.count)!)/\(maxTextLength)"
        }
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = UIColor.white
        self.title = "群组名称"
        
        self.setRightBtnWithArray(items: ["完成"])
        self.view.addSubview(inputTextField)
        self.view.addSubview(countLabel)
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    override func rightBtnClick(button: UIButton) {
        self.progressShow()
        GroupRequest.update(params: ["app_token":sharePublicDataSingle.token,"groupid":groupModel?.groupid,"group_name":inputTextField.text], hadToast: true, fail: { [weak self](error) in
            if let strongSelf = self {
                strongSelf.progressDismiss()
            }
        }) { [weak self](dic) in
            if let strongSelf = self {
                strongSelf.progressDismiss()
                let realm:RLMRealm = RLMRealm.default()
                realm.beginWriteTransaction()
                strongSelf.groupModel?.setValue(strongSelf.inputTextField.text, forKey: "group_name")
                try? realm.commitWriteTransaction()
                strongSelf.navigationController!.popViewController(animated: true)
            }
        }
    }
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        inputTextField.endEditing(true)
    }
    //MARK: --------------------------- Getter and Setter --------------------------
    fileprivate lazy var inputTextField: GroupNameEditTextField = {
        var inputTextField = GroupNameEditTextField.init(placeholder: "请输入群组名称")
        inputTextField.frame = CGRect.init(x: 15, y: NAV_HEIGHT + 15, width: SCREEN_WIDTH - 15 * 2, height: inputTF_height)
        inputTextField.delegate = self
        inputTextField.addTarget(self, action: #selector(textFieldDidChange), for: .editingChanged);
        return inputTextField
    }()
    
    fileprivate lazy var countLabel: UILabel = {
        var countLabel = UILabel.init(frame: CGRect.init(x: SCREEN_WIDTH - 15 - 40, y: NAV_HEIGHT + 15 + inputTF_height + 5, width: 40, height: 30))
        countLabel.font = FONT_14
        countLabel.textColor = UIColor.gray
        countLabel.textAlignment = .right
        return countLabel
    }()
    @objc func textFieldDidChange(textField : UITextField) { //同样的代码:适配iOS8
        if textField.textInputMode?.primaryLanguage == "zh-Hans" { //键盘输入模式 : 简体中文输入，包括简体拼音，健体五笔，简体手写
            let selectedRange : UITextRange? = textField.markedTextRange
            //获取高亮部分
            var position : UITextPosition? = nil
            if (selectedRange != nil) {
                position = textField.position(from: (selectedRange?.start)!, offset: 0)!
            }
            //没有高亮选择的字，则对已输入的文字进行字数统计和限制
            if position == nil {
                if (textField.text?.count)! > maxTextLength {
                    textField.text = textField.text?.substring(to: (textField.text?.index((textField.text?.startIndex)!, offsetBy: maxTextLength))!)
                    countLabel.text = "\(maxTextLength)/\(maxTextLength)"
                    return
                }
                countLabel.text = "\((textField.text?.count)!)/\(maxTextLength)"
            }else{ //有高亮选择的字符串，则暂不对文字进行统计和限制
            
            }
        }else{ //中文输入法以外的直接对其统计限制即可，不考虑其他语种情况
            if (textField.text?.count)! > maxTextLength {
                textField.text = textField.text?.substring(to: (textField.text?.index((textField.text?.startIndex)!, offsetBy: maxTextLength))!)
                countLabel.text = "\(maxTextLength)/\(maxTextLength)"
                return
            }
            countLabel.text = "\((textField.text?.count)!)/\(maxTextLength)"
        }
    }
}
extension GroupNameEditViewController : UITextFieldDelegate {
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        var str = textField.text?.replacingCharacters(in: (textField.text?.changeToRange(from: range)!)!, with: string)
        if textField.textInputMode?.primaryLanguage == "zh-Hans" {
            let selectedRange : UITextRange? = textField.markedTextRange
            var position : UITextPosition? = nil
            if (selectedRange != nil) {
                position = textField.position(from: (selectedRange?.start)!, offset: 0)!
            }
            if position == nil {
                if (str?.count)! > maxTextLength {
                    textField.text = str?.substring(to: (str?.index((str?.startIndex)!, offsetBy: maxTextLength))!)
                    countLabel.text = "\(maxTextLength)/\(maxTextLength)"
                    return false
                }
            }else{
                
            }
        }else{
            if (str?.count)! > maxTextLength {
                textField.text = str?.substring(to: (str?.index((str?.startIndex)!, offsetBy: maxTextLength))!)
                countLabel.text = "\(maxTextLength)/\(maxTextLength)"
                return false
            }
        }
        return true
    }
    func textFieldShouldClear(_ textField: UITextField) -> Bool {
//        countLabel.text = "0/\(maxTextLength)"
        return true
    }
}
//
//  GroupQRCodeViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/23.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupQRCodeViewController: BaseViewController {
    var groupModel:GroupModel?{
        
        didSet {
            
            self.getQrCodeWithGroupId(id: (groupModel?.groupid)!)
            headerImageView.sd_setImage(with: NSURL.init(string: groupModel?.icon_url != nil ? (groupModel?.icon_url)!  : " ") as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
            groupNameLabel.text = groupModel?.group_name
        }
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = UIColor.darkGray
        self.title = "群二维码名片"
        
        self.view.addSubview(bgView)
        bgView.addSubview(headerImageView)
        bgView.addSubview(groupNameLabel)
        bgView.addSubview(seperateLine)
        bgView.addSubview(qrCodeImageView)
        bgView.addSubview(bottomLabel)
        
        bgView.mas_makeConstraints { (make) in
            make!.left.equalTo()(20)
            make!.right.equalTo()(-20)
            make!.top.equalTo()(NAV_HEIGHT + kReal(value: 80))
            make!.bottom.equalTo()(kReal(value: -120))
        }
        headerImageView.mas_makeConstraints { (make) in
            make!.left.equalTo()(20)
            make!.top.equalTo()(20)
            make!.size.equalTo()(CGSize.init(width: 45, height: 45))
        }
        groupNameLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(self.headerImageView.mas_right)!.offset()(10)
            make!.right.equalTo()(-20)
            make!.centerY.equalTo()(self.headerImageView)
        }
        seperateLine.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(self.headerImageView)
            make!.right.equalTo()(-20)
            make!.top.equalTo()(self.headerImageView.mas_bottom)!.offset()(15)
            make!.height.equalTo()(0.5)
        }
        qrCodeImageView.mas_makeConstraints { (make) in
            make!.left.equalTo()(50)
            make!.top.equalTo()(self.headerImageView.mas_bottom)!.offset()(30)
            make!.right.equalTo()(-50)
            make!.height.equalTo()(SCREEN_WIDTH - 40 - 100)
        }
        bottomLabel.mas_makeConstraints { [unowned self](make) in
            make!.centerX.equalTo()(self.bgView)
            make!.top.equalTo()(self.qrCodeImageView.mas_bottom)!.offset()(20)
        }
    }
    func getQrCodeWithGroupId(id:String){
        self.progressShow()
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        params["groupid"] = id
        GroupRequest.getQrCode(params: params, hadToast: true, fail: { [weak self](error) in
            if let strongSelf = self {
                strongSelf.progressDismiss()
            }
        }) { [weak self](success) in
            if let strongSelf = self{
                strongSelf.progressDismiss()
                strongSelf.qrCodeImageView.sd_setImage(with: NSURL.init(string: (success["qr_url"] as? String) != nil ? success["qr_url"] as! String : " ") as URL?, placeholderImage: UIImage.init(named: ""))
                let currentDate : Date = Date()
                let dateFormatter : DateFormatter = DateFormatter()
                dateFormatter.dateFormat = "M月d日"
                
                if let life_day = success["life_day"], let expire = success["expire"] {
                    let endDate : Date = Date.init(timeIntervalSince1970:(expire as! TimeInterval))
                    let endDateStr : String = dateFormatter.string(from: endDate)
                    strongSelf.bottomLabel.text = "该二维码\(life_day)天内(\(endDateStr)前)有效,重新进入将更新"
                }else{
                    let endDate : Date = Date.init(timeInterval: 7*24*60*60, since: currentDate)
                    let endDateStr : String = dateFormatter.string(from: endDate)
                    strongSelf.bottomLabel.text = "该二维码7天内(\(endDateStr)前)有效,重新进入将更新"
                }
            }
        }
        
    }
    
    fileprivate lazy var bgView: UIView = {
        var bgView = UIView.init()
        bgView.backgroundColor = UIColor.white
        bgView.layer.cornerRadius = 2
        bgView.clipsToBounds = true
        return bgView
    }()
    fileprivate var headerImageView: UIImageView = {
        var headerImageView = UIImageView.init()
        headerImageView.layer.cornerRadius = 4.0
        headerImageView.clipsToBounds = true
        headerImageView.layer.borderColor = UIColor.hexString(hexString: headerBorderColor).cgColor
        headerImageView.layer.borderWidth = 0.5
        return headerImageView
    }()
    fileprivate var groupNameLabel: UILabel = {
        var groupNameLabel = UILabel.init()
        groupNameLabel.textColor = UIColor.black
        groupNameLabel.font = FONT_16
        return groupNameLabel
    }()
    fileprivate var seperateLine: UIView = {
        var seperateLine = UIView.init()
        seperateLine.backgroundColor = UIColor.lightGray
        return seperateLine
    }()
    fileprivate var qrCodeImageView: UIImageView = {
        var qrCodeImageView = UIImageView.init()
        return qrCodeImageView
    }()
    fileprivate var bottomLabel: UILabel = {
        var bottomLabel = UILabel.init()
        bottomLabel.textColor = UIColor.darkGray
        bottomLabel.font = FONT_12
        return bottomLabel
    }()
}
//
//  GroupNoticeEditViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/20.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupNoticeEditViewController: BaseViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = UIColor.white
        self.title = "群公告"
        self.setRightBtnWithArray(items: ["完成"])
        
        self.view.addSubview(inputTextView)
        inputTextView.mas_makeConstraints { (make) in
            make!.top.equalTo()(20)
            make!.left.equalTo()(10)
            make!.right.equalTo()(-10)
            make!.height.equalTo()(300)
        }
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    override func rightBtnClick(button: UIButton) {
        self.navigationController!.popViewController(animated: true)
    }
    
    lazy var inputTextView: UITextView = {
        var inputTextView = UITextView.init()
        inputTextView.font = FONT_16
        inputTextView.textColor = UIColor.black
        return inputTextView
    }()
}
//
//  GroupListViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/2/28.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import MJRefresh
let kGROUP_SYSTEM = "group_system"
class GroupListViewController: RCConversationListViewController {
    
    var newTargetId : String? //新加入的群组Id,不为空时直接进入会话页面
    var fakeView = FakeTabView.init()
    let  header = HYPrivateListHeaderView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 65))
    var systemMsgArr = NSMutableArray.init()
    override func viewDidLoad() {
        super.viewDidLoad()
        
        
        self.configNav()
//        view.backgroundColor = UIColor.white
        self.title = "群组列表"
        self.view.backgroundColor = UIColor.hexString(hexString: "272727")
        self.setRightBtnWithArray(items: [UIImage.init(named: "nav_add")])
        self.makeNavigationBackBtn()
        self.isShowNetworkIndicatorView = false
        
        if #available(iOS 11.0, *) {
            self.conversationListTableView.contentInsetAdjustmentBehavior = .never
        }else {
        }
       
//        self.conversationListTableView.backgroundColor = UIColor.orange
//        let rightBtn2 = UIButton.init(type: .custom)
//        rightBtn2.frame =  CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight)
//        rightBtn2.setImage(UIImage.init(named: "ewmbgtop"), for: .normal)
//        rightBtn2.sizeToFit()
//        rightBtn2.addTarget(self, action: #selector(scanClick(btn:)), for: .touchUpInside)
//        let rightBarButtonItem2 = UIBarButtonItem.init(customView: rightBtn2)
//        self.navigationItem.rightBarButtonItems?.append(rightBarButtonItem2)
        self.setDisplayConversationTypes([RCConversationType.ConversationType_SYSTEM.rawValue,RCConversationType.ConversationType_GROUP.rawValue,RCConversationType.ConversationType_PRIVATE.rawValue])
        self.setCollectionConversationType([RCConversationType.ConversationType_PRIVATE.rawValue,RCConversationType.ConversationType_SYSTEM.rawValue])
        self.showConnectingStatusOnNavigatorBar = true
        //                self.refreshConversationTableViewIfNeeded()
        self.conversationListTableView.tableFooterView = UIView.init()
        
        self.conversationListTableView.tag = 10086 //方便获取conversationListTableView
        self.conversationListTableView.frame = CGRect(x: self.conversationListTableView.frame.origin.x, y: NAV_HEIGHT, width: self.conversationListTableView.frame.width, height: MAIN_SCREEN_HEIGHT_PX - NAV_HEIGHT)
//        if #available(iOS 11, *) {
//            self.conversationListTableView.contentInsetAdjustmentBehavior = .never
//        }else {
//            self.automaticallyAdjustsScrollViewInsets = false
//        }
        
        self.conversationListTableView.mj_header? = MJRefreshNormalHeader(refreshingTarget: self, refreshingAction:#selector(headerRefresh))
        self.emptyConversationView = UIView.init()
        self.configHeader()
        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
        let getRemote:Bool? = UserDefaults.standard.object(forKey: getRemoteKey + username) as! Bool?
        if getRemote!{ //首次进入时同步会话
            self.progressShow()
            self.getRemoteMessage(success: {
                self.progressDismiss()
            }, error: {
                self.progressDismiss()
            })
        }
        //        self.view.addSubview(RepeatMessageView(type: "test", model: GroupModel() , message:""))
        
        RCIM.shared().connectionStatusDelegate = self
        RCIM.shared()?.receiveMessageDelegate = self
        //        RCIM.shareas.registerMessageType(ThemeMessageContent.self)
//        RCIM.shared().registerMessageType(HistoryMessageContent.self)
        self.registerCustomerMessageContent()
        
        NotificationCenter.default.addObserver(self, selector: #selector(clickOnePerson(noti:)), name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil)
//        self.addFakeTab()
    }
    
    func configHeader(){
        header.cellClickWithTargetId = { (idStr,nameStr) in
            guard idStr != kGROUP_SYSTEM else{
                RCIMClient.shared()?.clearMessagesUnreadStatus(RCConversationType.ConversationType_SYSTEM, targetId: kGROUP_SYSTEM)
                // MARK:系统消息
                let sbc = SbcViewController()
                
                let urlString =  kBASE_URL + "sbc.html#/showTcp?tcpRouter=/myGroupTips"
                sbc.url = urlString
                sbc.token = sharePublicDataSingle.token as String
                sbc.viewTitle = "系统消息"
                self.navigationController?.pushViewController(sbc, animated: true)
                return
            }
           
          
        }
        
        self.conversationListTableView.tableHeaderView = header;
    }
    
    @objc func clickOnePerson(noti:Notification) {
        
        let userinfo = noti.userInfo
        
        let userid:String = userinfo?["str"]as! String
        
    
        let sbc = SbcViewController()
        
        let urlString = kBASE_URL +  "sbc.html#/showTcp?tcpRouter=/center/page/\(userid)"
        sbc.url = urlString
        sbc.viewTitle = "个人主页"
        self.navigationController?.pushViewController(sbc, animated: true)
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        DispatchQueue.main.async {
            
//            self.fakeView.showBage(type: .group, bage: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_PRIVATE,RCConversationType.ConversationType_GROUP])))
            let addbtn = self.navigationItem.rightBarButtonItems![0]
            addbtn.showBadge(with: WBadgeStyle.number, value: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_PRIVATE,RCConversationType.ConversationType_SYSTEM])), animationType: WBadgeAnimType.none)
            
            self.headerRefresh()
        }
    }
    
    func getRemoteMessage(success: (() -> ())!, error: (() -> ())!) {
        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
        let getRemote:Bool? = UserDefaults.standard.object(forKey: getRemoteKey + username) as! Bool?
        //切换账号时需要重新同步会话列表
        if getRemote! {
            let groupModels = GroupModel.objects(with: NSPredicate.init(format: "is_delete == '0' AND is_remove == '0'"))
            //            if groupModels.count == 0 {
            //                success()
            //                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            //                UserDefaults.standard.set(false, forKey: getRemoteKey + username)
            //                return
            //            }
            var realArr : Array<GroupModel> = []
            for i in 0..<groupModels.count {
                let groupModel : GroupModel = groupModels[i] as! GroupModel
                let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@ AND is_delete == '0'", sharePublicDataSingle.publicData.userid,groupModel.groupid)).firstObject() as! GroupUserModel?
                if groupUserModel != nil {
                    realArr.append(groupModel)
                }
            }
            if realArr.count == 0 {
                success()
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                UserDefaults.standard.set(false, forKey: getRemoteKey + username)
                return
            }
            
            self.getRemoteHistoryMessages(from: 0, grouplist: realArr,successCount:0)
        }
        
    }
    
    func getRemoteHistoryMessages(from:Int ,grouplist:Array<GroupModel>, successCount:Int) {
        
        if from == grouplist.count { //全部获取一遍并且有成功的(不能保证全部成功)
            self.progressDismiss()
            self.conversationListTableView.mj_header?.endRefreshing()
            if  successCount > 0 {//有成功的(不能保证全部成功)
                
                let arr = RCIMClient.shared().getConversationList([RCConversationType.ConversationType_GROUP.rawValue]) as NSArray
                
                for conversation in arr {
                    self.conversationListDataSource.add(RCConversationModel.init(conversation: (conversation as! RCConversation), extend: nil))
                }
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                UserDefaults.standard.set(false, forKey: getRemoteKey + username)
                
                
                self.refreshConversationTableViewIfNeeded()
            }
            return
        }
        let groupModel : GroupModel = grouplist[from]
        DispatchQueue.main.async {
            
            RCIMClient.shared()?.getRemoteHistoryMessages(.ConversationType_GROUP, targetId: groupModel.groupid, recordTime: 0, count: 5, success: { [weak self] (array, success) in
                if let strongSelf = self {
                    strongSelf.getRemoteHistoryMessages(from: from + 1, grouplist: grouplist,successCount:successCount + 1)
                }
            }, error: { (errorCode) in
                
                self.getRemoteHistoryMessages(from: from + 1, grouplist: grouplist,successCount:successCount)
//                if let strongSelf = self {
//
//
//                }
            })
//            RCIMClient.shared().getRemoteHistoryMessages(.ConversationType_GROUP, targetId: groupModel.groupid, recordTime: 0, count: 5, success: { [weak self](array) in
//
//                if let strongSelf = self {
//                    strongSelf.getRemoteHistoryMessages(from: from + 1, grouplist: grouplist,successCount:successCount + 1)
//                }
//                }, error: { [weak self](errorCode) in
//                    if let strongSelf = self {
//
//                        strongSelf.getRemoteHistoryMessages(from: from + 1, grouplist: grouplist,successCount:successCount)
//                    }
//            })
        }
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    private func makeNavigationBackBtn() {
        let backBtn = UIButton.init(frame: CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight))
        backBtn.addTarget(self, action: #selector(backBtnDidClick), for: .touchUpInside)
        backBtn.setImage(UIImage.init(named: "nav_back"), for: .normal)
        backBtn.sizeToFit()
        let leftBarButtonItem = UIBarButtonItem.init(customView: backBtn)
        self.navigationItem.leftBarButtonItem = leftBarButtonItem
    }
    
    //左上角返回按钮点击事件
    @objc func backBtnDidClick() {
        self.dismiss(animated: true) {
            //断开融云链接
            RCIM.shared().logout()
        }
    }
    
    override func rightBtnClick(button: UIButton) {
        
        UIApplication.shared.keyWindow?.addSubview(comboboxView!)
        comboboxView?.btnList[1].badgeCenterOffset = CGPoint.init(x: -73, y: 10)
        comboboxView?.btnList[1].showBadge(with: WBadgeStyle.number, value: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_PRIVATE])), animationType: WBadgeAnimType.none)
        //        comboboxView?.btnList[3].badgeCenterOffset = CGPoint.init(x: -73, y: 10)
        //        comboboxView?.btnList[3].showBadge(with: WBadgeStyle.number, value: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_SYSTEM])), animationType: WBadgeAnimType.none)
    }
    @objc func emptyBtnClick(button: UIButton) {
        self.progressShow()
        GroupRequest.joinPublicGroup(params: ["app_token":sharePublicDataSingle.token], hadToast: true, fail: { [weak self](error) in
            if let strongSelf = self {
                strongSelf.progressDismiss()
            }
            
            }, success: { (dic) in
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                let time = UserDefaults.standard.object(forKey: username) as! String
                
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                    
                    }, success: {[weak self] (dic) in
                        
                        if let strongSelf = self {
                            strongSelf.progressDismiss()
                            strongSelf.refreshConversationTableViewIfNeeded()
                            
                        }
                    }
                )
                
        })
    }
    @objc func scanClick(btn:Any) {
        let str = "{\"action\":\"goto\",\"data\":{\"data\":\"\",\"subAction\":\"scan\"}}"
        //        let notice = NSNotification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : str])
        let notice = Notification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : str])
        NotificationCenter.default.post(notice)
    }
    
    @objc func headerRefresh(){
        
        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
        var time:String? = (UserDefaults.standard.object(forKey: username) as! String?)
        
        if (time == nil ){
            time = "0"
        }
        
        UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (error) in
            if let strongSelf = self {
                strongSelf.conversationListTableView.mj_header?.endRefreshing()
            }
            
            }, success: {[weak self] (dic) in
                
                if let strongSelf = self {
                    let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                    let getRemote:Bool? = UserDefaults.standard.object(forKey: getRemoteKey + username) as! Bool?
                    if getRemote! {
                        strongSelf.getRemoteMessage(success: {
                            strongSelf.conversationListTableView.mj_header?.endRefreshing()
                        }, error: {
                            strongSelf.conversationListTableView.mj_header?.endRefreshing()
                            
                        })
                    }else{
                        strongSelf.conversationListTableView.mj_header?.endRefreshing()
                        strongSelf.refreshConversationTableViewIfNeeded()
                    }
                }
            }
        )
        
    }
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }
    //重写RCConversationListViewController的onSelectedTableRow事件
    override func onSelectedTableRow(_ conversationModelType: RCConversationModelType, conversationModel model: RCConversationModel!, at indexPath: IndexPath!) {
        //打开会话界面
        if conversationModelType == RCConversationModelType.CONVERSATION_MODEL_TYPE_CUSTOMIZATION {
            
            //            let talk = SmallTalkVC(conversationType: (model?.conversationType)!, targetId: model?.targetId)
            //            self.navigationController?.pushViewController(talk!, animated: true)
            
            let tabBarVc : TMTabbarController = TMTabbarController()
            tabBarVc.groupModel = model
            self.navigationController?.pushViewController(tabBarVc, animated: true)
            
        }
    }
    
    override func willReloadTableData(_ dataSource: NSMutableArray!) -> NSMutableArray! {
        super.willReloadTableData(dataSource)
        var tempDelGroupModels = Array<RCConversationModel>()//应该移除的融云会话模型(永久移除)
        var tempDelSubGroupModels = Array<RCConversationModel>()//应该移除的话题会话模型(非永久移除)
        
        for i in 0..<dataSource.count {
            let model : RCConversationModel = dataSource[i] as! RCConversationModel
            
//            if model.targetId == kGROUP_SYSTEM {
//                if systemMsgArr.count > 0 {
//                    systemMsgArr.replaceObject(at: 0, with: model)
//                }else {
//                    systemMsgArr.add(model)
//                }
//            }else {
                let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@ AND is_delete == '0'",model.targetId)).firstObject() as! GroupModel?
                if groupModel == nil ||  groupModel?.is_delete == "1"{
                    tempDelGroupModels.append(model)
                    continue
                }
                if groupModel?.type == "1" {//话题
                    tempDelSubGroupModels.append(model)
                    continue
                }
                model.conversationModelType = RCConversationModelType.CONVERSATION_MODEL_TYPE_CUSTOMIZATION
                model.conversationTitle = groupModel?.group_name
                model.extend = groupModel?.icon_url
                model.topCellBackgroundColor = UIColor.hexString(hexString: "DCDCDC")
                model.cellBackgroundColor = UIColor.white
//            }
            
            
        }
        for model in tempDelGroupModels {//移除数据库中不包含的会话
            dataSource.remove(model)
            RCIMClient.shared().clearMessages(model.conversationType, targetId: model.targetId)
            RCIMClient.shared().remove(model.conversationType, targetId: model.targetId)
        }
        for model in tempDelSubGroupModels {//移除话题会话数据
            dataSource.remove(model)
        }
        
        if (newTargetId != nil) {
            for i in 0..<dataSource.count {
                let model : RCConversationModel = dataSource[i] as! RCConversationModel
                if newTargetId == model.targetId {
                    newTargetId = nil
                    DispatchQueue.main.async {
                        let tabBarVc : TMTabbarController = TMTabbarController()
                        tabBarVc.groupModel = model
                        self.navigationController?.pushViewController(tabBarVc, animated: true)
                        //                        let talk = SmallTalkVC(conversationType: model.conversationType, targetId: model.targetId)
                        //                        self.navigationController?.pushViewController(talk!, animated: true)
                        
                    }
                }
                
            }
            
        }
        
//        if systemMsgArr.count < 1 {
//            let model : RCConversationModel = RCConversationModel.init()
//            model.targetId = kGROUP_SYSTEM
//            model.conversationModelType = RCConversationModelType.CONVERSATION_MODEL_TYPE_CUSTOMIZATION
//            model.conversationType = RCConversationType.ConversationType_SYSTEM
//            model.conversationTitle = "系统消息"
//            model.objectName = "RC:TxtMsg"
//            model.extend = ""
//            model.blockStatus = RCConversationNotificationStatus(rawValue: 1)!
//            model.topCellBackgroundColor = UIColor.hexString(hexString: "DCDCDC")
//            model.cellBackgroundColor = UIColor.white
//            let lastMsg = RCTextMessage.init(content: "暂时没有新消息")
//            model.lastestMessage = lastMsg
//            systemMsgArr.add(model)
//        }
//
//        dataSource.insert(systemMsgArr.firstObject as Any, at: 0)
        self.conversationListDataSource = dataSource
        self.configHeaderData()
        DispatchQueue.main.async {
            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            let getRemote:Bool? = UserDefaults.standard.object(forKey: getRemoteKey + username) as! Bool?
            if dataSource.count == 0 && getRemote! == false{
                if sharePublicDataSingle.publicData.corpid == "0" {
                    self.conversationListTableView.addSubview(self.emptyBtn)
                }else{
                    
                    self.conversationListTableView.addSubview(self.emptyImg)
                }
            }else{
                self.emptyBtn.removeFromSuperview()
                self.emptyImg.removeFromSuperview()
            }
        }
        
        //        self.footLabel.text = "\(dataSource.count)个群聊"
        return dataSource
    }
    
    func configHeaderData(){
        header.refresh()
    }
    
    lazy var emptyBtn : UIButton = {
        var  emptyBtn = UIButton.init()
        emptyBtn.setImage(UIImage.init(named: "emptyImg22"), for: .normal)
        emptyBtn.adjustsImageWhenHighlighted = false
        emptyBtn.sizeToFit()
        emptyBtn.addTarget(self, action: #selector(self.emptyBtnClick), for: .touchUpInside)
        emptyBtn.center = self.conversationListTableView.center
        return emptyBtn
        
    }()
    lazy var emptyImg : UIImageView = {
        var emptyImg = UIImageView.init(image: UIImage.init(named: "emptyImg11"))
        emptyImg.center = self.conversationListTableView.center
        return emptyImg
        
    }()
    override func rcConversationListTableView(_ tableView: UITableView!, heightForRowAt indexPath: IndexPath!) -> CGFloat {
        return 64
    }
    override func rcConversationListTableView(_ tableView: UITableView!, cellForRowAt indexPath: IndexPath!) -> RCConversationBaseCell! {
        let cell = GroupListCell.cell(withTableView: tableView)
        let model = self.conversationListDataSource![indexPath.row] as! RCConversationModel
        cell.setDataModel(model)
        
//        if model.targetId == kGROUP_SYSTEM {
//            cell.nameLabel.text = "系统消息"
//            cell.headerImageView.image = UIImage.init(named: "commenticon")
//        }
        if MessageCenterModel.objects(with: NSPredicate(format: "parentId == %@", cell.model.targetId)).count != 0 {
            cell.badgeLb.isHidden = false
        }
        return cell
        
    }
    
    override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {
        let conversationModel : RCConversationModel = self.conversationListDataSource![indexPath.row] as! RCConversationModel
        let delAction = UITableViewRowAction.init(style: .destructive, title: "删除") { (action, indexPath) in
            RCIMClient.shared().remove(conversationModel.conversationType, targetId: conversationModel.targetId)
            RCIMClient.shared().clearMessages(conversationModel.conversationType, targetId: conversationModel.targetId)
            let realm:RLMRealm = RLMRealm.default()
            let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",conversationModel.targetId)).firstObject() as! GroupModel?
            realm.beginWriteTransaction()
            groupModel?.setValue("1", forKey: "is_remove")
            try? realm.commitWriteTransaction()
            
            self.refreshConversationTableViewIfNeeded()
        }
        var topAction : UITableViewRowAction?
        if conversationModel.isTop{
            topAction = UITableViewRowAction.init(style: .destructive, title: "取消置顶") { (action, indexPath) in
                RCIMClient.shared().setConversationToTop(conversationModel.conversationType, targetId: conversationModel.targetId, isTop: false)
                self.refreshConversationTableViewIfNeeded()
            }
            
        }else{
            topAction = UITableViewRowAction.init(style: .destructive, title: "置顶") { (action, indexPath) in
                RCIMClient.shared().setConversationToTop(conversationModel.conversationType, targetId: conversationModel.targetId, isTop: true)
                self.refreshConversationTableViewIfNeeded()
            }
        }
        topAction?.backgroundColor = UIColor.hexString(hexString: "c7c7c7")
        return [delAction,topAction!]
    }
    override func didReceiveMessageNotification(_ notification: Notification!) {
        DispatchQueue.main.async {
//            self.fakeView.showBage(type: .group, bage: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_PRIVATE,RCConversationType.ConversationType_GROUP])))
            let addbtn = self.navigationItem.rightBarButtonItems![0]
            addbtn.showBadge(with: WBadgeStyle.number, value: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_PRIVATE])), animationType: WBadgeAnimType.none)
        }
        
        let message : RCMessage = notification.object as! RCMessage
        
        if message.conversationType == .ConversationType_PRIVATE {
            let pri = PrivateUserModel()
            pri.id = message.targetId
            DataBaseOperation.addData(rlmObject: pri)
        }
        
        print("groupid == " + message.targetId)
        let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",message.targetId)).firstObject() as! GroupModel?
        if groupModel?.is_remove == "1" {
            let realm:RLMRealm = RLMRealm.default()
            realm.beginWriteTransaction()
            groupModel?.setValue("0", forKey: "is_remove")
            try? realm.commitWriteTransaction()
        }
        if message.objectName == RCGroupNotificationMessageIdentifier {//群组通知类消息
            
            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            let time = UserDefaults.standard.object(forKey: username) as! String
            
            UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { [weak self](error) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                }
                
                }, success: {[weak self] (dic) in
                    
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                        //                    let me = message.content as! RCGroupNotificationMessage
                        //                    if !(me.operatorUserId == sharePublicDataSingle.publicData.im_userid) {
                        //                        strongSelf.refreshConversationTableViewIfNeeded()
                        //                    }
                        let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",message.targetId)).firstObject() as! GroupModel?
                        if groupModel != nil {
                            let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,(groupModel?.groupid)!)).firstObject() as! GroupUserModel?
                            if groupModel?.is_delete == "1" || groupUserModel?.is_delete == "1"{
                                RCIMClient.shared().setConversationToTop(.ConversationType_GROUP, targetId: message.targetId, isTop: false)
                            }
                        }
                        
                        if strongSelf.navigationController?.topViewController is GroupListViewController{
                            strongSelf.refreshConversationTableViewIfNeeded()
                            
                        }
                        if strongSelf.navigationController?.topViewController is SmallTalkVC{
                            let vc : SmallTalkVC = strongSelf.navigationController?.topViewController as! SmallTalkVC
                            
                            vc.refreshUserInfoOrGroupInfo()
                            let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,message.targetId)).firstObject() as! GroupUserModel?
                            if groupUserModel?.is_delete == "1"{
                                vc.makeNavigationRightBtn(canClick: false)
                                
                            }else{
                                vc.makeNavigationRightBtn(canClick: true)
                                
                            }
                            
                        }
                        if strongSelf.navigationController?.topViewController is GroupSettingViewController {
                            let vc : GroupSettingViewController = strongSelf.navigationController?.topViewController as! GroupSettingViewController
                            let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,message.targetId)).firstObject() as! GroupUserModel?
                            if groupUserModel?.is_delete == "1"{
                                vc.navigationController?.popToRootViewController(animated: true)
                            }else{
                                vc.reloadHeaderData()
                            }
                        }
                        if strongSelf.navigationController?.topViewController is GroupQRCodeViewController {
                            let vc : GroupSettingViewController = strongSelf.navigationController?.children[(strongSelf.navigationController?.children.count)! - 2] as! GroupSettingViewController
                            let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,message.targetId)).firstObject() as! GroupUserModel?
                            if groupUserModel?.is_delete == "1"{
                                vc.navigationController?.popToRootViewController(animated: true)
                            }else{
                                vc.reloadHeaderData()
                            }
                        }
                    }
                }
            )
        }else{
            if self.navigationController?.topViewController is GroupListViewController{
                let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",message.targetId)).firstObject() as! GroupModel?
                if groupModel != nil { //数据库中没有更新下来的会话暂时不需要显示
                    self.refreshConversationTableViewIfNeeded()
                }
                
            }
        }
    }
    
    lazy var footView: UIView = {
        var footView : UIView = UIView.init(frame: CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 40))
        var separateLine : UIView = UIView.init(frame: CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 0.5))
        separateLine.backgroundColor = separateLine_Color
        footView.addSubview(separateLine)
        footView.addSubview(self.footLabel)
        return footView
    }()
    
    lazy var footLabel: UILabel = {
        var footLabel : UILabel = UILabel.init(frame: CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 40))
        footLabel.font = FONT_14
        footLabel.textColor = UIColor.darkGray
        footLabel.textAlignment = .center
        return footLabel
    }()
    
    lazy var comboboxView: ComboboxView? = {
        var comboboxView = ComboboxView.init(titles: ["创建群组","查找群组"], imageNames: [["group_add","search_white"],["group_add","search_white"]], bgImgName: "combobox", frame: CGRect.init(x: SCREEN_WIDTH - 100 - 10, y: NAV_HEIGHT, width: 100, height: (oneRow_height * 2 + TOP_PADDING + 1)))
        comboboxView.delegate = self
        return comboboxView
    }()
    
    
    
    
    /// 假tab
    func addFakeTab(){
        
        self.fakeView = FakeTabView.init(frame: CGRect(x: 0, y: MAIN_SCREEN_HEIGHT_PX-kFakeTab_HEIGHT , width: kScreenW, height: kFakeTab_HEIGHT))
        self.fakeView.congigUI(menuList: nil)
        
        self.view.addSubview(self.fakeView)
        
        //显示红点
        //        fakeView.showBage(type: .mine, bage: 4)
        NotificationCenter.default.addObserver(forName: NSNotification.Name(rawValue: "changeMyRedCount"), object: nil, queue: nil) { (notif) in
            self.fakeView.showBage(type: .mine, bage: Int(notif.userInfo?["myRedCount"] as! String)!)
            //            self.comboboxView?.badgeCenterOffset = CGPoint.init(x: 10, y: 10)
            let addbtn = self.navigationItem.rightBarButtonItems![0]
            addbtn.showBadge(with: WBadgeStyle.number, value: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_PRIVATE,RCConversationType.ConversationType_SYSTEM])), animationType: WBadgeAnimType.none)
        }
        NotificationCenter.default.addObserver(forName: NSNotification.Name(rawValue: "changeGroupRedCount"), object: nil, queue: nil) { (notif) in
            self.fakeView.showBage(type: .group, bage: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_PRIVATE,RCConversationType.ConversationType_GROUP])))
            //            self.comboboxView?.badgeCenterOffset = CGPoint.init(x: 10, y: 10)
            let addbtn = self.navigationItem.rightBarButtonItems![0]
            addbtn.showBadge(with: WBadgeStyle.number, value: 1, animationType: WBadgeAnimType.none)
        }
        //按钮点击响应
        fakeView.fakeType {[weak self] (type) in
            
            var str = "{\"action\":\"goto\",\"data\":{\"data\":\"\",\"subAction\":\""
            
            switch type {
            case .friend:
                str += "friends"
                break
            case .group:
                str += "group"
                break
            case .finding:
                str += "find"
                break
            case .course:
                str += "classes"
                break
            case .mine:
                str += "center"
                break
            case .helpingStatus:
                str += "helpingStatus"
                break
            default:
                break
            }
            
            str += "\"}}"
            if type != .group{
                let notice = Notification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : str])
                NotificationCenter.default.post(notice)
            }
        }
        
        
    }
}
extension GroupListViewController : ComboboxViewDelegate {
    
    func comboboxViewOneRowClick(button: UIButton) {
        switch button.tag {
        case 10:
            let addMemeberVc = GroupCreateVC()
//            addMemeberVc.isCreatGroup = true
            
            self.navigationController?.pushViewController(addMemeberVc, animated: true)
        case 11:
            let search = GroupSearchVC()
            self.navigationController?.pushViewController(search, animated: true)
            
            break
//        case 12:
//            let search = PrivateListViewController.init()
//            self.navigationController?.pushViewController(search, animated: true)
//            break
//        case 13:
//            let search = PrivateListViewController.init()
//            self.navigationController?.pushViewController(search, animated: true)
//            break
            
        default:
            break
        }
    }
}
extension GroupListViewController:RCIMConnectionStatusDelegate,RCIMReceiveMessageDelegate{
    
    func onRCIMConnectionStatusChanged(_ status: RCConnectionStatus) {
        
        //        if RCIMClient.shared().getCurrentNetworkStatus() == RCNetworkStatus.notReachable  {
        //            self.isShowNetworkIndicatorView = true
        //        }
        //        else{
        //            self.isShowNetworkIndicatorView = false
        //        }
        
        if status == .ConnectionStatus_KICKED_OFFLINE_BY_OTHER_CLIENT {
            
            
            
            
//            let str = "{\"action\":\"goto\",\"data\":{\"data\":\"\",\"subAction\":\"kick\"}}"
//            //        let notice = NSNotification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : str])
//            let notice = Notification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : str])
//            NotificationCenter.default.post(notice)
            
            
            let alert = UIAlertController(title: "温馨提示", message:"您的账号已经在别的设备登录,您在当前设备被迫下线！", preferredStyle: .alert)
            let okAction = UIAlertAction(title: "确定", style: .default, handler: { action in
                
            })
            alert.addAction(okAction)
            
            
            self.present(alert, animated: true, completion: nil)
            
            
            
            
            
            //            SVProgressHUD.showError(withStatus: "账号在别的设备登录，本设备被迫下线")
            //            SVProgressHUD.dismiss(withDelay: 1)
        }else if status == .ConnectionStatus_Unconnected{
            
            //            self.navigationController?.view.makeToast("当前与服务器未连接", duration: 3.0, position: .center)
            
        }else if status == .ConnectionStatus_Connected{
            //            self.navigationController?.view.makeToast("已经连接服务器", duration: 3.0, position: .center)
        }
    }
    //onRCIMReceiveMessage
    func onRCIMReceive(_ message: RCMessage!, left: Int32) {
        print(message)
        print("-------------")
        if message.targetId.elementsEqual("group_system") {
            //系统消息
            DispatchQueue.main.async {
                let cell = self.header.subCellArray.first
//                cell.badgeLb.
                if message.content is RCTextMessage {
                    let textmsg = message.content as! RCTextMessage
                    cell?.detailLabel.text = textmsg.content
                }else {
                    cell?.detailLabel.text = "收到一条新消息"
                }
            }
        }
    }
    
}
//
//  SelectMyGroup.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/4/21.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
enum ConversationType {
    case group
    case theme
}
class SelectMyGroup:BaseViewController {
    
    var table:UITableView?
    var searchView:BaseSearchView?
    
    var finishSelect:(_ selectList:Array<RLMObject>,_ otherText:String?)->() = {
        a,b in
    }
    
    //基础数据源
    var groupDataArray:Array<RLMObject>? = []
    var themeDataArray:Array<RLMObject>? = []
    var groupSearchText : String? = ""
    var themeSearchText : String? = ""
    //当前显示的数据源
    var dataArray:Array<RLMObject>?
    var selectedArray:Array<RLMObject>? = [] //记录已经选择的群组/话题
    var conversationList : NSArray = []
    var message : RCMessageContent? //转发的消息
    var hiddenSelectIcon:Bool? = true //默认为单选
    var leftBtn:UIButton?
    var rightBtn:UIButton?
    fileprivate var conversationType: ConversationType! = .group
    var iszhuanfa : Bool? //用来区分转发和转推
    var targetId : String?{
        didSet{
            conversationList = RCIMClient.shared().getConversationList([RCConversationType.ConversationType_GROUP.rawValue]) as NSArray
            
            let idArr = NSMutableArray.init(array: conversationList.value(forKeyPath: "targetId") as! NSArray) 
            var isTopIdArr = Array<String>()
            var allDataArray : Array<RLMObject>? = []
            for i in 0..<idArr.count {
                let groupid : String = idArr[i] as! String
                let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,groupid)).firstObject() as! GroupUserModel?
                let conversation = RCIMClient.shared().getConversation(.ConversationType_GROUP, targetId: groupid)
                if groupUserModel?.is_delete == "0" && groupid != targetId {
                    if let groupModel = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@ AND is_delete == '0'",groupid)).firstObject() as! GroupModel?{
                        if (conversation?.isTop)! {
                            let index = (allDataArray?.count)!
                            allDataArray?.insert(groupModel, at: index)
                        }else{
                            
                            allDataArray?.append(groupModel)
                        }
                    }
                
                    isTopIdArr.append(groupid)
                }
            }
            
//            for i in 0..<idArr.count {
//                let groupid : String = idArr[i] as! String
//                let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,groupid)).firstObject() as! GroupUserModel?
//                if groupUserModel?.is_delete == "0" && groupid != targetId && !isTopIdArr.contains(groupid){
//                    self.allDataArray?.append(GroupModel.objects(with: NSPredicate.init(format: "groupid == %@ AND is_delete == '0'",groupid)).firstObject()!)
//                }
//            }
           
            self.groupDataArray = allDataArray?.filter({ (model:RLMObject) -> Bool in
                return (model as! GroupModel).type == "0"
            })
            self.themeDataArray = allDataArray?.filter({ (model:RLMObject) -> Bool in
                return (model as! GroupModel).type == "1"
            })
            self.dataArray = self.groupDataArray
       
        }
        
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.configUI()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
    }
    
    /// UI初始化
    fileprivate func configUI()
    {
        
        self.view.backgroundColor = UIColor.groupTableViewBackground
        
        leftBtn = UIButton.init(type: .custom)
        leftBtn?.frame = CGRect.init(x: 0, y: 100, width: 60, height: 30)
        leftBtn?.setTitleColor(UIColor.white, for: .normal)
        leftBtn?.setImage(UIImage.init(named: "nav_back"), for: .normal)
        leftBtn?.sizeToFit()
        let leftItem  = UIBarButtonItem.init(customView: leftBtn!)
        leftBtn?.addTarget(self, action: #selector(leftClick), for: .touchUpInside)
        self.navigationItem.leftBarButtonItem = leftItem
        rightBtn = UIButton.init(type: .custom)
        rightBtn?.frame = CGRect.init(x: 0, y: 100, width: 60, height: 30)
        rightBtn?.setTitle("多选", for:.normal)
        rightBtn?.setTitleColor(UIColor.white, for: .normal)
        rightBtn?.sizeToFit()
        let rightItem  = UIBarButtonItem.init(customView: rightBtn!)
        rightBtn?.addTarget(self, action: #selector(rightClick), for: .touchUpInside)
        self.navigationItem.rightBarButtonItem = rightItem
        
        searchView = Bundle.main.loadNibNamed("BaseSearchView", owner: self, options: nil)?.last as? BaseSearchView
        searchView?.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: searchView_height)
        searchView?.configCollectionViewWith(isShowCollect: true)
        searchView?.delegate = self
        searchView?.isShowCollectionView = true
        self.view.addSubview(searchView!)
        
        var tableY : CGFloat = NAV_HEIGHT+searchView_height
        if self.iszhuanfa! {
            tableY += cardView_height
            let cardView = CardView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT+searchView_height, width: self.view.frame.size.width, height: cardView_height))
            cardView.creatBtnsWithTitles(titlesArr: ["闲聊","话题"])
            cardView.btnClickBlock = ({ (btn) in
                switch btn.tag {
                case 10:
                    self.conversationType = .group
                    self.searchView?.searchView.text = self.groupSearchText
                    self.searchViewResearch(keyText: self.groupSearchText, dataArr: self.groupDataArray)
                case 11:
                    self.conversationType = .theme
                    self.searchView?.searchView.text = self.themeSearchText
                    self.searchViewResearch(keyText: self.themeSearchText, dataArr: self.themeDataArray)
                    
                default:
                    break
                }
                self.showRemind()
                self.table?.reloadData()
            })
            self.view .addSubview(cardView)
        }
        
        table = UITableView.init(frame: CGRect.init(x: 0, y: tableY, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-tableY))
        table?.backgroundColor = UIColor.groupTableViewBackground
        self.view.addSubview(table!)
        table?.delegate = self;
        table?.dataSource = self;
//        table?.tableFooterView = UIView.init()
        //写在这里是因为已经获取到了数据源,但是table并未创建,以致空页面未显示
        self.showRemind()
        self.table?.reloadData()
    }
    @objc func leftClick(button: UIButton) {
        if hiddenSelectIcon! {
            self.navigationController?.popViewController(animated: true)
        }else{
            hiddenSelectIcon = true
            changeLeftBtnStatus()
            self.selectedArray?.removeAll()
            changeRightBtnStatus()
            searchView?.configWithDataArray(array:selectedArray!)
            table?.reloadData()
        }
    }
    @objc func rightClick(button: UIButton) {
        if button.titleLabel?.text == "多选" {
            hiddenSelectIcon = false
            self.selectedArray?.removeAll()
            table?.reloadData()
        }else{
            //TODO:群转发操作
//            self.selectedArray?.removeAll()
//            changeRightBtnStatus()
//            searchView?.configWithDataArray(array:selectedArray!)
//            table?.reloadData()
           self.addRepeatMessageView()
        }
        changeLeftBtnStatus()
        changeRightBtnStatus()
    }
    func changeLeftBtnStatus(){
        if hiddenSelectIcon! {
            leftBtn?.setImage(UIImage.init(named: "nav_back"), for: .normal)
            leftBtn?.setTitle("", for: .normal)
            leftBtn?.sizeToFit()
        }else{
            leftBtn?.setImage(UIImage.init(named: ""), for: .normal)
            leftBtn?.setTitle("取消", for: .normal)
            leftBtn?.sizeToFit()
        }
        
    }
    func changeRightBtnStatus(){
        if hiddenSelectIcon!{
            rightBtn?.setTitleColor(UIColor.white, for: .normal)
            rightBtn?.isEnabled = true
            rightBtn?.setTitle("多选", for: .normal)
        }else{
            if selectedArray?.count != 0 {
                let countStr = String.init(format: "确定(%d)", (selectedArray?.count)!)
                self.navigationItem.rightBarButtonItem?.isEnabled = true
                rightBtn?.setTitleColor(UIColor.white, for: .normal)
                rightBtn?.isEnabled = true
                rightBtn?.setTitle(countStr, for: .normal)
                rightBtn?.sizeToFit()
            }else{
                self.navigationItem.rightBarButtonItem?.isEnabled = false
                rightBtn?.isEnabled = false
                rightBtn?.setTitleColor(UIColor.lightGray, for: .normal)
                rightBtn?.setTitle("确定", for: .normal)
            }
        }
        
    }
    
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        if (self.searchView?.searchView.isFirstResponder)! {
            self.searchView?.searchView.resignFirstResponder()
        }
    }
    var repeatMessageView:RepeatMessageView?
    var model = GroupModel()
    
    func addRepeatMessageView() {
        self.repeatMessageView = RepeatMessageView(type: "\(type(of: message))", modelArr: self.selectedArray as! Array<GroupModel>, message:RCKitUtility.formatMessage(self.message))
        //TODO: 资源文件的二次配置
        if RCKitUtility.formatMessage(self.message) == "[图片]" {
            //            let imageUrl = (message as! RCImageMessage).imageUrl
            //
            //            (self.repeatMessageView?.resourceView as! UIImageView).sd_setImage(with: URL.init(string: imageUrl!))
            //            (self.repeatMessageView?.resourceView as! UIImageView).backgroundColor = UIColor.red
            (self.repeatMessageView?.resourceView as! UIImageView).image = (message as! RCImageMessage).thumbnailImage
        }
        
        repeatMessageView?.enterBtn.addTarget(self, action: #selector(repeatMessageAction(btn:)), for: UIControl.Event.touchUpInside)
        self.view.addSubview(self.repeatMessageView!)
    }
    @objc func repeatMessageAction(btn:UIButton) {
        finishSelect(self.selectedArray!, self.repeatMessageView?.inputText.text)
    }
}
//MARK: - ---------------------TableDelegate AND DataSource----------------------
extension SelectMyGroup:UITableViewDelegate,UITableViewDataSource
{
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if self.conversationType == .group{
            return 44
        }else{
            return 54
        }
    }
    
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        
        return dataArray != nil ?Int((dataArray?.count)!): 0
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        var cell:UITableViewCell? = tableView.dequeueReusableCell(withIdentifier: "cell")
        if cell == nil
        {
            if self.conversationType == .group {
                
                cell = SelectMyGroupCell.init(style: .default, reuseIdentifier: "SelectMyGroupCell")
            }else{
                cell = SelectMyThemeCell.init(style: .default, reuseIdentifier: "SelectMyThemeCell")                
            }
        }
        (cell as! SelectMyGroupCell).hiddenSelectImage = self.hiddenSelectIcon
        
        let model:RLMObject = self.dataArray![indexPath.row]
        if (self.selectedArray?.contains(where: { (m) -> Bool in
            return (m as! GroupModel).groupid == (model as! GroupModel).groupid
        }))!{
            (cell as! SelectMyGroupCell).selectImageView.image = UIImage.init(named: "logic_select")
        }
        else
        {
            (cell as! SelectMyGroupCell).selectImageView.image = UIImage.init(named: "logic_normal")
        }
        
        if cell is SelectMyGroupCell {
            let bCell = cell as! SelectMyGroupCell
            bCell.model = model as? GroupModel
        }else if cell is SelectMyThemeCell {
            let bCell = cell as! SelectMyThemeCell
            bCell.model = model as? GroupModel
        }
//        cell?.setValue(model, forKey: "model")
        
        return cell!
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
    {
        tableView.deselectRow(at: indexPath, animated: true)
        if (self.searchView?.searchView.isFirstResponder)! {
            self.searchView?.searchView.resignFirstResponder()
        }
        if hiddenSelectIcon! == false {
 
            let model:GroupModel = self.dataArray![indexPath.row] as! GroupModel
            
            let index = self.selectedArray?.index(where: { (m) -> Bool in
                return (m as! GroupModel).groupid == model.groupid
            })
            if (index != nil) {
                self.selectedArray?.remove(at: index!)
            }
            else
            {
                if (self.selectedArray?.count)! == 9 {
                    self.view.makeToast("您最多选择9个闲聊或话题", duration: 1.0, position: CSToastPositionCenter)
                    return
                }
                self.selectedArray?.append(model)
                
            }
            
            searchView?.configWithDataArray(array:selectedArray!)
            
            changeRightBtnStatus()
            tableView.reloadData()
            return
        }
        self.model = self.dataArray?[indexPath.row] as! GroupModel
        self.selectedArray?.append(model)
    
        self.addRepeatMessageView()
    }
    
    /// 提醒个数
    func showRemind(){
        
        let fView = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 50))
        
        let line = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 1))
        line.backgroundColor = UIColor.groupTableViewBackground
        fView.addSubview(line)
        
        let numberLable = UILabel.init(frame: CGRect.init(x: 0, y: 0, width: kScreenW, height: 50))
        numberLable.textAlignment = NSTextAlignment.center
        numberLable.font = UIFont.systemFont(ofSize: 14)
        numberLable.numberOfLines = 0
        numberLable.text = self.conversationType == .group ? "暂无其它群组\n您可通过查找群组来加入其它群组" : "暂无其它话题"
        fView.addSubview(numberLable)
        
        if (self.dataArray?.count)! == 0 {
            table?.tableFooterView = fView
        }else{
            table?.tableFooterView = UIView.init()
        }
        
    }
    
}
extension SelectMyGroup:BaseSearchViewDelegate
{
    func searchDeleteItem(item: RLMObject)
    {
        let model = item as! GroupModel
        let index = self.selectedArray?.index(where: { (m) -> Bool in
            return (m as! GroupModel).groupid == model.groupid
        })
        if (index != nil) {
            self.selectedArray?.remove(at: index!)
        }
        changeRightBtnStatus()
        table?.reloadData()
    }
    
    func searchBarTextChangedWith(nowText:String)
    {
        var tempDataArray : Array<RLMObject>? = []
        if self.conversationType == .group{
            tempDataArray = self.groupDataArray
            groupSearchText = nowText
        }else{
            tempDataArray = self.themeDataArray
            themeSearchText = nowText
        }
        self.searchViewResearch(keyText: nowText, dataArr: tempDataArray)
        self.showRemind()
        table?.reloadData()
    }
    //因为键盘带搜索按钮,所以必须实现这个方法,否则会崩溃
    func searchBarSearchButtonClicked(nowText:String)
    {
        
    }
}
extension SelectMyGroup {
    func searchViewResearch(keyText: String?, dataArr: Array<RLMObject>?) {
        if (keyText?.isEmpty)! {
            self.dataArray = dataArr
        }
        else{
            self.dataArray?.removeAll()
            for groupModel in dataArr! {
                if (groupModel as! GroupModel).group_name.contains(keyText!) {
                    self.dataArray?.append(groupModel)
                }
            }
        }
    }
}
//
//  ApplyJoinGroupViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/16.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ApplyJoinGroupViewController: BaseViewController {
    var groupModel:GroupModel?
    var isAuthCode : Bool? //是否是验证码入群
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = UIColor.white
        self.title = "申请加群"
        isAuthCode = false
        
        self.setRightBtnWithArray(items: ["发送"])
        self.view.addSubview(inputTextView)
        self.view.addSubview(bottomBtn)
        inputTextView.mas_makeConstraints { (make) in
            make!.left.equalTo()(15)
            make!.top.equalTo()(NAV_HEIGHT + 15)
            make!.width.equalTo()(SCREEN_WIDTH - 15 * 2)
            make!.height.equalTo()(inputTV_height_MAX)
        }
        bottomBtn.mas_makeConstraints { [unowned self](make) in
            make!.right.equalTo()(-15)
            make!.top.equalTo()(self.inputTextView.mas_bottom)!.offset()(5)
        }
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
     override func rightBtnClick(button: UIButton) {
        if isAuthCode! {
            self.progressShow()
            GroupRequest.groupJoinByCode(params: ["app_token":sharePublicDataSingle.token,"groupid":groupModel?.groupid,"auth_code":inputTextView.text], hadToast: true, fail: { [weak self](error) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                }
            }, success: { (dic) in
                
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                let time = UserDefaults.standard.object(forKey: username) as! String
                
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                }, success: {[weak self] (dic) in
                    
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                        let groupListVc : GroupListViewController = strongSelf.navigationController?.children.first as! GroupListViewController
                        groupListVc.newTargetId = strongSelf.groupModel?.groupid
                        DispatchQueue.main.async {
                            strongSelf.navigationController!.popToRootViewController(animated: false)
                        }
                        //                            groupListVc.pushChatBlock!((strongSelf.groupModel?.groupid)!)
                    }
                    }
                )
            })
        }else{
            self.progressShow()
            GroupRequest.groupJoinApply(params: ["app_token":sharePublicDataSingle.token,"groupid":groupModel?.groupid,"msg":inputTextView.text], hadToast: true, fail: { [weak self](error) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                }
            }, success: { (dic) in
                
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                let time = UserDefaults.standard.object(forKey: username) as! String
                
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                }, success: {[weak self] (dic) in
                    
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                        strongSelf.navigationController!.popViewController(animated: true)
                    }
                    }
                )
            })
        }
        
    }
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        inputTextView.endEditing(true)
    }
    
    //MARK: --------------------------- Getter and Setter --------------------------
    fileprivate lazy var inputTextView: ApplyJoinGroupTextView = {
        var inputTextView = ApplyJoinGroupTextView.init(frame: CGRect.init(x: 15, y: NAV_HEIGHT + 15, width: SCREEN_WIDTH - 15 * 2, height: inputTV_height_MAX), textContainer: nil)
        inputTextView.placeholder = "请输入您的入群申请消息"
        return inputTextView
    }()
    
    fileprivate lazy var bottomBtn: UIButton = {
        var bottomBtn = ApplyJoinGroupBottomBtn.init()
        bottomBtn.setTitle("我有群组验证码点击这里~~", for: .normal)
        bottomBtn.setTitleColor(UIColor.hexString(hexString: "2183DE"), for: .normal)
        bottomBtn.titleLabel?.font = FONT_14
        bottomBtn.addTarget(self, action: #selector(bottomBtnClick), for: .touchUpInside)
        return bottomBtn
    }()
}
extension ApplyJoinGroupViewController {
    @objc func bottomBtnClick(button:UIButton) {
        inputTextView.text = ""
        inputTextView.placeholderLabel.isHidden = false
        if (button.titleLabel?.text?.contains("没有"))! {
            isAuthCode = false
            inputTextView.placeholder = "请输入您的入群申请消息"
             bottomBtn.setTitle("我有群组验证码点击这里~~", for: .normal)
            inputTextView.mas_updateConstraints({ (make) in
                make!.height.equalTo()(inputTV_height_MAX)
            })
        }else{
            isAuthCode = true
            inputTextView.placeholder = "请输入群组验证码,直接入群"
             bottomBtn.setTitle("没有群组验证码点击这里~~", for: .normal)
            inputTextView.mas_updateConstraints({ (make) in
                make!.height.equalTo()(inputTV_height_MIN)
            })
        }
    }
}
//
//  SingleChatVC.swift
//  SLAPP
//
//  Created by apple on 2018/5/4.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class SingleChatVC: RCConversationViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        RCIM.shared().globalMessageAvatarStyle = RCUserAvatarStyle.USER_AVATAR_CYCLE
        self.chatSessionInputBarControl.pluginBoardView.removeItem(at: 4)
        self.chatSessionInputBarControl.pluginBoardView.removeItem(at: 3)
        self.chatSessionInputBarControl.pluginBoardView.removeItem(at: 2)
        
        if !self.targetId.contains("system") {
            self.add()
        }
        
        self.configHead()
    }
    
    
    func configHead(){
        
        
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    
    func add(){
        
        //        self.chatSessionInputBarControl.pluginBoardView.insertItem(with: UIImage.init(named: "talkYuYinBeiwang"), title: "语音备忘", at: 2, tag: 211)
        //        self.chatSessionInputBarControl.pluginBoardView.insertItem(with: UIImage.init(named: "talkFenxiBaoGao"), title: "分析报告", at: 3, tag: 212)
        
        self.register(ProjectReportMessageContentCell.self, forMessageClass: ProjectReportMessageContent.self)
        self.register(ProjectVoiceMessageContentCell.self, forMessageClass: ProjectVoiceMessageContent.self)
        self.conversationMessageCollectionView.register(ProjectReportMessageContentCell.self, forCellWithReuseIdentifier: "ProjectReportMessageContent")
        self.conversationMessageCollectionView.register(ProjectVoiceMessageContentCell.self, forCellWithReuseIdentifier: "ProjectVoiceMessageContent")
    }
    
    
    
    // MARK: - 高度处理
    override func rcConversationCollectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: UICollectionViewLayout!, sizeForItemAt indexPath: IndexPath!) -> CGSize {
        let model:RCMessageModel = self.conversationDataRepository[indexPath.row] as! RCMessageModel
        if model.objectName == "ProjectVoiceMessageContent" {
            if model.isDisplayMessageTime == true{
                return CGSize.init(width: SCREEN_WIDTH, height: 200)
            }
            else{
                return CGSize.init(width: SCREEN_WIDTH, height: 120)
            }
            
        }else if model.objectName == "ProjectReportMessageContent"{
            
            if model.isDisplayMessageTime == true{
                return CGSize.init(width: SCREEN_WIDTH, height: 280)
            }
            else{
                return CGSize.init(width: SCREEN_WIDTH, height: 280)
            }
            
        }else{
            return super.rcConversationCollectionView(collectionView, layout: collectionViewLayout, sizeForItemAt: indexPath)
        }
    }
    
    
    //    override func didTapMessageCell(_ model: RCMessageModel!) {
    //        super.didTapMessageCell(model)
    //        if model.objectName == "RC:TxtMsg" {
    //            let content:RCTextMessage = model.content as! RCTextMessage
    //            guard content.extra != nil else {
    //                return
    //            }
    //            let json = JSON.init(parseJSON: content.extra)
    //
    //            if json["type"].stringValue == "consult"{
    //                let vc = TutoringDetailVC()
    //
    //                vc.new_consult_id = json["data"]["id"].stringValue
    //
    //                self.navigationController?.pushViewController(vc, animated: true)
    //            }
    //
    //
    //        }
    //    }
    
    
    
    
    override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        
        let model:RCMessageModel = self.conversationDataRepository[indexPath.row] as! RCMessageModel
        if model.objectName == "ProjectVoiceMessageContent"
        {
            let cell:ProjectVoiceMessageContentCell = collectionView.dequeueReusableCell(withReuseIdentifier: "ProjectVoiceMessageContent", for: indexPath) as! ProjectVoiceMessageContentCell
            cell.setDataModel(model)
            
            
            
            if shareAVManager.player != nil {
                
                if cell.model.messageId == shareAVManager.model?.messageId {
                    if (shareAVManager.player?.isPlaying)!{
                        cell.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                    }else {
                        if shareAVManager.player?.currentTime != 0 {
                            cell.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                        }
                    }
                }
                
            }
            
            
            cell.click = {[weak cell,weak collectionView] (model) in
                
                if cell?.model.messageId == shareAVManager.model?.messageId {
                    
                    if shareAVManager.player != nil {
                        if (shareAVManager.player?.isPlaying)!{
                            shareAVManager.stopPlay()
                            cell?.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                            cell?.progress.progress = shareAVManager.currentProgress()
                            cell?.timeLable.text = shareAVManager.currentTime()
                            return
                        }else {
                            if shareAVManager.player?.currentTime != 0 {
                                shareAVManager.startPlay()
                                cell?.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                                cell?.progress.progress = shareAVManager.currentProgress()
                                
                                cell?.timeLable.text = shareAVManager.currentTime()
                                return
                            }
                            
                        }
                    }
                    
                    
                }
                
                shareAVManager.playUrlDataWithModel(progress: 0, mModel: model, compete: { (finish) in
                    
                    
                    
                    let array = collectionView?.visibleCells
                    if (array?.count)! > 0 {
                        for mycell in array! {
                            if mycell .isKind(of: ProjectVoiceMessageContentCell.self){
                                let myCell:ProjectVoiceMessageContentCell = mycell as! ProjectVoiceMessageContentCell
                                if myCell.model.messageId == shareAVManager.model?.messageId{
                                    myCell.progress.progress = shareAVManager.currentProgress()
                                    if finish {
                                        myCell.timeLable.text = "0:00"
                                        myCell.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                                        myCell.progress.progress = 0
                                        return
                                    }
                                }
                            }
                        }
                        
                    }
                    
                }, action: {
                    let array = collectionView?.visibleCells
                    if (array?.count)! > 0 {
                        for mycell in array! {
                            if mycell .isKind(of: ProjectVoiceMessageContentCell.self){
                                let myCell:ProjectVoiceMessageContentCell = mycell as! ProjectVoiceMessageContentCell
                                if myCell.model.messageId == shareAVManager.model?.messageId{
                                    myCell.progress.progress = shareAVManager.currentProgress()
                                    
                                    cell?.timeLable.text = shareAVManager.currentTime()
                                    cell?.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                                }else{
                                    myCell.progress.progress = 0
                                    cell?.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                                }
                            }
                        }
                        
                    }
                    
                    //                        }
                    
                })
            }
            return cell
            
        }else if model.objectName == "ProjectReportMessageContent"
        {
            let cell:ProjectReportMessageContentCell = collectionView.dequeueReusableCell(withReuseIdentifier: "ProjectReportMessageContent", for: indexPath) as! ProjectReportMessageContentCell
            cell.setDataModel(model)
            cell.clickWithUrl = { [weak self] (url)in
                let vc = MineReviseVC()
                vc.url = URL.init(string:url)
                self?.navigationController?.pushViewController(vc, animated: true)
            }
            return cell
        }
        else
        {
            return super.collectionView(collectionView, cellForItemAt: indexPath)
        }
    }
    
    
    
    
    // MARK: - 输入板点击加号后出来的按钮点击响应
    ///
    ///
    /// - Parameters:
    ///   - pluginBoardView: <#pluginBoardView description#>
    ///   - tag: <#tag description#>
    override func pluginBoardView(_ pluginBoardView: RCPluginBoardView!, clickedItemWithTag tag: Int) {
        if tag == 200 {
            
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            let vc = ThemeCreatVC();
            vc.groupid = self.targetId
            self.tabBarController?.navigationController?.pushViewController(vc, animated: true)
        }
        else if tag == 1101 || tag == 1102{ //语音/视频通话
            
            //            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            //            let predicate = NSPredicate.init(format: "groupid == %@ AND is_delete == '0'", argumentArray: [self.targetId])
            //            let groupUsers =  GroupUserModel.objects(with: predicate)
            //
            //            var vc : SelectMemberViewController?
            //            if tag == 1101{
            //                vc = SelectMemberViewController.init(conversationType: self.conversationType, targetId: self.targetId, mediaType: RCCallMediaType.audio, exist: [sharePublicDataSingle.publicData.im_userid], success: { [weak self](addUserIdList) in
            //
            //                    self?.callAudioVc = CallAudioMultiCallViewController.init(outgoingCall: (self?.conversationType)!, targetId: self?.targetId, mediaType: RCCallMediaType.audio, userIdList: addUserIdList)
            //                    self?.present((self?.callAudioVc)!, animated: true, completion: nil)
            //                })
            //            }
            //            if tag == 1102{
            //                vc = SelectMemberViewController.init(conversationType: self.conversationType, targetId: self.targetId, mediaType: RCCallMediaType.video, exist: [sharePublicDataSingle.publicData.im_userid], success: { [weak self](addUserIdList) in
            //
            //                    self?.callVideoVc = CallVideoMultiCallViewController.init(outgoingCall: (self?.conversationType)!, targetId: self?.targetId, mediaType: RCCallMediaType.video, userIdList: addUserIdList)
            //                    self?.present((self?.callVideoVc)!, animated: true, completion: nil)
            //                })
            //            }
            //            vc?.listingUserIdList = groupUsers.value(forKeyPath: "im_userid") as! [Any]
            //            self.present(vc!, animated: true, completion: nil)
        }
            //        else if tag == 210 {
            ////            DLog("点击了图文")
            //            self.sendRichMessage()
            //        }
            //        else if tag == 211 {
            //            DLog("点击了语音备忘")
            //            self.sendProVoiceMessage()
            //        }
            //        else if tag == 212 {
            //            DLog("点击了赢单")
            //            self.sendReportMessage()
            //        }
        else{
            super.pluginBoardView(pluginBoardView, clickedItemWithTag: tag)
        }
    }
    
    //    // MARK: - 发送语音备份录消息
    //    func sendProVoiceMessage(){
    //
    //        self.getRrojectList(userid: self.targetId) { (m) in
    //
    //
    //
    //            var btnDic = Dictionary<String,String>()
    //            for oneDic in m["list"] as! Array<Dictionary<String,Any>>{
    //                btnDic[oneDic["project_id"]! as! String] = (oneDic["project_name"] as! String)
    //            }
    //            btnDic[kCancel] = "取消"
    //            let alert = UIAlertController.init(title: "选择项目", message: nil, preferredStyle: UIAlertControllerStyle.alert, btns: btnDic, btnActions: {[weak self] (a, key) in
    //
    //                guard key != kCancel else {
    //                    return
    //                }
    //
    //                        let vc  =  RecorderPlayerListViewController()
    //                        vc.projectId = key
    //                        vc.click = {[weak self](dic) in
    //                            DLog(dic)
    //                            let voice = ProjectVoiceMessageContent.init()
    //                            voice.projectId = key
    //                            voice.projectName = dic["parallelism_name"]!
    //                            voice.duration = dic["duration"]!
    //                            voice.url = dic["file"]!
    //                            voice.extra = ""
    //                            self?.sendMessage(voice, pushContent: "")
    //                        }
    //                self?.navigationController?.pushViewController(vc, animated: true)
    //                        return
    //            })
    //            self.present(alert, animated: true, completion: nil)
    //            //            let alertCont = UIAlertController.init(title: "选择项目", message: nil, preferredStyle: UIAlertControllerStyle.alert, btns: btnDic, btnActions: {action,key in
    //            //                DLog(key)
    //            //                if key != kCancel{
    //
    //
    //
    //
    //
    //
    //
    //            DLog(m)
    //        }
    //
    //
    //
    ////        let vc  =  RecorderPlayerListViewController()
    ////        vc.projectId = gModel?.project_id
    ////        vc.click = {[weak self](dic) in
    ////            DLog(dic)
    ////            let voice = ProjectVoiceMessageContent.init()
    ////            voice.projectId = (self?.gModel?.project_id)!
    ////            voice.projectName = dic["parallelism_name"]!
    ////            voice.duration = dic["duration"]!
    ////            voice.url = dic["file"]!
    ////            voice.extra = ""
    ////            self?.sendMessage(voice, pushContent: "")
    ////        }
    ////        self.navigationController?.pushViewController(vc, animated: true)
    ////        return
    //
    //
    //
    //
    //    }
    //
    //
    //    // MARK: - 发送赢单
    //    func sendReportMessage(){
    //
    //        DLog(self.targetId)
    //        self.getRrojectList(userid: self.targetId) { (m) in
    //
    //
    //
    //            var btnDic = Dictionary<String,String>()
    //            for oneDic in m["list"] as! Array<Dictionary<String,Any>>{
    //                btnDic[oneDic["project_id"]! as! String] = (oneDic["project_name"] as! String)
    //            }
    //            btnDic[kCancel] = "取消"
    //            let alert = UIAlertController.init(title: "选择项目", message: nil, preferredStyle: UIAlertControllerStyle.alert, btns: btnDic, btnActions: {[weak self] (a, key) in
    //
    //                guard key != kCancel else {
    //                    return
    //                }
    //
    //                        self?.getReportInfo(pid:key) {[weak self] (model) in
    //                            let report = ProjectReportMessageContent.init()
    //                            report.projectId = model.projectId
    //                            report.projectName = model.projectName
    //                            report.projectRisk = model.projectRisk
    //                            report.url = model.url
    //                            report.extra = ""
    //                            report.projectWinIndex = model.projectWinIndex
    //                            report.projectScore = model.projectScore
    //                            self?.sendMessage(report, pushContent: "")
    //                        }
    //            })
    //            self.present(alert, animated: true, completion: nil)
    ////            let alertCont = UIAlertController.init(title: "选择项目", message: nil, preferredStyle: UIAlertControllerStyle.alert, btns: btnDic, btnActions: {action,key in
    ////                DLog(key)
    ////                if key != kCancel{
    //
    //
    //
    //
    //
    //
    //
    //            DLog(m)
    //        }
    ////        self.getReportInfo(pid: (self.gModel?.project_id)!) {[weak self] (model) in
    ////            let report = ProjectReportMessageContent.init()
    ////            report.projectId = model.projectId
    ////            report.projectName = model.projectName
    ////            report.projectRisk = model.projectRisk
    ////            report.url = model.url
    ////            report.extra = ""
    ////            report.projectWinIndex = model.projectWinIndex
    ////            report.projectScore = model.projectScore
    ////            self?.sendMessage(report, pushContent: "")
    ////        }
    //
    //
    //    }
    //
    //    // MARK: - 发送图文消息
    //    func sendRichMessage(){
    //        let rich = RCRichContentMessage.init(title: "图文消息", digest: "哈哈", imageURL: "", url: "www.baidu.com", extra: "")
    //        self.sendMessage(rich, pushContent: "")
    //    }
    //
    
    
}
//
//  SmallTalkVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/9.
//  Copyright © 2017年 柴进. All rights reserved.
//
let unReadButton_Y:CGFloat = 125.0
import UIKit
import PhotosUI
import Realm
import IQKeyboardManager
import Photos
import WebKit
let tipView_Width : CGFloat = SCREEN_WIDTH - 40
class SmallTalkVC: RCConversationViewController,RCMessageCellDelegate {
    
    var isRunApi:Bool? //是否执行viewDidApper里的方法 第一次进来的时候执行  其他界面返回不执行,(如果想执行,请设置为false)
    
    var isSearch:Bool?//是否是搜索
    var searchModel:ChatContentModel?//搜索内容
    var gModel: GroupModel?
    var isTheme:Bool?//是否是话题会话页面
    
    var isChooseView = false//多选开关
    var showMoreBottomView = false//点击更多按钮显示底部view(true:不接收kvo)
    var chooseType = "RCTextMessageCell,RCImageMessageCell"//多选内容分类
    var chooseList = Array<String>.init()//选中的messageId
    
    
    var isMsgCopy:Bool?
    var isSearchBack:Bool?
    var atArray:Array<GroupUserModel>?
    
    var openArray = Array<String>() //记录展开的消息id
    var callAudioVc : CallAudioMultiCallViewController? //语音通话页面
    var callVideoVc : CallVideoMultiCallViewController? //视频通话页面
    
    func getAllMembers(ofGroup groupId: String!, result resultBlock: (([String]?) -> Void)!) {
        let groupUserModels = GroupUserModel.objects(with: NSPredicate(format:"groupid == %@ AND is_delete == '0'", groupId))
        
        let idStringArr = (NSArray.init(objects: groupUserModels).value(forKeyPath: "im_userid") as! NSArray).firstObject as! Array<String>
        resultBlock(idStringArr)
        
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.configBackItem()
        atArray = Array()
        
//        RCIM.shared()?.groupMemberDataSource = self
        RCIM.shared().enableMessageMentioned = true
        RCIM.shared().globalMessageAvatarStyle = RCUserAvatarStyle.USER_AVATAR_CYCLE
        RCIM.shared().registerMessageType(ThemeMessageContent.self)
        RCIM.shared().registerMessageType(HistoryMessageContent.self)
        self.enableUnreadMessageIcon = true
        self.enableNewComingMessageIcon = true
        self.displayUserNameInCell = true
        self.chatSessionInputBarControl.inputTextView.disableActionMenu = true
        self.conversationMessageCollectionView.register(MyVoiceCell.self, forCellWithReuseIdentifier: "voice")
        self.chatSessionInputBarControl.pluginBoardView.removeItem(at: 2)
        
        //todo 要替换话题图片
        self.chatSessionInputBarControl.pluginBoardView.insertItem(with: UIImage.init(named: "theme"), title: "话题", at: 0, tag: 200)
//        self.chatSessionInputBarControl.pluginBoardView.insertItem(with: UIImage.init(named: "actionbar_audio_call_icon"), title: "语音通话", tag: 1601)
//        self.chatSessionInputBarControl.pluginBoardView.insertItem(with: UIImage.init(named: "actionbar_video_call_icon"), title: "视频通话", tag: 1602)
        
        
        self.register(ThemeMessageCell.self, forMessageClass: ThemeMessageContent.self)
        self.register(HistoryMessageCell.self, forMessageClass: HistoryMessageContent.self)
        
        self.conversationMessageCollectionView.register(ThemeMessageCell.self, forCellWithReuseIdentifier: "ThemeMessageContent")
        self.add()
        
        
        //暂时注释   不要删除
        NotificationCenter.default.addObserver(self, selector: #selector(click), name: UIResponder.keyboardDidHideNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(clickshow), name: UIResponder.keyboardDidShowNotification, object: nil)
        
        if isSearch != true {
            RCIM.shared().receiveMessageDelegate = self as RCIMReceiveMessageDelegate;
        }
        
        
        
        
        self.addObserve()
        if isSearch != true{
           
        }else{
          self.title = "历史记录";
            
        }
        
    }
    
    
    
    func add(){
        
        self.register(ProjectReportMessageContentCell.self, forMessageClass: ProjectReportMessageContent.self)
        self.register(ProjectVoiceMessageContentCell.self, forMessageClass: ProjectVoiceMessageContent.self)
        self.conversationMessageCollectionView.register(ProjectReportMessageContentCell.self, forCellWithReuseIdentifier: "ProjectReportMessageContent")
        self.conversationMessageCollectionView.register(ProjectVoiceMessageContentCell.self, forCellWithReuseIdentifier: "ProjectVoiceMessageContent")
    }
    
    // MARK: - 高度处理
    override func rcConversationCollectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: UICollectionViewLayout!, sizeForItemAt indexPath: IndexPath!) -> CGSize {
        let model:RCMessageModel = self.conversationDataRepository[indexPath.row] as! RCMessageModel
        if model.objectName == "ProjectVoiceMessageContent" {
            if model.isDisplayMessageTime == true{
                return CGSize.init(width: SCREEN_WIDTH, height: 200)
            }
            else{
                return CGSize.init(width: SCREEN_WIDTH, height: 120)
            }
            
        }else if model.objectName == "ProjectReportMessageContent"{
            
            if model.isDisplayMessageTime == true{
                return CGSize.init(width: SCREEN_WIDTH, height: 280)
            }
            else{
                return CGSize.init(width: SCREEN_WIDTH, height: 280)
            }
            
        }else{
            return super.rcConversationCollectionView(collectionView, layout: collectionViewLayout, sizeForItemAt: indexPath)
        }
    }
    
    
    //处理播放的时候电话来了   TODO 需要整理
    func callPhoneNoti(){
    
    
        NotificationCenter.default.addObserver(self, selector: #selector(callPhone(notification: )), name: NSNotification.Name(rawValue: "AVAudioSessionInterruptionNotification"), object:nil)
        
    }
    
    @objc func callPhone(notification:Notification){
        
        
        let type:NSNumber = notification.userInfo?[AVAudioSessionInterruptionTypeKey] as! NSNumber
        
        
        if type == 1 {
            
            shareAVManager.finishBlock?(false)
            shareAVManager.saveProgress(time: 1)
            shareAVManager.player?.stop()
            
            shareAVManager.timerStop()
        }
    }
//    override func rcConversationCollectionView(_ collectionView: UICollectionView!, cellForItemAt indexPath: IndexPath!) -> RCMessageBaseCell! {
//        print(collectionView.self)
//        
//        let model:RCMessageModel = self.conversationDataRepository[indexPath.row] as! RCMessageModel
//        if model.objectName == "ThemeMessageContent"
//        {
//            
//            let cell:ThemeMessageCell = collectionView.dequeueReusableCell(withReuseIdentifier: "ThemeMessageContent", for: indexPath) as! ThemeMessageCell
//            cell.openList = self.openArray
//            cell.setDataModel(model)
//            cell.backgroundColor = UIColor.red
//            cell.delegate = self as RCMessageCellDelegate
//            self.willDisplayMessageCell(cell, at: indexPath)
//            return  cell as RCMessageBaseCell
//        }
//
//        
//        
//        
//        return super.rcConversationCollectionView(collectionView, cellForItemAt: indexPath)
//    }
    
    override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
        
            if(action == #selector(paste(_:)) )
            {
                if isMsgCopy == true {
                    isMsgCopy = false
                    return false
                }
                return true
            }
            else{
                return super.canPerformAction(action, withSender: sender)
            }
        
    
    }
    
    
    override func viewWillAppear(_ animated: Bool) {
        
        if isSearchBack == true {
            isSearchBack = false
        }
        else{
        super.viewWillAppear(animated)
         let predicate = NSPredicate.init(format: "groupid == %@", argumentArray: [self.targetId])
        
        gModel = GroupModel.objects(with: predicate).firstObject() as! GroupModel?
        if gModel != nil {
            if isTheme != true {
                self.tabBarController?.title = gModel?.group_name
            }else{
                self.title = gModel?.group_name
            }
        }
        
        let notice = Notification.init(name: NSNotification.Name(rawValue: "reLoadTotalUnreadCount"), object: nil, userInfo: nil)
            //清除未读数据
            let mResult = MessageCenterModel.objects(with: NSPredicate(format: "targetId == %@", self.targetId))
            DataBaseOperation.removeDataWithArray(rlmObjects: mResult)
        NotificationCenter.default.post(notice)
        
//        NotificationCenter.default.addObserver(self, selector: #selector(avfinish), name: NSNotification.Name(rawValue: "avFinish"), object: nil)
//        
//        NotificationCenter.default.addObserver(self, selector: #selector(avStart), name: NSNotification.Name(rawValue: "avStart"), object: nil)
            
            if isSearch != true {
                
                let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,self.targetId)).firstObject() as! GroupUserModel?
                if groupUserModel?.is_delete == "1"{
                    makeNavigationRightBtn(canClick: false)
                    
                }else{
                    makeNavigationRightBtn(canClick: true)
                    
                }
                
            }
            //多选操作时跳转其他页面回来时重置导航栏
            if (self.navigationController?.navigationBar.subviews.contains(coverNavBar))! {
                coverNavBar.removeFromSuperview()
            }
        }
        
        
        //移除原有截面数据，然后把查到的数据插入到当前界面数据列表中
//        self.conversationDataRepository.removeAllObjects()
//        for nemodel in newDataArr! {
//            self.conversationDataRepository.insert(RCMessageModel.init(message: nemodel as! RCMessage), at: 0)
//        }
//        //刷新界面数据显示
//        self.conversationMessageCollectionView.reloadData()
        self.callPhoneNoti()
    }
    
    
    override func viewWillDisappear(_ animated: Bool) {
        
        super.viewWillDisappear(animated)
        isRunApi = true
        shareAVManager.stopPlay()
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        //底部更多面板重置
        self.chatSessionInputBarControl.resetToDefaultStatus()
        //多选操作时跳转其他页面取消多选
        self.cancleMoreAction(UIButton.init())
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        if isRunApi == true {
            isRunApi = false
            return;
        }
        
        if isSearch == true {
            self.scrollToIndexWithMessageId(model: searchModel!)
        }
        if isTheme != true || isSearch != true {
        
            self.view.frame = CGRect.init(x: 0, y: 0, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
            self.view.backgroundColor = UIColor.hexString(hexString: "EFEFF4")
            self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: 0, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-50-49)
            self.chatSessionInputBarControl.frame = CGRect.init(x: 0, y: MAIN_SCREEN_HEIGHT_PX-50-49, width: kScreenW, height: 50)
        }
        if isSearch == true {
            self.view.frame = CGRect.init(x: 0, y: 0, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
            self.view.backgroundColor = UIColor.hexString(hexString: "EFEFF4")
            self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-50-NAV_HEIGHT)
            self.chatSessionInputBarControl.frame = CGRect.init(x: 0, y: MAIN_SCREEN_HEIGHT_PX-50, width: kScreenW, height: 50)
        }
//        if self.unReadButton != nil {
//
//            self.unReadButton.frame = CGRect.init(x: self.unReadButton.frame.origin.x, y: unReadButton_Y, width: self.unReadButton.frame.size.width, height: self.unReadButton.frame.size.height)
//            
//            
//       }
//
        //界面存在的时候有时候数据不全，
        
//        let newDataArr = RCIMClient.shared().getHistoryMessages(RCConversationType.ConversationType_GROUP, targetId: self.targetId, sentTime:(self.conversationDataRepository.lastObject as! RCMessageModel).sentTime + 1, beforeCount: 0, afterCount: 1000)
//        if newDataArr?.count != 0{
//            for nemodel in newDataArr! {
//                self.conversationDataRepository.add(RCMessageModel.init(message: nemodel as! RCMessage))
//            }
//            self.conversationMessageCollectionView.reloadData()
//        }
        
        let contentOffsetY = (self.conversationMessageCollectionView.contentSize.height < (MAIN_SCREEN_HEIGHT_PX - 50 - 49 - NAV_HEIGHT)) ? -NAV_HEIGHT : self.conversationMessageCollectionView.contentOffset.y + NAV_HEIGHT
        self.scrollToBottom(animated: false)
        print(contentOffsetY)
        self.conversationMessageCollectionView.contentOffset = CGPoint.init(x: 0, y: contentOffsetY)
        
        refreshUserInfoOrGroupInfo()
        self.isShowRedRemind()
    }
//清除输入框文字,防止下次进来弹出键盘出现bug
    func clearInputText(){
        if self.chatSessionInputBarControl.inputTextView.text.count > 0 {
            self.chatSessionInputBarControl.inputTextView.text = nil;
        }
        if self.chatSessionInputBarControl.inputTextView.isFirstResponder
        {
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            
        }
    }
    /// 是否显示tab红点提醒
    func isShowRedRemind(){
    
     
        let groupIdArr : Array<String> = GroupModel.objects(with: NSPredicate.init(format: "parentid == %@", (self.gModel?.groupid)!)).value(forKeyPath: "groupid") as! Array<String>
        var subGroupMesTotalCount : Int32? = 0
        for targetId in groupIdArr {
            subGroupMesTotalCount = subGroupMesTotalCount! + RCIMClient.shared().getUnreadCount(.ConversationType_GROUP, targetId: targetId)
        }
        
        if subGroupMesTotalCount != 0 {
            self.showRedRemind(type: 1)
        }
        else{
           self.clearTabRedPoint()
        }
        
    }
    
    
    override func willDisplayMessageCell(_ cell: RCMessageBaseCell!, at indexPath: IndexPath!) {
        
        print("deinit: \(cell.classForCoder) + \(cell.model.objectName)")
        if cell.model.objectName == "RC:GrpNtf"  {
            let notModel:RCGroupNotificationMessage = cell.model.content as! RCGroupNotificationMessage
            if notModel.operation == GroupNotificationMessage_GroupOperationAdd || notModel.operation == GroupNotificationMessage_GroupOperationKicked  {
                
                let mycell = cell as! RCTipMessageCell
                let label = UILabel.init()
                label.font = mycell.tipMessageLabel.font
                guard notModel.message.contains(sharePublicDataSingle.publicData.realname) else {
                    
                    mycell.tipMessageLabel.text = notModel.message
                    let height = Int((mycell.tipMessageLabel.text?.getTextHeight(font: mycell.tipMessageLabel.font, width: tipView_Width))!) + 6
                    label.text = notModel.message
                    label.sizeToFit()
                    mycell.tipMessageLabel.frame.size = CGSize.init(width: label.frame.size.width < tipView_Width ? label.frame.size.width : tipView_Width, height: CGFloat(height))
                    mycell.tipMessageLabel.center.x = SCREEN_WIDTH * 0.5
                    return
                }
                
                mycell.tipMessageLabel.text = notModel.message.replacingOccurrences(of: sharePublicDataSingle.publicData.realname, with: "你")
                let height = Int((mycell.tipMessageLabel.text?.getTextHeight(font: mycell.tipMessageLabel.font, width: tipView_Width))!) + 6
                label.text = notModel.message.replacingOccurrences(of: sharePublicDataSingle.publicData.realname, with: "你")
                label.sizeToFit()
                mycell.tipMessageLabel.frame.size = CGSize.init(width: label.frame.size.width < tipView_Width ? label.frame.size.width : tipView_Width, height: CGFloat(height))
                mycell.tipMessageLabel.center.x = SCREEN_WIDTH * 0.5
                
                
            }
            else{
                super.willDisplayMessageCell(cell, at: indexPath)
                print(cell)
                cell.delegate = self
            }
            
        }
        else{
            super.willDisplayMessageCell(cell, at: indexPath)
//            for oneView in cell.contentView.subviews {
//                if oneView.isKind(of: UIButton.self) || oneView.isKind(of: UIImageView.self){
//                    oneView.removeFromSuperview()
//                }
//            }
            
            cell.clearCell()
            
            if self.isChooseView {
                let className = "\(cell.classForCoder)"
                if self.chooseType.range(of: className) != nil {
                    
                    let  btn = UIButton.init(type: .custom)
                    self.chooseShow(cell: cell, isShow: true, listArray: self.chooseList as NSArray, btn: btn)
                    btn.addTarget(self, action: #selector(cellBtnClick(btn:)), for: .touchUpInside)
                }
                else{
                    self.chooseShow(cell: cell, isShow: false, listArray: self.chooseList as NSArray, btn: UIButton())
                }
            }
            if cell.isKind(of: HistoryMessageCell.self) || cell.isKind(of: ThemeMessageCell.self){
                if cell.isDisplayMessageTime{
                    cell.messageTimeLabel.isHidden = true
                    cell.baseContentView.frame = CGRect(x: cell.baseContentView.frame.origin.x, y: cell.baseContentView.frame.origin.y - cell.messageTimeLabel.frame.height, width: cell.baseContentView.frame.width, height: cell.baseContentView.frame.height)
                }
            }
            if cell.isKind(of: ThemeMessageCell.self) {
                (cell as! ThemeMessageCell).didJoin = {[weak self]
                    (themeId:String) in
//                    print(themeId)
                    DispatchQueue.main.async {
                        
                        let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: themeId)
                        self?.navigationController?.pushViewController(talk!, animated: true)
                    }
                }
                
                (cell as! ThemeMessageCell).didClickOpen = {[weak self]
                    (themeId:String) in
                    
                    if (self?.openArray.contains(themeId))! {
                        self?.openArray.remove(at: (self?.openArray.index(of: themeId))!)
                    }
                    else{
                      
                        self?.openArray.append(themeId)
                    }
                    
                    self?.conversationMessageCollectionView.reloadData()
                    print("点击了打开")
                    
                    let r = ThemeInfoModel.allObjects()
                    print(r.count)
                }
                
            }
            
            
            
//            print(subView.value(forKey: "headerImageView"))
        cell.delegate = self
            
            
        }
    }
    
//    override func register(_ cellClass: AnyClass!, forMessageClass messageClass: AnyClass!) {
//        <#code#>
//    }
    @objc func cellBtnClick(btn:UIButton){
        
        let view  =  btn.superview
        let imageView:UIImageView = view?.viewWithTag(1234) as! UIImageView
        if (self.chooseList.contains("\(btn.tag)")) {
            self.chooseList.remove(at: (self.chooseList.index(of: "\(btn.tag)")!))
       imageView.image = UIImage.init(named: "logic_normal")
        }else{
            self.chooseList.append("\(btn.tag)")
            imageView.image = UIImage.init(named: "logic_select")
        }
        
    }
    
    override func willAppendAndDisplay(_ message: RCMessage!) -> RCMessage! {
        print(message.content.self)
        let newme = super.willAppendAndDisplay(message)
        
        print(message)
        return newme
    }
    
    
    
    //MARK: -----------RCMessageCellDelegate  cell点击事件------------------------//
    override func didLongTouchMessageCell(_ model: RCMessageModel!, in view: UIView!) {
        if self.isChooseView {
            
        }else{
            super.didLongTouchMessageCell(model, in: view)
        }
    }
    var selectRCMessageModel:RCMessageModel?
    
    override func didTapMessageCell(_ model: RCMessageModel!) {
        super.didTapMessageCell(model)
        
        if model.content.isKind(of: ThemeMessageContent.self) {
            let predicate = NSPredicate(format:"userid == %@ AND groupid == %@  AND is_delete == '0'", sharePublicDataSingle.publicData.userid,(model.content as! ThemeMessageContent).themeId)
            let results = GroupUserModel.objects(with: predicate)
            if results.count == 0 {
                self.progressShow()
                GroupRequest.joinGroupSubject(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":(model.content as! ThemeMessageContent).themeId], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self {
                    
                        strongSelf.progressDismiss()
                    }
                }, success: { (dic) in
                    let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                    var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                    
                    if time == nil{
                        time = "0"
                    }
                    UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self](fail) in
                        if let strongSelf = self {
                            strongSelf.progressDismiss()
                            let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: (model.content as! ThemeMessageContent).themeId)
                            strongSelf.navigationController?.pushViewController(talk!, animated: true)
                        }
                        }, success: {[weak self] (dic) in
                            if let strongSelf = self {
                                strongSelf.progressDismiss()
                                
                                let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: (model.content as! ThemeMessageContent).themeId)
                                strongSelf.navigationController?.pushViewController(talk!, animated: true)
                            }
                        }
                    )
                    
                })
            }else{
                let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: (model.content as! ThemeMessageContent).themeId)
                self.navigationController?.pushViewController(talk!, animated: true)
            }
        }
        if model.content.isKind(of: HistoryMessageContent.self) {
            
            let webView = WKWebView.init(frame: self.view.frame)
            let wbc = BaseViewController.init()
            wbc.configBackItem()
            wbc.title = (model.content as! HistoryMessageContent).title
            wbc.view = webView
            webView.load(URLRequest.init(url: URL.init(string: (model.content as! HistoryMessageContent).url)!))
            self.navigationController?.pushViewController(wbc, animated: true)
            
            
//            self.didTapUrl(inMessageCell: (model.content as! HistoryMessageContent).url, model: model)
        }
    }
    
    override func getLongTouchMessageCellMenuList(_ model: RCMessageModel!) -> [UIMenuItem]! {
        super.getLongTouchMessageCellMenuList(model)
        var menuList = super.getLongTouchMessageCellMenuList(model)
        self.selectRCMessageModel = model
         isMsgCopy = true
        
        
        if self.selectRCMessageModel?.objectName == "RC:ImgMsg" {
            let callBackBtn = UIMenuItem.init(title: "复制", action: #selector(callCopyBtnAction(_:)))
            menuList?.append(callBackBtn)
        }
        
        if model.senderUserId == sharePublicDataSingle.publicData.im_userid{
            
            let send:Double = Double((self.selectRCMessageModel?.sentTime)!)
            
            let interval:TimeInterval = Date().timeIntervalSince1970 * 1000
            if interval - send <= 120*1000  {
                let callBackBtn = UIMenuItem.init(title: "撤回", action: #selector(callBackBtnAction(_:)))
                menuList?.append(callBackBtn)
            }
        }
        
        if self.selectRCMessageModel?.objectName == "RC:ImgMsg" || self.selectRCMessageModel?.objectName == "RC:TxtMsg" || self.selectRCMessageModel?.objectName == "RC:VcMsg"{
        
            let callBackBtn = UIMenuItem.init(title: "转发", action: #selector(repeatAction(_:)))
            menuList?.append(callBackBtn)
        }
        
        
        
        if self.selectRCMessageModel?.objectName == "RC:ImgMsg" || self.selectRCMessageModel?.objectName == "RC:TxtMsg"{
        let moreBtn = UIMenuItem.init(title: "更多…", action: #selector(moreAction(_:)))
        menuList?.append(moreBtn)
            
        let themeBtn = UIMenuItem.init(title: "转为话题", action: #selector(creatThemeAction(_:)))
            menuList?.insert(themeBtn, at: 0)
        }
        
        if self.selectRCMessageModel?.objectName == "ThemeMessageContent"{
            let callBackBtn = UIMenuItem.init(title: "转推", action: #selector(goThemeRetweetVC(_:)))
            menuList?.append(callBackBtn)
        }
        
        
        return menuList
    }
    @objc func goThemeRetweetVC(_ btn:Any) {
        let vc = ThemeRetweetVC()
        vc.thisThemeId = (self.selectRCMessageModel!.content as! ThemeMessageContent).themeId
        self.navigationController?.pushViewController(vc, animated: true)
    }
    
    @objc func callCopyBtnAction(_ btn:Any) {
        
//        for i in 0..< self.conversationMessageCollectionView.visibleCells.count {
//            
//        }
        for i in 0..<self.conversationMessageCollectionView.visibleCells.count {
            let cell = self.conversationMessageCollectionView.visibleCells[i]
            guard cell is RCMessageCell else {
                continue
            }
            
            let myCell:RCMessageCell = cell as! RCMessageCell
            
            if myCell.model.messageId == self.selectRCMessageModel?.messageId {
                let fullImageUrl = (myCell.model.content as! RCImageMessage).imageUrl
                //                print(fullImageUrl)
                let myImageCell:RCImageMessageCell = myCell as! RCImageMessageCell
                let pasteboard:UIPasteboard = UIPasteboard.general
                pasteboard.image = myImageCell.pictureView.image
                
                if fullImageUrl?.range(of: "http://") != nil{
                    DispatchQueue.global().async {
                        do{
                            let fullImage = try UIImage.init(data: Data.init(contentsOf: URL.init(string: fullImageUrl!)!))
                            DispatchQueue.main.async {
                                pasteboard.image = fullImage
                            }
                        }catch{
                            print(error)
                        }
                    }
                }else{
                    //                    do{
                    //                    print(fullImageUrl as! String)
                    //                    print(Bundle.main.resourcePath)
                    //                    print(NSData.init(contentsOf: URL(fileURLWithPath: fullImageUrl as! String)))
                    //                    try print(NSData.init(contentsOfFile: fullImageUrl!, options: NSData.ReadingOptions.init(rawValue: 0)))
                    //                    }
                    //                    catch{
                    //                        print(error)
                    //                    }
                    //                    
                    pasteboard.image = UIImage.init(contentsOfFile: fullImageUrl!)
                }
            }
        }
   }
    
   override func paste(_ btn:(Any)?){
        
    let pasteboard:UIPasteboard = UIPasteboard.general
    if pasteboard.image != nil {
       
        self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
        
        let paste:PasteView = Bundle.main.loadNibNamed("PasteView", owner: self, options: nil)?.last as! PasteView
        paste.frame = CGRect(x: 0, y: 0, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
        paste.imageView.image = pasteboard.image
        UIApplication.shared.keyWindow?.addSubview(paste)
        
        paste.sendBtnClick {[weak self] in
            let message:RCImageMessage = RCImageMessage.init(image: pasteboard.image)
            self?.sendMessage(message, pushContent: PublicDataSingle.makePushContent(message, groupId: (self?.targetId)!))
            
            
        }
    }
    else{
      super.paste(btn)
    }
        
    }
    @objc func callBackBtnAction(_ btn:Any) {
        //callback
        
        self.recallMessage((self.selectRCMessageModel?.messageId)!)
        UserRequest.withdraw_message(params: ["app_token":sharePublicDataSingle.token,"msg_uid":self.selectRCMessageModel?.messageUId,"groupid":self.targetId], hadToast: true, fail: { (error) in
            
        }) { (dic) in
            
        }
    }
    @objc func moreAction(_ btn:Any) {
        
//        isChooseView = true
//        self.conversationMessageCollectionView.reloadData()
        self.doMoreAction(btn) { (list) in
            
        }
    }
    @objc func repeatAction(_ btn:Any) {
        
        
        //callback
//        self.recallMessage((self.selectRCMessageModel?.messageId)!)
        let aaa = SelectMyGroup()
        aaa.targetId = self.targetId  //当前所在群组的groupid
        aaa.message = self.selectRCMessageModel?.content
        aaa.iszhuanfa = true
        aaa.finishSelect = {
            sGroupList,otherText in
            
            for sGroupOne in sGroupList {
                let gModel = sGroupOne as! GroupModel
                RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: self.selectRCMessageModel?.content, pushContent: PublicDataSingle.makePushContent(self.selectRCMessageModel?.content, groupId: gModel.groupid), pushData: PublicDataSingle.makePushContent(self.selectRCMessageModel?.content, groupId: gModel.groupid), success: { (Int) in
                    
                    if otherText != "" {
                        DispatchQueue.main.async {
                            RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: RCTextMessage.init(content: otherText), pushContent: PublicDataSingle.makePushContent(RCTextMessage.init(content: otherText), groupId: gModel.groupid), pushData: PublicDataSingle.makePushContent(RCTextMessage.init(content: otherText), groupId: gModel.groupid), success: { (Int) in
                            }, error: { (RCErrorCode, Int) in
                            })
                        }
                    }
                }, error: { (RCErrorCode, Int) in
                    
                })
            }
            self.navigationController?.view.makeToast("转发成功", duration: 1.0, position: CSToastPositionCenter)
            
            self.navigationController?.popViewController(animated: true)
            
        }
    
        self.navigationController?.pushViewController(aaa, animated: true)
    }
    
    
    @objc func creatThemeAction(_ btn:Any) {
        
        let vc = ThemeCreatVC()
        self.progressShow()
        vc.subGroupid = nil
        
        vc.groupid = self.targetId
        
        if (self.selectRCMessageModel?.content.isKind(of: RCTextMessage.self))! {
            let textMessage = self.selectRCMessageModel?.content as! RCTextMessage
            vc.textView?.text = textMessage.content
            vc.placeholderLabel?.isHidden = true
            
        }else if (self.selectRCMessageModel?.content.isKind(of: RCImageMessage.self))! {
            let textMessage = self.selectRCMessageModel?.content as! RCImageMessage
            let fullImageUrl = textMessage.imageUrl
            
            if fullImageUrl?.range(of: "http://") != nil{
                let imaData = try? Data.init(contentsOf: URL.init(string: textMessage.imageUrl)!)
                if imaData == nil {
                    self.progressDismissWith(str: "图片链接错误")
                    return
                }
                
//               let phphotoLib = PHPhotoLibrary.init()
                
//                let lib = ALAssetsLibrary.init()
//                lib.writeImageData(toSavedPhotosAlbum: imaData, metadata: nil, completionBlock: { (assetURL, error) in
//                    print(error)
//                    vc.selectedAssets = [PHAsset.fetchAssets(withALAssetURLs: [assetURL!], options: nil).firstObject as Any!]
//                    vc.isSelectOriginalPhoto = true
//                    if vc.isSelectOriginalPhoto! {
//                        DispatchQueue.main.async {
//                            var tempPhotos : Array<UIImage>? = []
//                            TZImageManager().getOriginalPhoto(withAsset: vc.selectedAssets?.first, completion: { (image, dic) in
//                                tempPhotos?.append(image!)
//                                vc.selectedPhotos = tempPhotos
//                                vc.creatImageView()
//                            })
//
//                        }
//                    }
//                })
            }else{
                vc.selectedPhotos = [UIImage.init(contentsOfFile: fullImageUrl!)!]
                vc.creatImageView()
            }
        }
        
        vc.creatThemeSuccessBlock = ({ (themeid) in
            GroupRequest.getGroupSubjectInfo(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":themeid!], hadToast: true, fail: { [weak self](error) in
                if let strongSelf = self {
                    strongSelf.progressDismissWith(str: "获取话题信息失败")
                }
                
                }, success: { [weak self](dic) in
//                    if let strongSelf = self {
//                        strongSelf.progressDismiss()
//                        print(dic)
//                        let nMessage = ThemeMessageContent()
//                        nMessage.content = dic["group_name"] as! String
//                        nMessage.extra = ""
//                        nMessage.imageURL = ""
//                        nMessage.thumbnailUrl = ""
//                        nMessage.url = ""
//                        nMessage.groupId = dic["parentid"] as! String
//                        nMessage.themeId = dic["groupid"] as! String
//                        if (dic["titleFileList"] is Array<Dictionary<String, Any>>) {
//                            var urlArr : Array<Any>? = []
//                            for dict:Dictionary<String, Any> in (dic["titleFileList"] as! Array<Dictionary<String, Any>>){
//                                urlArr?.append(dict)
//                            }
////                            strongSelf.selectedUrls = urlArr
////                            strongSelf.creatImageView()
//                        }
//                        strongSelf.sendMessage(nMessage, pushContent: nMessage.content)
//                    }
            })
            
            
            
        })
        self.progressDismiss()
        self.navigationController?.pushViewController(vc, animated: true)
        
    }
    //更多按钮点击事件
    func doMoreAction(_ btn:Any,finishB:@escaping (Array<String>)->()) {
        //收回键盘
        if self.chatSessionInputBarControl.inputTextView.isFirstResponder {
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
        }
        self.chatSessionInputBarControl.resetToDefaultStatus()
        self.navigationController?.navigationBar.addSubview(coverNavBar)
        showMoreBottomView = true
        isChooseView = true
        self.conversationMessageCollectionView.reloadData()
        self.moreBottomView.creatBtnsWithImageNames(ImageNamesArr: ["more_transmit","more_delete"])
        self.moreBottomView.btnClickBlock = ({ [weak self](btn) in
            if let strongSelf = self {
                switch btn.tag {
                case 10:
                    if strongSelf.chooseList.count == 0 {
                        strongSelf.view.makeToast("请选择转发的内容", duration: 1.0, position: CSToastPositionCenter)
                        return
                    }
                    let alertV = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet)
                    alertV.addAction(UIAlertAction(title: "取消", style: .cancel, handler: { (cAlert) in
                    }))
                    alertV.addAction(UIAlertAction(title: "逐条转发", style: .default, handler: { (cAlert) in
                        
                        var idlist = Array<RCMessageModel>.init()
//                        var idlist = Array<Array<RCMessageModel>>.init()
                        for  idStr in strongSelf.chooseList {
                            for oneMessage in strongSelf.conversationDataRepository {
                                let oneM = oneMessage as! RCMessageModel
                                if idStr == "\(oneM.messageId)"{
                                    idlist.append(oneM)
                                    break
                                }
                            }
                        }
                        idlist.sort(by: { (model1, model2) -> Bool in
                            return model1.sentTime < model2.sentTime
                        })
                        let selectVC = SelectMyGroup()
                        selectVC.targetId = strongSelf.gModel?.groupid  //当前所在群组的groupid
                        selectVC.iszhuanfa = true
                        selectVC.finishSelect = {
                            sGroupList,otherText in
                            for sGroupOne in sGroupList {
                                let gModel = sGroupOne as! GroupModel
                                self?.sendListMessage(from: 0, idlist: idlist, ggModel: gModel, endMessage: otherText!)
//                                for oneM in idlist {
//                                    RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: oneM.content, pushContent: "转发", pushData: "转发", success: { (Int) in
//                                    }, error: { (RCErrorCode, Int) in
//                                    })
//                                }
//                                if otherText != "" {
//                                    RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: RCTextMessage.init(content: otherText), pushContent: otherText, pushData: otherText, success: { (Int) in
//                                    }, error: { (RCErrorCode, Int) in
//                                    })
//                                }
                            }
                            strongSelf.navigationController?.view.makeToast("转发成功", duration: 1.0, position: CSToastPositionCenter)
                            
                            strongSelf.navigationController?.popViewController(animated: true)
                            
                            strongSelf.cancleMoreAction(btn)
                        }
                        strongSelf.navigationController?.pushViewController(selectVC, animated: true)
                        
                    }))
                    alertV.addAction(UIAlertAction(title: "合并转发", style: .default, handler: { (cAlert) in
                        var idlist = ""
                        for  idStr in strongSelf.chooseList {
                            for oneMessage in strongSelf.conversationDataRepository {
                                let oneM = oneMessage as! RCMessageModel
                                if idStr == "\(oneM.messageId)"{
                                    idlist.append(oneM.messageUId+",")
                                    break
                                }
                            }
                        }
                        let selectVC = SelectMyGroup()
                        selectVC.targetId = strongSelf.gModel?.groupid  //当前所在群组的groupid
                        selectVC.iszhuanfa = true
                        selectVC.finishSelect = {
                            sGroupList,otherText in
                            strongSelf.progressShow()
                            GroupRequest.forwardGroupSubject(params: ["app_token":sharePublicDataSingle.token,"groupid":strongSelf.gModel?.groupid,"msg_uid_str":idlist,"is_all":false], hadToast: true, fail: { [weak self](errorDic) in
                                if let strongSelf = self{
                                    strongSelf.progressDismiss()
                                }
                                print(errorDic)
                            }, success: { [weak self](succDic) in
                                if let strongSelf = self{
                                    strongSelf.progressDismiss()
                                    let nMessage = HistoryMessageContent.init()
                                    nMessage.title = succDic["title"] as! String
                                    nMessage.content = succDic["content"] as! String
                                    nMessage.url = succDic["forwardUrl"] as! String
                                    
                                    for sGroupOne in sGroupList {
                                        let gModel = sGroupOne as! GroupModel
                                        
                                        RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: nMessage, pushContent: PublicDataSingle.makePushContent(nMessage, groupId: gModel.groupid), pushData: PublicDataSingle.makePushContent(nMessage, groupId: gModel.groupid), success: { (Int) in
                                            if otherText != "" {
                                                DispatchQueue.main.async {
                                                    RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: RCTextMessage.init(content: otherText), pushContent: PublicDataSingle.makePushContent(RCTextMessage.init(content: otherText), groupId: gModel.groupid), pushData: PublicDataSingle.makePushContent(RCTextMessage.init(content: otherText), groupId: gModel.groupid), success: { (Int) in
                                                    }, error: { (RCErrorCode, Int) in
                                                    })
                                                }
                                            }
                                        }, error: { (RCErrorCode, Int) in
                                        })
                                        
                                    }
                                    
                                    strongSelf.navigationController?.view.makeToast("转发成功", duration: 1.0, position: CSToastPositionCenter)
                                    
                                    strongSelf.navigationController?.popViewController(animated: true)
                                    
                                }
                                
                            })
                           
                            strongSelf.cancleMoreAction(btn)
                            
                        }
                        strongSelf.navigationController?.pushViewController(selectVC, animated: true)
                    }))
                    
                    strongSelf.present(alertV, animated: true, completion: nil)
                    
                    print("转发")
                case 11:
                    if strongSelf.chooseList.count == 0 {
                        strongSelf.view.makeToast("请选择删除的内容", duration: 1.0, position: CSToastPositionCenter)
                        return
                    }
                    for idStr in strongSelf.chooseList {
                        for oneMessage in strongSelf.conversationDataRepository {
                            let oneM = oneMessage as! RCMessageModel
                            if idStr == "\(oneM.messageId)"{
                                strongSelf.deleteMessage(oneM)
                                break
                            }
                        }
                    }
                    
                    //todo没有找到更好的方法，暂时这么处理
                    DispatchQueue.main.asyncAfter(deadline: DispatchTime.now()+0.5, execute: {
                        strongSelf.cancleMoreAction(btn)
                    })
                    
                    print("删除")
                default:
                    break
                }
            }
        })
        self.view.addSubview(self.moreBottomView)
        self.view.frame = CGRect.init(x: 0, y: 0, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
        self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: 0, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-50)
        self.chatSessionInputBarControl.frame = CGRect.init(x: 0, y: MAIN_SCREEN_HEIGHT_PX-50, width: kScreenW, height: 50)
        self.chatSessionInputBarControl.isHidden = true
        self.isHiddeTab(isHidden: true)
    }
    func sendListMessage(from:Int ,idlist:Array<RCMessageModel> , ggModel:GroupModel ,endMessage:String) {
        
        if idlist.count == from{
            if endMessage != "" {
                DispatchQueue.main.async {
                    RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: ggModel.groupid, content: RCTextMessage.init(content: endMessage), pushContent: PublicDataSingle.makePushContent(RCTextMessage.init(content: endMessage), groupId: ggModel.groupid), pushData: PublicDataSingle.makePushContent(RCTextMessage.init(content: endMessage), groupId: ggModel.groupid), success: { (Int) in
                    }, error: { (RCErrorCode, Int) in
                    })
                }
            }
            return
        }
        
        let oneM = idlist[from]
        DispatchQueue.main.async {
            RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: ggModel.groupid, content: oneM.content, pushContent: "[转发]"+PublicDataSingle.makePushContent(oneM.content, groupId: ggModel.groupid), pushData: "[转发]"+PublicDataSingle.makePushContent(oneM.content, groupId: ggModel.groupid), success: { (Int) in
                Thread.sleep(forTimeInterval: 0.1)
                self.sendListMessage(from: from+1, idlist: idlist, ggModel: ggModel, endMessage: endMessage )
            }, error: { (RCErrorCode, Int) in
                Thread.sleep(forTimeInterval: 0.1)
                self.sendListMessage(from: from+1, idlist: idlist, ggModel: ggModel, endMessage: endMessage )
            })
        }
    }
    
//    func sendFiveMessage(from:Int ,idlist:Array<RCMessageModel> , ggModel:GroupModel ,endMessage:String) {
//        var i = 0
//        var j = 0
//        while i<5 {
//            if idlist.count == from+i{
//                if endMessage != "" {
//                    DispatchQueue.main.async {
//                        RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: ggModel.groupid, content: RCTextMessage.init(content: endMessage), pushContent: endMessage, pushData: endMessage, success: { (Int) in
//                        }, error: { (RCErrorCode, Int) in
//                        })
//                    }
//                }
//                return
//            }
//            let oneM = idlist[from+i]
//            DispatchQueue.main.async {
//                RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: ggModel.groupid, content: oneM.content, pushContent: "转发", pushData: "转发", success: { (Int) in
//                    j += 1
//                    if j == 5 {
//                        self.sendFiveMessage(from: from+i+1, idlist: idlist, ggModel: ggModel, endMessage: endMessage )
//                    }
//                }, error: { (RCErrorCode, Int) in
//                    j += 1
//                    if j == 5 {
//                        self.sendFiveMessage(from: from+i+1, idlist: idlist, ggModel: ggModel, endMessage: endMessage )
//                    }
//                })
//            }
//            i += 1;
//        }
//    }
    
    //取消更多点击事件
    @objc func cancleMoreAction(_ btn:Any) {
        coverNavBar.removeFromSuperview()
        showMoreBottomView = false
        isChooseView = false
        self.chooseList.removeAll()
        self.conversationMessageCollectionView.reloadData()
        self.moreBottomView.removeFromSuperview()
        self.view.frame = CGRect.init(x: 0, y: 0, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
        self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: 0, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-50-49)
        self.chatSessionInputBarControl.frame = CGRect.init(x: 0, y: MAIN_SCREEN_HEIGHT_PX-50-49, width: kScreenW, height: 50)
        self.chatSessionInputBarControl.isHidden = false
        self.isHiddeTab(isHidden: false)
    }
    func gimage(image:UIImage,error:NSError,contextInfo:Any) {
        print("image = \(image), error = \(error), contextInfo = \(contextInfo)")
    }
    
    func makeNavigationRightBtn(canClick : Bool) {
        let rightBtn = UIButton.init(type: .system)
        rightBtn.frame =  CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight)
        
        let rightBtn2 = UIButton.init(type: .system)
        rightBtn2.frame =  CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight)
        
        if canClick {
            rightBtn.setImage(UIImage.init(named: "nav_groupSetting"), for: .normal)
            rightBtn.addTarget(self, action: #selector(myRightBtnDidClick), for: .touchUpInside)
            
            rightBtn2.setImage(UIImage.init(named: "search_white"), for: .normal)
            rightBtn2.addTarget(self, action: #selector(myRightBtnDidClick2), for: .touchUpInside)
            
        }else{
            rightBtn.setImage(UIImage.init(named: ""), for: .normal)
            rightBtn.isUserInteractionEnabled = false
            
            rightBtn2.setImage(UIImage.init(named: ""), for: .normal)
            rightBtn2.isUserInteractionEnabled = false
        }
        rightBtn.sizeToFit()
        rightBtn2.sizeToFit()
        
        
        
        let rightBarButtonItem = UIBarButtonItem.init(customView: rightBtn)
        let rightBarButtonItem2 = UIBarButtonItem.init(customView: rightBtn2)
        let array = [rightBarButtonItem,rightBarButtonItem2]
        self.tabBarController?.navigationItem.rightBarButtonItems = array
    }
    @objc func myRightBtnDidClick(button: UIButton) {
        let groupSettingVC : GroupSettingViewController = GroupSettingViewController()
        groupSettingVC.targetId = self.targetId
        self.navigationController?.pushViewController(groupSettingVC, animated: true)
    }
    @objc func myRightBtnDidClick2(button: UIButton) {
        let v = ChatContentSearchVC()
        v.targetId = self.targetId
//        v.cellClick {[weak self] (model) in
//            
//            self?.scrollToIndexWithMessageId(model: model)
//            
//        }
        
        
        
        self.navigationController?.pushViewController(v, animated: true)
    }
        override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
            let model:RCMessageModel = self.conversationDataRepository[indexPath.row] as! RCMessageModel
            if model.objectName == "RC:VcMsg"
            {
//                return super.collectionView(collectionView, cellForItemAt: indexPath)
                let cell:MyVoiceCell = collectionView.dequeueReusableCell(withReuseIdentifier: "voice", for: indexPath) as! MyVoiceCell
                cell.setDataModel(model)
                cell.myDelegate = self
                cell.delegate = self as! RCMessageCellDelegate
                self.willDisplayMessageCell(cell, at: indexPath)
                return  cell as UICollectionViewCell
            }
            else if model.objectName == "ThemeMessageContent"
            {
                
                let cell:ThemeMessageCell = collectionView.dequeueReusableCell(withReuseIdentifier: "ThemeMessageContent", for: indexPath) as! ThemeMessageCell
                cell.openList = self.openArray
                cell.setDataModel(model)
                cell.delegate = self as RCMessageCellDelegate
                self.willDisplayMessageCell(cell, at: indexPath)
                return  cell as RCMessageBaseCell
            }
            else if model.objectName == "ProjectVoiceMessageContent"
            {
                let cell:ProjectVoiceMessageContentCell = collectionView.dequeueReusableCell(withReuseIdentifier: "ProjectVoiceMessageContent", for: indexPath) as! ProjectVoiceMessageContentCell
                cell.setDataModel(model)
                
                
                
                if shareAVManager.player != nil {
                    
                    if cell.model.messageId == shareAVManager.model?.messageId {
                        if (shareAVManager.player?.isPlaying)!{
                            cell.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                        }else {
                            if shareAVManager.player?.currentTime != 0 {
                                cell.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                            }
                        }
                    }
                    
                }
                
                
                cell.click = {[weak cell,weak collectionView] (model) in
                    
                    if cell?.model.messageId == shareAVManager.model?.messageId {
                        
                        if shareAVManager.player != nil {
                            if (shareAVManager.player?.isPlaying)!{
                                shareAVManager.stopPlay()
                                cell?.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                                cell?.progress.progress = shareAVManager.currentProgress()
                                cell?.timeLable.text = shareAVManager.currentTime()
                                return
                            }else {
                                if shareAVManager.player?.currentTime != 0 {
                                    shareAVManager.startPlay()
                                    cell?.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                                    cell?.progress.progress = shareAVManager.currentProgress()
                                    
                                    cell?.timeLable.text = shareAVManager.currentTime()
                                    return
                                }
                                
                            }
                        }
                        
                        
                    }
                    
                    shareAVManager.playUrlDataWithModel(progress: 0, mModel: model, compete: { (finish) in
                        
                        
                        
                        let array = collectionView?.visibleCells
                        if (array?.count)! > 0 {
                            for mycell in array! {
                                if mycell .isKind(of: ProjectVoiceMessageContentCell.self){
                                    let myCell:ProjectVoiceMessageContentCell = mycell as! ProjectVoiceMessageContentCell
                                    if myCell.model.messageId == shareAVManager.model?.messageId{
                                        myCell.progress.progress = shareAVManager.currentProgress()
                                        if finish {
                                            myCell.timeLable.text = "0:00"
                                            myCell.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                                            myCell.progress.progress = 0
                                            return
                                        }
                                    }
                                }
                            }
                            
                        }
                        
                    }, action: {
                        let array = collectionView?.visibleCells
                        if (array?.count)! > 0 {
                            for mycell in array! {
                                if mycell .isKind(of: ProjectVoiceMessageContentCell.self){
                                    let myCell:ProjectVoiceMessageContentCell = mycell as! ProjectVoiceMessageContentCell
                                    if myCell.model.messageId == shareAVManager.model?.messageId{
                                        myCell.progress.progress = shareAVManager.currentProgress()
                                        
                                        cell?.timeLable.text = shareAVManager.currentTime()
                                        cell?.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                                    }else{
                                        myCell.progress.progress = 0
                                        cell?.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                                    }
                                }
                            }
                            
                        }
                        
                        //                        }
                        
                    })
                }
                return cell
                
            }else if model.objectName == "ProjectReportMessageContent"
            {
                let cell:ProjectReportMessageContentCell = collectionView.dequeueReusableCell(withReuseIdentifier: "ProjectReportMessageContent", for: indexPath) as! ProjectReportMessageContentCell
                cell.setDataModel(model)
                cell.clickWithUrl = { [weak self] (url)in
                    let vc = MineReviseVC()
                    vc.url = URL.init(string:url)
                    self?.navigationController?.pushViewController(vc, animated: true)
                }
                return cell
            }
            else
            {
                print("321"+model.objectName)
                print("456\(collectionView.self)")
                return super.collectionView(collectionView, cellForItemAt: indexPath)
            }
        }
    
    //MARK: - ----------------------更多底部按钮----------------------
    lazy var moreBottomView: MoreSelectBottomView = {
        var moreBottomView = MoreSelectBottomView.init(frame: CGRect.init(x: 0, y: MAIN_SCREEN_HEIGHT_PX - 50, width: kScreenW, height: 50))
        return moreBottomView
    }()
    //MARK: - ----------------------更多选择时遮盖导航栏----------------------
    lazy var coverNavBar: UINavigationBar = {
        var coverNavBar = UINavigationBar.init(frame: (self.navigationController?.navigationBar.bounds)!)
        let cancleBtn = UIButton.init()
        cancleBtn.setTitle("取消", for: .normal)
        cancleBtn.setTitleColor(UIColor.white, for: .normal)
        cancleBtn.sizeToFit()
        cancleBtn.addTarget(self, action: #selector(cancleMoreAction(_:)), for: .touchUpInside)
        coverNavBar.addSubview(cancleBtn)
        let titleLabel = UILabel.init()
        titleLabel.text = self.gModel?.group_name
        titleLabel.textColor = UIColor.white
        titleLabel.textAlignment = .center
        titleLabel.sizeToFit()
        coverNavBar.addSubview(titleLabel)
        cancleBtn.mas_makeConstraints({ (make) in
            make!.left.equalTo()(20)
            make!.centerY.equalTo()(coverNavBar)
        })
        titleLabel.mas_makeConstraints({ (make) in
            make!.width.equalTo()(SCREEN_WIDTH - 2 * (cancleBtn.frame.size.width + 30))
            make!.center.equalTo()(coverNavBar)
        })
        return coverNavBar
    }()
   
    //MARK:----------------------键盘通知----------------------
    @objc func click(notification: NSNotification)
    {
        
        if self.chatSessionInputBarControl.frame.origin.y>MAIN_SCREEN_HEIGHT_PX-49{
//            self.view.frame = CGRect.init(x: 0, y: 0, width:kScreenW, height: kScreenH)
            if self.unReadButton != nil {
//                self.unReadMessageLabel.frame = CGRect.init(x: self.unReadMessageLabel.frame.origin.x, y: self.unReadMessageLabel.frame.origin.y-49, width: self.unReadMessageLabel.frame.size.width, height: self.unReadMessageLabel.frame.size.height)
                
                 self.unReadButton.frame = CGRect.init(x: self.unReadButton.frame.origin.x, y: unReadButton_Y-49, width: self.unReadButton.frame.size.width, height: self.unReadButton.frame.size.height)
            }
        }
        else
        {
//            self.view.frame = CGRect.init(x: 0, y: -49, width:kScreenW, height: kScreenH)
            if self.unReadButton != nil {
//                self.unReadMessageLabel.frame = CGRect.init(x: self.unReadMessageLabel.frame.origin.x, y: self.unReadMessageLabel.frame.origin.y+49, width: self.unReadMessageLabel.frame.size.width, height: self.unReadMessageLabel.frame.size.height)
                
                 self.unReadButton.frame = CGRect.init(x: self.unReadButton.frame.origin.x, y: unReadButton_Y, width: self.unReadButton.frame.size.width, height: self.unReadButton.frame.size.height)
            }
        }
       
    }
    
    
    @objc func clickshow(notification: NSNotification)
    {
        
        self.view.frame = CGRect.init(x: 0, y: 0, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
        if self.unReadButton != nil {
            //                self.unReadMessageLabel.frame = CGRect.init(x: self.unReadMessageLabel.frame.origin.x, y: self.unReadMessageLabel.frame.origin.y+49, width: self.unReadMessageLabel.frame.size.width, height: self.unReadMessageLabel.frame.size.height)
            
            self.unReadButton.frame = CGRect.init(x: self.unReadButton.frame.origin.x, y: unReadButton_Y-49, width: self.unReadButton.frame.size.width, height: self.unReadButton.frame.size.height)
        }
    }
    
    
    
    
////MARK: - ---------------------语音消息播放完成的通知响应事件----------------------
//    
//    @objc func avStart(){
//        
//        
//        
//        let mArray = notification.object as! Array<Any>
//        let m:RCMessageModel = mArray[0] as! RCMessageModel
//        guard m.targetId == self.targetId else {
//            //必须保证 当前播放的语音消息 是属于当前聊天场景（后续可能会添加 话题等，由于系统设计tabbarcontroller 会出现同时有多个聊天场景共存的现象）  否则没有必要去做接下来的处理
//            return
//        }
//
//        //需要将播放完成语音消息  接收状态改变
//        let i = self.conversationDataRepository.index(of: m)
//        m.receivedStatus = .ReceivedStatus_LISTENED
//        
//        //在滑动的时候 可能会出现越界 因此要加一个判断
//        if self.conversationDataRepository.count>=i
//        {
//            self.conversationDataRepository.replaceObject(at: i, with: m)
//        }
//
//        //todo  当开启自动播放后   在没有显示到屏幕上的当播放完后 第一次滑出红色的未读还有存在  暂时没有找到更好的方法  先这样
//        if shareAVManager.isAuto == true {
//            self.conversationMessageCollectionView.reloadData()
//        }
//
//       
//    }
//    
    
    
     func avfinish(){
        
    
//        let mArray = notification.object as! Array<Any>
//        let m:RCMessageModel = mArray[0] as! RCMessageModel
        
        if shareAVManager.isAuto != true {
            return
        }
        
        if shareAVManager.model?.messageDirection == .MessageDirection_SEND {
            //自己发的消息不用做自动播放处理
            return
        }
        
        
        let m:RCMessageModel = shareAVManager.model!
        
        guard m.targetId == self.targetId else {
            //必须保证 当前播放的语音消息 是属于当前聊天场景（后续可能会添加 话题等，由于系统设计tabbarcontroller 会出现同时有多个聊天场景共存的现象）  否则没有必要去做接下来的处理
            return
        }
        
        
        //需要将播放完成语音消息  接收状态改变
        let i = self.conversationDataRepository.index(of: m)
        m.receivedStatus = .ReceivedStatus_LISTENED
        
        //在滑动的时候 可能会出现越界 因此要加一个判断
        if self.conversationDataRepository.count>=i
        {
        self.conversationDataRepository.replaceObject(at: i, with: m)
        }
        
//        如果刚播完的语音在播放前不是未读  就没有必要做自动播放
        
        
        
        //拿到当前屏幕上显示的cell  并做类型过滤
        var array = Array<Any>()
       
        if self.conversationMessageCollectionView.visibleCells.count > 0 {
            for i in 0..<self.conversationMessageCollectionView.visibleCells.count {
                let cell = self.conversationMessageCollectionView.visibleCells[i]
                
                guard cell is MyVoiceCell else {
                    continue
                }
                
                let cuCell:MyVoiceCell = cell as! MyVoiceCell
                if cuCell.model.messageDirection == .MessageDirection_RECEIVE && cuCell.model.receivedStatus != .ReceivedStatus_LISTENED {
                    array.append(cell)
                }
                
            }
        }
        
        
        
  if array.count > 0
   {
    
       
        //必须做排序  必须做！！！ 必须做！！！ 必须做！！！
        //拿到的屏幕显示的数据  并不会按照cell显示的顺序存放到数组
        array = array.sorted(by: { (cell1, cell2) -> Bool in
            let cell11:RCMessageCell = cell1 as! RCMessageCell
             let cell22:RCMessageCell = cell2 as! RCMessageCell
            return cell22.model.messageId > cell11.model.messageId
        })
        
        
        
        //我们是要做语音消息的处理  所以保证接下来处理的cell类型为语音类型
            for i in 0..<array.count {
                let cell  = array[i]
                
                /// 先在显示到屏幕的cell中去做处理 只要找到符合条件的就播放 并跳出循环
                let myCell:MyVoiceCell = cell as! MyVoiceCell
                if myCell.model.receivedStatus != RCReceivedStatus.ReceivedStatus_LISTENED {
                    
                    if myCell.model.messageId > (shareAVManager.model?.messageId)! {
                        myCell.play()
                        return
                    }
            }
        
    }
  }else{
    
    self.conversationMessageCollectionView.reloadData()
    
        }
        
        
        // 当把当前屏幕显示的所有未播放的播放完   要到数据源里去找未播放的语音
        for i in 0..<self.conversationDataRepository.count {
            let model:RCMessageModel = self.conversationDataRepository[i] as! RCMessageModel
            
            guard model.messageDirection == .MessageDirection_RECEIVE else {
                 continue
               }
            
            
            if model.objectName == "RC:VcMsg" && model.receivedStatus != RCReceivedStatus.ReceivedStatus_LISTENED {
                
                if model.messageId > (shareAVManager.model?.messageId)! {
                    
                    shareAVManager.playAudioWithModel(progress: 0, mModel: model, compete: {[weak self] (finish) in
                        if finish == true{
                          self?.avfinish()
                        }
                        
                        
                    }, action: {
                        
                    })
                    
                    
                    return
                }
                else{
                    continue
                }
            
            
            
            }
                
                
                
                
            }
            
        }
        
            
    
    
    
    /// 点击头像 响应事件
    ///
    /// - Parameter userId: <#userId description#>
    override func didTapCellPortrait(_ userId: String!) {
        
        print("点击了用户头像--用户id--"+userId)
        
        let userid = userId.substring(to: (userId.range(of: "-")?.lowerBound)!)
//        let str = "{\"action\":\"goto\",\"data\":{\"data\":"+userid+",\"subAction\":\"personDetail\"}}"
//        let notice = NSNotification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : str])
        let notice = Notification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : userid])
        NotificationCenter.default.post(notice)
      
    }
    
    
    
  //MARK: - ---------------------刷新用户信息 做头像  名称的刷新----------------------
    func  refreshUserInfoOrGroupInfo(){
    
        
        if self.conversationType == .ConversationType_GROUP{
            let predicate = NSPredicate.init(format: "groupid == %@ AND is_delete == '0'", argumentArray: [self.targetId])
            let groupUser =  GroupUserModel.objects(with: predicate)
            for i in 0..<groupUser.count {
                let gModel:GroupUserModel = groupUser.object(at: i) as! GroupUserModel
//                let userModelTemp : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", gModel.userid)).firstObject() as! UserModel?
                let userModel = RCUserInfo.init()
                userModel.userId = gModel.im_userid
                userModel.name = gModel.realname
                
                if gModel.avater == nil { //头像为空时设置默认头像
//                    userModel.portraitUri = "http://tcp.xslp.cn/static/images/userpic.jpg" //正式
                    userModel.portraitUri = kBASE_URL + "static/images/userpic.jpg"
                }
                else
                {
                    
                    userModel.portraitUri = gModel.avater
                   
                }
                
                RCIM.shared().refreshUserInfoCache(userModel, withUserId: userModel.userId)
            }
            
            
            }
     }
    
    
    /// 给发消息加推送
    ///
    /// - Parameters:
    ///   - messageContent: 消息内容
    ///   - pushContent: 消息推送内容
    override func sendMessage(_ messageContent: RCMessageContent!, pushContent: String!) {
        super.sendMessage(messageContent, pushContent: PublicDataSingle.makePushContent(messageContent, groupId: self.targetId))
    }
    
   //MARK: - ---------------------消息将要发送----------------------
    override func willSendMessage(_ messageContent: RCMessageContent!) -> RCMessageContent! {
//        if messageContent.isKind(of: RCImageMessage.self){
//            
//        }
        
        if messageContent.isMember(of: RCTextMessage.self){
            // atArray 中存放的是要@的对象
            if (self.atArray?.count != 0){
              
              let array:NSArray = NSArray.init(array: self.atArray!)
                messageContent.mentionedInfo = RCMentionedInfo.init(mentionedType:.mentioned_Users, userIdList: array.value(forKeyPath: "im_userid") as! [Any]?, mentionedContent:nil)
              self.atArray?.removeAll()
              return messageContent
            }
            else {
            //@全体
                let textMsg:RCTextMessage = messageContent as! RCTextMessage
                if textMsg.content.contains("@全体")  {
                    messageContent.mentionedInfo = RCMentionedInfo.init(mentionedType:.mentioned_All, userIdList: nil, mentionedContent:nil)
                    return messageContent
                }
                
                
                   return super.willSendMessage(messageContent)
            
            }
            
            
        }
        return super.willSendMessage(messageContent)
    }
    
 //MARK: - ---------------------每次输入框输入的内容发生变化的回调----------------------
    override func inputTextView(_ inputTextView: UITextView!, shouldChangeTextIn range: NSRange, replacementText text: String!) {
        
        guard text != nil else {
            
            super.inputTextView(inputTextView, shouldChangeTextIn: range, replacementText: text)
            return
        }
                if text == "@"{
            
            let vc =   GroupChooseMemberVC()
            vc.groupId = targetId
            vc.backWithUserName(username: {[weak self] (user) in
//                let imId = user.userid.appending("-0")
                self?.atArray?.append(user)
//                inputTextView.text.append("@")
                inputTextView.text.append(user.realname)
                inputTextView.text.append(" ")
            })
            
            self.navigationController?.pushViewController(vc, animated: true)
        }
        else{
        
            //每次当有删除的时候 如果输入框中不包括数组中的数据  说明该数据就是被删除了
            if self.atArray?.count == 0 || text != ""{
                return
            }
            var inputText = inputTextView.text as NSString
            let deleteText:NSString = inputText.substring(with: NSRange.init(location: inputTextView.selectedRange.location-1, length: 1)) as NSString
            if deleteText.isEqual(to: " ") {
                
                
                inputText = inputText.substring(to: inputTextView.selectedRange.location-1) as NSString
                
                var userTempStr = String()
                var indexTemp:Int = 0
                for i in (0..<inputText.length-1).reversed(){
                    let str = inputText.substring(with:NSRange(location: i,length: 1))
                    if str == "@" {
                        
                        let start = inputTextView.text.index(inputTextView.text.startIndex, offsetBy: i)
                        let end = inputTextView.text.index(inputTextView.text.startIndex, offsetBy: inputTextView.selectedRange.location)
                        let range = Range.init(uncheckedBounds: (start,end))
                        
                        userTempStr = inputTextView.text.substring(with: range)
                        
                        indexTemp = i
                        break
                    }
                }
                
                guard !userTempStr.isEmpty else {
                    return
                }
                for i in 0..<self.atArray!.count {
                    
                    let model:GroupUserModel = (self.atArray?[i])!
//                    let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", model.userid)).firstObject() as! UserModel?
                    let username = String.init(format: "@%@ ", model.realname != nil ? (model.realname): "")
                    
                        if username  == userTempStr {
                        self.atArray?.remove(at: i)
                            let startIndex = inputTextView.text.index(inputTextView.text.startIndex, offsetBy: indexTemp)
                            let endIndex = inputTextView.text.index(inputTextView.text.startIndex, offsetBy: inputTextView.selectedRange.location)
                           let t = Range(uncheckedBounds:(startIndex,endIndex))
                            
                        inputTextView.text = inputTextView.text.replacingCharacters(in: t ,with: " ")
                            
                        break
                    }
                    }
             }
            else{
                
                for i in 0..<self.atArray!.count {
                    
                    let model:GroupUserModel = (self.atArray?[i])!
//                    let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", model.userid)).firstObject() as! UserModel?
                    
//                    let username = String.init(format: "@%@ ", userModel?.realname != nil ? (userModel?.realname)! : "")
                    let username = String.init(format: "@%@ ", model.realname != nil ? (model.realname) : "")
                    if !inputTextView.text.contains(username) {
                       self.atArray?.remove(at: i)
                        break;
                    }
                    
                }
                
                }
            
        
        }
    }
    
    
 //MARK: - ---------------------自定义 @某个对象的时候   必须重写融云的该方法 融云的知识库里的说明----------------------
    override func showChooseUserViewController(_ selectedBlock: ((RCUserInfo?) -> Void)!, cancel cancelBlock: (() -> Void)!) {
        
    }
    
    
    
    
    //语音消息开始录音
    override func onBeginRecordEvent() {
        //应该把正在播放的语音关闭
        shareAVManager.stopPlay()
        self.scrollToBottom(animated: true)
        super.onBeginRecordEvent()
        
    }
    
    
    
    func scrollToIndexWithMessageId(model:ChatContentModel){
        
        isSearchBack = true
        //读取我们查到界面的前一条及后面所有条数（暂定1000条，超过就显示不全了）
        let newDataArr = RCIMClient.shared().getHistoryMessages(RCConversationType.ConversationType_GROUP, targetId: self.targetId, sentTime: model.time!, beforeCount: 0, afterCount: 1000)
        //移除原有截面数据，然后把查到的数据插入到当前界面数据列表中
        self.conversationDataRepository.removeAllObjects()
        for nemodel in newDataArr! {
            self.conversationDataRepository.insert(RCMessageModel.init(message: nemodel as! RCMessage), at: 0)
        }
        //刷新界面数据显示
        self.conversationMessageCollectionView.reloadData()
        //定位到最顶端（显示我们查到的数据）
        DispatchQueue.main.async {
            self.conversationMessageCollectionView.scrollToItem(at: IndexPath.init(row: 0, section: 0), at: .top, animated: true)
        }
        
        
    
        
    }
    
    
    
    
    //MARK: - ---------------------KVO监测输入栏Frame变化处理----------------------
    
    
    /// 添加kvo 监测
    func addObserve(){
    
        self.chatSessionInputBarControl.addObserver(self, forKeyPath: "frame", options: .new, context: nil)
        self.conversationMessageCollectionView.addObserver(self, forKeyPath: "frame", options: .new, context: nil)
    }
    
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)
    {
        if showMoreBottomView == true {
            return
        }
            if  let chatListView:UICollectionView = object as? UICollectionView{
                
                if isSearch == true {
                    if chatListView.frame.size.height > MAIN_SCREEN_HEIGHT_PX-50-NAV_HEIGHT {
                        self.conversationMessageCollectionView.frame = CGRect(x: self.conversationMessageCollectionView.frame.origin.x, y: self.conversationMessageCollectionView.frame.origin.y, width: self.conversationMessageCollectionView.frame.size.width, height: MAIN_SCREEN_HEIGHT_PX-50-NAV_HEIGHT)
                    }
                }else{
                
                    if chatListView.frame.size.height > MAIN_SCREEN_HEIGHT_PX-50-49 {
                        self.conversationMessageCollectionView.frame = CGRect(x: self.conversationMessageCollectionView.frame.origin.x, y: self.conversationMessageCollectionView.frame.origin.y, width: self.conversationMessageCollectionView.frame.size.width, height: MAIN_SCREEN_HEIGHT_PX-50-49)
                    }
                }
                
                
            }
           else{
                
             if  let chatBar:RCChatSessionInputBarControl = object as? RCChatSessionInputBarControl{
                
                if isSearch == true {
                    if chatBar.frame.origin.y < MAIN_SCREEN_HEIGHT_PX-50 {
                        self.isHiddeTab(isHidden: true)
                    }else if(chatBar.frame.origin.y > MAIN_SCREEN_HEIGHT_PX-50){
                        self.chatSessionInputBarControl.frame = CGRect.init(x: 0, y: MAIN_SCREEN_HEIGHT_PX-50, width: kScreenW, height: 50)
                        self.isHiddeTab(isHidden: false)
                        self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-50-NAV_HEIGHT)
                        self.scrollToBottom(animated: true)
                    }
                }
                else{
                if chatBar.frame.origin.y < MAIN_SCREEN_HEIGHT_PX-50-49 {
                    self.isHiddeTab(isHidden: true)
                }else if(chatBar.frame.origin.y > MAIN_SCREEN_HEIGHT_PX-50-49){
                    self.chatSessionInputBarControl.frame = CGRect.init(x: 0, y: MAIN_SCREEN_HEIGHT_PX-50-49, width: kScreenW, height: 50)
                    self.isHiddeTab(isHidden: false)
                    self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: 0, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-50-49)
                    self.scrollToBottom(animated: true)
                }
                }
            }
        }
    }
    
    
    
    
    ///输入板点击加号后出来的按钮点击响应
    ///
    /// - Parameters:
    ///   - pluginBoardView: <#pluginBoardView description#>
    ///   - tag: <#tag description#>
    override func pluginBoardView(_ pluginBoardView: RCPluginBoardView!, clickedItemWithTag tag: Int) {
        if tag == 200 {
           
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            let vc = ThemeCreatVC();
            vc.groupid = self.targetId
            self.tabBarController?.navigationController?.pushViewController(vc, animated: true)
        }
        else if tag == 1601 || tag == 1602{ //语音/视频通话
            
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            let predicate = NSPredicate.init(format: "groupid == %@ AND is_delete == '0'", argumentArray: [self.targetId])
            let groupUsers =  GroupUserModel.objects(with: predicate)
            
            var vc : SelectMemberViewController?
            if tag == 1601{
                RCCall.shared()?.startMultiCall(self.conversationType, targetId: self.targetId, mediaType: .audio)
                return
//                vc = SelectMemberViewController.init(conversationType: self.conversationType, targetId: self.targetId, mediaType: RCCallMediaType.audio, exist: [sharePublicDataSingle.publicData.im_userid], success: { [weak self](addUserIdList) in
//
//                    RCCall.shared()?.startMultiCallViewController(self!.conversationType, targetId: self?.targetId, mediaType: .audio, userIdList: addUserIdList)
////                    self?.callAudioVc = CallAudioMultiCallViewController.init(outgoingCall: (self?.conversationType)!, targetId: self?.targetId, mediaType: RCCallMediaType.audio, userIdList: addUserIdList)
////                    self?.present((self?.callAudioVc)!, animated: true, completion: nil)
//                })
            }
            if tag == 1602{
                vc = SelectMemberViewController.init(conversationType: self.conversationType, targetId: self.targetId, mediaType: RCCallMediaType.video, exist: [sharePublicDataSingle.publicData.im_userid], success: { [weak self](addUserIdList) in
                    
//                    self?.callVideoVc = CallVideoMultiCallViewController.init(outgoingCall: (self?.conversationType)!, targetId: self?.targetId, mediaType: RCCallMediaType.video, userIdList: addUserIdList)
//                    self?.present((self?.callVideoVc)!, animated: true, completion: nil)
                })
            }
            vc?.listingUserIdList = groupUsers.value(forKeyPath: "im_userid") as! [Any]
            
            self.navigationController?.pushViewController(vc!, animated: true)
//            self.present(vc!, animated: true, completion: nil)
        }
        else{
          super.pluginBoardView(pluginBoardView, clickedItemWithTag: tag)
        }
    }
    
    
    override func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let model:RCMessageModel? = self.conversationDataRepository.object(at: indexPath.row) as? RCMessageModel;
        if model?.objectName == "ThemeMessageContent"
        {
//            return CGSize.init(width:kScreenW, height: 200)
//            let size = super.collectionView(collectionView, layout: collectionViewLayout, sizeForItemAt: indexPath)
            //            return size
            return ThemeMessageCell.conFigSize(model: model!, width: kScreenW, openList: self.openArray)
            
            
        }else{
         
             return super.collectionView(collectionView, layout: collectionViewLayout, sizeForItemAt: indexPath)
            
        }
        
    }
    
    
    
    
    
    deinit {
        NotificationCenter.default.removeObserver(self)
//        if isSearch != true {
            self.chatSessionInputBarControl.removeObserver(self, forKeyPath: "frame")
            self.conversationMessageCollectionView.removeObserver(self, forKeyPath: "frame")
//        }
        
    }
    
}
//MARK: - ---------------------语音cell的代理----------------------
extension SmallTalkVC:MyVoiceViewCellDelegate{
    func clickPlayAbortive(model: RCMessageModel) {
        
        
        
        guard model.targetId == self.targetId else {
            //必须保证 当前播放的语音消息 是属于当前聊天场景（后续可能会添加 话题等，由于系统设计tabbarcontroller 会出现同时有多个聊天场景共存的现象）  否则没有必要去做接下来的处理
            return
        }
        
        
        //需要将播放完成语音消息  接收状态改变
        let i = self.conversationDataRepository.index(of: model)
        model.receivedStatus = .ReceivedStatus_LISTENED
        
        //在滑动的时候 可能会出现越界 因此要加一个判断
        if self.conversationDataRepository.count>=i
        {
            self.conversationDataRepository.replaceObject(at: i, with: model)
        }
        
    }
    
    func clickPlay(cell:MyVoiceCell,model:RCMessageModel,progress:Double){
    
        if  shareAVManager.isPlaying() {
            
            if model.messageId == shareAVManager.model?.messageId {
                shareAVManager.oncePlay()
                
            }else{
               shareAVManager.stopPlay()
            }
            
            
        }
        
        
        shareAVManager.playAudioWithModel(progress:progress,mModel:model, compete: {[weak cell,weak self] (finish) in
            
            if let myCell = cell{
                if finish == true {
                 
                    
                 myCell.cellStatus(status: .finish)
                 self?.avfinish()
                }
                else{
                 myCell.cellStatus(status: .pause)
                }
            }
            
            
        }) {[weak cell]  in
            
            if (cell != nil)
            {
                DispatchQueue.main.async {
                    cell?.timeChange()
                }
              
            }
            else{
            }
        }
        
    }
 
}
extension SmallTalkVC : RCIMReceiveMessageDelegate {
    func onRCIMReceive(_ message: RCMessage!, left: Int32) {
        
        if message.conversationType == .ConversationType_PRIVATE {
            let pri = PrivateUserModel()
            pri.id = message.targetId
            DataBaseOperation.addData(rlmObject: pri)
        }
       
        if message.objectName == "RC:GrpNtf" {
            return
        }
        
        
        //只有这种情况才做处理  如果在主题的聊天界面就不用处理了
        
        if self.tabBarController?.navigationController != nil {
            
            guard  (self.tabBarController?.navigationController?.children.last?.isKind(of:TMTabbarController.self))! else {
                return
            }
            
            let predicate = NSPredicate.init(format: "groupid == %@", argumentArray: [message.targetId])
            let r:RLMResults =  GroupModel.objects(with: predicate)
            if r.count != 0{
                
                let gModel:GroupModel = r.firstObject() as! GroupModel
                if gModel.parentid == self.targetId {
                    DispatchQueue.main.async {
                        self.showRedRemind(type: 1)
                    }
                    
                }
            }
        }
 
    }
}
//
//  CallAudioMultiCallViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 2018/1/15.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class CallAudioMultiCallViewController: RCCallAudioMultiCallViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        //自定义邀请按钮事件
        self.inviteUserButton.addTarget(self, action: #selector(self.inviteUserButtonClicked), for: .touchUpInside)
    }
    override func inviteUserButtonClicked() {
        let vc = SelectMemberViewController.init(conversationType: self.conversationType, targetId: self.targetId, mediaType: RCCallMediaType.audio, exist: [sharePublicDataSingle.publicData.im_userid], success: { [weak self](addUserIdList) in
            //邀请用户加入通话
            self?.callSession.inviteRemoteUsers(addUserIdList, mediaType: (self?.mediaType)!)
            
        })
        let predicate = NSPredicate.init(format: "groupid == %@ AND is_delete == '0'", argumentArray: [self.targetId])
        let groupUsers =  GroupUserModel.objects(with: predicate)
        
        vc?.listingUserIdList = groupUsers.value(forKeyPath: "im_userid") as! [Any]
        for userProfile in self.callSession.userProfileList {
            
            vc?.existUserIdList.append((userProfile as! RCCallUserProfile).userId)
        }
        self.present(vc!, animated: true, completion: nil)
    }
}
//
//  MineReviseVC.swift
//  SLAPP
//
//  Created by apple on 2018/4/28.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
import WebKit
class MineReviseVC: UIViewController,WKNavigationDelegate {
   
    var url:URL?
   
    lazy var web = { () -> WKWebView in
        let web  = WKWebView()
        return web
    }()
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.view.addSubview(web)
        web.mas_makeConstraints { (make) in
            make?.edges.equalTo()(self.view)
        }
        web.load(URLRequest.init(url: url!))
        web.navigationDelegate = self
        // Do any additional setup after loading the view.
    }
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        self.progressDismiss()
    }
    
    func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
        self.progressDismissWith(str: "出现错误")
    }
    
    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
        self.progressShow()
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
   
}
//
//  ChatContentSearchVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/4/27.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
typealias click = (_ mID:ChatContentModel)->()
class ChatContentSearchVC: BaseViewController {
    var clickCell:click?
    var table:UITableView?
    var dataArray:Array = Array<ChatContentModel>()
    var searchView:UISearchBar?
    var targetId:String?
    var isLoading:Bool?
    override func viewDidLoad() {
        super.viewDidLoad()
        self.configUI()
        
    }
    func configUI(){
        
      isLoading = false
      searchView = UISearchBar.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: NAV_HEIGHT))
      self.navigationItem.titleView = searchView
      searchView?.delegate = self as! UISearchBarDelegate
        
        
      table = UITableView.init(frame:CGRect(x: 0, y:NAV_HEIGHT, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT))
      self.view.addSubview(table!)
      table?.delegate = (self as UITableViewDelegate)
      table?.dataSource = (self as UITableViewDataSource)
      table?.tableFooterView = UIView()
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        searchView?.becomeFirstResponder()
    }
    
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        if (searchView?.isFirstResponder)! {
            searchView?.resignFirstResponder()
        }
    }
    
    func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
        if scrollView.contentOffset.y < (table?.contentSize.height)! && self.isLoading == true {
            self.searchMoreMessage()
        }
        
    }
    
    func searchMoreMessage(){
        
        let contentModel:ChatContentModel = self.dataArray[self.dataArray.count-1]
        let array = RCIMClient.shared().searchMessages(.ConversationType_GROUP, targetId: targetId!, keyword: self.searchView?.text, count: 50, startTime: contentModel.time!)
        if (array?.count)! < 50 {
            self.isLoading = false
        }
        else{
           self.isLoading = true
        }
        
        var resultArray = self.dataArray
        for m in array! {
            let message:RCMessage = m as RCMessage
            let contentModel:ChatContentModel = ChatContentModel()
            contentModel.otherInformation = RCKitUtility.formatMessage(message.content)
            contentModel.time = message.sentTime
            
            contentModel.messageID = m.messageId
            resultArray.append(contentModel)
 
        }
        
        self.dataArray = resultArray
        if self.dataArray.count == 0 {
            
        self.remindNoSearchContent()
        }
        else{
          table?.tableFooterView = UIView()
        }
        table?.reloadData()
    }
    
        func remindNoSearchContent(){
            let fView = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 50))
            
            let line = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 1))
            line.backgroundColor = UIColor.groupTableViewBackground
            fView.addSubview(line)
            
            
            let numberLable = UILabel.init(frame: CGRect.init(x: 0, y: 10, width: kScreenW, height: 30))
            numberLable.textAlignment = NSTextAlignment.center
            numberLable.font = UIFont.systemFont(ofSize: 14)
            
            numberLable.text = "无结果"
            fView.addSubview(numberLable)
            table?.tableFooterView = fView
        }
    func cellClick(cellClick:@escaping click){
       clickCell = cellClick
        
    }
    
    
    
    
    
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    
}
extension ChatContentSearchVC:UISearchBarDelegate{
    
    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
        
        guard !searchText.isEmpty else {
            dataArray.removeAll()
            table?.reloadData()
            return
        }
        
        let array:Array = RCIMClient.shared().searchMessages(.ConversationType_GROUP, targetId: self.targetId!, keyword: searchText, count: 50, startTime: 0)
        
        var resultArray:Array = Array<ChatContentModel>()
        for m in array {
            let message:RCMessage = m as RCMessage
            let contentModel:ChatContentModel = ChatContentModel()
            contentModel.otherInformation = RCKitUtility.formatMessage(message.content)
            contentModel.time = message.sentTime
            
            contentModel.messageID = m.messageId
            let predicate = NSPredicate.init(format: "groupid == %@ AND is_delete == '0' AND im_userid == %@", argumentArray: [self.targetId,message.senderUserId])
            let result = GroupUserModel.allObjects().objects(with: predicate)
            if result.count > 0 {
                let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", (result.firstObject() as! GroupUserModel).userid)).firstObject() as! UserModel?
                if  userModel?.avater != nil {
                    
                    contentModel.portraitUri = (userModel?.avater)!
                }
                if userModel?.realname != nil {
                    
                    contentModel.name = (userModel?.realname)!
                }
            }
            
            resultArray.append(contentModel)
            
            
        }
        dataArray = resultArray
        
        
       
        
//        [self refreshSearchView:searchText];
        if (self.dataArray.count < 50) {
            self.isLoading = false;
        }else{
            self.isLoading = true;
        }
        if self.dataArray.count == 0 {
            
            self.remindNoSearchContent()
        }
        else{
            table?.tableFooterView = UIView()
        }
        
        table?.reloadData()
        
        
    }
    
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        
    }
    
    
    
    
    
}
extension ChatContentSearchVC:UITableViewDelegate,UITableViewDataSource{
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 44
    }
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return dataArray.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cellIde = "cell"
        var cell:ChatContentCell? = tableView.dequeueReusableCell(withIdentifier: cellIde) as? ChatContentCell
        if cell == nil {
            cell = Bundle.main.loadNibNamed("ChatContentCell", owner: self, options: nil)?.last as? ChatContentCell
        }
        cell?.setModel(model: self.dataArray[indexPath.row])
        return cell!
        
        
    }
    
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let model  = self.dataArray[indexPath.row]
//        clickCell?(model)
        
        let talk = SmallTalkVC()
        talk.searchModel = model
        talk.conversationType = .ConversationType_GROUP
        talk.targetId = self.targetId
        talk.isSearch = true
        let unreadCount = RCIMClient.shared().getUnreadCount(.ConversationType_GROUP, targetId: self.targetId)
        talk.unReadMessage = Int(unreadCount)
        talk.enableNewComingMessageIcon = true
        talk.enableUnreadMessageIcon = true
        
       self.navigationController?.pushViewController(talk, animated: true)
        
    }
}
//
//  CallVideoMultiCallViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 2018/1/15.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class CallVideoMultiCallViewController: RCCallVideoMultiCallViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        //自定义邀请按钮事件
//        self.inviteUserButton.addTarget(self, action: #selector(self.inviteUserButtonClicked), for: .touchUpInside)
    }
    
    override func inviteUserButtonClicked() {
        let vc = SelectMemberViewController.init(conversationType: self.conversationType, targetId: self.targetId, mediaType: RCCallMediaType.video, exist: [sharePublicDataSingle.publicData.im_userid], success: { [weak self](addUserIdList) in
            //邀请用户加入通话
            self?.callSession.inviteRemoteUsers(addUserIdList, mediaType: (self?.mediaType)!)
            
        })
        let predicate = NSPredicate.init(format: "groupid == %@ AND is_delete == '0'", argumentArray: [self.targetId])
        let groupUsers =  GroupUserModel.objects(with: predicate)
        
        vc?.listingUserIdList = groupUsers.value(forKeyPath: "im_userid") as! [Any]
        for userProfile in self.callSession.userProfileList {
            
            vc?.existUserIdList.append((userProfile as! RCCallUserProfile).userId)
        }
        self.present(vc!, animated: true, completion: nil)
    }
}
//
//  SelectMemberViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 2018/1/15.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class SelectMemberViewController: RCCallSelectMemberViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
//        self.title = "选择联系人"
//        self.navigationItem.rightBarButtonItem = UIBarButtonItem.init(title: "确定", style: .plain, target: self, action: #selector(rightButtonClick))
        //融云页面样式问题修改
        for subView in self.view.subviews {
            if subView.isKind(of: UINavigationBar.self){
                subView.frame = CGRect.init(x: 0, y: 20, width: self.view.frame.size.width, height: 44)
                (subView as! UINavigationBar).isTranslucent = false
                (subView as! UINavigationBar).barTintColor = UIColor.hexString(hexString: "262e42")
            }
        }
    }
    
    @objc func rightButtonClick() {
        self.done()
    }
}
//
//  ThemeListVCViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/8.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
let cardView_height : CGFloat = 40.0
enum ThemeType {
    case unJoin
    case joined
}
class ThemeListVCViewController: RCConversationListViewController {
    
    fileprivate var themeType: ThemeType! = .joined
    var unJoinDataSource : NSMutableArray = [] //存有未参与的话题id
    var joinDataSource : NSMutableArray = [] //存有未参与的话题id
    var tabBarVc : TMTabbarController!
    var emptyBtn : UIButton! //空页面按钮
    var is_groupOwner : Bool?
    var is_search : Bool? //点击搜索按钮
    var getUnjoinDataFirst : Bool? //第一次加载未参与的
    var searchText_joined : String? = ""
    var searchText_unJoin : String? = ""
    var searchCoverView : UIView! //搜索时覆盖页面
    
    /// <#Description#>
    override func viewDidLoad() {
        super.viewDidLoad()
        
        is_search = false
        getUnjoinDataFirst = true
        
        tabBarVc = self.tabBarController as! TMTabbarController
        self.configNav()
        view.backgroundColor = UIColor.hexString(hexString: "EFEFF4")
        self.title = "话题列表"
        let groupModel = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",(self.tabBarVc.groupModel?.targetId)!)).firstObject() as! GroupModel?
        
        is_groupOwner = (groupModel?.owner_id)! == sharePublicDataSingle.publicData.userid as String
        cardView.creatBtnsWithTitles(titlesArr: ["已参与","未参与"])
        cardView.btnClickBlock = ({ (btn) in
            if (self.searchCoverView != nil) {
                self.searchCoverView.removeFromSuperview()
            }
            
            
            switch btn.tag {
            case 10:
                if self.themeType == .joined {
                    return
                }
                self.themeType = .joined
                if self.is_search! {
                    if (self.searchText_joined?.count)! > 0 {
                        self.searchView.text = self.searchText_joined
                    }else{
                        self.searchView.text = ""
                        self.searchView.resignFirstResponder()
                    }
                }
                
            case 11:
                if self.themeType == .unJoin {
                    return
                }
                self.themeType = .unJoin
                if self.is_search! {
                    if (self.searchText_unJoin?.count)! > 0{
                        self.searchView.text = self.searchText_unJoin
                    }else{
                        self.searchView.text = ""
                        self.searchView.resignFirstResponder()
                    }
                }
//                if self.getUnjoinDataFirst! {
//                    self.searchUnjoinData(keyword: self.searchView.text!, reloadSuccess: {
//
//                    }, reloadError: {
//
//                    })
//                }
                
            default:
                break
            }
            if self.is_search! {
                if (self.searchView.text?.count)! > 0 {
                    self.searchView.showsCancelButton = true
                }else{
                    self.searchView.showsCancelButton = false
                }
            }
            
            self.getThemeData(keyword: self.searchView.text ?? "")
//            self.refreshConversationTableViewIfNeeded()
        })
        self.view.addSubview(cardView)
        
        self.setDisplayConversationTypes([RCConversationType.ConversationType_GROUP.rawValue])
        self.showConnectingStatusOnNavigatorBar = true
        self.isShowNetworkIndicatorView = false
        self.conversationListTableView.tableFooterView = UIView.init()
        self.conversationListTableView.tag = 10086 //方便获取conversationListTableView
        self.conversationListTableView.frame = CGRect(x: 0, y: cardView.y + cardView.height, width: self.view.frame.width, height: MAIN_SCREEN_HEIGHT_PX - NAV_HEIGHT - cardView_height - 49)
        self.conversationListTableView.mj_header? = MJRefreshNormalHeader(refreshingTarget: self, refreshingAction:#selector(headerRefresh))
        self.conversationListTableView.separatorStyle = .none
        emptyBtn = UIButton.init()
        emptyBtn.addTarget(self, action: #selector(emptyBtnClick), for: .touchUpInside)
        emptyBtn.titleLabel?.font = FONT_14
        emptyBtn.setTitleColor(UIColor.lightGray, for: .normal)
        emptyBtn.titleLabel?.textAlignment = .center
        emptyBtn.titleLabel?.numberOfLines = 0
        
        self.emptyConversationView = emptyBtn
        
        
        self.view.bringSubviewToFront(cardView)
        //        self.reloadData(reloadSuccess: { [weak self] () in
        //            if let strongSelf = self{
        //                if strongSelf.joinedDataSource.count == 0 { //初始化应该显示的页面
        //                    if strongSelf.unJoinDataSource.count > 0 {
        //                        strongSelf.cardView.btnClick(btn: (strongSelf.cardView.viewWithTag(11) as? UIButton)!)
        //                    }
        //                }
        //
        //            }
        //        }, reloadError: {
        //
        //        })
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.makeNavigationRightBtn()
        
//        self.headerRefresh()
        
        self.getThemeData(keyword: "")
    }
    
    func makeNavigationRightBtn() {
        let rightBtn = UIButton.init(type: .system)
        rightBtn.frame =  CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight)
        
        let rightBtn2 = UIButton.init(type: .system)
        rightBtn2.frame =  CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight)
        
        rightBtn.setImage(UIImage.init(named: "nav_add"), for: .normal)
        rightBtn.addTarget(self, action: #selector(addBtnDidClick), for: .touchUpInside)
        
        rightBtn2.setImage(UIImage.init(named: "search_white"), for: .normal)
        rightBtn2.addTarget(self, action: #selector(searchBtnDidClick), for: .touchUpInside)
        
        rightBtn.sizeToFit()
        rightBtn2.sizeToFit()
        
        let rightBarButtonItem = UIBarButtonItem.init(customView: rightBtn)
        let rightBarButtonItem2 = UIBarButtonItem.init(customView: rightBtn2)
        let array = [rightBarButtonItem,rightBarButtonItem2]
        self.tabBarController?.navigationItem.rightBarButtonItems = array
    }
    //MARK: ------------ selector ------------
    //新建话题
    @objc func addBtnDidClick(button: UIButton) {
        self.creatOrEditSubject(subGroupid: "")
    }
    @objc func searchBtnDidClick(button: UIButton) {
        self.is_search = !self.is_search!
        if self.is_search! {
            self.view.addSubview(searchView)
            self.searchView.frame = CGRect(x: 0, y: NAV_HEIGHT + cardView_height, width: self.view.frame.width, height: searchView_height)
            self.conversationListTableView.frame = CGRect(x: 0, y: NAV_HEIGHT + cardView_height + searchView_height, width: self.view.frame.width, height: MAIN_SCREEN_HEIGHT_PX - NAV_HEIGHT  - cardView_height - searchView_height - 49)
        }else{
            if (self.searchCoverView != nil) {
                self.searchCoverView.removeFromSuperview()
            }
            searchView.removeFromSuperview()
            searchView.showsCancelButton = false
            searchView.text = ""
            if (self.searchText_joined?.count)! > 0{
                self.searchText_joined = ""
                self.refreshConversationTableViewIfNeeded()
            }
            if (self.searchText_unJoin?.count)! > 0{
                self.searchText_unJoin = ""
                searchUnjoinData(keyword: searchView.text!, reloadSuccess: {
                    self.refreshConversationTableViewIfNeeded()
                }, reloadError: {
                    
                })
            }
//            self.searchView.frame = CGRect(x: 0, y: NAV_HEIGHT, width: self.view.frame.width, height: cardView_height)
            self.conversationListTableView.frame = CGRect(x: 0, y: NAV_HEIGHT + cardView_height, width: self.view.frame.width, height: MAIN_SCREEN_HEIGHT_PX - NAV_HEIGHT  - cardView_height - 49)
        }
    }
    @objc func emptyBtnClick(button: UIButton) {
        self.creatOrEditSubject(subGroupid: "")
    }
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    func searchUnjoinData(keyword : String, reloadSuccess: (() -> ())!, reloadError: (() -> ())!) {
        
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        params["groupid"] = self.tabBarVc.groupModel?.targetId
        if keyword.count > 0 {
            params["keyword"] = keyword
        }
        params["is_join"] = 0 //未加入
        self.progressShow()
        GroupRequest.getSubjectList(params: params, hadToast: true, fail: { (fail) in
            self.progressDismiss()
            reloadError()
        }, success: { [weak self](success) in
            reloadSuccess()
            if let strongSelf = self {
                strongSelf.getUnjoinDataFirst = false
                strongSelf.progressDismiss()
                strongSelf.unJoinDataSource.removeAllObjects()
                if success["list"] != nil{
                    let arr = (success["list"] as! NSArray).value(forKeyPath: "groupid")
                    strongSelf.unJoinDataSource.addObjects(from: arr as! [Any])
                }
                strongSelf.refreshConversationTableViewIfNeeded()
            }
        })
        
    }
    
    
    func getThemeData(keyword : String) {
        
        var params = Dictionary<String, Any>()
        params["app_token"] = sharePublicDataSingle.token
        params["groupid"] = self.tabBarVc.groupModel?.targetId
        if keyword.count > 0 {
            params["keyword"] = keyword
        }
        
        params["is_join"] = 0 //未加入
        if self.themeType == .joined {
            params["is_join"] = 1 //未加入
        }
        
        self.progressShow()
        GroupRequest.getSubjectList(params: params, hadToast: true, fail: { (fail) in
            self.progressDismiss()
            
        }, success: { [weak self](success) in
            
            if let strongSelf = self {
                
                strongSelf.progressDismiss()
                
                
                
                let tmp : NSMutableArray = [] //
                
                if success["list"] != nil{
                    let arr = (success["list"] as! NSArray)
                    DataBaseOperation.addDataWithArray(rlmObjects: success["list"]as! Array<Any>, aClass: GroupModel.self)
                    for dic in arr {
                        let groupModel = GroupModel.init(value: dic)
                        tmp.add(groupModel)
                    }
                }
                
            
                if strongSelf.themeType == .joined {
                    strongSelf.joinDataSource.removeAllObjects()
                    strongSelf.joinDataSource = tmp
                }else {
                    strongSelf.unJoinDataSource.removeAllObjects()
                    strongSelf.unJoinDataSource = tmp
                }
                strongSelf.refreshConversationTableViewIfNeeded()
            }
        })
        
    }
    
    @objc func headerRefresh(){
        if themeType == .joined {
            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            var time:String? = (UserDefaults.standard.object(forKey: username) as! String?)
            
            if (time == nil ){
                time = "0"
            }
            self.progressShow()
            UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { [weak self] (error) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                    strongSelf.conversationListTableView.mj_header?.endRefreshing()
                }
                
                }, success: {[weak self] (dic) in
                    
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                        strongSelf.conversationListTableView.mj_header?.endRefreshing()
                        strongSelf.refreshConversationTableViewIfNeeded()
                    }
                }
            )
        }
        if themeType == .unJoin {
            
            searchUnjoinData(keyword: searchView.text!, reloadSuccess: { [weak self] () in
                if let strongSelf = self {
                    strongSelf.conversationListTableView.mj_header?.endRefreshing()
                }
                }, reloadError: { [weak self] () in
                    if let strongSelf = self {
                        strongSelf.conversationListTableView.mj_header?.endRefreshing()
                    }
            })
        }
    }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }
    //重写RCConversationListViewController的onSelectedTableRow事件
    override func onSelectedTableRow(_ conversationModelType: RCConversationModelType, conversationModel model: RCConversationModel!, at indexPath: IndexPath!) {
        if searchView.isFirstResponder {
            searchView.resignFirstResponder()
        }
        //打开会话界面
        self.conversationListTableView.deselectRow(at: indexPath, animated: false)
        if conversationModelType == RCConversationModelType.CONVERSATION_MODEL_TYPE_CUSTOMIZATION {
            
            if self.themeType == .joined {
                let talk = ThemeChatVC(conversationType: (model?.conversationType)!, targetId: model?.targetId)
                self.tabBarController?.navigationController?.pushViewController(talk!, animated: true)
            }else{
                self.joinGroupSubject(model: model, joinSuccess: {
                    
                    DispatchQueue.main.async {
                        let talk = ThemeChatVC(conversationType: .ConversationType_GROUP, targetId: model?.targetId)
                        self.tabBarController?.navigationController?.pushViewController(talk!, animated: true)
                    }
                    
                }, joinFail: {
                    
                })
            }
            
        }
    }
    
    override func willReloadTableData(_ dataSource: NSMutableArray!) -> NSMutableArray! {
        super.willReloadTableData(dataSource)
        
        dataSource.removeAllObjects()
        
        var tmp : NSMutableArray = [] //
        
        if self.themeType == .joined {
            tmp = self.joinDataSource
        }else {
            tmp = self.unJoinDataSource
        }
        
        for i in 0..<tmp.count {
            let groupModel : GroupModel? = (tmp[i] as! GroupModel)
            
            let model : RCConversationModel = RCConversationModel()
            model.targetId = groupModel?.groupid
            model.conversationModelType = RCConversationModelType.CONVERSATION_MODEL_TYPE_CUSTOMIZATION
            model.conversationTitle = groupModel?.group_name
            model.extend = groupModel?.icon_url
            model.sentTime = Int64((groupModel?.inputtime)!)!
            model.topCellBackgroundColor = UIColor.hexString(hexString: "DCDCDC")
            model.cellBackgroundColor = UIColor.white
            dataSource.add(model)
        }
        
//        if self.themeType == .joined {
//
//            var tempDelGroupModels = Array<RCConversationModel>()//应该移除的群组融云会话模型(非永久移除)
//            var tempDelSubGroupModels = Array<RCConversationModel>()//应该移除的话题会话模型(永久移除)
//            for i in 0..<dataSource.count {
//                let model : RCConversationModel = dataSource[i] as! RCConversationModel
//                let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",model.targetId)).firstObject() as! GroupModel?
//
//                //                let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@ AND is_delete == '0'", sharePublicDataSingle.publicData.userid,model.targetId)).firstObject() as! GroupUserModel?
//                // || self.unJoinDataSource.contains(model.targetId)
//                if groupModel == nil{
//                    tempDelSubGroupModels.append(model)
//                    continue
//                }
//                //                if is_search! {
//                //                    if (self.searchView.text?.count)! > 0 {
//                //                        if !(groupModel?.group_name.contains(self.searchView.text!))! {
//                //                            tempDelGroupModels.append(model)
//                //                            continue
//                //                        }
//                //                    }
//                //                }
//                //|| groupUserModel == nil 不考虑当前是不是在话题内(因为已经解散的还需保存会话)
//                if groupModel?.type == "0" || groupModel?.parentid != self.tabBarVc.groupModel?.targetId {
//
//                    tempDelGroupModels.append(model)
//                    continue
//                }
//                //                if groupModel?.type == "0" || groupModel?.parentid != self.tabBarVc.groupModel?.targetId || (self.joinedDataSource.count > 0 && !self.joinedDataSource.contains(model.targetId)){
//                //                    tempDelGroupModels.append(model)
//                //                    continue
//                //                }
//
//                model.conversationModelType = RCConversationModelType.CONVERSATION_MODEL_TYPE_CUSTOMIZATION
//                model.conversationTitle = groupModel?.group_name
//                model.extend = groupModel?.icon_url
//                model.sentTime = Int64((groupModel?.inputtime)!)!
//                model.topCellBackgroundColor = UIColor.hexString(hexString: "DCDCDC")
//                model.cellBackgroundColor = UIColor.white
//
//            }
//            for model in tempDelGroupModels {//移除数据库中不包含的会话
//                dataSource.remove(model)
//            }
//            for model in tempDelSubGroupModels {//移除数据库中不包含的会话
//                dataSource.remove(model)
//                RCIMClient.shared().clearMessages(model.conversationType, targetId: model.targetId)
//                RCIMClient.shared().remove(model.conversationType, targetId: model.targetId)
//            }
//
//        }
//        if self.themeType == .unJoin {
//            dataSource.removeAllObjects()
//            //            unJoinDataSource.sort(using: NSSortDescriptor.init(key: "inputtime", ascending: false))
//
//            unJoinDataSource.sort(
//                comparator: {
//                    (s1:Any!,s2:Any!)->ComparisonResult in
//                    let groupModel1 : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",s1 as! String)).firstObject() as! GroupModel?
//                    let groupModel2 : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",s2 as! String)).firstObject() as! GroupModel?
//
//                    if (groupModel1?.inputtime)! < (groupModel2?.inputtime)!{
//                        return .orderedDescending
//                    }else{
//                        return .orderedAscending
//                    }
//
//            })    //按创建时间降序排序
//            for i in 0..<unJoinDataSource.count {
//                let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",unJoinDataSource[i] as! String)).firstObject() as! GroupModel?
//                let model : RCConversationModel = RCConversationModel.init()
//                model.targetId = groupModel?.groupid
//                model.conversationModelType = RCConversationModelType.CONVERSATION_MODEL_TYPE_CUSTOMIZATION
//                model.conversationTitle = groupModel?.group_name
//                model.extend = groupModel?.icon_url
//                model.sentTime = Int64((groupModel?.inputtime)!)!
//                model.topCellBackgroundColor = UIColor.hexString(hexString: "DCDCDC")
//                model.cellBackgroundColor = UIColor.white
//                dataSource.add(model)
//            }
//        }
        DispatchQueue.main.async {
            self.emptyBtn.setTitle("您暂无话题\n赶紧创建一个话题吧~", for: .normal)
            self.emptyBtn.sizeToFit()
            self.emptyBtn.center = self.conversationListTableView.center
        }
        
        self.conversationListDataSource = dataSource
        if self.is_search! {
            if (self.searchView.text?.count)! > 0 {
                
                self.conversationListDataSource.filter(using: NSPredicate.init(format:"conversationTitle contains %@",self.searchView.text!))
            }
            DispatchQueue.main.async {
                self.showRemind()
            }
        }else{
            DispatchQueue.main.async {
                self.conversationListTableView.tableFooterView = UIView.init()
                self.emptyConversationView = self.emptyBtn
            }
        }
        return dataSource
    }
    override func rcConversationListTableView(_ tableView: UITableView!, heightForRowAt indexPath: IndexPath!) -> CGFloat {
        if indexPath.row < self.conversationListDataSource.count {
            if themeType == .joined {
                return 64 + 50
            }
            if themeType == .unJoin {
                return 64 + 10
            }
            return 64 + 50
        }
        return 0
    }
    override func rcConversationListTableView(_ tableView: UITableView!, cellForRowAt indexPath: IndexPath!) -> RCConversationBaseCell! {
        
        if indexPath.row < self.conversationListDataSource.count {
            var cell : ThemeListBaseCell?
            let model : RCConversationModel = self.conversationListDataSource![indexPath.row] as! RCConversationModel
            
//            var groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@ AND type == '1'",model.targetId)).firstObject() as! GroupModel?
            
            var groupModel: GroupModel?
            if self.themeType == .joined {
                groupModel = (self.joinDataSource[indexPath.row] as! GroupModel)
            }else {
                groupModel = (self.unJoinDataSource[indexPath.row] as! GroupModel)
            }
            let is_themeOwner = (groupModel?.owner_id)! == sharePublicDataSingle.publicData.userid as String
            
            if themeType == .joined {
                cell = ThemeJoinedListCell.cell(withTableView: tableView)
            }
            if themeType == .unJoin {
                cell = ThemeListBaseCell.cell(withTableView: tableView)
            }
            
            cell?.btnClickBlock = ({ (btn) in
                switch btn.titleLabel?.text! {
                case "置顶"?:
                    RCIMClient.shared().setConversationToTop(model.conversationType, targetId: model.targetId, isTop: true)
                    self.refreshConversationTableViewIfNeeded()
                case "取消置顶"?:
                    RCIMClient.shared().setConversationToTop(model.conversationType, targetId: model.targetId, isTop: false)
                    self.refreshConversationTableViewIfNeeded()
                case "转推"?:
                    if groupModel?.is_delete == "1" {//已经解散的话题
                        self.view.makeToast("该话题已被解散,无法转推", duration: 1.0, position: CSToastPositionCenter)
                        break
                    }
                    let vc = ThemeRetweetVC()
                    vc.thisThemeId = model.targetId
                    self.tabBarVc.navigationController?.pushViewController(vc, animated: true)
                case "编辑"?:
                    if groupModel?.is_delete == "1" {//已经解散的话题
                        self.view.makeToast("该话题已被解散,无法编辑", duration: 1.0, position: CSToastPositionCenter)
                        break
                    }
                    self.creatOrEditSubject(subGroupid: model.targetId)
                case "解散"?:
                    if groupModel?.is_delete == "1" {//已经解散的话题
                        self.addAlertView(title: "温馨提示", message: "该话题已被解散,您确定要删除该会话?", actionTitles: ["确定","取消"], okAction: { (action) in
                            RCIMClient.shared().clearMessages(.ConversationType_GROUP, targetId: model.targetId)
                            RCIMClient.shared().remove(.ConversationType_GROUP, targetId: model.targetId)
                            self.refreshConversationTableViewIfNeeded()
                            
                        }, cancleAction: { (action) in
                            
                        })
                        
                        break
                    }
                    
                    self.quitGroupSubject(title: "解散", message: "解散该话题讨论后，其他人也将无法查看话题内容",sub_groupid: model.targetId)
                case "退出"?:
                    print("退出")
                    self.quitGroupSubject(title: "退出", message:"退出话题后，将无法收到该话题群的消息",sub_groupid: model.targetId)
                    
                case "结束辅导"?:
                    self.quitGroupSubject(title: "结束辅导", message:"结束辅导后，导师将不再进行辅导，您确认要结束辅导吗？",sub_groupid: model.targetId)
                default:
                    break
                }
                //                self.conversationListDataSource.removeAllObjects()
                //                self.refreshConversationTableViewIfNeeded()
            })
            cell?.setDataModel(self.conversationListDataSource![indexPath.row] as! RCConversationModel)
            var bottomTitleList = [[(model.isTop ? "取消置顶" : "置顶"),"theme_setTop"],["转推","theme_transmit"],["退出","theme_quit"]]
            if is_groupOwner! && !is_themeOwner{
                bottomTitleList = [[(model.isTop ? "取消置顶" : "置顶"),"theme_setTop"],["转推","theme_transmit"],["解散","theme_dismiss"],["退出","theme_quit"]]
            }else if is_themeOwner{
                bottomTitleList = [[(model.isTop ? "取消置顶" : "置顶"),"theme_setTop"],["转推","theme_transmit"],["编辑","theme_edit"],["解散","theme_dismiss"]]
            }else{
                bottomTitleList = [[(model.isTop ? "取消置顶" : "置顶"),"theme_setTop"],["转推","theme_transmit"],["退出","theme_quit"]]
            }
            
            if groupModel?.is_consult == 1 {
//                print("groupModel?.consult_info?.consult_status :\(groupModel?.consult_info?.consult_status)")
//                if groupModel?.consult_info?.consult_status == "5" {
//                    bottomTitleList.append(["结束辅导",""])
//                }else if groupModel?.consult_info?.consult_status == "6"{
//                    bottomTitleList.append(["已结束",""])
//                }else if groupModel?.consult_info?.consult_status == "4"{
//                    bottomTitleList.append(["取消",""])
//                }
            }
            cell?.bottomTitleImgs = bottomTitleList
            return cell
        }
        return nil
    }
    override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        return false
    }
    override func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
        
    }
    override func didReceiveMessageNotification(_ notification: Notification!) {
        let message : RCMessage = notification.object as! RCMessage
        
        if message.conversationType == .ConversationType_PRIVATE {
            let pri = PrivateUserModel()
            pri.id = message.targetId
            DataBaseOperation.addData(rlmObject: pri)
        }
        
        print("groupid == " + message.targetId)
        if message.objectName == RCGroupNotificationMessageIdentifier {//群组通知类消息
            
            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            let time = UserDefaults.standard.object(forKey: username) as! String
            
            UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { (error) in
                //                print(error)
            }, success: {[weak self] (dic) in
                
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                    
                    let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",message.targetId)).firstObject() as! GroupModel?
                    if groupModel != nil {
                        let groupUserModel : GroupUserModel? = GroupUserModel.objects(with: NSPredicate(format:"userid == %@ AND groupid == %@", sharePublicDataSingle.publicData.userid,(groupModel?.groupid)!)).firstObject() as! GroupUserModel?
                        if groupModel?.is_delete == "1" || groupUserModel?.is_delete == "1"{
                            RCIMClient.shared().setConversationToTop(.ConversationType_GROUP, targetId: message.targetId, isTop: false)
                        }
                    }
                    
                    strongSelf.refreshConversationTableViewIfNeeded()
                    
                }
                }
            )
        }else{
            //            if self.navigationController?.topViewController is GroupListViewController{
            let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",message.targetId)).firstObject() as! GroupModel?
            if groupModel != nil { //数据库中没有更新下来的会话暂时不需要显示
                self.refreshConversationTableViewIfNeeded()
            }
            
            //            }
        }
        
    }
    //创建或编辑话题
    func creatOrEditSubject(subGroupid:String?) {
        let vc = ThemeCreatVC()
        if (subGroupid?.count)! > 0{
            vc.subGroupid = subGroupid
        }
        vc.groupid = self.tabBarVc.groupModel?.targetId
        vc.creatThemeSuccessBlock = ({ (themeid) in
            RCIMClient.shared().getRemoteHistoryMessages(.ConversationType_GROUP, targetId: themeid!, recordTime: 0, count: 20, success: { [weak self] (array,success) in
                DispatchQueue.main.async {
                    let talk = ThemeChatVC(conversationType: .ConversationType_GROUP, targetId: themeid)
                    self?.tabBarController?.navigationController?.pushViewController(talk!, animated: true)
                }
                }, error: { (errorCode) in
                    
            })
            
            self.refreshConversationTableViewIfNeeded()
        })
        self.tabBarVc.navigationController?.pushViewController(vc, animated: false)
    }
    func joinGroupSubject(model: RCConversationModel,joinSuccess: (() -> ())!, joinFail: (() -> ())!) {
        self.progressShow()
        GroupRequest.joinGroupSubject(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":model.targetId!], hadToast: true, fail: { [weak self] (fail) in
            if let strongSelf = self {
                strongSelf.progressDismiss()
                joinFail()
            }
            
            }, success: { (dic) in
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                
                if time == nil{
                    time = "0"
                }
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                    }, success: {[weak self] (dic) in
                        if let strongSelf = self {
                            strongSelf.progressDismiss()
                            strongSelf.unJoinDataSource.remove(model.targetId)
                            strongSelf.cardView.btnClick(btn: (self?.cardView.viewWithTag(10) as? UIButton)!)
                            strongSelf.refreshConversationTableViewIfNeeded()
                            joinSuccess()
                            
                        }
                    }
                )
                
        })
    }
    //解散或退出话题
    func quitGroupSubject(title: String?, message: String?, sub_groupid: String?) {
        self.addAlertView(title: "", message: message!, actionTitles: ["确定","取消"], okAction: { (action) in
            self.progressShow()
            switch title! {
            case "解散":
                GroupRequest.dismissGroupSubject(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":sub_groupid!], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self{
                        strongSelf.progressDismiss()
                    }
                    }, success: { [weak self](dic) in
                        if let strongSelf = self{
                            strongSelf.progressDismiss()
                            let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",sub_groupid!)).firstObject() as! GroupModel?
                            
                            let realm:RLMRealm = RLMRealm.default()
                            realm.beginWriteTransaction()
                            groupModel?.setValue("1", forKey: "is_delete")
                            try? realm.commitWriteTransaction()
                            
                            //                        RCIMClient.shared().clearMessages(.ConversationType_GROUP, targetId: sub_groupid)
                            //                        RCIMClient.shared().remove(.ConversationType_GROUP, targetId: sub_groupid)
//                            strongSelf.refreshConversationTableViewIfNeeded()
                            
                            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                            var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                            
                            if time == nil{
                                time = "0"
                            }
                            UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                                if let strongSelf = self {
                                    strongSelf.progressDismiss()
                                }
                                }, success: { [weak self] (dic) in
                                    if let strongSelf = self{
                                        strongSelf.progressDismiss()
                                        RCIMClient.shared().clearMessages(.ConversationType_GROUP, targetId: sub_groupid)
                                        RCIMClient.shared().remove(.ConversationType_GROUP, targetId: sub_groupid)
                                        let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",sub_groupid!)).firstObject() as! GroupModel?
                                        if groupModel?.is_delete == "1" {//已经解散了不要添加到未参与列表里
                                        }else{
                                            if !strongSelf.unJoinDataSource.contains(sub_groupid!) {
                                                strongSelf.unJoinDataSource.insert(sub_groupid!, at: 0)
                                            }
                                        }
                                        
                                        strongSelf.refreshConversationTableViewIfNeeded()
                                    }
                                }
                            )
                        }
                })
            case "退出":
                GroupRequest.quitGroupSubject(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":sub_groupid!], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self{
                        strongSelf.progressDismiss()
                    }
                    }, success: { (dic) in
                        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                        var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                        
                        if time == nil{
                            time = "0"
                        }
                        UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                            if let strongSelf = self {
                                strongSelf.progressDismiss()
                            }
                            }, success: { [weak self] (dic) in
                                if let strongSelf = self{
                                    strongSelf.progressDismiss()
                                    RCIMClient.shared().clearMessages(.ConversationType_GROUP, targetId: sub_groupid)
                                    RCIMClient.shared().remove(.ConversationType_GROUP, targetId: sub_groupid)
                                    let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",sub_groupid!)).firstObject() as! GroupModel?
                                    if groupModel?.is_delete == "1" {//已经解散了不要添加到未参与列表里
                                    }else{
                                        if !strongSelf.unJoinDataSource.contains(sub_groupid!) {
                                            strongSelf.unJoinDataSource.insert(sub_groupid!, at: 0)
                                        }
                                    }
                                    
                                    strongSelf.refreshConversationTableViewIfNeeded()
                                }
                            }
                        )
                        
                })
                
            case "结束辅导" :
                GroupRequest.finishOnlineConsult(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":sub_groupid!], hadToast: true, fail: { [weak self](error) in
                    if let strongSelf = self{
                        strongSelf.progressDismiss()
                    }
                    }, success: { (dic) in
                        print(dic)
                        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                        var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                        
                        if time == nil{
                            time = "0"
                        }
                        UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                            if let strongSelf = self {
                                strongSelf.progressDismiss()
                            }
                            }, success: { [weak self] (dic) in
                                print(dic)
                                self?.conversationListTableView.reloadData()
                            }
                        )
                        
                })
                
            default:
                break
            }
            
            
        }, cancleAction: { (action) in
            
        })
        
    }
    /// 提醒个数
    func showRemind(){
        
        let fView = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 50))
        
        let line = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 1))
        line.backgroundColor = UIColor.groupTableViewBackground
        fView.addSubview(line)
        
        let numberLable = UILabel.init(frame: CGRect.init(x: 0, y: 10, width: kScreenW, height: 30))
        numberLable.textAlignment = NSTextAlignment.center
        numberLable.font = UIFont.systemFont(ofSize: 14)
        
        numberLable.text = "没有查找到相关的话题"
        fView.addSubview(numberLable)
        
        if self.conversationListDataSource.count == 0 && (self.searchView.text?.count)! > 0{
            conversationListTableView.tableFooterView = fView
            self.emptyConversationView = UIView.init()
        }else{
            conversationListTableView.tableFooterView = UIView.init()
            self.emptyConversationView = self.emptyBtn
        }
        
    }
    
    //MARK: - Getter and Setter
    lazy var cardView : CardView  = {
        let cardView = CardView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT+cardView_height, width: self.view.frame.size.width, height: cardView_height))
        return cardView
    }()
    
    lazy var searchView: UISearchBar = {
        let searchView = UISearchBar.init(frame: CGRect.init(x: 0, y: cardView.y + cardView_height, width: kScreenW, height: 50))
        searchView.setBackgroundImage(UIImage.init(named: "backGray")!, for: .any, barMetrics: .default)
        searchView.delegate = self
        searchView.placeholder = "搜索"
        return searchView
    }()
}
extension ThemeListVCViewController:UISearchBarDelegate{
    func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
        searchView.showsCancelButton = true
        if (self.searchCoverView != nil) {
            self.searchCoverView.removeFromSuperview()
        }
        self.searchCoverView = UIView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT + cardView_height + searchView_height, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX - (NAV_HEIGHT + cardView_height + searchView_height)))
        self.searchCoverView.backgroundColor = UIColor.white
        let numberLable = UILabel.init(frame: CGRect.init(x: 0, y: 10, width: kScreenW, height: 30))
        numberLable.textAlignment = NSTextAlignment.center
        numberLable.font = UIFont.systemFont(ofSize: 14)
        numberLable.text = "搜索相关内容"
        self.searchCoverView.addSubview(numberLable)
        self.view.addSubview(self.searchCoverView)
        self.view.bringSubviewToFront(self.searchCoverView)
    }
    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
        if (self.searchCoverView != nil) {
            self.searchCoverView.removeFromSuperview()
        }
        searchView.showsCancelButton = false
        searchView.text = ""
        if themeType == .joined {
            self.searchText_joined = searchView.text
            self.refreshConversationTableViewIfNeeded()
        }
        if themeType == .unJoin {
            self.searchText_unJoin = searchView.text
            searchUnjoinData(keyword: searchView.text!, reloadSuccess: {
                self.refreshConversationTableViewIfNeeded()
            }, reloadError: {
                
            })
            
        }
        searchBar.resignFirstResponder()
        conversationListTableView.tableFooterView = UIView.init()
        self.emptyConversationView = self.emptyBtn
    }
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        if (self.searchCoverView != nil) {
            self.searchCoverView.removeFromSuperview()
        }
        searchBar.resignFirstResponder()
        if themeType == .joined {
            self.searchText_joined = searchView.text
            //            self.conversationListDataSource.filter(using: NSPredicate.init(format:"conversationTitle contains %@",searchView.text!))
            //            self.conversationListTableView.reloadData()
            self.refreshConversationTableViewIfNeeded()
        }
        if themeType == .unJoin {
            self.searchText_unJoin = searchView.text
            searchUnjoinData(keyword: searchView.text!, reloadSuccess: {
                
            }, reloadError: { 
                
            })
        }
        
    }
    
}
extension ThemeListVCViewController{
    func addAlertView(title:String, message:String, actionTitles:Array<String>,okAction: ((UIAlertAction) -> Void)?, cancleAction: ((UIAlertAction) -> Void)?) {
        let alertController = UIAlertController.init(title: title, message: message, preferredStyle: .alert)
        for (index,actionTitle) in actionTitles.enumerated() {
            if index == 0 {
                alertController.addAction(UIAlertAction.init(title: actionTitle, style: .default, handler: { (action) in
                    okAction!(action)
                }))
            }
            if index > 0 && index == actionTitles.count - 1 {
                alertController.addAction(UIAlertAction.init(title: actionTitle, style: .cancel, handler: { (action) in
                    cancleAction!(action)
                }))
            }
        }
        self.present(alertController, animated: true, completion: nil)
    }
}
//
//  ThemeRetweetVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/6/23.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ThemeRetweetVC: BaseViewController {
    var thisGroupId = ""
    var thisThemeId:String = ""{
        didSet{
            self.getGroupId(themeId: thisThemeId)
        }
    }
    let nMessage = ThemeMessageContent()
    
    var titleFileList = Array<Dictionary<String, Any>>.init()
    
    func getGroupId(themeId:String) {
//        self.progressShow()
        GroupRequest.getGroupSubjectInfo(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":themeId], hadToast: true, fail: { [weak self](error) in
            if let strongSelf = self {
                strongSelf.progressDismissWith(str: "获取话题信息失败")
            }
            
            }, success: { [weak self](dic) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                    strongSelf.thisGroupId = dic["parentid"] as! String
                    strongSelf.nMessage.content = dic["group_name"] as! String
                    strongSelf.nMessage.extra = ""
                    strongSelf.nMessage.imageURL = ""
                    strongSelf.nMessage.thumbnailUrl = ""
                    strongSelf.nMessage.url = ""
                    strongSelf.nMessage.groupId = dic["parentid"] as! String
                    strongSelf.nMessage.themeId = dic["groupid"] as! String
                    self?.titleFileList = dic["titleFileList"] as! Array<Dictionary<String, Any>>
                }
        })
    }
    
    var localGroupContainAll :Bool = true //默认选择本群
    var otherGroupCount : Int = 0
    var localGroupContainNone :Bool = false //本群不包含内容
    var localGroupContainSome :Bool = false //本群包含部分内容
    var otherGroupContainNone :Bool = false //其他群不包含内容
    var otherGroupContain :Bool = false
    var otherGroupContainAll :Bool = false //其他群包含所有内容
    var otherGroupContainSome :Bool = false //其他群包含部分内容
    override func viewDidLoad() {
        super.viewDidLoad()
        self.title = "转推"
        self.setRightBtnWithArray(items: ["确定"])
        self.view.addSubview(tableView)
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    override func rightBtnClick(button: UIButton) {
        
        if !localGroupContainAll && !otherGroupContainNone && !otherGroupContainAll && !otherGroupContainSome {
            self.view.makeToast("请选择转推类型", duration: 1.0, position: CSToastPositionCenter)
            return
        }
        if self.thisGroupId == ""{
            self.progressShow()
            GroupRequest.getGroupSubjectInfo(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":self.thisThemeId], hadToast: true, fail: { [weak self](error) in
                if let strongSelf = self {
                    strongSelf.progressDismissWith(str: "获取话题信息失败")
                }
                }, success: { [weak self](dic) in
                    if let strongSelf = self {
                        if strongSelf.otherGroupCount > 0{
                            strongSelf.progressDismiss()
                        }
                        strongSelf.thisGroupId = dic["parentid"] as! String
                        strongSelf.nMessage.content = dic["group_name"] as! String
                        strongSelf.nMessage.extra = ""
                        strongSelf.nMessage.imageURL = ""
                        strongSelf.nMessage.thumbnailUrl = ""
                        strongSelf.nMessage.url = ""
                        strongSelf.nMessage.groupId = dic["parentid"] as! String
                        strongSelf.nMessage.themeId = dic["groupid"] as! String
                        self?.titleFileList = dic["titleFileList"] as! Array<Dictionary<String, Any>>
                        strongSelf.rightBtnClick(button: button)
                    }
            })
            return
        }
        if localGroupContainAll { //本群包含所有内容
            var tempMesArr : Array<Any>? = []
            let sendTime : Int64? = Int64(Date().timeIntervalSince1970) * 1000
            let hisMesArr = RCIMClient.shared().getHistoryMessages(RCConversationType.ConversationType_GROUP, targetId: self.thisThemeId, sentTime: sendTime!, beforeCount: 100, afterCount: 0)
            if (hisMesArr?.count)! > 0 {
                for i in 0..<(hisMesArr?.count)! {
                    //                    RCMessageModel.init(message: nemodel as! RCMessage)
                    if (tempMesArr?.count)! == 2 {
                        break
                    }
                    if (hisMesArr?[i] as! RCMessage).objectName == RCTextMessageTypeIdentifier {
                        tempMesArr?.append(hisMesArr?[i])
                    }else{
                    
                    }
                }
            }
            for i in 0..<(tempMesArr?.count)! {
                let groupUserModel = GroupUserModel.objects(with: NSPredicate.init(format:"im_userid == %@", (tempMesArr?[i] as! RCMessage).senderUserId)).firstObject() as? GroupUserModel
                let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", groupUserModel?.userid != nil ? (groupUserModel?.userid)! : "")).firstObject() as! UserModel?
                if i == 0 {
                    nMessage.extra = (userModel?.realname.appendingFormat(":%@", ((tempMesArr?[i] as! RCMessage).content as! RCTextMessage).conversationDigest()))!
                }else{
                    nMessage.extra = nMessage.extra.appendingFormat("\n%@:%@", userModel?.realname != nil ? (userModel?.realname)! : "",((tempMesArr?[i] as! RCMessage).content as! RCTextMessage).conversationDigest())
                }
            }
            
            let Tab:TMTabbarController = self.navigationController?.children[1] as! TMTabbarController
            let smak:SmallTalkVC = Tab.viewControllers?.first as! SmallTalkVC
            smak.isRunApi = false
            smak.sendMessage(nMessage, pushContent: PublicDataSingle.makePushContent(nMessage, groupId: smak.targetId))
            self.navigationController?.view.makeToast("转推成功", duration: 1.0, position: CSToastPositionCenter)
            self.navigationController?.popViewController(animated: true)
        }
        if otherGroupCount > 0{ //其他群
            switch true {
            case otherGroupContainNone:
                let aaa = SelectMyGroup()
                aaa.targetId = self.thisGroupId  //当前所在群组的groupid
                aaa.message = self.nMessage
                aaa.iszhuanfa = false
                aaa.finishSelect = {
                    sGroupList,otherText in
                    let failArr : Array<GroupModel> = []
//                    self.progressShow()
                    self.navigationController?.view.makeToastActivity(CSToastPositionCenter)
                    self.creatTheme(from:0,sGroupList: sGroupList as? Array<GroupModel>,failArr:failArr, otherText: otherText, bbb: nil)
                   
                }
                self.navigationController?.pushViewController(aaa, animated: true)
                break
            case otherGroupContainAll:
                let aaa = SelectMyGroup()
                aaa.targetId = self.thisGroupId  //当前所在群组的groupid
                aaa.message = self.nMessage
                aaa.iszhuanfa = false
                aaa.finishSelect = {
                    sGroupList,otherText in
                    DispatchQueue.main.async {
                        
//                        self.progressShow()
                         self.navigationController?.view.makeToastActivity(CSToastPositionCenter)
                        GroupRequest.forwardGroupSubject(params: ["app_token":sharePublicDataSingle.token,"groupid":self.thisThemeId,"msg_uid_str":"","is_all":true], hadToast: true, fail: { [weak self](errorDic) in
                            if let strongSelf = self{
                                strongSelf.progressDismiss()
                                strongSelf.navigationController?.view.hideToastActivity()
                                print(errorDic)
                            }
                            }, success: { [weak self](succDic) in
                                if let strongSelf = self{
                                    let bbb = HistoryMessageContent.init()
                                    bbb.title = succDic["title"] as! String
                                    bbb.content = succDic["content"] as! String
                                    bbb.url = succDic["forwardUrl"] as! String
                                    DispatchQueue.main.async {
                                    
                                    let failArr : Array<GroupModel> = []
                                    strongSelf.creatTheme(from:0,sGroupList: sGroupList as? Array<GroupModel>,failArr:failArr, otherText: otherText, bbb: bbb)
                                    }
                                }
                                
                        })
                    }
//                     self.creatTheme(sGroupList: sGroupList as? Array<GroupModel>, otherText: otherText, bbb: nil)
                }
                self.navigationController?.pushViewController(aaa, animated: true)
                break
            case otherGroupContainSome:
                
                let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: self.thisThemeId)
                talk?.isZhuantui = true
                self.navigationController?.pushViewController(talk!, animated: true)
                talk?.finishSelect = { (chooseList) in
                    
                    let aaa = SelectMyGroup()
                    aaa.targetId = self.thisGroupId  //当前所在群组的groupid
                    aaa.message = self.nMessage
                    aaa.iszhuanfa = false
                    aaa.finishSelect = {
                        sGroupList,otherText in
                        
                        var msg_uid_str: String? = ""
                        if chooseList.count > 0 {
                            msg_uid_str = (chooseList as NSArray).componentsJoined(by: ",")
                        }
//                        self.progressShow()
                        self.navigationController?.view.makeToastActivity(CSToastPositionCenter)
                        GroupRequest.forwardGroupSubject(params: ["app_token":sharePublicDataSingle.token,"groupid":self.thisThemeId,"msg_uid_str":msg_uid_str!,"is_all":false], hadToast: true, fail: { [weak self](errorDic) in
                            if let strongSelf = self{
                                strongSelf.progressDismiss()
                                strongSelf.navigationController?.view.hideToastActivity()
                                print(errorDic)
                            }
                        }, success: { [weak self](succDic) in
                            if let strongSelf = self{
                                
                                let bbb = HistoryMessageContent.init()
                                bbb.title = succDic["title"] as! String
                                bbb.content = succDic["content"] as! String
                                bbb.url = succDic["forwardUrl"] as! String
                                let failArr : Array<GroupModel> = []
                                strongSelf.creatTheme(from:0,sGroupList: sGroupList as? Array<GroupModel>,failArr:failArr, otherText: otherText, bbb: bbb)
                                
                            }
                        })
                    }
                    self.navigationController?.pushViewController(aaa, animated: true)
                    
                }
                
                break
            default:
                break
            }
        }
    }
    func creatTheme(from:Int,sGroupList: Array<GroupModel>?,failArr: Array<GroupModel>,otherText:String?,bbb:HistoryMessageContent?){
        var failArrTemp = failArr
        if sGroupList?.count == from{
            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            var time:String? = UserDefaults.standard.object(forKey: username) as! String?
            print(failArr)
            if time == nil{
                time = "0"
            }
            UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                    strongSelf.navigationController?.view.makeToast("转推失败", duration: 1.0, position: CSToastPositionCenter)
                }
                }, success: {[weak self] (dic) in
                    if let strongSelf = self {
                        DispatchQueue.main.async {
                            strongSelf.progressDismiss()
                            strongSelf.navigationController?.view.hideToastActivity()
                            if (failArr.count) > 0{
                                let alert = UIAlertController(title: "温馨提示", message: "群组:".appending(((failArr as! NSArray).value(forKeyPath: "group_name") as! NSArray).componentsJoined(by: "\n")).appending("此话题已存在，您可直接参与讨论。"), preferredStyle: .alert)
                                let okAction = UIAlertAction(title: "我知道了", style: .default, handler: { action in
                                    var reweetVc : ThemeRetweetVC? = nil
                                    for vc in (strongSelf.navigationController?.children)!{
                                        if vc is ThemeRetweetVC {
                                            reweetVc = vc as? ThemeRetweetVC
                                        }
                                    }
                                    strongSelf.navigationController?.popToViewController(reweetVc!, animated: false)
                                    reweetVc?.navigationController?.popViewController(animated: true)
                                    
                                })
                                alert.addAction(okAction)
                                strongSelf.present(alert, animated: true, completion: nil)
                            }else{
                                strongSelf.navigationController?.view.makeToast("转推成功", duration: 1.0, position: CSToastPositionCenter)
                                var reweetVc : ThemeRetweetVC? = nil
                                for vc in (strongSelf.navigationController?.children)!{
                                    if vc is ThemeRetweetVC {
                                        reweetVc = vc as? ThemeRetweetVC
                                    }
                                }
                                strongSelf.navigationController?.popToViewController(reweetVc!, animated: false)
                                reweetVc?.navigationController?.popViewController(animated: true)
                            }
                        }
                    }
                }
            )
            return
        }
        
        let gModel = sGroupList?[from]
        
        DispatchQueue.main.async {
            var params : Dictionary<String, Any> = [:]
            params = ["app_token":sharePublicDataSingle.token,"groupid":gModel?.groupid,"title":self.nMessage.content,"file_json":SignTool.makeJsonStrWith(object: self.titleFileList)]
            GroupRequest.createGroupSubject(params: params, hadToast: false, fail: { [weak self] (fail) in
                if let strongSelf = self {
                    failArrTemp.append(gModel!)
                    strongSelf.creatTheme(from:from+1,sGroupList: sGroupList,failArr:failArrTemp, otherText: otherText, bbb: bbb != nil ? bbb! : nil)
                    
                }
            }) { [weak self](success) in
                print("创建话题成功",success)
                if let strongSelf = self {
                    let themeid : String? = String.changeToString(inValue: success["subGroupId"])
                    let newMess = strongSelf.nMessage
                    newMess.groupId = (gModel?.groupid)!
                    newMess.themeId = String.changeToString(inValue: success["subGroupId"])
                    strongSelf.sendMessageToOtherGroup(themeid: themeid!, gModel: gModel, otherText: otherText != "" ? otherText! : "", newMess: newMess, bbb:bbb != nil ? bbb! : nil)
                    
                    strongSelf.creatTheme(from:from+1,sGroupList: sGroupList,failArr:failArrTemp, otherText: otherText, bbb: bbb != nil ? bbb! : nil)
                    
                }
                
            }
        
        }
    }
    func creatTheme(sGroupList: Array<GroupModel>?,otherText:String?,bbb:HistoryMessageContent?){
        var num : Int? = 0
        var failArr : Array<GroupModel>? = []
//        self.progressShow()
        for sGroupOne in sGroupList! {
            let gModel = sGroupOne 
            var params : Dictionary<String, Any> = [:]
            params = ["app_token":sharePublicDataSingle.token,"groupid":gModel.groupid,"title":self.nMessage.content,"file_json":SignTool.makeJsonStrWith(object: self.titleFileList)]
            GroupRequest.createGroupSubject(params: params, hadToast: false, fail: { [weak self] (fail) in
                if let strongSelf = self {
                    num = num! + 1
                    failArr?.append(gModel)
                    if num == (sGroupList?.count)!{
                        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                        var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                        print(failArr!)
                        if time == nil{
                            time = "0"
                        }
                        UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                            if let strongSelf = self {
                                strongSelf.progressDismiss()
                                strongSelf.navigationController?.view.makeToast("转推失败", duration: 1.0, position: CSToastPositionCenter)
                            }
                            }, success: {[weak self] (dic) in
                                if let strongSelf = self {
                                    DispatchQueue.main.async {
                                        strongSelf.progressDismiss()
                                        if (failArr?.count)! > 0{
                                            let alert = UIAlertController(title: "温馨提示", message: "群组:".appending(((failArr as! NSArray).value(forKeyPath: "group_name") as! NSArray).componentsJoined(by: "\n")).appending("此话题已存在，您可直接参与讨论。"), preferredStyle: .alert)
                                            let okAction = UIAlertAction(title: "我知道了", style: .default, handler: { action in
                                                var reweetVc : ThemeRetweetVC? = nil
                                                for vc in (strongSelf.navigationController?.children)!{
                                                    if vc is ThemeRetweetVC {
                                                        reweetVc = vc as? ThemeRetweetVC
                                                    }
                                                }
                                                strongSelf.navigationController?.popToViewController(reweetVc!, animated: false)
                                                reweetVc?.navigationController?.popViewController(animated: true)
                                                
                                            })
                                            alert.addAction(okAction)
                                            strongSelf.present(alert, animated: true, completion: nil)
                                        }else{
                                        strongSelf.navigationController?.view.makeToast("转推成功", duration: 1.0, position: CSToastPositionCenter)
                                            var reweetVc : ThemeRetweetVC? = nil
                                            for vc in (strongSelf.navigationController?.children)!{
                                                if vc is ThemeRetweetVC {
                                                    reweetVc = vc as? ThemeRetweetVC
                                                }
                                            }
                                            strongSelf.navigationController?.popToViewController(reweetVc!, animated: false)
                                            reweetVc?.navigationController?.popViewController(animated: true)
                                        }
                                    }
                                }
                            }
                        )
                    }
                }
            }) { [weak self](success) in
                print("创建话题成功",success)
                num = num! + 1
                if let strongSelf = self {
                    let themeid : String? = String.changeToString(inValue: success["subGroupId"])
                    let newMess = strongSelf.nMessage
                    newMess.groupId = gModel.groupid
                    newMess.themeId = String.changeToString(inValue: success["subGroupId"])
                    strongSelf.sendMessageToOtherGroup(themeid: themeid!, gModel: gModel, otherText: otherText != "" ? otherText! : "", newMess: newMess, bbb:bbb != nil ? bbb! : nil)
                    
                    if num == (sGroupList?.count)!{
                    
                        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                        var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                        
                        if time == nil{
                            time = "0"
                        }
                        UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                            if let strongSelf = self {
                                DispatchQueue.main.async {
                                    strongSelf.progressDismiss()
                                    strongSelf.navigationController?.view.makeToast("转推失败", duration: 1.0, position: CSToastPositionCenter)
                                }
                            }
                            }, success: {[weak self] (dic) in
                                if let strongSelf = self {
                                   
                                    DispatchQueue.main.async {
                                        strongSelf.progressDismiss()
                                        strongSelf.navigationController?.view.makeToast("转推成功", duration: 1.0, position: CSToastPositionCenter)
                                        var reweetVc : ThemeRetweetVC? = nil
                                        for vc in (strongSelf.navigationController?.children)!{
                                            if vc is ThemeRetweetVC {
                                                reweetVc = vc as? ThemeRetweetVC
                                            }
                                        }
                                        strongSelf.navigationController?.popToViewController(reweetVc!, animated: false)
                                        reweetVc?.navigationController?.popViewController(animated: true)
                                    }
                                }
                            }
                        )
                    }
                }
                
            }
        }
        
    }
    func sendMessageToOtherGroup(themeid: String?,gModel: GroupModel?,otherText:String?,newMess:ThemeMessageContent?,bbb:HistoryMessageContent?) {
//        let themeid : String? = String.changeToString(inValue: success["subGroupId"])
//        let newMess = strongSelf.nMessage
//        newMess.groupId = gModel.groupid
//        newMess.themeId = String.changeToString(inValue: success["subGroupId"])
        
        RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel?.groupid, content: newMess, pushContent: PublicDataSingle.makePushContent(newMess, groupId: gModel!.groupid), pushData: PublicDataSingle.makePushContent(newMess, groupId: (gModel?.groupid)!), success: { (Int) in
            
            if otherText != "" {
                DispatchQueue.main.async {
                    
                    RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel?.groupid, content: RCTextMessage.init(content: otherText), pushContent: otherText, pushData: otherText, success: { (Int) in
                        
                    }, error: { (RCErrorCode, Int) in
                    })
                }
            }
        }, error: { (RCErrorCode, Int) in
        })
        if bbb != nil {
            RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: themeid, content: bbb, pushContent: PublicDataSingle.makePushContent(bbb, groupId: themeid!), pushData: PublicDataSingle.makePushContent(bbb, groupId: themeid!), success: { (Int) in
            }, error: { (RCErrorCode, Int) in
            })
        }
    }
    lazy var tableView: UITableView = {
        var tableView = UITableView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT, width: SCREEN_WIDTH, height: SCREEN_HEIGHT - NAV_HEIGHT))
        tableView.backgroundColor = UIColor.groupTableViewBackground
        tableView.delegate = self;
        tableView.dataSource = self;
        tableView.tableFooterView = UIView.init()
        return tableView
    }()
    
    
}
//MARK: - ---------------------TableDelegate AND DataSource----------------------
extension ThemeRetweetVC:UITableViewDelegate,UITableViewDataSource
{
    func numberOfSections(in tableView: UITableView) -> Int {
        return 2
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        
        if section == 0 {
            return 0
        }else{
            return otherGroupCount
        }
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let sectionView : ThemeRetweetView? = ThemeRetweetView.init(frame: CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height: 44))
        sectionView?.delegate = self
        if section == 0 {
            sectionView?.iconButton.isSelected = self.localGroupContainAll
            sectionView?.iconButton.tag = 10
            sectionView?.iconButton.setTitle("本群", for: .normal)
        }else{
            sectionView?.iconButton.isSelected = (self.otherGroupCount > 0)
            sectionView?.iconButton.tag = 11
            sectionView?.iconButton.setTitle("其他群", for: .normal)
        }
        return sectionView
    }
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return 44
    }
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        
        return 44
    }
    func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
        if section == 1 {
            let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height: 88))
            view.backgroundColor = UIColor.white
            let sectionView1 : ThemeRetweetView? = ThemeRetweetView.init(frame: CGRect.init(x: 60, y: 0, width: SCREEN_WIDTH - 60, height: 44))
            sectionView1?.delegate = self
            sectionView1?.iconButton.isSelected = self.otherGroupContainAll
            sectionView1?.iconButton.tag = 1110
            sectionView1?.iconButton.setTitle("全部内容", for: .normal)
            view.addSubview(sectionView1!)
            let sectionView2 : ThemeRetweetView? = ThemeRetweetView.init(frame: CGRect.init(x: 60, y: 44, width: SCREEN_WIDTH - 60, height: 44))
            sectionView2?.delegate = self
            sectionView2?.iconButton.isSelected = self.otherGroupContainSome
            sectionView2?.iconButton.tag = 1111
            sectionView2?.iconButton.setTitle("部分内容", for: .normal)
            view.addSubview(sectionView2!)
            return view
        }
        return nil
    }
    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
        if section == 1 {
            if self.otherGroupContain {
                return 88
            }else{
                return 0
            }
        }else{
            return 5
        }
    }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        let cell:UITableViewCell? = UITableViewCell.init(style: .default, reuseIdentifier: "ThemeRetweetCell")
        cell?.selectionStyle = .none
        let sectionView : ThemeRetweetView? = ThemeRetweetView.init(frame: CGRect.init(x: 30, y: 0, width: SCREEN_WIDTH - 30, height: 44))
        sectionView?.delegate = self
        if indexPath.section == 0 {
            if indexPath.row == 0 {
                sectionView?.iconButton.isSelected = self.localGroupContainNone
                sectionView?.iconButton.tag = 100
                sectionView?.iconButton.setTitle("不包括讨论内容", for: .normal)
            }else{
                sectionView?.iconButton.isSelected = self.localGroupContainSome
                sectionView?.iconButton.tag = 101
                sectionView?.iconButton.setTitle("包括部分讨论内容", for: .normal)
            }
        }else{
            if indexPath.row == 0 {
                sectionView?.iconButton.isSelected = self.otherGroupContainNone
                sectionView?.iconButton.tag = 110
                sectionView?.iconButton.setTitle("不包括讨论内容", for: .normal)
            }else{
                sectionView?.iconButton.isSelected = self.otherGroupContain
                sectionView?.iconButton.tag = 111
                sectionView?.iconButton.setTitle("包括讨论内容", for: .normal)
            }
        }
        cell?.addSubview(sectionView!)
        return cell!
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
    {
        tableView.deselectRow(at: indexPath, animated: true)
    }
}
extension ThemeRetweetVC : ThemeRetweetViewDelegate{
    func selectButtonDidClick(btn: UIButton) {
        if btn.isSelected {
            return
        }
        btn.isSelected = !btn.isSelected
        if btn.isSelected {
            self.localGroupContainNone = false
            self.localGroupContainSome = false
            self.otherGroupContainNone = false
            self.otherGroupContain = false
            self.otherGroupContainAll = false
            self.otherGroupContainSome = false
            if btn.tag == 10 {
                self.localGroupContainAll = true
                self.otherGroupCount = 0
            }
            if btn.tag == 11 {
                self.localGroupContainAll = false
                self.otherGroupCount = 2
                self.otherGroupContainNone = true
            }
            if btn.tag == 100 {
                self.localGroupContainNone = true
            }
            if btn.tag == 101 {
                self.localGroupContainSome = true
            }
            if btn.tag == 110 {
                self.otherGroupContainNone = true
            }
            if btn.tag == 111 {
                self.otherGroupContain = true
                self.otherGroupContainAll = true
            }
            if btn.tag == 1110 {
                self.otherGroupContain = true
                self.otherGroupContainAll = true
            }
            if btn.tag == 1111 {
                self.otherGroupContain = true
                self.otherGroupContainSome = true
            }
        }else{
            self.localGroupContainAll = false
            self.otherGroupCount = 0
        }
        tableView.reloadData()
    }
}
//
//  ThemeCreatVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/6/14.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
private let textView_height : CGFloat = 150.0
fileprivate let maxTextLength = 1000
class ThemeCreatVC: BaseViewController {
    var textView : UITextView?
    var placeholderLabel : UILabel?
    var imageBgView : UIScrollView?
    var selectedAssets : Array<Any>? = [] //记录已经选择的图片(传给imagepick)
    var selectedPhotos : Array<UIImage>? = [] //记录选择的UIImage类型图片
    var selectedUrls : Array<Any>? = [] //记录话题已经包含的图片url(修改话题或图片转为话题时使用)
    var isSelectOriginalPhoto : Bool? = false //记录选择图片时是否选择原图
    var subGroupid : String?
    var groupid : String?{
        didSet{
            self.title = subGroupid != nil ? "修改话题" : "新建话题"
            self.configUI()
            if subGroupid != nil {
                let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",subGroupid!)).firstObject() as! GroupModel?
                if groupModel != nil {
                    textView?.text = groupModel?.group_name
                    placeholderLabel?.isHidden = true
                    self.progressShow()
                    GroupRequest.getGroupSubjectInfo(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":subGroupid!], hadToast: true, fail: { [weak self](error) in
                        if let strongSelf = self {
                            strongSelf.progressDismissWith(str: "获取话题信息失败")
                        }
                    }, success: { [weak self](dic) in
                        if let strongSelf = self {
                            strongSelf.progressDismiss()
                            if (dic["titleFileList"] is Array<Dictionary<String, Any>>) {
                                var urlArr : Array<Any>? = []
                                for dict:Dictionary<String, Any> in (dic["titleFileList"] as! Array<Dictionary<String, Any>>){
                                    urlArr?.append(dict)
                                }
                                strongSelf.selectedUrls = urlArr
                                strongSelf.creatImageView()
                            }
                        
                        }
                    })
                }
            }
        }
    }
    var creatThemeSuccessBlock : ((_ themeid:String?) -> ())?
    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = UIColor.groupTableViewBackground
      
    }
    
    func configUI() {
        let scrollView = UIScrollView.init(frame: self.view.bounds)
        if #available(iOS 11, *) {
            scrollView.contentInsetAdjustmentBehavior = .never
        }else {
            
        }
        scrollView.contentSize = CGSize.init(width: SCREEN_WIDTH, height: SCREEN_HEIGHT + 1)
        scrollView.backgroundColor = UIColor.groupTableViewBackground
        scrollView.delegate = self
        self.view.addSubview(scrollView)
        textView = UITextView.init(frame: CGRect.init(x: LEFT_PADDING, y: NAV_HEIGHT + LEFT_PADDING, width: SCREEN_WIDTH - 2 * LEFT_PADDING, height: textView_height));
        textView?.backgroundColor = UIColor.groupTableViewBackground
        textView?.textColor = UIColor.black
        textView?.font = FONT_14
        textView?.delegate = self
//        解决UITextView文本自动滑动问题。
        textView?.layoutManager.allowsNonContiguousLayout = false
        textView?.becomeFirstResponder()
        scrollView.addSubview(textView!)
        placeholderLabel = UILabel.init()
        placeholderLabel?.font = FONT_14
        placeholderLabel?.textColor = UIColor.lightGray
        textView?.addSubview(placeholderLabel!)
        placeholderLabel?.text = "请输入话题内容"
        placeholderLabel!.mas_makeConstraints { (make) in
            make!.top.equalTo()(8)
            make!.left.equalTo()(5)
        }
        imageBgView = UIScrollView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT + textView_height + 20, width: SCREEN_WIDTH, height: SCREEN_HEIGHT - (NAV_HEIGHT + textView_height + 20)))
        scrollView.addSubview(imageBgView!)
        self.setRightBtnWithArray(items: ["完成"]);
        self.creatImageView()
    }
    func creatImageView() {
        for subView in (imageBgView?.subviews)! {
            subView.removeFromSuperview()
        }
        let imgMargin : CGFloat = 10.0
        let imgW : CGFloat = (SCREEN_WIDTH - 4 * imgMargin)/3.0
        let btnW : CGFloat = 30.0
        imageBgView?.contentSize = CGSize.init(width: SCREEN_WIDTH, height: (imgMargin + imgW) * CGFloat(((self.selectedUrls?.count)! + (self.selectedPhotos?.count)!)/3 + 1))
        for i in 0..<(self.selectedUrls?.count)! {
           
            let imageView = UIImageView.init(frame: CGRect.init(x: imgMargin * CGFloat(i%3 + 1) + imgW * CGFloat(i%3), y: imgMargin * CGFloat(i/3 + 1) + imgW * CGFloat(i/3), width: imgW, height: imgW))
            imageView.tag = 10 + i
            imageView.isUserInteractionEnabled = true
            imageView.contentMode = .scaleAspectFill
            imageView.clipsToBounds = true
            imageView.sd_setImage(with: NSURL.init(string: (self.selectedUrls?[i] as! Dictionary)["thumb_url"]!) as URL?, placeholderImage: UIImage.init(named: ""))
            let ges = UITapGestureRecognizer.init(target: self, action: #selector(tapped(_:)))
            ges.numberOfTapsRequired = 1
            imageView.addGestureRecognizer(ges)
            imageBgView?.addSubview(imageView)
            
            let delBtn = UIButton.init(frame: CGRect.init(x: imgW - btnW, y: 0, width: btnW, height: btnW))
            delBtn.tag = 20 + i
            delBtn.addTarget(self, action: #selector(delBtnClick), for: .touchUpInside)
            delBtn.setImage(UIImage.init(named: "delect"), for: .normal)
            imageView.addSubview(delBtn)
        }
        for i in 0..<(self.selectedPhotos?.count)! + 1 {
            if i == self.selectedPhotos?.count {
                let chooseImageBtn = UIButton.init(frame: CGRect.init(x: imgMargin * CGFloat((i + (self.selectedUrls?.count)!)%3 + 1) + imgW * CGFloat((i + (self.selectedUrls?.count)!)%3), y: imgMargin * CGFloat((i + (self.selectedUrls?.count)!)/3 + 1) + imgW * CGFloat((i + (self.selectedUrls?.count)!)/3), width: imgW, height: imgW))
                chooseImageBtn.addTarget(self, action: #selector(chooseImage), for: .touchUpInside)
                chooseImageBtn.setBackgroundImage(UIImage.init(named: "select_photo"), for: .normal)
                chooseImageBtn.setTitleColor(UIColor.black, for: .normal)
                chooseImageBtn.layer.borderWidth = 0.5
                chooseImageBtn.layer.borderColor = UIColor.lightGray.cgColor
                imageBgView?.addSubview(chooseImageBtn)
            }else{
                let imageView = UIImageView.init(frame: CGRect.init(x: imgMargin * CGFloat((i + (self.selectedUrls?.count)!)%3 + 1) + imgW * CGFloat((i + (self.selectedUrls?.count)!)%3), y: imgMargin * CGFloat((i + (self.selectedUrls?.count)!)/3 + 1) + imgW * CGFloat((i + (self.selectedUrls?.count)!)/3), width: imgW, height: imgW))
                imageView.tag = 10 + (i + (self.selectedUrls?.count)!)
                imageView.isUserInteractionEnabled = true
                imageView.contentMode = .scaleAspectFill
                imageView.clipsToBounds = true
                imageView.image = self.selectedPhotos?[i]
                imageBgView?.addSubview(imageView)
                let ges = UITapGestureRecognizer.init(target: self, action: #selector(tapped(_:)))
                ges.numberOfTapsRequired = 1
                imageView.addGestureRecognizer(ges)
                
                let delBtn = UIButton.init(frame: CGRect.init(x: imgW - btnW, y: 0, width: btnW, height: btnW))
                delBtn.tag = 20 + (i + (self.selectedUrls?.count)!)
                delBtn.addTarget(self, action: #selector(delBtnClick), for: .touchUpInside)
                delBtn.setImage(UIImage.init(named: "delect"), for: .normal)
                imageView.addSubview(delBtn)
            }
        }
    }
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        if scrollView is UITextView {
            return
        }
        if (textView?.isFirstResponder)! {
            textView?.resignFirstResponder()
        }
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    override func rightBtnClick(button: UIButton) {
        if (textView?.text.count)! == 0 {
            self.view.makeToast("话题名称不能为空", duration: 1.0, position: CSToastPositionCenter)
            return
        }
        self.progressShow()
        var photoArr : Array<Dictionary<String, Any>>? = []
        if (self.selectedPhotos?.count)! > 0 {
            
            for i in 0..<(self.selectedPhotos?.count)! {
                
                GroupRequest.uploadImage(image: (self.selectedPhotos?[i])!, params: ["groupid":self.groupid!,"thumb":1,"thumbWidht":300,"thumbHeight":300], hadToast: true, fail: { [weak self](fail) in
                     if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                }, success: { [weak self](success) in
                    if let strongSelf = self {
                        var tempDic : Dictionary<String, Any>? = [:]
                        tempDic?["url"] = success["url"]
                        tempDic?["thumb_url"] = success["thumb_url"]
                        photoArr?.append(tempDic!)
                        if photoArr?.count == strongSelf.selectedPhotos?.count{
                            DispatchQueue.main.async {
                              
                                strongSelf.creatTheme(photoArr:photoArr)
                            }
                        }
                    }
                })
            }
        }else{
            self.creatTheme(photoArr:photoArr)
        }
    }
    func creatTheme(photoArr:Array<Dictionary<String, Any>>?)  {
        var params : Dictionary<String, Any> = [:]
        if subGroupid != nil {
            //TODO:修改话题图片
            var tempArr : Array<Dictionary<String, Any>>? = photoArr
            for i in 0..<(selectedUrls?.count)! {
                tempArr?.insert(self.selectedUrls?[i] as! [String : Any], at: i)
            }
            if (tempArr?.count)! > 0 {
                params = ["app_token":sharePublicDataSingle.token,"sub_groupid":subGroupid!,"title":textView?.text!,"file_json":SignTool.makeJsonStrWith(object: tempArr!)]
            }else{
                params = ["app_token":sharePublicDataSingle.token,"sub_groupid":subGroupid!,"title":textView?.text!]
            }
            GroupRequest.updateGroupSubject(params: params, hadToast: true, fail: { [weak self] (fail) in
                if let strongSelf = self {
                    strongSelf.progressDismiss()
                }
            }) { (success) in
                print("修改话题成功",success)
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                
                if time == nil{
                    time = "0"
                }
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                    if let strongSelf = self {
                        strongSelf.progressDismiss()
                    }
                    }, success: {[weak self] (dic) in
                        if let strongSelf = self {
                            strongSelf.progressDismiss()
                            strongSelf.selectedAssets?.removeAll()
                            strongSelf.selectedPhotos?.removeAll()
                            strongSelf.isSelectOriginalPhoto = false
                            strongSelf.navigationController?.popViewController(animated: true)
                        }
                    }
                    
                )
                
            }
        }else{
            if (photoArr?.count)! > 0 {
                params = ["app_token":sharePublicDataSingle.token,"groupid":self.groupid!,"title":textView?.text!,"file_json":SignTool.makeJsonStrWith(object: photoArr!)]
            }else{
                params = ["app_token":sharePublicDataSingle.token,"groupid":self.groupid!,"title":textView?.text!]
            }
            GroupRequest.createGroupSubject(params: params, hadToast: true, fail: { [weak self] (fail) in
                if let strongSelf = self {
                    strongSelf.progressDismissWith(str: "创建话题失败")
                }
            }) { [weak self](success) in
                print("创建话题成功",success)
                if let strongSelf = self{
                    let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                    var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                    
                    if time == nil{
                        time = "0"
                    }
                    let themeid : String? = String.changeToString(inValue: success["subGroupId"])
                    let newMess = ThemeMessageContent()
                    newMess.content = (strongSelf.textView?.text)!
                    newMess.extra = ""
                    newMess.imageURL = ""
                    newMess.thumbnailUrl = ""
                    newMess.url = ""
                    newMess.groupId = strongSelf.groupid!
                    newMess.themeId = themeid!
                    let Tab:TMTabbarController = strongSelf.navigationController?.children[1] as! TMTabbarController
                    let smak:SmallTalkVC = Tab.viewControllers?.first as! SmallTalkVC
                    smak.isRunApi = false
                    smak.sendMessage(newMess, pushContent: PublicDataSingle.makePushContent(newMess, groupId: smak.targetId))
                   
                    UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self] (fail) in
                        if let strongSelf = self {
                            strongSelf.progressDismiss()
                        }
                        }, success: {[weak self] (dic) in
                            if let strongSelf = self {
                                strongSelf.progressDismiss()
                                strongSelf.selectedAssets?.removeAll()
                                strongSelf.selectedPhotos?.removeAll()
                                strongSelf.isSelectOriginalPhoto = false
                                strongSelf.navigationController?.popViewController(animated: false)
                                if strongSelf.creatThemeSuccessBlock != nil{
                                    strongSelf.creatThemeSuccessBlock!(themeid)}
                            }
                        }
                        
                    )
                    
                }
            }
        }
    }
    @objc func chooseImage() {
        if (self.selectedUrls?.count)! >= 9 {
            self.view.makeToast("最多选择九张图片", duration: 1.0, position: CSToastPositionCenter)
            return
        }
        let imagePickerVc = TZImagePickerController.init(maxImagesCount: (9 - (self.selectedUrls?.count)!) > 0 ? (9 - (self.selectedUrls?.count)!) : 0, delegate: self)
        imagePickerVc?.allowPickingOriginalPhoto = false
        imagePickerVc?.selectedAssets = NSMutableArray.init(array: self.selectedAssets!)
        imagePickerVc?.isSelectOriginalPhoto = self.isSelectOriginalPhoto!
        imagePickerVc?.didFinishPickingPhotosHandle = ({ (photos : Array<UIImage>?, assets : Array<Any>?,isSelectOriginalPhoto:Bool?) in
            
            self.selectedAssets = assets
            self.isSelectOriginalPhoto = isSelectOriginalPhoto
            if isSelectOriginalPhoto! {
                DispatchQueue.main.async {
                    var tempPhotos : Array<UIImage>? = []
                    for i in 0..<(assets?.count)! {
                        
                        TZImageManager().getOriginalPhoto(with: (assets?[i] as! PHAsset), completion: { (image, dic) in
                            tempPhotos?.append(image!)
                            if tempPhotos?.count == (assets?.count)!{
                                DispatchQueue.main.async {
                                    self.selectedPhotos = tempPhotos
                                    
                                    self.creatImageView()
                                }
                            }
                        })
                        
                    }
                }
            }else{
                self.selectedPhotos = photos
                self.creatImageView()
            }
        })
        self.present(imagePickerVc!, animated: true, completion: nil)
    }
    /// 图片点击响应
    ///
    /// - Parameter tap: <#tap description#>
    @objc func tapped(_ tap:UITapGestureRecognizer){
        let image:UIImageView = tap.view as! UIImageView
        
        let photoBrowser = SDPhotoBrowser.init()
        photoBrowser.delegate = self as SDPhotoBrowserDelegate
        photoBrowser.currentImageIndex = image.tag - 10
        photoBrowser.imageCount = (imageBgView?.subviews.count)! - 1
        photoBrowser.sourceImagesContainerView = imageBgView
        
        photoBrowser.show()
        
    }
    
    @objc func delBtnClick(btn:UIButton) {
        if btn.tag - 20 < (self.selectedUrls?.count)! {
            self.selectedUrls?.remove(at: btn.tag - 20)
        }else{
            self.selectedAssets?.remove(at: btn.tag - (20 + (self.selectedUrls?.count)!))
            self.selectedPhotos?.remove(at: btn.tag - (20 + (self.selectedUrls?.count)!))
            if (self.selectedAssets?.count)! == 0 {
                self.isSelectOriginalPhoto = false
            }
        }
        self.creatImageView()
    }
}
extension ThemeCreatVC : TZImagePickerControllerDelegate{
    
}
extension ThemeCreatVC : UITextViewDelegate{
    func textViewDidBeginEditing(_ textView: UITextView) {
        textView.contentSize = CGSize.init(width: textView.frame.size.width, height: textView.layoutManager.usedRect(for: textView.textContainer).size.height + 20)
//        textView.layoutIfNeeded()
    }
    func textViewDidChange(_ textView: UITextView) {//同样的代码:适配iOS8
        if textView.textInputMode?.primaryLanguage == "zh-Hans" {
            let selectedRange : UITextRange? = textView.markedTextRange
            var position : UITextPosition? = nil
            if (selectedRange != nil) {
                position = textView.position(from: (selectedRange?.start)!, offset: 0)!
            }
            if position == nil {
                if (textView.text?.count)! > 0 {
                    placeholderLabel?.isHidden = true
                }else{
                    placeholderLabel?.isHidden = false
                }
//                if (textView.text?.count)! > maxTextLength {
//                    textView.text = textView.text?.substring(to: (textView.text?.index((textView.text?.startIndex)!, offsetBy: maxTextLength))!)
//                    return
//                }
            }else{
                
            }
        }else{
            if (textView.text?.count)! > 0 {
                placeholderLabel?.isHidden = true
            }else{
                placeholderLabel?.isHidden = false
            }
//            if (textView.text?.count)! > maxTextLength {
//                textView.text = textView.text?.substring(to: (textView.text?.index((textView.text?.startIndex)!, offsetBy: maxTextLength))!)
//                return
//            }
        }
        
        
    }
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
//        if text == "\n" {
//            return false
//        }
        var str = textView.text?.replacingCharacters(in: (textView.text?.changeToRange(from: range)!)!, with: text)
        if textView.textInputMode?.primaryLanguage == "zh-Hans" {
            let selectedRange : UITextRange? = textView.markedTextRange
            var position : UITextPosition? = nil
            if (selectedRange != nil) {
                position = textView.position(from: (selectedRange?.start)!, offset: 0)!
            }
            if position == nil {
                if (str?.count)! > 0 {
                    placeholderLabel?.isHidden = true
                }else{
                    placeholderLabel?.isHidden = false
                }
//                if (str?.count)! > maxTextLength {
//                    textView.text = str?.substring(to: (str?.index((str?.startIndex)!, offsetBy: maxTextLength))!)
//                    return false
//                }
            }else{
                
            }
        }else{
            if (str?.count)! > 0 {
                placeholderLabel?.isHidden = true
            }else{
                placeholderLabel?.isHidden = false
            }
//            if (str?.count)! > maxTextLength {
//                textView.text = str?.substring(to: (str?.index((str?.startIndex)!, offsetBy: maxTextLength))!)
//                return false
//            }
        }
        
        return true
    }
}
// MARK: - 图片浏览器代理
extension ThemeCreatVC:SDPhotoBrowserDelegate{
    
    func photoBrowser(_ browser: SDPhotoBrowser!, placeholderImageFor index: Int) -> UIImage! {
        
        let imageView:UIImageView = imageBgView?.subviews[index] as! UIImageView
        return imageView.image
        
    }
    
//    func photoBrowser(_ browser: SDPhotoBrowser!, highQualityImageURLFor index: Int) -> URL! {
//        
//        let dic = imageArray?[index]
//        let str = dic?["url"]
//        return NSURL.init(string: str!)! as URL
//    }
    
}
//
//  ThemeChatVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/9.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import WebKit
class ThemeChatVC: RCConversationViewController,RCMessageCellDelegate {
    
    var isSearch:Bool?//是否是搜索
    var searchModel:ChatContentModel?//搜索内容
    var gModel: GroupModel?
    
    var isMsgCopy:Bool?
    var isSearchBack:Bool?
    var atArray:Array<GroupUserModel>?
    var themeInfoView:ThemeInfoView?
    
    var endBtn:UIButton?
    
    var isChooseView = false//多选开关
    var chooseList = Array<String>.init()//选中的messageId
    var chooseType = "RCTextMessageCell,RCImageMessageCell"//多选内容分类
    
    var lasttime: Any?  //获取的最后一条历史消息的时间
    var length: Int? = 10 //需要获取的历史消息条数,默认10条
    var isLoadingMore:Bool? //是否正在获取更多历史消息,防止下拉获取历史消息接口重复调用
    var lastMessageUid: String?
    var isZhuantui:Bool?//是否是转推选择消息页面
    var finishSelect:(_ chooseList:Array<String>)->() = {//转推选择的消息回调
        msgIdArr in
    }
    var scrollToBottom:Bool?//获取完历史消息是否应该滚动到底部
    var callAudioVc : CallAudioMultiCallViewController? //语音通话页面
    var callVideoVc : CallVideoMultiCallViewController? //视频通话页面
    override func viewDidLoad() {
        super.viewDidLoad()
        self.configBackItem()
        isLoadingMore = false
        scrollToBottom = false
        atArray = Array()
        RCIM.shared().enableMessageMentioned = true
        RCIM.shared().globalMessageAvatarStyle = RCUserAvatarStyle.USER_AVATAR_CYCLE
        RCIM.shared().registerMessageType(ThemeMessageContent.self)
        RCIM.shared().registerMessageType(HistoryMessageContent.self)
        self.enableUnreadMessageIcon = true
        self.displayUserNameInCell = true
        self.chatSessionInputBarControl.inputTextView.disableActionMenu = true
        self.conversationMessageCollectionView.register(MyVoiceCell.self, forCellWithReuseIdentifier: "voice")
        self.chatSessionInputBarControl.pluginBoardView.removeItem(at: 2)
        
        self.register(ThemeMessageCell.self, forMessageClass: ThemeMessageContent.self)
        self.register(HistoryMessageCell.self, forMessageClass: HistoryMessageContent.self)
        self.add()
        self.chatSessionInputBarControl.addObserver(self, forKeyPath: "frame", options: .new, context: nil)
        
        self.getThemeInfo()
        let predicate = NSPredicate.init(format: "groupid == %@", argumentArray: [self.targetId])
        
        gModel = GroupModel.objects(with: predicate).firstObject() as! GroupModel?
        print((gModel?.groupid)!+"|||"+String(describing: gModel?.is_consult))
//        if gModel?.is_consult == 1 {
//            print("groupModel?.consult_info?.consult_status :\(gModel?.consult_info?.consult_status)")
//            if gModel?.consult_info?.consult_status == "5" {
//                //导师端应该没有结束辅导的按钮
////                addEndBtn()
//            }
//        }
        
        if self.conversationDataRepository.count > 0 {
            let lastMessageModel : RCMessageModel = self.conversationDataRepository.firstObject as! RCMessageModel
            lasttime = lastMessageModel.sentTime - 1
            length = 10 - self.conversationDataRepository.count
        }else{
            lasttime = Date().timeIntervalSince1970 * 1000.0 - 1
        }
        if length! > 0 {
            scrollToBottom = true
            self.getHistoryMsg()
        }
        
    }
    
    func add(){
        
        self.register(ProjectReportMessageContentCell.self, forMessageClass: ProjectReportMessageContent.self)
        self.register(ProjectVoiceMessageContentCell.self, forMessageClass: ProjectVoiceMessageContent.self)
        self.conversationMessageCollectionView.register(ProjectReportMessageContentCell.self, forCellWithReuseIdentifier: "ProjectReportMessageContent")
        self.conversationMessageCollectionView.register(ProjectVoiceMessageContentCell.self, forCellWithReuseIdentifier: "ProjectVoiceMessageContent")
    }
    
    // MARK: - 高度处理
    override func rcConversationCollectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: UICollectionViewLayout!, sizeForItemAt indexPath: IndexPath!) -> CGSize {
        let model:RCMessageModel = self.conversationDataRepository[indexPath.row] as! RCMessageModel
        if model.objectName == "ProjectVoiceMessageContent" {
            if model.isDisplayMessageTime == true{
                return CGSize.init(width: SCREEN_WIDTH, height: 140)
            }
            else{
                return CGSize.init(width: SCREEN_WIDTH, height: 120)
            }
            
        }else if model.objectName == "ProjectReportMessageContent"{
            
            if model.isDisplayMessageTime == true{
                return CGSize.init(width: SCREEN_WIDTH, height: 280)
            }
            else{
                return CGSize.init(width: SCREEN_WIDTH, height: 280)
            }
            
        }else{
            return super.rcConversationCollectionView(collectionView, layout: collectionViewLayout, sizeForItemAt: indexPath)
        }
    }
    
    
    
    func getThemeInfo(){
        
        let predicate = NSPredicate(format:"groupid == %@  AND is_delete == '0'",self.targetId)
        let themeResult = ThemeInfoModel.objects(with: predicate)
        if  themeResult.count > 0 {
            
            //            group_name
            //            titleFileList
            let themeInfoModel:ThemeInfoModel = themeResult.firstObject() as! ThemeInfoModel
            
            let anyArray = BaseRequest.makeJsonWithString(jsonStr: themeInfoModel.imageArray)
            
            
            
            
            
            
            
            
            var dic:Dictionary<String,Any> = Dictionary.init()
            
            dic.updateValue(themeInfoModel.group_name, forKey: "group_name")
            dic.updateValue(anyArray, forKey: "titleFileList")
            self.addThemeInfoView(dic: dic)
            
            
            let params = ["sub_groupid":self.targetId as Any,"app_token":sharePublicDataSingle.token]
            GroupRequest.getGroupSubjectInfo(params: params, hadToast: false, fail: { [weak self](fail)  in
                //            self?.getThemeInfo()
            }) { [weak self](success) in
                
                //                print(success)
                
            }
            
            
        }
        else{
            
            let params = ["sub_groupid":self.targetId as Any,"app_token":sharePublicDataSingle.token]
            GroupRequest.getGroupSubjectInfo(params: params, hadToast: false, fail: { [weak self](fail)  in
                //            self?.getThemeInfo()
            }) { [weak self](success) in
                
                self?.addThemeInfoView(dic: success)
            }
            
            
        }
        
        
    }
    
    func getHistoryMsg(){
        isLoadingMore = true
        GroupRequest.getGroupSubjectHistorymsg(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":self.targetId,"lasttime": lasttime!,"length":length!], hadToast: false, fail: { (error) in
            self.isLoadingMore = false
        }, success: { [weak self](dic) in
            self?.isLoadingMore = false
            print("历史消息记录:",dic)
            if let lastTime = dic["lastTime"] as? NSNumber {
                let lastTimeString = lastTime.stringValue
                self?.lasttime = (Float64)(lastTimeString)! - 1
            }
            if let lastTime = dic["lastTime"] as? String {
                self?.lasttime = (Float64)(lastTime)! - 1
            }
            
            self?.length = dic["count"] as! Int? == 0 ? -1 : dic["count"] as! Int?
            let list : Array<Dictionary<String, Any>> = dic["list"] as! Array<Dictionary<String, Any>>
            for i in 0..<list.count {
                let messageModel = RCMessageModel.init()
                
                let dict = list[i]
                let contentData : Data? = (dict["content"] as? String)?.data(using: String.Encoding.utf8)
                //                let contentdic = try?JSONSerialization.jsonObject(with: contentData!, options: JSONSerialization.ReadingOptions.allowFragments) as! Dictionary<String, Any>
                //                            }1499397019384
                var messageContent = RCMessageContent.init()
                if dict["classname"] as! String? == "RC:GrpNtf" {
                    messageContent = RCGroupNotificationMessage.init()
                }
                if dict["classname"] as! String? == "RC:TxtMsg" {
                    messageContent = RCTextMessage.init()
                }
                if dict["classname"] as! String? == "RC:ImgMsg" {
                    messageContent = RCImageMessage.init()
                }
                if dict["classname"] as! String? == "RC:VcMsg" {
                    messageContent = RCVoiceMessage.init()
                    messageModel.receivedStatus = .ReceivedStatus_LISTENED
                    
                }
                if dict["classname"] as! String? == "RC:FileMsg" {
                    messageContent = RCFileMessage.init()
                }
                if dict["classname"] as! String? == "HistoryMessageContent" {
                    messageContent = HistoryMessageContent.init()
                }
                
                if dict["classname"] as! String? == "ProjectVoiceMessageContent" {
                    messageContent = ProjectVoiceMessageContent.init()
                }
                
                if dict["classname"] as! String? == "ProjectReportMessageContent" {
                    messageContent = ProjectReportMessageContent.init()
                }
                
                if contentData != nil {
                    messageContent.decode(with: contentData!)
                }
                
                messageModel.isDisplayMessageTime = true
                messageModel.isDisplayNickname = true
                messageModel.conversationType = .ConversationType_GROUP
                messageModel.targetId = self?.targetId
                messageModel.receivedStatus = .ReceivedStatus_READ
                messageModel.senderUserId = dict["from_im_userid"] as! String?
                messageModel.content = messageContent
                messageModel.messageDirection = .MessageDirection_RECEIVE
                messageModel.objectName = dict["classname"] as! String?
                messageModel.messageUId = dict["msg_uid"] as! String?
                if dict["direction"] as! String? == "send" {
                    messageModel.messageDirection = .MessageDirection_SEND
                }else{
                    messageModel.messageDirection = .MessageDirection_RECEIVE
                }
                
                
                
                messageModel.sentTime = ((dict["datetime"] as! NSString?)?.longLongValue)!
                
                let mNum = NSNumber.init(value: messageModel.sentTime)
                
                messageModel.messageId = mNum.intValue-i
                
                if (self?.conversationDataRepository.value(forKeyPath: "messageUId") as! NSArray).contains(dict["msg_uid"]!){
                    return
                }
                self?.conversationDataRepository.insert(messageModel, at: 0)
                
            }
            self?.conversationMessageCollectionView.reloadData()
            if self?.scrollToBottom == true{
                self?.scrollToBottom(animated: false)
                self?.scrollToBottom = false
            }
        })
        
    }
    func addThemeInfoView(dic:Dictionary<String, Any>) {
        
        print(dic)
        if self.title == nil{
            self.title = dic["group_name"] as! String?
        }
        
        themeInfoView = ThemeInfoView.init(frame: CGRect(x: 0, y: NAV_HEIGHT, width: kScreenW, height:40))
        themeInfoView?.themeName = dic["group_name"] as! String
        
        themeInfoView?.imageArray = dic["titleFileList"] as! Array<Dictionary<String, String>>
        themeInfoView?.configUI()
        themeInfoView?.openUrl = {url in
            let webView = WKWebView.init(frame: self.view.frame)
            let wbc = BaseViewController.init()
            wbc.configBackItem()
            //                wbc.title = (model.content as! HistoryMessageContent).title
            wbc.view = webView
            var newUrl = url
            if url.range(of: "//") == nil{
                newUrl = "http://"+url
            }
            webView.load(URLRequest.init(url: URL.init(string: newUrl)!))
            self.navigationController?.pushViewController(wbc, animated: true)
        }
        themeInfoView?.openBtnClick = {
            
            if self.chatSessionInputBarControl.inputTextView.isFirstResponder {
                self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            }
            self.chatSessionInputBarControl.resetToDefaultStatus()
        }
        self.view.addSubview(themeInfoView!);
    }
    
    func addEndBtn() {
//        endBtn = UIButton(frame: CGRect(x: kScreenW - 107 - 10, y: 114, width: 107, height: 36))
//        endBtn?.setImage(UIImage(named: "endBtn"), for: .normal)
//        endBtn?.addTarget(self, action: #selector(clickEndBtn(btn:)), for: .touchUpInside)
//        self.view.addSubview(endBtn!)
    }
    func clickEndBtn(btn:UIButton){
        weak var weakSelf = self
        self.addAlertView(title: "", message: "结束辅导后，导师将不再进行辅导，您确认要结束辅导吗？", actionTitles: ["确定","取消"], okAction: { (action) in
            weakSelf?.progressShow()
            GroupRequest.finishOnlineConsult(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":weakSelf?.gModel?.groupid], hadToast: true, fail: { (error) in
                weakSelf?.progressDismiss()
            }, success: { (dic) in
                print(dic)
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                if time == nil{
                    time = "0"
                }
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { (fail) in
                    weakSelf?.progressDismiss()
                }, success: {(dic) in
                    print(dic)
                    weakSelf?.endBtn?.removeFromSuperview()
                    weakSelf?.progressDismiss()
                }
                )
                
            })
            
            
        }, cancleAction: { (action) in
            
        })
        
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)
    {
        if  let chatBar:RCChatSessionInputBarControl = object as? RCChatSessionInputBarControl{
            print(chatBar.frame)
            if chatBar.frame.origin.y < MAIN_SCREEN_HEIGHT_PX - chatBar.frame.size.height {
                if self.themeInfoView?.isOpen == true{
                    self.themeInfoView?.btnClick()
                }
            }
        }
    }
    
    override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
        
        if(action == #selector(paste(_:)) )
        {
            if isMsgCopy == true {
                isMsgCopy = false
                return false
            }
            return true
        }
        else{
            return super.canPerformAction(action, withSender: sender)
        }
        
        
    }
    
    
    
    /// 判断是否显示tab上的红点提醒
    func isClearNewPoint(){
        
        guard gModel != nil else {
            return
        }
        
        let groupIdArr : Array<String> = GroupModel.objects(with: NSPredicate.init(format: "parentid == %@", (self.gModel?.parentid)!)).value(forKeyPath: "groupid") as! Array<String>
        var subGroupMesTotalCount : Int32? = 0
        for targetId in groupIdArr {
            subGroupMesTotalCount = subGroupMesTotalCount! + RCIMClient.shared().getUnreadCount(.ConversationType_GROUP, targetId: targetId)
        }
        
        if subGroupMesTotalCount == 0 {
            self.clearTabRedPoint()
        }
        else{
            self.showTabRedPoint()
        }
        
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        if isSearchBack == true {
            isSearchBack = false
        }
        else{
            
            let predicate = NSPredicate.init(format: "groupid == %@", argumentArray: [self.targetId])
            
            gModel = GroupModel.objects(with: predicate).firstObject() as! GroupModel?
            if gModel != nil {
                
                self.title = gModel?.group_name
                
            }
            
            //清除未读数据
            let mResult = MessageCenterModel.objects(with: NSPredicate(format: "targetId == %@", self.targetId))
            DataBaseOperation.removeDataWithArray(rlmObjects: mResult)
            
            let notice = Notification.init(name: NSNotification.Name(rawValue: "reLoadTotalUnreadCount"), object: nil, userInfo: nil)
            NotificationCenter.default.post(notice)
            if (self.navigationController?.navigationBar.subviews.contains(coverNavBar))! {
                coverNavBar.removeFromSuperview()
            }
            if isSearch != true {
                
                makeNavigationRightBtn()
            }
        }
        
        
        self.callPhoneNoti()
    }
    
    
    
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        
        shareAVManager.stopPlay()
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        self.cancleMoreAction(UIButton.init())
    }
    
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        self.isClearNewPoint()
        
        if isSearch == true {
            self.scrollToIndexWithMessageId(model: searchModel!)
        }
        refreshUserInfoOrGroupInfo()
        
        
    }
    
    override func scrollViewDidScroll(_ scrollView: UIScrollView) {
        super.scrollViewDidScroll(scrollView)
        if self.conversationDataRepository.count > 0 {
            if self.lastMessageUid == nil {
                for messageModel in self.conversationDataRepository {
                    if (messageModel as! RCMessageModel).content is RCGroupNotificationMessage{
                        if let notiMessage = ((messageModel as! RCMessageModel).content as! RCGroupNotificationMessage).message{
                            if notiMessage  == String.init(format: "%@加入了话题。",sharePublicDataSingle.publicData.realname){
                                self.lastMessageUid = (messageModel as! RCMessageModel).messageUId
                                break
                            }
                        }
                    }
                }
            }else{
                if self.isLoadingMore! || length! < 0 || scrollView.contentOffset.y > 0{
                    return
                }
                self.getHistoryMsg()
                
                //                if (self.conversationDataRepository.firstObject as! RCMessageModel).content is RCGroupNotificationMessage{
                //                    if ((self.conversationDataRepository.firstObject as! RCMessageModel).content as! RCGroupNotificationMessage).message == String.init(format: "%@加入了话题。",sharePublicDataSingle.publicData.realname){
                //                                           }
                //                }else{
                //
                //                }
            }
        }
    }
    
    override func willDisplayMessageCell(_ cell: RCMessageBaseCell!, at indexPath: IndexPath!) {
        print("deinit: \(cell.classForCoder) + \(cell.model.objectName)")
        if cell.model.objectName == "RC:GrpNtf"  {
            let notModel:RCGroupNotificationMessage? = cell.model.content as? RCGroupNotificationMessage
            //            if notModel?.operation == GroupNotificationMessage_GroupOperationAdd || notModel?.operation == GroupNotificationMessage_GroupOperationKicked  {
            
            let mycell = cell as! RCTipMessageCell
            let label = UILabel.init()
            label.font = mycell.tipMessageLabel.font
            guard (notModel?.message.contains(sharePublicDataSingle.publicData.realname))! else {
                
                mycell.tipMessageLabel.text = notModel?.message
                let height = Int((mycell.tipMessageLabel.text?.getTextHeight(font: mycell.tipMessageLabel.font, width: tipView_Width))!) + 6
                label.text = notModel?.message
                label.sizeToFit()
                mycell.tipMessageLabel.frame.size = CGSize.init(width: label.frame.size.width < tipView_Width ? label.frame.size.width : tipView_Width, height: CGFloat(height))
                mycell.tipMessageLabel.center.x = SCREEN_WIDTH * 0.5
                return
            }
            
            mycell.tipMessageLabel.text = notModel?.message.replacingOccurrences(of: sharePublicDataSingle.publicData.realname, with: "你")
            let height = Int((mycell.tipMessageLabel.text?.getTextHeight(font: mycell.tipMessageLabel.font, width: tipView_Width))!) + 6
            label.text = notModel?.message.replacingOccurrences(of: sharePublicDataSingle.publicData.realname, with: "你")
            label.sizeToFit()
            mycell.tipMessageLabel.frame.size = CGSize.init(width: label.frame.size.width < tipView_Width ? label.frame.size.width : tipView_Width, height: CGFloat(height))
            mycell.tipMessageLabel.center.x = SCREEN_WIDTH * 0.5
            
            
            //            }
            //            else{
            //                super.willDisplayMessageCell(cell, at: indexPath)
            //                print(cell)
            //                cell.delegate = self
            //            }
            
        }
        else{
            super.willDisplayMessageCell(cell, at: indexPath)
            
            cell.clearCell()
            
            if self.isChooseView {
                let className = "\(cell.classForCoder)"
                if self.chooseType.range(of: className) != nil {
                    
                    let  btn = UIButton.init(type: .custom)
                    self.chooseShow(cell: cell, isShow: true, listArray: self.chooseList as NSArray, btn: btn)
                    btn.addTarget(self, action: #selector(cellBtnClick(btn:)), for: .touchUpInside)
                }
                else{
                    self.chooseShow(cell: cell, isShow: false, listArray: self.chooseList as NSArray, btn: UIButton())
                }
            }
            if cell.isKind(of: ThemeMessageCell.self) {
                (cell as! ThemeMessageCell).didJoin = {
                    (themeId:String) in
                    //                    print(themeId)
                    let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: themeId)
                    self.navigationController?.pushViewController(talk!, animated: true)
                }
            }
            
            //            print(subView.value(forKey: "headerImageView"))
            cell.delegate = self
            
            
        }
    }
    
    
    @objc func cellBtnClick(btn:UIButton){
        
        let view  =  btn.superview
        let imageView:UIImageView = view?.viewWithTag(1234) as! UIImageView
        if (self.chooseList.contains("\(btn.tag)")) {
            self.chooseList.remove(at: (self.chooseList.index(of: "\(btn.tag)")!))
            imageView.image = UIImage.init(named: "logic_normal")
            
        }else{
            self.chooseList.append("\(btn.tag)")
            imageView.image = UIImage.init(named: "logic_select")
        }
        
    }
    
    
    
    override func willAppendAndDisplay(_ message: RCMessage!) -> RCMessage! {
        let newme = super.willAppendAndDisplay(message)
        
        print(message)
        return newme
    }
    
    
    
    
    
    //MARK: -----------RCMessageCellDelegate  cell点击事件------------------------//
    override func didLongTouchMessageCell(_ model: RCMessageModel!, in view: UIView!) {
        if self.isChooseView {
            
        }else{
            super.didLongTouchMessageCell(model, in: view)
        }
    }
    var selectRCMessageModel:RCMessageModel?
    
    override func didTapMessageCell(_ model: RCMessageModel!) {
        super.didTapMessageCell(model)
        
        if model.content.isKind(of: ThemeMessageContent.self) {
            let predicate = NSPredicate(format:"userid == %@ AND groupid == %@  AND is_delete == '0'", sharePublicDataSingle.publicData.userid,(model.content as! ThemeMessageContent).themeId)
            let results = GroupUserModel.objects(with: predicate)
            if results.count == 0 {
                GroupRequest.getGroupSubjectInfo(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":(model.content as! ThemeMessageContent).themeId], hadToast: true, fail: { (dic) in
                    
                }) { (dic) in
                    let results2 = GroupUserModel.objects(with: predicate)
                    if results2.count == 0 {
                        GroupRequest.joinGroupSubject(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":(model.content as! ThemeMessageContent).themeId], hadToast: true, fail: { (error) in
                            
                        }, success: { (dic) in
                            let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: (model.content as! ThemeMessageContent).themeId)
                            self.navigationController?.pushViewController(talk!, animated: true)
                        })
                    }else{
                        let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: (model.content as! ThemeMessageContent).themeId)
                        self.navigationController?.pushViewController(talk!, animated: true)
                    }
                }
            }else{
                let talk = ThemeChatVC(conversationType: RCConversationType.ConversationType_GROUP, targetId: (model.content as! ThemeMessageContent).themeId)
                self.navigationController?.pushViewController(talk!, animated: true)
            }
        }
        if model.content.isKind(of: HistoryMessageContent.self) {
            let webView = WKWebView.init(frame: self.view.frame)
            let wbc = BaseViewController.init()
            wbc.configBackItem()
            wbc.title = (model.content as! HistoryMessageContent).title
            wbc.view = webView
            webView.load(URLRequest.init(url: URL.init(string: (model.content as! HistoryMessageContent).url)!))
            self.navigationController?.pushViewController(wbc, animated: true)
            
            //            self.didTapUrl(inMessageCell: (model.content as! HistoryMessageContent).url, model: model)
        }
    }
    
    override func getLongTouchMessageCellMenuList(_ model: RCMessageModel!) -> [UIMenuItem]! {
        var menuList = super.getLongTouchMessageCellMenuList(model)
        self.selectRCMessageModel = model
        isMsgCopy = true
        if self.selectRCMessageModel?.objectName == "RC:ImgMsg" {
            let callBackBtn = UIMenuItem.init(title: "复制", action: #selector(callCopyBtnAction(_:)))
            menuList?.append(callBackBtn)
        }
        
        if model.senderUserId == sharePublicDataSingle.publicData.im_userid{
            
            let send:Double = Double((self.selectRCMessageModel?.sentTime)!)
            
            let interval:TimeInterval = Date().timeIntervalSince1970 * 1000
            if interval - send <= 120*1000  {
                
                
                let callBackBtn = UIMenuItem.init(title: "撤回", action: #selector(callBackBtnAction(_:)))
                menuList?.append(callBackBtn)
                
                
            }
            
            
            
        }
        
        if self.selectRCMessageModel?.objectName == "RC:ImgMsg" || self.selectRCMessageModel?.objectName == "RC:TxtMsg" || self.selectRCMessageModel?.objectName == "RC:VcMsg"{
            
            let callBackBtn = UIMenuItem.init(title: "转发", action: #selector(repeatAction(_:)))
            menuList?.append(callBackBtn)
            
        }
        
        
        
        if self.selectRCMessageModel?.objectName == "RC:ImgMsg" || self.selectRCMessageModel?.objectName == "RC:TxtMsg"{
            let moreBtn = UIMenuItem.init(title: "更多…", action: #selector(moreAction(_:)))
            menuList?.append(moreBtn)
        }
        
        
        
        
        
        return menuList
    }
    
    
    
    
    
    @objc func callCopyBtnAction(_ btn:Any) {
        
        //        for i in 0..< self.conversationMessageCollectionView.visibleCells.count {
        //
        //        }
        for i in 0..<self.conversationMessageCollectionView.visibleCells.count {
            let cell = self.conversationMessageCollectionView.visibleCells[i]
            guard cell is RCMessageCell else {
                continue
            }
            
            let myCell:RCMessageCell = cell as! RCMessageCell
            
            if myCell.model.messageId == self.selectRCMessageModel?.messageId {
                let fullImageUrl = (myCell.model.content as! RCImageMessage).imageUrl
                //                print(fullImageUrl)
                let myImageCell:RCImageMessageCell = myCell as! RCImageMessageCell
                let pasteboard:UIPasteboard = UIPasteboard.general
                pasteboard.image = myImageCell.pictureView.image
                
                if fullImageUrl?.range(of: "http://") != nil{
                    DispatchQueue.global().async {
                        do{
                            let fullImage = try UIImage.init(data: Data.init(contentsOf: URL.init(string: fullImageUrl!)!))
                            DispatchQueue.main.async {
                                pasteboard.image = fullImage
                            }
                        }catch{
                            print(error)
                        }
                    }
                }else{
                    //                    do{
                    //                    print(fullImageUrl as! String)
                    //                    print(Bundle.main.resourcePath)
                    //                    print(NSData.init(contentsOf: URL(fileURLWithPath: fullImageUrl as! String)))
                    //                    try print(NSData.init(contentsOfFile: fullImageUrl!, options: NSData.ReadingOptions.init(rawValue: 0)))
                    //                    }
                    //                    catch{
                    //                        print(error)
                    //                    }
                    //
                    pasteboard.image = UIImage.init(contentsOfFile: fullImageUrl!)
                }
            }
        }
    }
    
    
    
    
    
    override func paste(_ btn:(Any)?){
        
        let pasteboard:UIPasteboard = UIPasteboard.general
        if pasteboard.image != nil {
            
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            
            let paste:PasteView = Bundle.main.loadNibNamed("PasteView", owner: self, options: nil)?.last as! PasteView
            paste.frame = CGRect(x: 0, y: 0, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
            paste.imageView.image = pasteboard.image
            UIApplication.shared.keyWindow?.addSubview(paste)
            
            paste.sendBtnClick {[weak self] in
                let message:RCImageMessage = RCImageMessage.init(image: pasteboard.image)
                self?.sendMessage(message, pushContent:PublicDataSingle.makePushContent(message, groupId: (self?.targetId)!))
            }
        }
        else{
            super.paste(btn)
        }
        
    }
    
    
    
    
    
    @objc func callBackBtnAction(_ btn:Any) {
        //callback
        
        self.recallMessage((self.selectRCMessageModel?.messageId)!)
        UserRequest.withdraw_message(params: ["app_token":sharePublicDataSingle.token,"msg_uid":self.selectRCMessageModel?.messageUId,"groupid":self.targetId], hadToast: true, fail: { (error) in
            
        }) { (dic) in
            
        }
    }
    @objc func repeatAction(_ btn:Any) {
        
        
        //callback
        //        self.recallMessage((self.selectRCMessageModel?.messageId)!)
        let aaa = SelectMyGroup()
        aaa.targetId = self.targetId  //当前所在群组的groupid
        aaa.message = self.selectRCMessageModel?.content
        aaa.iszhuanfa = true
        aaa.finishSelect = {
            sGroupList,otherText in
            
            for sGroupOne in sGroupList {
                let gModel = sGroupOne as! GroupModel
                if gModel.groupid == self.gModel?.parentid {//转发到本群
                    let Tab:TMTabbarController = self.navigationController?.children[1] as! TMTabbarController
                    let smak:SmallTalkVC = Tab.viewControllers?.first as! SmallTalkVC
                    smak.isRunApi = false //设置为false,返回到闲聊会话会滚动到底部显示最新消息
                    
                }
                RCIM.shared().sendMessage(.ConversationType_GROUP, targetId: gModel.groupid, content: self.selectRCMessageModel?.content, pushContent: PublicDataSingle.makePushContent(self.selectRCMessageModel?.content, groupId: gModel.groupid), pushData: PublicDataSingle.makePushContent(self.selectRCMessageModel?.content, groupId: gModel.groupid), success: { (Int) in
                    
                    if otherText != "" {
                        DispatchQueue.main.async {
                            RCIM.shared().sendMessage(.ConversationType_GROUP, targetId: gModel.groupid, content: RCTextMessage.init(content: otherText), pushContent: PublicDataSingle.makePushContent(RCTextMessage.init(content: otherText), groupId: gModel.groupid), pushData: PublicDataSingle.makePushContent(RCTextMessage.init(content: otherText), groupId: gModel.groupid), success: { (Int) in
                                
                            }, error: { (RCErrorCode, Int) in
                                
                            })
                        }
                    }
                }, error: { (RCErrorCode, Int) in
                    
                })
                
                
            }
            self.navigationController?.view.makeToast("转发成功", duration: 1.0, position: CSToastPositionCenter)
            
            self.navigationController?.popViewController(animated: true)
            
            
        }
        
        self.navigationController?.pushViewController(aaa, animated: true)
        
    }
    
    
    
    
    func makeNavigationRightBtn() {
        if isZhuantui == true {
            let rightBtn = UIButton.init(type: .system)
            rightBtn.setTitle("确定", for: .normal)
            rightBtn.sizeToFit()
            let rightBarButtonItem = UIBarButtonItem.init(customView: rightBtn)
            rightBtn.addTarget(self, action: #selector(retweetSureBtnDidClick), for: .touchUpInside)
            self.navigationItem.rightBarButtonItem = rightBarButtonItem
            
            isChooseView = true
            //收回键盘
            if self.chatSessionInputBarControl.inputTextView.isFirstResponder {
                self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            }
            self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: SCREEN_WIDTH, height: SCREEN_HEIGHT - NAV_HEIGHT)
            self.chatSessionInputBarControl.isHidden = true
            return
        }
        let rightBtn = UIButton.init(type: .system)
        rightBtn.frame =  CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight)
        
        let rightBtn2 = UIButton.init(type: .system)
        rightBtn2.frame =  CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight)
        
        rightBtn.setImage(UIImage.init(named: "theme_transmit_big"), for: .normal)
        rightBtn.addTarget(self, action: #selector(retweetBtnDidClick), for: .touchUpInside)
        
        rightBtn2.setImage(UIImage.init(named: "search_white"), for: .normal)
        rightBtn2.addTarget(self, action: #selector(searchBtnDidClick), for: .touchUpInside)
        
        rightBtn.sizeToFit()
        rightBtn2.sizeToFit()
        
        
        
        let rightBarButtonItem = UIBarButtonItem.init(customView: rightBtn)
        let rightBarButtonItem2 = UIBarButtonItem.init(customView: rightBtn2)
        let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",self.targetId)).firstObject() as! GroupModel?
        if groupModel?.is_delete == "1" {//已经解散了
            self.navigationItem.rightBarButtonItem = rightBarButtonItem2
        }else{
            let array = [rightBarButtonItem,rightBarButtonItem2]
            self.navigationItem.rightBarButtonItems = array
        }
    }
    @objc func retweetBtnDidClick(button: UIButton) {
        let vc = ThemeRetweetVC()
        vc.thisThemeId = self.targetId
        self.navigationController?.pushViewController(vc, animated: true)
    }
    @objc func searchBtnDidClick(button: UIButton) {
        let v = ChatContentSearchVC()
        v.targetId = self.targetId
        
        self.navigationController?.pushViewController(v, animated: true)
    }
    
    @objc func retweetSureBtnDidClick(button: UIButton){//选择完转推消息后确认按钮点击事件
        var idlist = Array<String>.init()
        
        for  idStr in self.chooseList {
            for oneMessage in self.conversationDataRepository {
                let oneM = oneMessage as! RCMessageModel
                if idStr == "\(oneM.messageId)"{
                    idlist.append(oneM.messageUId)
                    break
                }
            }
        }
        
        self.finishSelect(idlist)
    }
    
    override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        
        let model:RCMessageModel = self.conversationDataRepository[indexPath.row] as! RCMessageModel
        if model.objectName == "RC:VcMsg"
        {
            //                return super.collectionView(collectionView, cellForItemAt: indexPath)
            let cell:MyVoiceCell = collectionView.dequeueReusableCell(withReuseIdentifier: "voice", for: indexPath) as! MyVoiceCell
            cell.setDataModel(model)
            cell.myDelegate = self as! MyVoiceViewCellDelegate
            cell.delegate = self as! RCMessageCellDelegate
            //多选时语音不可点击
            self.willDisplayMessageCell(cell, at: indexPath)
            return  cell as UICollectionViewCell
            
            
        }
        else if model.objectName == "ProjectVoiceMessageContent"
        {
            let cell:ProjectVoiceMessageContentCell = collectionView.dequeueReusableCell(withReuseIdentifier: "ProjectVoiceMessageContent", for: indexPath) as! ProjectVoiceMessageContentCell
            cell.setDataModel(model)
            
            
            
            if shareAVManager.player != nil {
                
                if cell.model.messageId == shareAVManager.model?.messageId {
                    if (shareAVManager.player?.isPlaying)!{
                        cell.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                    }else {
                        if shareAVManager.player?.currentTime != 0 {
                            cell.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                        }
                    }
                }
                
            }
            
            
            cell.click = {[weak cell,weak collectionView] (model) in
                
                if cell?.model.messageId == shareAVManager.model?.messageId {
                    
                    if shareAVManager.player != nil {
                        if (shareAVManager.player?.isPlaying)!{
                            shareAVManager.stopPlay()
                            cell?.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                            cell?.progress.progress = shareAVManager.currentProgress()
                            cell?.timeLable.text = shareAVManager.currentTime()
                            return
                        }else {
                            if shareAVManager.player?.currentTime != 0 {
                                shareAVManager.startPlay()
                                cell?.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                                cell?.progress.progress = shareAVManager.currentProgress()
                                
                                cell?.timeLable.text = shareAVManager.currentTime()
                                return
                            }
                            
                        }
                    }
                    
                    
                }
                
                shareAVManager.playUrlDataWithModel(progress: 0, mModel: model, compete: { (finish) in
                    
                    
                    
                    let array = collectionView?.visibleCells
                    if (array?.count)! > 0 {
                        for mycell in array! {
                            if mycell .isKind(of: ProjectVoiceMessageContentCell.self){
                                let myCell:ProjectVoiceMessageContentCell = mycell as! ProjectVoiceMessageContentCell
                                if myCell.model.messageId == shareAVManager.model?.messageId{
                                    myCell.progress.progress = shareAVManager.currentProgress()
                                    if finish {
                                        myCell.timeLable.text = "0:00"
                                        myCell.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                                        myCell.progress.progress = 0
                                        return
                                    }
                                }
                            }
                        }
                        
                    }
                    
                }, action: {
                    let array = collectionView?.visibleCells
                    if (array?.count)! > 0 {
                        for mycell in array! {
                            if mycell .isKind(of: ProjectVoiceMessageContentCell.self){
                                let myCell:ProjectVoiceMessageContentCell = mycell as! ProjectVoiceMessageContentCell
                                if myCell.model.messageId == shareAVManager.model?.messageId{
                                    myCell.progress.progress = shareAVManager.currentProgress()
                                    
                                    cell?.timeLable.text = shareAVManager.currentTime()
                                    cell?.btn.setImage(UIImage.init(named: "proStop"), for: .normal)
                                }else{
                                    myCell.progress.progress = 0
                                    cell?.btn.setImage(UIImage.init(named: "proStart"), for: .normal)
                                }
                            }
                        }
                        
                    }
                    
                    //                        }
                    
                })
            }
            return cell
            
        }else if model.objectName == "ProjectReportMessageContent"
        {
            let cell:ProjectReportMessageContentCell = collectionView.dequeueReusableCell(withReuseIdentifier: "ProjectReportMessageContent", for: indexPath) as! ProjectReportMessageContentCell
            cell.setDataModel(model)
            cell.clickWithUrl = { [weak self] (url)in
                let vc = MineReviseVC()
                vc.url = URL.init(string:url)
                self?.navigationController?.pushViewController(vc, animated: true)
            }
            return cell
        }
        else
        {
            //                print(model.objectName)
            return super.collectionView(collectionView, cellForItemAt: indexPath)
        }
    }
    
    @objc func moreAction(_ btn:Any) {
        
        //        isChooseView = true
        //        self.conversationMessageCollectionView.reloadData()
        self.doMoreAction(btn) { (list) in
            
        }
    }
    
    //更多按钮点击事件
    func doMoreAction(_ btn:Any,finishB:@escaping (Array<String>)->()) {
        //收回键盘
        if self.chatSessionInputBarControl.inputTextView.isFirstResponder {
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
        }
        self.chatSessionInputBarControl.resetToDefaultStatus()
        self.navigationController?.navigationBar.addSubview(coverNavBar)
        isChooseView = true
        self.conversationMessageCollectionView.reloadData()
        self.moreBottomView.creatBtnsWithImageNames(ImageNamesArr: ["more_transmit","more_delete"])
        self.moreBottomView.btnClickBlock = ({ [weak self](btn) in
            if let strongSelf = self{
                switch btn.tag {
                case 10:
                    if strongSelf.chooseList.count == 0 {
                        strongSelf.view.makeToast("请选择转发的内容", duration: 1.0, position: CSToastPositionCenter)
                        return
                    }
                    
                    let alertV = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet)
                    alertV.addAction(UIAlertAction(title: "取消", style: .cancel, handler: { (cAlert) in
                    }))
                    alertV.addAction(UIAlertAction(title: "逐条转发", style: .default, handler: { (cAlert) in
                        
                        var idlist = Array<RCMessageModel>.init()
                        for  idStr in strongSelf.chooseList {
                            for oneMessage in strongSelf.conversationDataRepository {
                                let oneM = oneMessage as! RCMessageModel
                                if idStr == "\(oneM.messageId)"{
                                    idlist.append(oneM)
                                    break
                                }
                            }
                        }
                        idlist.sort(by: { (model1, model2) -> Bool in
                            return model1.sentTime < model2.sentTime
                        })
                        let selectVC = SelectMyGroup()
                        selectVC.targetId = strongSelf.gModel?.groupid  //当前所在群组的groupid
                        selectVC.iszhuanfa = true
                        selectVC.finishSelect = {
                            sGroupList,otherText in
                            for sGroupOne in sGroupList {
                                let gModel = sGroupOne as! GroupModel
                                self?.sendListMessage(from: 0, idlist: idlist, ggModel: gModel, endMessage: otherText!)
                                
                                //                                for oneM in idlist {
                                //                                    if gModel.groupid == self?.gModel?.parentid {//转发到本群
                                //                                        let Tab:TMTabbarController = self!.navigationController?.childViewControllers[1] as! TMTabbarController
                                //                                        let smak:SmallTalkVC = Tab.viewControllers?.first as! SmallTalkVC
                                //                                        smak.sendMessage(oneM.content, pushContent: nil)
                                //                                        if otherText != "" {
                                //                                            smak.sendMessage(RCTextMessage.init(content: otherText), pushContent: otherText)
                                //                                        }
                                //                                    }else{
                                //                                        RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: oneM.content, pushContent: "转发", pushData: "转发", success: { (Int) in
                                //                                        }, error: { (RCErrorCode, Int) in
                                //                                        })
                                //                                        if otherText != "" {
                                //                                            RCIMClient.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: RCTextMessage.init(content: otherText), pushContent: otherText, pushData: otherText, success: { (Int) in
                                //                                            }, error: { (RCErrorCode, Int) in
                                //                                            })
                                //                                        }
                                //                                    }
                                //
                                //                                }
                                
                            }
                            strongSelf.navigationController?.view.makeToast("转发成功", duration: 1.0, position: CSToastPositionCenter)
                            
                            strongSelf.navigationController?.popViewController(animated: true)
                            strongSelf.cancleMoreAction(btn)
                        }
                        strongSelf.navigationController?.pushViewController(selectVC, animated: true)
                        
                    }))
                    alertV.addAction(UIAlertAction(title: "合并转发", style: .default, handler: { (cAlert) in
                        var idlist = ""
                        for  idStr in strongSelf.chooseList {
                            for oneMessage in strongSelf.conversationDataRepository {
                                let oneM = oneMessage as! RCMessageModel
                                if idStr == "\(oneM.messageId)"{
                                    idlist.append(oneM.messageUId+",")
                                    break
                                }
                            }
                        }
                        let selectVC = SelectMyGroup()
                        selectVC.targetId = strongSelf.gModel?.groupid  //当前所在群组的groupid
                        selectVC.iszhuanfa = true
                        selectVC.finishSelect = {
                            sGroupList,otherText in
                            strongSelf.progressShow()
                            GroupRequest.forwardGroupSubject(params: ["app_token":sharePublicDataSingle.token,"groupid":strongSelf.gModel?.groupid,"msg_uid_str":idlist,"is_all":false], hadToast: true, fail: { [weak self](errorDic) in
                                if let strongSelf = self{
                                    strongSelf.progressDismiss()
                                }
                                print(errorDic)
                                }, success: { [weak self](succDic) in
                                    if let strongSelf = self{
                                        strongSelf.progressDismiss()
                                        let nMessage = HistoryMessageContent.init()
                                        nMessage.title = succDic["title"] as! String
                                        nMessage.content = succDic["content"] as! String
                                        nMessage.url = succDic["forwardUrl"] as! String
                                        
                                        for sGroupOne in sGroupList {
                                            let gModel = sGroupOne as! GroupModel
                                            if gModel.groupid == self?.gModel?.parentid {//转发到本群
                                                let Tab:TMTabbarController = self!.navigationController?.children[1] as! TMTabbarController
                                                let smak:SmallTalkVC = Tab.viewControllers?.first as! SmallTalkVC
                                                smak.isRunApi = false
                                                
                                            }
                                            RCIM.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: nMessage, pushContent: PublicDataSingle.makePushContent(nMessage, groupId: gModel.groupid), pushData: PublicDataSingle.makePushContent(nMessage, groupId: gModel.groupid), success: { (Int) in
                                                if otherText != "" {
                                                    DispatchQueue.main.async {
                                                        RCIM.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: gModel.groupid, content: RCTextMessage.init(content: otherText), pushContent: PublicDataSingle.makePushContent(RCTextMessage.init(content: otherText), groupId: gModel.groupid), pushData: PublicDataSingle.makePushContent(RCTextMessage.init(content: otherText), groupId: gModel.groupid), success: { (Int) in
                                                        }, error: { (RCErrorCode, Int) in
                                                        })
                                                    }
                                                }
                                            }, error: { (RCErrorCode, Int) in
                                            })
                                            
                                        }
                                        
                                        strongSelf.navigationController?.view.makeToast("转发成功", duration: 1.0, position: CSToastPositionCenter)
                                        
                                        strongSelf.navigationController?.popViewController(animated: true)
                                        
                                        
                                    }
                                    
                            })
                            
                            
                            strongSelf.cancleMoreAction(btn)
                            
                        }
                        strongSelf.navigationController?.pushViewController(selectVC, animated: true)
                    }))
                    
                    strongSelf.present(alertV, animated: true, completion: nil)
                    
                    print("转发")
                case 11:
                    if strongSelf.chooseList.count == 0 {
                        strongSelf.view.makeToast("请选择删除的内容", duration: 1.0, position: CSToastPositionCenter)
                        return
                    }
                    
                    for idStr in strongSelf.chooseList {
                        for oneMessage in strongSelf.conversationDataRepository {
                            let oneM = oneMessage as! RCMessageModel
                            if idStr == "\(oneM.messageId)"{
                                strongSelf.deleteMessage(oneM)
                                break
                            }
                        }
                    }
                    
                    //todo没有找到更好的方法，暂时这么处理
                    DispatchQueue.main.asyncAfter(deadline: DispatchTime.now()+0.5, execute: {
                        strongSelf.cancleMoreAction(btn)
                    })
                    
                    print("删除")
                default:
                    break
                }
            }
        })
        self.view.addSubview(self.moreBottomView)
        self.chatSessionInputBarControl.isHidden = true
    }
    
    func doSelectAction(_ btn:Any,finishB:@escaping (Array<String>)->()) {
        isChooseView = true
        //收回键盘
        if self.chatSessionInputBarControl.inputTextView.isFirstResponder {
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
        }
        //        self.conversationMessageCollectionView.reloadData()
        self.moreBottomView.creatBtnsWithTitleNames(TitleNamesArr: ["取消","确定"])
        self.moreBottomView.btnClickBlock = ({ (btn) in
            
            var idlist = Array<String>.init()
            
            for  idStr in self.chooseList {
                for oneMessage in self.conversationDataRepository {
                    let oneM = oneMessage as! RCMessageModel
                    if idStr == "\(oneM.messageId)"{
                        idlist.append(oneM.messageUId)
                        break
                    }
                }
            }
            
            switch btn.tag {
            case 10:
                print("转发")
            //                finishB(idlist)
            case 11:
                print("删除")
                finishB(idlist)
            default:
                break
            }
            
        })
        self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: SCREEN_WIDTH, height: SCREEN_HEIGHT - NAV_HEIGHT)
        //        self.view.addSubview(self.moreBottomView)
        self.chatSessionInputBarControl.isHidden = true
    }
    
    func sendListMessage(from:Int ,idlist:Array<RCMessageModel> , ggModel:GroupModel ,endMessage:String) {
        
        if idlist.count == from{
            if endMessage != "" {
                DispatchQueue.main.async {
                    if ggModel.groupid == self.gModel?.parentid {//转发到本群
                        if self.navigationController != nil{
                            let Tab:TMTabbarController = self.navigationController?.children[1] as! TMTabbarController
                            let smak:SmallTalkVC = Tab.viewControllers?.first as! SmallTalkVC
                            smak.isRunApi = false
                        }
                    }
                    RCIM.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: ggModel.groupid, content: RCTextMessage.init(content: endMessage), pushContent: PublicDataSingle.makePushContent(RCTextMessage.init(content: endMessage), groupId: ggModel.groupid), pushData: PublicDataSingle.makePushContent(RCTextMessage.init(content: endMessage), groupId: ggModel.groupid), success: { (Int) in
                    }, error: { (RCErrorCode, Int) in
                    })
                }
            }
            return
        }
        
        let oneM = idlist[from]
        DispatchQueue.main.async {
            if ggModel.groupid == self.gModel?.parentid {//转发到本群
                if self.navigationController != nil{
                    let Tab:TMTabbarController = self.navigationController?.children[1] as! TMTabbarController
                    let smak:SmallTalkVC = Tab.viewControllers?.first as! SmallTalkVC
                    smak.isRunApi = false
                    
                }
                
            }
            RCIM.shared().sendMessage(RCConversationType.ConversationType_GROUP, targetId: ggModel.groupid, content: oneM.content, pushContent: "[转发]"+PublicDataSingle.makePushContent(oneM.content, groupId: ggModel.groupid), pushData: "[转发]"+PublicDataSingle.makePushContent(oneM.content, groupId: ggModel.groupid), success: { (Int) in
                Thread.sleep(forTimeInterval: 0.1)
                self.sendListMessage(from: from+1, idlist: idlist, ggModel: ggModel, endMessage: endMessage )
            }, error: { (RCErrorCode, Int) in
                Thread.sleep(forTimeInterval: 0.1)
                self.sendListMessage(from: from+1, idlist: idlist, ggModel: ggModel, endMessage: endMessage )
            })
        }
        
    }
    
    //取消更多点击事件
    @objc func cancleMoreAction(_ btn:Any) {
        coverNavBar.removeFromSuperview()
        isChooseView = false
        self.chooseList.removeAll()
        self.conversationMessageCollectionView.reloadData()
        self.moreBottomView.removeFromSuperview()
        self.chatSessionInputBarControl.isHidden = false
        
    }
    
    
    
    
    
    func avfinish(){
        
        
        //        let mArray = notification.object as! Array<Any>
        //        let m:RCMessageModel = mArray[0] as! RCMessageModel
        
        if shareAVManager.isAuto != true {
            return
        }
        
        if shareAVManager.model?.messageDirection == .MessageDirection_SEND {
            //自己发的消息不用做自动播放处理
            return
        }
        
        
        let m:RCMessageModel = shareAVManager.model!
        
        guard m.targetId == self.targetId else {
            //必须保证 当前播放的语音消息 是属于当前聊天场景（后续可能会添加 话题等，由于系统设计tabbarcontroller 会出现同时有多个聊天场景共存的现象）  否则没有必要去做接下来的处理
            return
        }
        
        
        //需要将播放完成语音消息  接收状态改变
        let i = self.conversationDataRepository.index(of: m)
        m.receivedStatus = .ReceivedStatus_LISTENED
        
        //在滑动的时候 可能会出现越界 因此要加一个判断
        if self.conversationDataRepository.count>=i
        {
            self.conversationDataRepository.replaceObject(at: i, with: m)
        }
        
        //        如果刚播完的语音在播放前不是未读  就没有必要做自动播放
        
        
        
        //拿到当前屏幕上显示的cell  并做类型过滤
        var array = Array<Any>()
        
        if self.conversationMessageCollectionView.visibleCells.count > 0 {
            for i in 0..<self.conversationMessageCollectionView.visibleCells.count {
                let cell = self.conversationMessageCollectionView.visibleCells[i]
                
                guard cell is MyVoiceCell else {
                    continue
                }
                
                let cuCell:MyVoiceCell = cell as! MyVoiceCell
                if cuCell.model.messageDirection == .MessageDirection_RECEIVE && cuCell.model.receivedStatus != .ReceivedStatus_LISTENED {
                    array.append(cell)
                }
                
            }
            
        }
        
        
        
        if array.count > 0
        {
            
            
            //必须做排序  必须做！！！ 必须做！！！ 必须做！！！
            //拿到的屏幕显示的数据  并不会按照cell显示的顺序存放到数组
            array = array.sorted(by: { (cell1, cell2) -> Bool in
                let cell11:RCMessageCell = cell1 as! RCMessageCell
                let cell22:RCMessageCell = cell2 as! RCMessageCell
                return cell22.model.messageId > cell11.model.messageId
            })
            
            
            
            //我们是要做语音消息的处理  所以保证接下来处理的cell类型为语音类型
            for i in 0..<array.count {
                let cell  = array[i]
                
                /// 先在显示到屏幕的cell中去做处理 只要找到符合条件的就播放 并跳出循环
                let myCell:MyVoiceCell = cell as! MyVoiceCell
                if myCell.model.receivedStatus != RCReceivedStatus.ReceivedStatus_LISTENED {
                    
                    if myCell.model.messageId > (shareAVManager.model?.messageId)! {
                        myCell.play()
                        return
                    }
                }
                
            }
        }else{
            
            self.conversationMessageCollectionView.reloadData()
            
        }
        
        
        // 当把当前屏幕显示的所有未播放的播放完   要到数据源里去找未播放的语音
        for i in 0..<self.conversationDataRepository.count {
            let model:RCMessageModel = self.conversationDataRepository[i] as! RCMessageModel
            
            guard model.messageDirection == .MessageDirection_RECEIVE else {
                continue
            }
            
            
            if model.objectName == "RC:VcMsg" && model.receivedStatus != RCReceivedStatus.ReceivedStatus_LISTENED {
                
                if model.messageId > (shareAVManager.model?.messageId)! {
                    
                    shareAVManager.playAudioWithModel(progress: 0, mModel: model, compete: {[weak self] (finish) in
                        if finish == true{
                            self?.avfinish()
                        }
                        
                        
                        }, action: {
                            
                    })
                    
                    
                    return
                }
                else{
                    continue
                }
                
                
                
            }
            
            
            
            
        }
        
    }
    
    
    
    
    
    
    
    
    /// 点击头像 响应事件
    ///
    /// - Parameter userId: <#userId description#>
    override func didTapCellPortrait(_ userId: String!) {
        
        print("点击了用户头像--用户id--"+userId)
        let userid = userId.substring(to: (userId.range(of: "-")?.lowerBound)!)
//        let str = "{\"action\":\"goto\",\"data\":{\"data\":"+userId.substring(to: (userId.range(of: "-")?.lowerBound)!)+",\"subAction\":\"personDetail\"}}"
        //        let notice = NSNotification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : str])
        let notice = Notification.init(name: NSNotification.Name(rawValue: "touchOnePerson"), object: nil, userInfo: ["str" : userid])
        NotificationCenter.default.post(notice)
        
    }
    
    
    //MARK: - ----------------------更多底部按钮----------------------
    lazy var moreBottomView: MoreSelectBottomView = {
        var moreBottomView = MoreSelectBottomView.init(frame: CGRect.init(x: 0, y: MAIN_SCREEN_HEIGHT_PX - 50, width: kScreenW, height: 50))
        return moreBottomView
    }()
    
    //MARK: - ----------------------更多选择时遮盖导航栏----------------------
    lazy var coverNavBar: UINavigationBar = {
        var coverNavBar = UINavigationBar.init(frame: (self.navigationController?.navigationBar.bounds)!)
        let cancleBtn = UIButton.init()
        cancleBtn.setTitle("取消", for: .normal)
        cancleBtn.setTitleColor(UIColor.white, for: .normal)
        cancleBtn.sizeToFit()
        cancleBtn.addTarget(self, action: #selector(cancleMoreAction(_:)), for: .touchUpInside)
        coverNavBar.addSubview(cancleBtn)
        let titleLabel = UILabel.init()
        titleLabel.text = self.gModel?.group_name
        titleLabel.textColor = UIColor.white
        titleLabel.textAlignment = .center
        titleLabel.sizeToFit()
        coverNavBar.addSubview(titleLabel)
        cancleBtn.mas_makeConstraints({ (make) in
            make!.left.equalTo()(20)
            make!.centerY.equalTo()(coverNavBar)
        })
        titleLabel.mas_makeConstraints({ (make) in
            make!.width.equalTo()(SCREEN_WIDTH - 2 * (cancleBtn.frame.size.width + 30))
            make!.center.equalTo()(coverNavBar)
        })
        return coverNavBar
    }()
    
    
    
    //MARK: - ---------------------刷新用户信息 做头像  名称的刷新----------------------
    func  refreshUserInfoOrGroupInfo(){
        
        
        if self.conversationType == .ConversationType_GROUP{
            let predicate = NSPredicate.init(format: "groupid == %@ AND is_delete == '0'", argumentArray: [self.targetId])
            let groupUser =  GroupUserModel.objects(with: predicate)
            for i in 0..<groupUser.count {
                let gModel:GroupUserModel = groupUser.object(at: i) as! GroupUserModel
                let userModelTemp : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", gModel.userid)).firstObject() as! UserModel?
                
                let userModel = RCUserInfo.init()
                userModel.userId = gModel.im_userid
                userModel.name = userModelTemp?.realname
                
                if userModelTemp?.avater  == nil || userModelTemp?.avater == "" {
                    userModel.portraitUri = kBASE_URL +  "static/images/userpic.jpg" //正式
                    //                    userModel.portraitUri = "http://t-tcp.xslp.cn/static/images/userpic.jpg"
                }
                else
                {
                    
                    userModel.portraitUri = userModelTemp?.avater
                    
                }
                
                RCIM.shared().refreshUserInfoCache(userModel, withUserId: userModel.userId)
            }
            
            
        }
        
    }
    
    /// 给发消息加推送
    ///
    /// - Parameters:
    ///   - messageContent: 消息内容
    ///   - pushContent: 消息推送内容
    override func sendMessage(_ messageContent: RCMessageContent!, pushContent: String!) {
        super.sendMessage(messageContent, pushContent: PublicDataSingle.makePushContent(messageContent, groupId: self.targetId))
    }
    
    //MARK: - ---------------------消息将要发送----------------------
    override func willSendMessage(_ messageContent: RCMessageContent!) -> RCMessageContent! {
        
        if messageContent.isMember(of: RCTextMessage.self){
            
            // atArray 中存放的是要@的对象
            if (self.atArray?.count != 0){
                
                let array:NSArray = NSArray.init(array: self.atArray!)
                messageContent.mentionedInfo = RCMentionedInfo.init(mentionedType:.mentioned_Users, userIdList: array.value(forKeyPath: "im_userid") as! [Any]?, mentionedContent:nil)
                self.atArray?.removeAll()
                return messageContent
            }
            else {
                //@全体
                let textMsg:RCTextMessage = messageContent as! RCTextMessage
                if textMsg.content.contains("@全体")  {
                    messageContent.mentionedInfo = RCMentionedInfo.init(mentionedType:.mentioned_All, userIdList: nil, mentionedContent:nil)
                    return messageContent
                }
                
                return super.willSendMessage(messageContent)
                
            }
            
            
        }
        return super.willSendMessage(messageContent)
    }
    
    
    //MARK: - ---------------------每次输入框输入的内容发生变化的回调----------------------
    override func inputTextView(_ inputTextView: UITextView!, shouldChangeTextIn range: NSRange, replacementText text: String!) {
        
        guard text != nil else {
            
            super.inputTextView(inputTextView, shouldChangeTextIn: range, replacementText: text)
            return
        }
        if text == "@"{
            
            let vc =   GroupChooseMemberVC()
            vc.groupId = targetId
            vc.backWithUserName(username: {[weak self] (user) in
                //                let imId = user.userid.appending("-0")
                self?.atArray?.append(user)
                inputTextView.text.append(user.realname)
                inputTextView.text.append(" ")
            })
            
            self.navigationController?.pushViewController(vc, animated: true)
        }
        else{
            
            //每次当有删除的时候 如果输入框中不包括数组中的数据  说明该数据就是被删除了
            if self.atArray?.count == 0 || text != ""{
                return
            }
            var inputText = inputTextView.text as NSString
            let deleteText:NSString = inputText.substring(with: NSRange.init(location: inputTextView.selectedRange.location-1, length: 1)) as NSString
            if deleteText.isEqual(to: " ") {
                
                
                inputText = inputText.substring(to: inputTextView.selectedRange.location-1) as NSString
                
                var userTempStr = String()
                var indexTemp:Int = 0
                for i in (0..<inputText.length-1).reversed(){
                    let str = inputText.substring(with:NSRange(location: i,length: 1))
                    if str == "@" {
                        
                        let start = inputTextView.text.index(inputTextView.text.startIndex, offsetBy: i)
                        let end = inputTextView.text.index(inputTextView.text.startIndex, offsetBy: inputTextView.selectedRange.location)
                        let range = Range.init(uncheckedBounds: (start,end))
                        
                        userTempStr = inputTextView.text.substring(with: range)
                        
                        indexTemp = i
                        break
                    }
                }
                
                guard !userTempStr.isEmpty else {
                    return
                }
                for i in 0..<self.atArray!.count {
                    
                    let model:GroupUserModel = (self.atArray?[i])!
                    let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", model.userid)).firstObject() as! UserModel?
                    
                    let username = String.init(format: "@%@ ", userModel?.realname != nil ? (userModel?.realname)! : "")
                    
                    if username  == userTempStr {
                        self.atArray?.remove(at: i)
                        let startIndex = inputTextView.text.index(inputTextView.text.startIndex, offsetBy: indexTemp)
                        let endIndex = inputTextView.text.index(inputTextView.text.startIndex, offsetBy: inputTextView.selectedRange.location)
                        
                        let t = Range(uncheckedBounds:(startIndex,endIndex))
                        
                        inputTextView.text = inputTextView.text.replacingCharacters(in: t ,with: " ")
                        
                        break
                    }
                }
            }
            else{
                
                for i in 0..<self.atArray!.count {
                    
                    let model:GroupUserModel = (self.atArray?[i])!
                    let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", model.userid)).firstObject() as! UserModel?
                    
                    let username = String.init(format: "@%@ ", userModel?.realname != nil ? (userModel?.realname)! : "")
                    
                    if !inputTextView.text.contains(username) {
                        self.atArray?.remove(at: i)
                        break;
                    }
                    
                }
                
            }
            
            
        }
    }
    
    ///输入板点击加号后出来的按钮点击响应
    ///
    /// - Parameters:
    ///   - pluginBoardView: <#pluginBoardView description#>
    ///   - tag: <#tag description#>
    override func pluginBoardView(_ pluginBoardView: RCPluginBoardView!, clickedItemWithTag tag: Int) {
        if tag == 1601 || tag == 1602{ //语音/视频通话
            
            self.chatSessionInputBarControl.inputTextView.resignFirstResponder()
            let predicate = NSPredicate.init(format: "groupid == %@ AND is_delete == '0'", argumentArray: [self.targetId])
            let groupUsers =  GroupUserModel.objects(with: predicate)
            
            var vc : SelectMemberViewController?
            if tag == 1601{
                vc = SelectMemberViewController.init(conversationType: self.conversationType, targetId: self.targetId, mediaType: RCCallMediaType.audio, exist: [sharePublicDataSingle.publicData.im_userid], success: { [weak self](addUserIdList) in
                    
                    self?.callAudioVc = CallAudioMultiCallViewController.init(outgoingCall: (self?.conversationType)!, targetId: self?.targetId, mediaType: RCCallMediaType.audio, userIdList: addUserIdList)
                    self?.present((self?.callAudioVc)!, animated: true, completion: nil)
                })
            }
            if tag == 1602{
                vc = SelectMemberViewController.init(conversationType: self.conversationType, targetId: self.targetId, mediaType: RCCallMediaType.video, exist: [sharePublicDataSingle.publicData.im_userid], success: { [weak self](addUserIdList) in
                    
                    self?.callVideoVc = CallVideoMultiCallViewController.init(outgoingCall: (self?.conversationType)!, targetId: self?.targetId, mediaType: RCCallMediaType.video, userIdList: addUserIdList)
                    self?.present((self?.callVideoVc)!, animated: true, completion: nil)
                })
            }
            vc?.listingUserIdList = groupUsers.value(forKeyPath: "im_userid") as! [Any]
            self.present(vc!, animated: true, completion: nil)
        }
        else{
            super.pluginBoardView(pluginBoardView, clickedItemWithTag: tag)
        }
    }
    
    //MARK: - ---------------------自定义 @某个对象的时候   必须重写融云的该方法 融云的知识库里的说明----------------------
    override func showChooseUserViewController(_ selectedBlock: ((RCUserInfo?) -> Void)!, cancel cancelBlock: (() -> Void)!) {
        
    }
    
    
    
    
    //语音消息开始录音
    override func onBeginRecordEvent() {
        //应该把正在播放的语音关闭
        shareAVManager.stopPlay()
        self.scrollToBottom(animated: true)
        super.onBeginRecordEvent()
        
    }
    
    
    
    func scrollToIndexWithMessageId(model:ChatContentModel){
        
        isSearchBack = true
        //读取我们查到界面的前一条及后面所有条数（暂定1000条，超过就显示不全了）
        let newDataArr = RCIMClient.shared().getHistoryMessages(RCConversationType.ConversationType_GROUP, targetId: self.targetId, sentTime: model.time!, beforeCount: 1, afterCount: 1000)
        //移除原有截面数据，然后把查到的数据插入到当前界面数据列表中
        self.conversationDataRepository.removeAllObjects()
        for nemodel in newDataArr! {
            self.conversationDataRepository.insert(RCMessageModel.init(message: nemodel as! RCMessage), at: 0)
        }
        //刷新界面数据显示
        self.conversationMessageCollectionView.reloadData()
        //定位到最顶端（显示我们查到的数据）
        self.conversationMessageCollectionView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: false)
        
    }
    
    
    
    //处理播放的时候电话来了   TODO 需要整理
    func callPhoneNoti(){
        
        
        NotificationCenter.default.addObserver(self, selector: #selector(callPhone(notification: )), name: NSNotification.Name(rawValue: "AVAudioSessionInterruptionNotification"), object:nil)
        
    }
    
    @objc func callPhone(notification:Notification){
        
        
        let type:NSNumber = notification.userInfo?[AVAudioSessionInterruptionTypeKey] as! NSNumber
        
        
        if type == 1 {
            
            shareAVManager.finishBlock?(false)
            shareAVManager.saveProgress(time: 1)
            shareAVManager.player?.stop()
            
            shareAVManager.timerStop()
        }
    }
    
    
    
    
    
    
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    
    
}
//MARK: - ---------------------语音cell的代理----------------------
extension ThemeChatVC:MyVoiceViewCellDelegate{
    
    
    func addAlertView(title:String, message:String, actionTitles:Array<String>,okAction: ((UIAlertAction) -> Void)?, cancleAction: ((UIAlertAction) -> Void)?) {
        let alertController = UIAlertController.init(title: title, message: message, preferredStyle: .alert)
        for (index,actionTitle) in actionTitles.enumerated() {
            if index == 0 {
                alertController.addAction(UIAlertAction.init(title: actionTitle, style: .default, handler: { (action) in
                    okAction!(action)
                }))
            }
            if index > 0 && index == actionTitles.count - 1 {
                alertController.addAction(UIAlertAction.init(title: actionTitle, style: .cancel, handler: { (action) in
                    cancleAction!(action)
                }))
            }
        }
        self.present(alertController, animated: true, completion: nil)
    }
    
    func clickPlayAbortive(model: RCMessageModel) {
        
        
        
        guard model.targetId == self.targetId else {
            //必须保证 当前播放的语音消息 是属于当前聊天场景（后续可能会添加 话题等，由于系统设计tabbarcontroller 会出现同时有多个聊天场景共存的现象）  否则没有必要去做接下来的处理
            return
        }
        
        
        //需要将播放完成语音消息  接收状态改变
        let i = self.conversationDataRepository.index(of: model)
        model.receivedStatus = .ReceivedStatus_LISTENED
        
        //在滑动的时候 可能会出现越界 因此要加一个判断
        if self.conversationDataRepository.count>=i
        {
            self.conversationDataRepository.replaceObject(at: i, with: model)
        }
        
    }
    
    
    func clickPlay(cell:MyVoiceCell,model:RCMessageModel,progress:Double){
        
        if  shareAVManager.isPlaying() {
            
            if model.messageId == shareAVManager.model?.messageId {
                shareAVManager.oncePlay()
                
            }else{
                shareAVManager.stopPlay()
            }
            
            
        }
        
        
        shareAVManager.playAudioWithModel(progress:progress,mModel:model, compete: {[weak cell,weak self] (finish) in
            
            if let myCell = cell{
                if finish == true {
                    
                    
                    myCell.cellStatus(status: .finish)
                    self?.avfinish()
                }
                else{
                    myCell.cellStatus(status: .pause)
                }
            }
            
            
        }) {[weak cell]  in
            
            if (cell != nil)
            {
                DispatchQueue.main.async {
                    cell?.timeChange()
                }
                
                
            }
            else{
                
            }
        }
        
    }
    
}
//
//  TMTabbarController.swift
//  TMSwiftLearn
//
//  Created by harry on 17/2/7.
//  Copyright © 2017年 timer. All rights reserved.
//
import UIKit
//tabbar高度
let kTabBarHeight :Float = 49;
let kScreenW = UIScreen.main.bounds.width
//let kScreenH = UIScreen.main.bounds.height
class TMTabbarController: UITabBarController
{
    
    var currentBtn:TMTabbarButton?
    var groupModel:RCConversationModel?{
    
        didSet {
            creatChildViewControllers()
        }
    }
    
    lazy var titleArray:[String] =
    {
//       let array = ["闲聊","话题","文件","公告"]
        let array = ["闲聊","话题"]
       return array
    
    }()
    
//    lazy var vcArray:[String] =
//        {
//            let array = ["ViewController","ViewController","ViewController","ViewController"]
//            return array
//            
//    }()
    
    lazy var imageNomalArray:[String] =
    {
            let array = ["xljm5_Nomal","xljm6_Nomal","xljm8","xljm9"]
            return array
            
    }()
    
    
    lazy var imageSelectArray:[String] =
        {
            let array = ["xljm5_Select","xljm6_Select","xljm8","xljm9"]
            return array
            
    }()
    
    
    
    lazy var bgImageView :UIImageView =
        {
            let img = UIImageView(image: UIImage(named: "find_radio_default"))
            img.contentMode = .scaleAspectFill
            img.layer.masksToBounds = true
            img.isUserInteractionEnabled = true
            return img
            
    }()
    
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        self.view.backgroundColor = UIColor.hexString(hexString: "EFEFF4")
        tabBar.isHidden = true
        self.configBackItem()
        creatTab()
//        self.setRightBtnWithArray(items: [UIImage.init(named: "nav_groupSetting")])
//        self.navigationController?.setNavigationBarHidden(true, animated: true)
        // Do any additional setup after loading the view.
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
//         self.navigationController?.setNavigationBarHidden(true, animated: true)
    }
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
//        self.navigationController?.setNavigationBarHidden(false, animated: true)
    }
    override func didReceiveMemoryWarning()
    {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    override func rightBtnClick(button: UIButton) {
        let groupSettingVC : GroupSettingViewController = GroupSettingViewController()
        groupSettingVC.targetId = groupModel?.targetId
        self.navigationController?.pushViewController(groupSettingVC, animated: true)
    }
    
    
    /// 是否隐藏tab
    ///
    /// - Parameter isHidden: <#isHidden description#>
    func isHiddenTab(isHidden:Bool){
        
        bgImageView.isHidden = isHidden;
        for view in bgImageView.subviews {
            if view != nil {
                view.isHidden = isHidden
            }
        }
    }
    
    
    /// 消除主题红点显示
    func clearRedPoint(){
    
      let btn:TMTabbarButton? = bgImageView.viewWithTag(1001) as? TMTabbarButton
        if btn != nil {
            btn?.clearBadge()
        }
        
    }
    
    
    /// 显示红点提醒
    ///
    /// - Parameter type: 对应是哪个按钮 左--》右 0..1..2
    func showRedPoint(type:Int){
    
        let btn:TMTabbarButton? = bgImageView.viewWithTag(type+1000) as? TMTabbarButton
        
        if btn != nil {
            
            btn?.badgeCenterOffset = CGPoint.init(x:-(btn?.frame.size.width)!/2+10 , y: 16)
            btn?.showBadge(with: .redDot, value: 0, animationType: .none)
        }
    }
    
    
    
    
}
extension TMTabbarController
{
    
    /// 创建tab
    func creatTab()
    {
        bgImageView.frame = CGRect(x: 0, y: MAIN_SCREEN_HEIGHT_PX - 49, width: kScreenW, height: 49)
        bgImageView.backgroundColor = UIColor.groupTableViewBackground
        self.view.addSubview(bgImageView)
    }
    
    
    //MARK: 创建子控制器
    func creatChildViewControllers ()
    {
        for index  in 0..<titleArray.count
        {
           
//           let aClass = getClassWitnClassName(vcArray[index]) as! UIViewController.Type
//           let vc:UIViewController = aClass.init()
//          let nav = TabNavgationVC.init(rootViewController: vc)
//          vc.tabBarItem.title = titleArray[index]
//          vc.tabBarItem.image = UIImage(named:imageNomalArray[index])
//          vc.tabBarItem.selectedImage = UIImage(named:imageSelectArray[index])
//          vc.title = titleArray[index]
//           addChildViewController(nav)
            
           
            var cuVC :UIViewController?
            
            
            switch index {
            case 0:
                
                let vc = SmallTalkVC(conversationType: (groupModel?.conversationType)!, targetId: groupModel?.targetId)
//                let nav = TabNavgationVC.init(rootViewController: vc!)
                          vc?.tabBarItem.title = titleArray[index]
                          vc?.tabBarItem.image = UIImage(named:imageNomalArray[index])
                          vc?.tabBarItem.selectedImage = UIImage(named:imageSelectArray[index])
                          vc?.title = titleArray[index]
                addChild(vc!)
//                vc?.navigationController?.setNavigationBarHidden(true, animated: false)
//
                 cuVC = vc
            case 1:
                let vc = ThemeListVCViewController.init()
                let nav = TabNavgationVC.init(rootViewController: vc)
                vc.tabBarItem.title = titleArray[index]
                vc.tabBarItem.image = UIImage(named:imageNomalArray[index])
                vc.tabBarItem.selectedImage = UIImage(named:imageSelectArray[index])
                vc.title = titleArray[index]
                addChild(nav)
                cuVC = vc
//            case 2:
//                let vc = UIViewController.init()
//                let nav = TabNavgationVC.init(rootViewController: vc)
//                vc.tabBarItem.title = titleArray[index]
//                vc.tabBarItem.image = UIImage(named:imageNomalArray[index])
//                vc.tabBarItem.selectedImage = UIImage(named:imageSelectArray[index])
//                vc.title = titleArray[index]
//                addChildViewController(nav)
//                cuVC = vc
//            case 1:
//                let vc = TestVC.init()
//                let nav = TabNavgationVC.init(rootViewController: vc)
//                vc.tabBarItem.title = titleArray[index]
//                vc.tabBarItem.image = UIImage(named:imageNomalArray[index])
//                vc.tabBarItem.selectedImage = UIImage(named:imageSelectArray[index])
//                vc.title = titleArray[index]
//                addChildViewController(nav)
//                cuVC = vc
            default: break
                
            }
            
            
            
            let width :CGFloat = kScreenW/CGFloat(titleArray.count)
            let btn:TMTabbarButton = TMTabbarButton.init(frame:CGRect(x: width * CGFloat(index), y: 0, width: width, height: 49 ))
            btn.configWithItem((cuVC?.tabBarItem)!)
            btn.tag = index+1000
            
            bgImageView.addSubview(btn)
            btn.addTarget(self, action: #selector(btnClick(_ :)), for: UIControl.Event.touchUpInside)
            if index == 0 {
                
                self.selectedIndex = 0
                btn.isSelected = true
//                btn.backgroundColor = UIColor.hexString(hexString: "1782D2")
                currentBtn = btn;
            }
            
        }
    }
    
    @objc func btnClick(_ btn:TMTabbarButton)
    {
        
        if (currentBtn != nil)
        {
           currentBtn?.isSelected = false
            currentBtn?.backgroundColor = UIColor.groupTableViewBackground
        }
        btn.isSelected = true
        self.selectedIndex = btn.tag-1000
//        btn.backgroundColor = UIColor.hexString(hexString: "1782D2")
        currentBtn = btn
    
    }
    //获取工程的名字
    func getBundleName() -> String{
        var bundlePath = Bundle.main.bundlePath
        bundlePath = bundlePath.components(separatedBy: "/").last!
        bundlePath = bundlePath.components(separatedBy: ".").first!
        return bundlePath
    }
    //通过类名返回一个AnyClass
    func getClassWitnClassName(_ name:String) ->AnyClass?{
        let type = getBundleName() + "." + name
        return NSClassFromString(type)
    }
    
}
//
//  TMTabbarButton.swift
//  TMSwiftLearn
//
//  Created by harry on 17/2/7.
//  Copyright © 2017年 timer. All rights reserved.
//
import UIKit
class TMTabbarButton: UIButton {
   
    
   var item :UITabBarItem?
//   {
//    
//    
//    
//    didSet
//    {
//        item.addObserver(self, forKeyPath: "title", options: NSKeyValueObservingOptions(rawValue: 0), context: nil)
//        item.addObserver(self, forKeyPath: "image", options: NSKeyValueObservingOptions(rawValue: 0), context: nil)
//        item.addObserver(self, forKeyPath: "selectedImage", options: NSKeyValueObservingOptions(rawValue: 0), context: nil)
//        self.observeValue(forKeyPath: nil, of: nil, change: nil, context: nil)
//        
//    }
//    
//  }
//    
   override init(frame: CGRect)
   {
       super.init(frame: frame)
    imageView?.contentMode = UIView.ContentMode.center
       titleLabel?.textAlignment = NSTextAlignment.center
       titleLabel?.font = UIFont.systemFont(ofSize: 11)
       self.setTitleColor(UIColor.darkGray, for: .normal)
       self.setTitleColor(UIColor.hexString(hexString: "1782D2"), for: .selected)
    
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    deinit {
//         self.removeObserver(self, forKeyPath: "title", context: nil)
//        self.removeObserver(self, forKeyPath: "image", context: nil)
//        self.removeObserver(self, forKeyPath: "selectedImage", context: nil)
        
    }
    
    }
extension TMTabbarButton
{
    public func configWithItem(_ item :UITabBarItem)
    {
//        self.item = item;
//        self.item!.addObserver(self, forKeyPath: "title", options: NSKeyValueObservingOptions(rawValue: 0), context: nil)
//        self.item!.addObserver(self, forKeyPath: "image", options: NSKeyValueObservingOptions(rawValue: 0), context: nil)
//        self.item!.addObserver(self, forKeyPath: "selectedImage", options: NSKeyValueObservingOptions(rawValue: 0), context: nil)
//        self.observeValue(forKeyPath: nil, of: nil, change: nil, context: nil)
        
        self.setTitle(item.title, for: UIControl.State.normal)
        self.setTitle(item.title, for: UIControl.State.selected)
        
        self.setImage(item.image, for: UIControl.State.normal)
        self.setImage(item.selectedImage, for: UIControl.State.selected)
        
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)
    {
        self.setTitle(item?.title, for: UIControl.State.normal)
        self.setTitle(item?.title, for: UIControl.State.selected)
        
        self.setImage(item?.image, for: UIControl.State.normal)
        self.setImage(item?.selectedImage, for: UIControl.State.selected)
    }
    
    override func imageRect(forContentRect contentRect: CGRect) -> CGRect {
        let imageW:CGFloat = contentRect.size.width;
        let imageH:CGFloat = contentRect.size.height;
        return CGRect(x: 0, y: -3, width: imageW, height: imageH)
    }
    
    override func titleRect(forContentRect contentRect: CGRect) -> CGRect {
        let titleY:CGFloat = contentRect.size.height * CGFloat(0.7)
        let imageW:CGFloat = contentRect.size.width;
        let imageH:CGFloat = contentRect.size.height-titleY;
        
        return CGRect(x: 0, y: titleY-2, width: imageW, height: imageH)
    }
    
   
}
//
//  TabNavgationVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/8.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class TabNavgationVC: UINavigationController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
        
        
        
       let bar = UINavigationBar.appearance()
        bar.barTintColor = UIColor.black
        bar.tintColor = UIColor.white
        
        var attrs:[NSAttributedString.Key: AnyObject] = [:]
        
        attrs[NSAttributedString.Key(rawValue: NSAttributedString.Key.font.rawValue)] = UIFont.systemFont(ofSize: 17)
        attrs[NSAttributedString.Key(rawValue: NSAttributedString.Key.foregroundColor.rawValue)] = UIColor.white
        bar.titleTextAttributes = attrs
        
        
    }
    
    
   
    override func pushViewController(_ viewController: UIViewController, animated: Bool) {
        if viewControllers.count > 0 {
            
            let backBtn :UIButton = UIButton.init(type: .custom)
            backBtn.frame = CGRect.init(x: 0, y: 0, width: kNavBackWidth, height: kNavBackHeight)
            //        backBtn.setTitle("返回", for: .normal)
            backBtn.setImage(UIImage.init(named: "nav_back"), for: .normal)
            backBtn.sizeToFit()
            backBtn.addTarget(self, action: #selector(btnClick), for: .touchUpInside)
            let barItem :UIBarButtonItem = UIBarButtonItem.init(customView: backBtn)
            viewController.navigationItem.leftBarButtonItem = barItem
            
        }
        super.pushViewController(viewController, animated: true)
    }
    
    
    @objc func btnClick()
    {
        if self.children.count>1 {
            if self.children[1] is TMTabbarController{
                let Tab:TMTabbarController = self.children[1] as! TMTabbarController
            let smak:SmallTalkVC = Tab.viewControllers?.first as! SmallTalkVC
            smak.clearInputText()
            }
            self.popViewController(animated: true)
        }
        else
        {
            let nav = self.tabBarController?.navigationController
            nav?.popViewController(animated: true)
            
        }
        
        
    }
    
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */
}
//
//  BaseViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/2/28.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class BaseViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
         self.configBackItem()
        self.automaticallyAdjustsScrollViewInsets = false
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    func addAlertView(title:String, message:String, actionTitles:Array<String>,okAction: ((UIAlertAction) -> Void)?, cancleAction: ((UIAlertAction) -> Void)?) {
        let alertController = UIAlertController.init(title: title, message: message, preferredStyle: .alert)
        for (index,actionTitle) in actionTitles.enumerated() {
            if index == 0 {
                alertController.addAction(UIAlertAction.init(title: actionTitle, style: .default, handler: { (action) in
                    okAction!(action)
                }))
            }
            if index > 0 && index == actionTitles.count - 1 {
                alertController.addAction(UIAlertAction.init(title: actionTitle, style: .cancel, handler: { (action) in
                    cancleAction!(action)
                }))
            }
        }
        self.present(alertController, animated: true, completion: nil)
    }
    
    //通过类名返回一个AnyClass
    func getClassWitnClassName(_ name:String) ->AnyClass?{
        let type = getBundleName() + "." + name
        return NSClassFromString(type)
    }
    
    //获取工程的名字
    func getBundleName() -> String{
        var bundlePath = Bundle.main.bundlePath
        bundlePath = bundlePath.components(separatedBy: "/").last!
        bundlePath = bundlePath.components(separatedBy: ".").first!
        return bundlePath
    }
}
//
//  BaseSearchView.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/10.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import Realm
let itemWidth:CGFloat = 35
let itemSpace:CGFloat = 10
@objc protocol BaseSearchViewDelegate {
    
    /// 删除展示项目的代理
    ///
    /// - Parameter item: 删除的对象
    func searchDeleteItem(item:RLMObject)
    
    
    
    /// 搜索框的值发生变化
    ///
    /// - Parameter nowText: 当前搜索框的值
    func searchBarTextChangedWith(nowText:String)
    
    @objc optional func searchBarSearchButtonClicked(nowText:String)
}
class BaseSearchView: UIView {
    
   weak var delegate:BaseSearchViewDelegate?
    
    @IBOutlet weak var searchView: UISearchBar!
    @IBOutlet weak var collectWidth: NSLayoutConstraint!
    @IBOutlet weak var collectionView: UICollectionView!
    
    var isShowCollectionView:Bool?
    
    
    var dataArray:Array<RLMObject>?
    
    override func awakeFromNib() {
        super.awakeFromNib()
        self.searchView.backgroundColor = UIColor.init(patternImage: UIImage.init(named: "backGray")!)
        self.searchView.placeholder = "搜索"
          self.searchView.setBackgroundImage(UIImage.init(named: "backGray")!, for: .any, barMetrics: .default)
        
//        searchView.inputAccessoryView?.backgroundColor = UIColor.groupTableViewBackground
        dataArray = Array.init()
        searchView.delegate = self
        
            }
    
    
    /// 配置数据
    ///
    /// - Parameter array: 要展示的数据
    public func configWithDataArray(array:Array<RLMObject>)
    {
        guard self.isShowCollectionView == true else {
            return
        }
        dataArray = array
        self.collectionView.backgroundColor = UIColor.init(patternImage: UIImage.init(named: "backGray")!)
        self.refreshLayout()
        self.collectionView .reloadData()
    }
    
    
    
}
extension BaseSearchView{
    
    
    /// 配置collectionView
   public func configCollectionViewWith(isShowCollect:Bool)
    {
        isShowCollectionView = isShowCollect
        guard isShowCollect == true else {
            return
        }
        self.collectWidth.constant = 0.1
        self.collectionView.delegate = self
        self.collectionView.dataSource = self
        
        self.collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "cell")
        let layout:UICollectionViewFlowLayout = UICollectionViewFlowLayout.init()
    layout.sectionInset = UIEdgeInsets(top: 0, left: 5, bottom: 0, right: 5)
        layout.itemSize = CGSize.init(width: 30, height: 30)
        layout.scrollDirection = .horizontal;
        layout.minimumLineSpacing = itemSpace;
        //      layout.UICollectionViewDelegateFlowLayout = self
        self.collectionView.showsHorizontalScrollIndicator = false
        
        self.collectionView.setCollectionViewLayout(layout, animated: true)
    }
    
    
        
    
    
    /// 更新layout
    fileprivate func refreshLayout()
    {
        if self.dataArray?.count == 0 {
            self.collectWidth.constant = 0
        }
        else
        {
            if ((self.dataArray?.count)!*Int(itemSpace+itemWidth)+100) <= Int(kScreenW){
                self.collectWidth.constant = CGFloat((self.dataArray?.count)!*Int(itemSpace+itemWidth))
            }
            else
            {
               self.collectWidth.constant = kScreenW-100
            }
        }
    }
    
}
//MARK: - ---------------------collectionView代理----------------------
extension BaseSearchView:UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout
{
    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return (dataArray?.count)!
    }
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)
        
        //临时处理  应该自定义cell
                for view in cell.subviews {
                    if view is UIImageView {
                        view .removeFromSuperview()
                    }
                }
        
        let image = UIImageView.init(frame: CGRect.init(x: 0, y: 0, width: 30, height: 30))
        image.clipsToBounds = true
        image.layer.cornerRadius = 15
        let model = dataArray?[indexPath.row]
        if model is FriendsModel {
            let fModel  = model as! FriendsModel
            if !fModel.avater.isEmpty {
                
                image.sd_setImage(with: NSURL.init(string: fModel.avater) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
            }
            else
            {
                image.image = UIImage.init(named: "mine_avatar")
            }
        }
        else if (model is GroupUserModel){
            let fModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", (model as! GroupUserModel).userid)).firstObject() as! UserModel?
            if fModel?.avater != nil {
                image.sd_setImage(with: NSURL.init(string: (fModel?.avater)!) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
            }
            else
            {
                image.image = UIImage.init(named: "mine_avatar")
            }
        }else if (model is GroupModel){
            let fModel  = model as! GroupModel
            if !fModel.icon_url.isEmpty {
                image.sd_setImage(with: NSURL.init(string: fModel.icon_url) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
            }
            else
            {
                image.image = UIImage.init(named: "mine_avatar")
            }
        }
        
        cell.addSubview(image)
        
      
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return CGSize.init(width: itemWidth, height: itemWidth)
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)
    {
        guard indexPath.row<(self.dataArray?.count)! else {
            return
        }
        let item = self.dataArray?[indexPath.row]
        delegate?.searchDeleteItem(item: item!)
        self.dataArray?.remove(at: indexPath.row)
        self.refreshLayout()
        self.collectionView.reloadData()
        
    }
}
//MARK: - ---------------------搜索框代理方法----------------------
extension BaseSearchView:UISearchBarDelegate
{
    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
        
        delegate?.searchBarTextChangedWith(nowText: searchText)
    }
    
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        delegate?.searchBarSearchButtonClicked!(nowText: searchBar.text!)
    }
}
//
//  BaseCollectionView.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/10.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class BaseCollectionView: UIView {
    /*
    // Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        // Drawing code
    }
    */
}
//
//  TestVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/10.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class TestVC: BaseTableVC {
    override func viewDidLoad() {
        super.viewDidLoad()
      
        self.configUIWith(fromCellName: "BaseTableCell", fromIsShowSearch: true,fromSearchType: true ,fromCellHeight: 50)
        
//        for i in 0...20
//        {
//            let model:BaseTableModel = BaseTableModel()
//            model.text = String(i)
//            model.id = String(i)
//            self.allDataArray?.append(model)
//        }
//        
//        self.setDataArray(dataArray: self.allDataArray!)
        
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
}
//
//  BaseTableCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/13.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import Realm
@objc protocol BaseCellDelegate {
    func cellRightBtnClick(model:RLMObject)
}
class BaseTableCell: UITableViewCell {
    
   weak var delegate:BaseCellDelegate?
    
    @IBOutlet weak var imageLeftSpace: NSLayoutConstraint!
    @IBAction func BtnClick(_ sender: UIButton) {
        
        delegate?.cellRightBtnClick(model: self.model!)
    }
    @IBOutlet weak var rightBtnWidth: NSLayoutConstraint!
    @IBOutlet weak var rightBtn: UIButton!
    @IBOutlet weak var desLable: UILabel!
    @IBOutlet weak var iconImage: UIImageView!
    @IBOutlet weak var selectImage: UIImageView!
    
    var model:RLMObject?
    {
        didSet{
            
            if model is FriendsModel {
               let fModel  = model as! FriendsModel
               desLable.text = fModel.realname
               rightBtnWidth.constant = 60
               rightBtn.layer.borderWidth = 0.5
               rightBtn.layer.cornerRadius = 6
                rightBtn.clipsToBounds = true
                rightBtn.titleLabel?.font = FONT_14
                rightBtn.isEnabled = false
                if fModel.type == 1 {
                   rightBtn.layer.borderColor = UIColor.orange.cgColor
                   rightBtn.setTitleColor(UIColor.orange, for: .normal)
                   rightBtn.setTitle("互粉", for: .normal)
                }
                else if fModel.type == 2
                {
                    rightBtn.layer.borderColor = UIColor.hexString(hexString: "7bbb28").cgColor
                    rightBtn.setTitleColor(UIColor.hexString(hexString: "7bbb28"), for: .normal)
                   rightBtn.setTitle("粉丝", for: .normal)
                }
                else if fModel.type == 3 || fModel.type == 4
                {
                    rightBtn.layer.borderColor = UIColor.hexString(hexString: "7bbb28").cgColor
                    rightBtn.setTitleColor(UIColor.hexString(hexString: "7bbb28"), for: .normal)
                    rightBtn.setTitle("陌生人", for: .normal)
                }
                self.cycleStyle(isCycle: true)
                if !fModel.avater.isEmpty {
                   iconImage.sd_setImage(with: NSURL.init(string: fModel.avater) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
                }
                else
                {
                     iconImage.image = UIImage.init(named: "mine_avatar")
                }
                
                
            }
            else if model is GroupUserModel{
                
                 self.cycleStyle(isCycle: true)
                let fModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", (model as! GroupUserModel).userid)).firstObject() as! UserModel?
                desLable.text = fModel?.realname
                if fModel?.avater != nil {
                    iconImage.sd_setImage(with: NSURL.init(string: (fModel?.avater)!) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
                }
                else
                {
                    iconImage.image = UIImage.init(named: "mine_avatar")
                }
               
                rightBtn.isHidden = true
            }
            else if model is GroupModel {
                self.cycleStyle(isCycle: false)
                selectImage.isHidden = true
                self.imageLeftSpace.constant = -20
                
                
                
                
                
                
                
                
                let gModel = model as! GroupModel
                
//                let predicate = NSPredicate(format:"userid == %@ AND groupid == %@  AND is_delete == '0'", sharePublicDataSingle.publicData.userid,gModel.groupid)
//                
//                let results = GroupUserModel.objects(with: predicate)
                
                self.rightBtn.setTitleColor(UIColor.white, for: .normal)
                self.rightBtn.backgroundColor = UIColor.hexString(hexString: "166AD9")
                
//                if results.count == 0 {
//                    self.rightBtn.setTitleColor(UIColor.white, for: .normal)
//                    self.rightBtn.backgroundColor = UIColor.hexString(hexString: "166AD9")
//                    self.rightBtn.setTitle("申请加入", for: .normal)
//                }
//                else{
//                
//                    self.rightBtn.setTitleColor(UIColor.lightGray, for: .normal)
//                    self.rightBtn.backgroundColor = UIColor.white
//                    self.rightBtn.setTitle("已加入", for: .normal)
//                    self.rightBtn.isEnabled = false
//                }
                
                
                
                
                if !gModel.group_name.isEmpty {
                    
                let num = gModel.user_num.isEmpty ? "0" : gModel.user_num
                   desLable.text = String.init(format: "%@(%@)", gModel.group_name,num)
                }
               
               iconImage.image = UIImage.init(named: "mine_avatar")
                
                if !gModel.icon_url.isEmpty {
                    iconImage.sd_setImage(with: NSURL.init(string: gModel.icon_url) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
                }
                else
                {
                    iconImage.image = UIImage.init(named: "mine_avatar")
                }
               
                
            }
        }
    
    }
    
    func hidenChooseIcon(hiden:Bool){
    
        if hiden == true {
            selectImage.isHidden = true
            self.imageLeftSpace.constant = -20
        }
    }
    
    override func awakeFromNib() {
        super.awakeFromNib()
        self.selectionStyle = .none
//        iconImage.layer.cornerRadius = iconImage.bounds.size.width/2.0
        
    }
    
    func cycleStyle(isCycle:Bool){
        
        if isCycle == true {
            iconImage.layer.cornerRadius = 15
        }
        else{
           iconImage.layer.cornerRadius = 4
        }
        iconImage.layer.borderWidth = 0.3
        iconImage.layer.borderColor = UIColor.lightGray.cgColor
        iconImage.clipsToBounds = true
        
    }
    
    
    
    
    
//    override func setSelected(_ selected: Bool, animated: Bool) {
//         super.setSelected(selected, animated: animated)
//
//        // Configure the view for the selected state
//    }
    
}
//
//  BaseTableVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/10.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import Realm
class BaseTableVC: BaseViewController {
    var memberArray:Array<GroupUserModel>?
    
     var table:UITableView?
    
     var cellName:String?
    
     var modelName:String?
    
    //是否显示  选择空间
    var hidenChooseIcon:Bool? {
        
        didSet{
           
            table?.reloadData()
        }
    }
    
    //基础数据源
    var allDataArray:RLMResults<RLMObject>?
    
    //当前显示的数据源
    var dataArray:RLMResults<RLMObject>?
    
    
    
    //搜索结果数据源
     var searchArray:Array<RLMObject>?
    
    //是否显示搜索框
     var isShowSearch:Bool?
    
    //定义cell高度   没有做高度自动处理（目前看到的界面没有必要去做，后续添加）
    fileprivate var cellHeight:CGFloat?
    
    //选中结果集
     var selectedArray:Array<RLMObject>?
    
    
    var searchView:BaseSearchView?
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
         self.configUI()
        // Do any additional setup after loading the view.
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
}
//MARK: - ---------------------相关初始化----------------------
extension BaseTableVC{
    
   
   /// UI初始化
   fileprivate func configUI()
   {
    
    self.view.backgroundColor = UIColor.groupTableViewBackground
    
    selectedArray = Array()
    
    table = UITableView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT))
    table?.backgroundColor = UIColor.groupTableViewBackground
    self.view.addSubview(table!)
    table?.delegate = self;
    table?.dataSource = self;
    table?.tableFooterView = UIView.init()
    
   }
    
    
    
}
//MARK: - ---------------------TableDelegate AND DataSource----------------------
extension BaseTableVC:UITableViewDelegate,UITableViewDataSource
{
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if (cellHeight != nil) {
            return cellHeight!
        }
        else
        {
            return 44
        }
    }
    
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        
        return dataArray != nil ?Int((dataArray?.count)!): 0
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
      
        var cell:UITableViewCell? = tableView.dequeueReusableCell(withIdentifier: "cell")
        if cell == nil
        {
           
            let path:String? = Bundle.main.path(forResource: cellName, ofType: "nib")
            if path == nil {
               let  aClass  = getClassWitnClassName(cellName!) as! UITableViewCell.Type
                cell = aClass.init(style: .default, reuseIdentifier: cellName)
            }
            else
            {
                cell = Bundle.main.loadNibNamed(cellName!, owner: self, options: nil)?.last as! UITableViewCell?
                
            }
        }
        
        let model:RLMObject = self.dataArray![UInt(indexPath.row)]
        
        
        if cell is  BaseTableCell {
            let bCell = cell as! BaseTableCell
            
            bCell.model = model
            bCell.delegate = self
            
            //MARK: - ---------------------一段垃圾代码  先这么写  要整个整理这个类----------------------
            if model is FriendsModel {
                if (self.selectedArray?.contains(where: { (m) -> Bool in
                    return (m as! FriendsModel).userid == (model as! FriendsModel).userid
                }))!{
                    
                    
                    
                    bCell.selectImage.image = UIImage.init(named: "logic_select")
                }
                else
                {
                    bCell.selectImage.image = UIImage.init(named: "logic_normal")
                }
                
                //添加好友的时候  如果已经在群里的好友  不允许在做其他的操作
                if (self.memberArray?.contains(where: { (m) -> Bool in
                    return m.userid == (model as!FriendsModel).userid
                }) == true) {
                     bCell.selectImage.image = UIImage.init(named: "logic_disable")
                }
                
            }
            else if (model is GroupUserModel){
            //删除群成员
                if (self.selectedArray?.contains(where: { (m) -> Bool in
                    return (m as! GroupUserModel).userid == (model as! GroupUserModel).userid
                }))!{
                    
                    
                    bCell.selectImage.image = UIImage.init(named: "logic_select")
                }
                else
                {
                    bCell.selectImage.image = UIImage.init(named: "logic_normal")
                }
                
                
                if (self.memberArray?.contains(where: { (m) -> Bool in
                    return m.userid == (model as!GroupUserModel).userid
                }) == true) {
                    bCell.selectImage.backgroundColor = UIColor.yellow
                }
                //选择@对象的时候  不需要显示是否选择的状态
                if hidenChooseIcon == true {
                    bCell.hidenChooseIcon(hiden: hidenChooseIcon!)
                }
                
                
                
            }
            
            
        }
        
        
        
        
        
        return cell!
    }
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
    {
        
        
    }
  
}
//MARK: - ---------------------使用该类需要用到的方法----------------------
extension BaseTableVC
{
    
    /// 初始化配置
    ///
    /// - Parameters:
    ///   - fromCellName: cell 名称
    ///   - fromIsShowSearch: 是否有搜索框
    ///   - fromSearchType: 搜索框是否显示选择项目
    ///   - fromCellHeight: cell高度
    @objc func configUIWith(fromCellName:String,fromIsShowSearch:Bool,fromSearchType:Bool,fromCellHeight:CGFloat)
    {
        self.cellName = fromCellName
        guard self.cellName != nil else {
            return
        }
        let path:String? = Bundle.main.path(forResource: cellName, ofType: "nib")
        
        
        if path == nil {
            let  aClass = getClassWitnClassName(cellName!) as! UITableViewCell.Type
            self.table?.register(aClass , forCellReuseIdentifier: cellName!)
        }
        else
        {
            self.table?.register(UINib.init(nibName: cellName!, bundle: Bundle.main), forCellReuseIdentifier: "cell")
        }
        
        self.cellHeight = fromCellHeight
        self.isShowSearch = fromIsShowSearch
        if self.isShowSearch! {
            searchArray = Array()
            searchView = Bundle.main.loadNibNamed("BaseSearchView", owner: self, options: nil)?.last as? BaseSearchView
            searchView?.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: 50)
            searchView?.configCollectionViewWith(isShowCollect: fromSearchType)
            searchView?.delegate = self
            self.view.addSubview(searchView!)
            
            self.table?.frame = CGRect.init(x: 0, y:50+NAV_HEIGHT, width: kScreenW, height:MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT-50)
            
        }
        
        
        
        
    }
    
    
    
    
    /// 添加数据
    ///
    /// - Parameter dataArray: 要显示的数据
    func setDataArray(dataArray:RLMResults<RLMObject>)
    {
//        self.allDataArray = dataArray
        self.dataArray = dataArray
        self.table?.reloadData()
    
    }
    
    /// 空页面提醒
    func showRemind(){
        
        let fView = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 50))
        
        let line = UIView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: 1))
        line.backgroundColor = UIColor.groupTableViewBackground
        fView.addSubview(line)
        
        let numberLable = UILabel.init(frame: CGRect.init(x: 0, y: 10, width: kScreenW, height: 30))
        numberLable.textAlignment = NSTextAlignment.center
        numberLable.font = UIFont.systemFont(ofSize: 14)
        
        numberLable.text = "没有查找到相关内容"
        fView.addSubview(numberLable)
        if self.dataArray != nil {
            if (self.dataArray?.count)! == 0 && (self.searchView?.searchView.text?.count)! > 0{
                table?.tableFooterView = fView
            }else{
                table?.tableFooterView = UIView.init()
            }
        }
    }
}
extension BaseTableVC:BaseSearchViewDelegate
{
    func searchDeleteItem(item: RLMObject)
    {
    }
    func searchBarTextChangedWith(nowText:String)
    {
        
    }
    func searchBarSearchButtonClicked(nowText:String)
    {
        
    }
    
}
extension BaseTableVC:BaseCellDelegate{
    
    /// cell右边按钮点击
    ///
    /// - Parameter model: <#model description#>
    func cellRightBtnClick(model: RLMObject) {
        
    }
}
//
//  BaseTableModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/13.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class BaseTableModel: NSObject {
     var id:String?
    var text:String?
    var isSelect:Bool = false
}
//
//  BaseNavigationController.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/2.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class BaseNavigationController: UINavigationController {
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */
}
//
//  MyVoiceView.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/7.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import AVFoundation
@objc protocol MyVoiceViewDelegate {
    func clickPlay()
    //点击了无效的语音文件
    func clickAbortive()
//    func currentTime(_ timeStr:String)
}
class MyVoiceView: UIView {
    
    weak var delegate:MyVoiceViewDelegate?
    var model:RCMessageModel?
    var isPan:Bool?
    
    lazy var leftBtn : UIButton = {
    let btn = UIButton.init(type: .custom)
    return btn
    }()
    
    
   lazy var progressSlider:UISlider = {
      let s = UISlider.init()
      return s
    }()
    
    var number:Float?
    var currentNumber:Float?
    
   lazy var timeLable:UILabel = {
     
        let lable = UILabel()
        lable.font = UIFont.systemFont(ofSize: 12)
        lable.textAlignment = .center
        return lable
    
    }()
    
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        addSubview(leftBtn)
         addSubview(progressSlider)
//        NotificationCenter.default.addObserver(self, selector: #selector(avfinish), name: NSNotification.Name(rawValue: "avFinish"), object: nil)
//        NotificationCenter.default.addObserver(self, selector: #selector(avStart), name: NSNotification.Name(rawValue: "avStart"), object: nil)
        
     
     
      
        
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
  
   
    
    
    
    /// 根据传入的消息model 初始化UI
    ///
    /// - Parameter model: 消息模型
    func congigUIWithModel(_ model:RCMessageModel) {
        
        
      
      self.model = model
    
      leftBtn.removeFromSuperview()
      progressSlider.removeFromSuperview()
      timeLable.removeFromSuperview()
        
        
        
        addSubview(leftBtn)
        leftBtn.addTarget(self, action: #selector(btnClick(_ :)), for: .touchUpInside)
        
        addSubview(progressSlider)
        progressSlider.maximumValue = 1.0;
        progressSlider.minimumValue = 0.0;
        progressSlider.isContinuous = true
        currentNumber = 0
        progressSlider.value = currentNumber!
        
        addSubview(timeLable)
//        timeLable.text = "59.9''"
      //根据消息方向去初始化界面
        
      timeLable.frame = CGRect(x: self.frame.width-50, y: 0, width: 50, height: 40)
      if model.messageDirection == .MessageDirection_RECEIVE {
       
        leftBtn.frame = CGRect.init(x:0 , y: 0, width: 40, height: 40)
        progressSlider.frame = CGRect.init(x:41, y: 0, width:self.frame.width-90 , height: 40)
//        leftBtn.frame = CGRect.init(x: 10, y: 5, width: 30, height: 30)
//         addSubview(leftBtn)
//        leftBtn.addTarget(self, action: #selector(btnClick(_ :)), for: .touchUpInside)
        leftBtn.setImage(UIImage.init(named: "playBlue"), for: .normal)
        leftBtn.setImage(UIImage.init(named: "playBlue"), for: .selected)
        leftBtn.setImage(UIImage.init(named: "playBlue"), for: .highlighted)
//        progressSlider.frame = CGRect.init(x:40, y: 0, width:self.frame.width-50 , height: 40)
//        addSubview(progressSlider)
//        progressSlider.maximumValue = 1.0;
//        progressSlider.minimumValue = 0.0;
//        progressSlider.isContinuous = true
//        currentNumber = 0
//        progressSlider.value = currentNumber!
        progressSlider.setThumbImage(UIImage.init(named: "slider"), for: .normal)
         progressSlider.tintColor = UIColor.hexString(hexString: "1681e1")
        self.configCurrentTime()
        self.synchronousUIWithPlayer(isMy: false)
        
    }
    else
    {
    
        leftBtn.frame = CGRect.init(x: 0, y: 0, width: 40, height: 40)
       progressSlider.frame = CGRect.init(x:41, y: 0, width:self.frame.width-90 , height: 40)
//        leftBtn.frame = CGRect.init(x:self.frame.size.width-40 , y: 5, width: 30, height: 30)
//        addSubview(leftBtn)
//        leftBtn.addTarget(self, action: #selector(btnClick(_ :)), for: .touchUpInside)
        leftBtn.setImage(UIImage.init(named: "playWhite"), for: .normal)
        leftBtn.setImage(UIImage.init(named: "playWhite"), for: .selected)
        leftBtn.setImage(UIImage.init(named: "playWhite"), for: .highlighted)
//        progressSlider.frame = CGRect.init(x:10, y: 0, width:self.frame.width-50 , height: 40)
//        progressSlider.maximumValue = 1.0;
//        progressSlider.minimumValue = 0.0;
//        progressSlider.isContinuous = true
//        currentNumber = 0
//        progressSlider.value = 1-currentNumber!
        progressSlider.setThumbImage(UIImage.init(named: "sliderWhite"), for: .normal)
        progressSlider.tintColor = UIColor.white
//        addSubview(progressSlider)
//        progressSlider.addTarget(self, action: #selector(sliderChange(_ :)), for: .valueChanged)
        
        
        
        
        self.configCurrentTime()
        self.synchronousUIWithPlayer(isMy: true)
    }
        
     progressSlider.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: #selector(panGesture(pan:))))
        
        if currentNumber != 0 {
            if model.messageDirection == .MessageDirection_RECEIVE {
                leftBtn.setImage(UIImage.init(named: "playBlue"), for: .normal)
                leftBtn.setImage(UIImage.init(named: "playBlue"), for: .selected)
                leftBtn.setImage(UIImage.init(named: "playBlue"), for: .highlighted)
            }else{
                
                leftBtn.setImage(UIImage.init(named: "playWhite"), for: .normal)
                  leftBtn.setImage(UIImage.init(named: "playWhite"), for: .selected)
            }
        }
//    shareAVManager.configPlayerWith(data: self.model!)
}
    
    
    
    
    //根据消息来确定当前应该显示的时间
    func configCurrentTime(){
        let voiceModel:RCVoiceMessage = self.model!.content as! RCVoiceMessage
        let predicate = NSPredicate.init(format: "messageId == %@",String((self.model?.messageId)!))
        timeLable.text = String.init(format: "%.1f ''", Float(voiceModel.duration))
        
        
        let proModelSets = AVPlayerProgressModel.objects(with: predicate)
        if proModelSets.count != 0 {
            self.currentNumber = Float((proModelSets.firstObject() as! AVPlayerProgressModel).progress)
            let surplusTime = Float(voiceModel.duration) - self.currentNumber!
//            delegate?.currentTime(String.init(format: "%.1f''", surplusTime))
            timeLable.text = String.init(format: "%.1f ''", abs(surplusTime))
            self.progressSlider.value = self.currentNumber!/Float(voiceModel.duration)
        }
        else{
            
            timeLable.text = String.init(format: "%.1f ''", Float(voiceModel.duration))
        }
        number = Float(voiceModel.duration)
    }
    
    /// 同步当前UI与播放器的播放进度
    /////当当前cell滑出屏幕的时候  播放器仍然在播放   再一次创建cell的时候  需要将UI进度与播放器进度同步
    /// - Parameter isMy: 消息分方向   和自己发送的方向相同传True
    func synchronousUIWithPlayer(isMy:Bool){
    
        if shareAVManager.isPlaying() {
            guard  (shareAVManager.model?.messageId)! == model?.messageId else {
                return
            }
            
                let voiceModel:RCVoiceMessage = model!.content as! RCVoiceMessage
                self.currentNumber = Float((shareAVManager.player?.currentTime)!)
                var surplusTime = Float(voiceModel.duration) - self.currentNumber!
                if surplusTime < 0 {
                    surplusTime = 0
                }
            
            timeLable.text = String.init(format: "%.1f ''", surplusTime)
//                delegate?.currentTime(String.init(format: "%.1f''", surplusTime))
//                shareAVManager.stopPlay()
                
                if isMy == true {
                   self.progressSlider.value =  1.0 - self.currentNumber!/Float(voiceModel.duration)
                }
                else{
                self.progressSlider.value = self.currentNumber!/Float(voiceModel.duration)
                }
                
                DispatchQueue.main.async { [weak self] in
                    self?.start()
                    print("当前播放调用了 *************** 重新开始")
                }
                
                
            
            
        }
    }
    
    
    
    
    
    
    
    //MARK: - ---------------------播放器  播放  暂停  相关处理----------------------
    //做暂停处理
    func pause(){
     
        shareAVManager.stopPlay()
        
        if model?.messageDirection == .MessageDirection_RECEIVE {
            leftBtn.setImage(UIImage.init(named: "playBlue"), for: .normal)
            leftBtn.setImage(UIImage.init(named: "playBlue"), for: .selected)
            
        }else{
            
            leftBtn.setImage(UIImage.init(named: "playWhite"), for: .normal)
            leftBtn.setImage(UIImage.init(named: "playWhite"), for: .selected)
        }
    }
    
    
    //开始播放处理
    func start(){
    
//        if (leftBtn.imageView?.isAnimating)! {
//            leftBtn.imageView?.stopAnimating()
//        }
//        
//        if model?.messageDirection == .MessageDirection_RECEIVE {
//            leftBtn.animationStartWith(str: "voiceR")
//            
//        }else{
//            leftBtn.animationStartWith(str: "voiceL")
//        }
        
        
        
        let voiceModel:RCVoiceMessage = model!.content as! RCVoiceMessage
        
        guard voiceModel.wavAudioData != nil else {
            
            delegate?.clickAbortive()
            return
        }
        
        
        if model?.messageDirection == .MessageDirection_RECEIVE {
            leftBtn.setImage(UIImage.init(named: "pauseBlue"), for: .normal)
            leftBtn.setImage(UIImage.init(named: "pauseBlue"), for: .selected)
            
        }else{
            
            leftBtn.setImage(UIImage.init(named: "pauseWhite"), for: .normal)
            leftBtn.setImage(UIImage.init(named: "pauseWhite"), for: .selected)
        }
        
        delegate?.clickPlay()
  
    }
    
    //继续播放
    func continuePlay(){
        start()
    }
    
    
    
    
    //MARK: - ---------------------按钮点击 滑块相关处理----------------------
    @objc func btnClick(_ btn:UIButton)
    {
        if shareAVManager.isPlaying() == true {
           //正在播放  有两种情况  播放自己   播放别的
           
            if self.model != shareAVManager.model {
            //正在播放的是别人  做暂停处理  并要保存别人的进度  开始播放自己
               self.start()
            }
            else{
            //正在播放的是自己  要做暂停处理
                self.pause()
                
            }
            
            
        }
        else{
            if self.model != shareAVManager.model {
               //播放没有播放或者处于播放其他语音的暂停状态
                self.start()
            }
            else{
               //当前播放器语音信息是自己的
                self.continuePlay()
            
            }
         }
}
    
    @objc func panGesture(pan : UIPanGestureRecognizer)  {
    
       if pan.state == .began {
        
        isPan = true
        
       }
    
        let point = pan.location(in: progressSlider)
        let touch_X = point.x
        // 相对于slider的比例
        var value = touch_X / (progressSlider.frame.size.width)
       if value > 1{
          value = 1
       }
    
       if value < 0 {
           value = 0
        }
        progressSlider.value = Float(value)
    
    if pan.state == .ended {
        
        isPan = false
        self.currentNumber = self.number! * progressSlider.value
//        if model?.messageDirection == .MessageDirection_RECEIVE {
//            self.currentNumber = self.number! * progressSlider.value
//        }else{
//            self.currentNumber = self.number! * (1-progressSlider.value)
//        }
        if self.currentNumber! >= self.number!{
            self.currentNumber = self.number!
        }
        start()
        
    }
    
    }
    
    
    
    
    
    
  func timerChange(){
    
    if isPan == true{
      return
    }
    
        if self.model?.messageId != shareAVManager.model?.messageId
        {
          return
        }
    
        self.currentNumber! = Float((shareAVManager.player?.currentTime)!)
        if self.currentNumber! >= self.number!{
            self.currentNumber = self.number!
        }
        timeLable.text = String.init(format: "%.1f ''", (abs( self.number!-self.currentNumber!)))
//        self.delegate?.currentTime(String.init(format: "%.1f''",(self.number!-self.currentNumber!)))
    
        self.progressSlider.value = self.currentNumber!/self.number!
//        if self.model?.messageDirection == .MessageDirection_RECEIVE {
//         self.progressSlider.value = self.currentNumber!/self.number!
//        }
//        else{
//           self.progressSlider.value = 1.0 - self.currentNumber!/self.number!
//        }
    }
    
    
    
    deinit {
        
        
//        if (leftBtn.imageView?.isAnimating)!{
//        leftBtn.stopAnimation()
//            if model?.messageDirection == .MessageDirection_RECEIVE {
//                leftBtn.setImage(UIImage.init(named: "pauseBlue"), for: .normal)
//                leftBtn.setImage(UIImage.init(named: "pauseBlue"), for: .selected)
//            }else{
//                
//                leftBtn.setImage(UIImage.init(named: "pauseWhite"), for: .normal)
//                leftBtn.setImage(UIImage.init(named: "pauseBlue"), for: .selected)
//            }
//
//        }
        NotificationCenter.default.removeObserver(self)
    }
    
    
    }
    
    
//
//  MyVoiceCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/7.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
let chatWidth:CGFloat = kScreenW-150
enum CellStatus {
    case play
    case playIng //播放中
    case pause   //暂停
    case finish
}
@objc protocol  MyVoiceViewCellDelegate {
    
    func clickPlay(cell:MyVoiceCell,model:RCMessageModel,progress:Double)
    //无效的语音
    func clickPlayAbortive(model:RCMessageModel)
}
class MyVoiceCell: RCVoiceMessageCell {
    weak var myDelegate :MyVoiceViewCellDelegate?
    lazy var myView:MyVoiceView = {
      let  my = MyVoiceView.init(frame: CGRect.init())
      return my
    }()
  
    var voiceImage:UIImageView?
    
    
    override init!(frame: CGRect) {
        super.init(frame: frame)
        self.initialize()
            }
    
    func initialize() {
        bubbleBackgroundView = UIImageView.init(frame: CGRect.init())
        messageContentView.addSubview(bubbleBackgroundView!)
        
        if (myView.leftBtn.imageView?.isAnimating)! {
            myView.leftBtn.imageView?.stopAnimating()
        }
        myView.removeFromSuperview()
       
        messageContentView.addSubview(myView)
        myView.delegate = self
        
        
        if voiceImage == nil {
            voiceImage = UIImageView()
            voiceImage?.image = UIImage.init(named: "voiceR3")
            messageContentView.superview?.addSubview(voiceImage!)
            
                    }
        voiceImage?.isHidden = true
        
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    public static func getBubbleBackgroundViewSize(str:String) -> (CGSize)
    {
      return CGSize.init(width: 0, height: 0)
    }
    
    override func setDataModel(_ model: RCMessageModel!) {
        
        
        self.model = model
        
//        if voiceUnreadTagView != nil {
//            voiceUnreadTagView.removeFromSuperview()
//            voiceUnreadTagView = nil
//        }
        
       super.setDataModel(model)
        
        if model.receivedStatus == .ReceivedStatus_LISTENED {
            voiceUnreadTagView?.removeFromSuperview()
            voiceUnreadTagView = nil
        }
        
       self.setAutoLayout()
        
        
        
    }
    
    func setAutoLayout(){
        
        
        
        
        
        
        let bubbleBackgroundViewSize:CGSize = CGSize.init(width: lengthWithModel(), height: 40)
        var messageContentViewRect:CGRect = self.messageContentView.frame
         messageContentViewRect.size.width = bubbleBackgroundViewSize.width;
        
        
        
        if .MessageDirection_RECEIVE == self.messageDirection {
            self.messageContentView.frame = messageContentViewRect;
            self.bubbleBackgroundView?.frame = CGRect.init(x: 0, y: 0, width: bubbleBackgroundViewSize.width, height: bubbleBackgroundViewSize.height)
            
            let image:UIImage = RCKitUtility.imageNamed("chat_from_bg_normal", ofBundle: "RongCloud.bundle")
            self.bubbleBackgroundView?.image = image.resizableImage(withCapInsets: UIEdgeInsets(top: image.size.height * 0.8, left: image.size.height * 0.8, bottom: image.size.height * 0.2, right: image.size.height * 0.2))
            
            if model.receivedStatus == .ReceivedStatus_LISTENED {
                voiceUnreadTagView?.removeFromSuperview()
                voiceUnreadTagView = nil
            }
            else{
                
                voiceUnreadTagView?.frame = CGRect.init(x:lengthWithModel()+10, y: 0, width: 10, height: 10)
            }
            
            voiceImage?.frame = CGRect.init(x:messageContentViewRect.origin.x+messageContentViewRect.width+10, y:messageContentViewRect.origin.y+10, width: 20, height: 20)
            
        }
        else
        {
            messageContentViewRect.size.width = bubbleBackgroundViewSize.width;
            messageContentViewRect.size.height = bubbleBackgroundViewSize.height;
            messageContentViewRect.origin.x =
                self.baseContentView.bounds.size.width -
                (messageContentViewRect.size.width + 6 +
                    RCIM.shared().globalMessagePortraitSize.width + 10);
            self.messageContentView.frame = messageContentViewRect;
            
            self.bubbleBackgroundView?.frame = CGRect.init(x: 0, y: 0, width: bubbleBackgroundViewSize.width, height: bubbleBackgroundViewSize.height)
            
            let image:UIImage = RCKitUtility.imageNamed("chat_to_bg_normal", ofBundle: "RongCloud.bundle")
            
            self.bubbleBackgroundView?.image = image.resizableImage(withCapInsets: UIEdgeInsets(top: image.size.height * 0.8, left: image.size.height * 0.2, bottom: image.size.height * 0.2, right: image.size.height * 0.8))
            
            
            voiceImage?.frame = CGRect.init(x:messageContentViewRect.origin.x-30, y:messageContentViewRect.origin.y+10, width: 20, height: 20)
            
             self.messageFailedStatusView.superview?.frame = CGRect.init(x: (self.messageFailedStatusView.superview?.frame.origin.x)!-30, y: (self.messageFailedStatusView.superview?.frame.origin.y)!, width: self.messageFailedStatusView.frame.size.width, height: self.messageFailedStatusView.frame.size.height)
        }
        
        
        
        
        
       
        
        myView.frame =  CGRect.init(x: 0, y: 0, width: messageContentView.frame.width, height: 40)
        
        myView.congigUIWithModel(self.model)
        let longPress = UILongPressGestureRecognizer.init(target: self, action: #selector(longPre(_ :)))
        myView.addGestureRecognizer(longPress)
        
        let tap = UITapGestureRecognizer.init(target: self, action: #selector(tap(_ :)))
        
        myView.addGestureRecognizer(tap)
    }
    
    
    
    /// 开始播放
    func play(){
        
        DispatchQueue.main.async { [weak self] in
            self?.myView.btnClick((self?.myView.leftBtn)!)
        }
        
        
//        self.clickPlay()
    }
    
    
    @objc func tap(_ tap:UITapGestureRecognizer){
     
        if model.messageId == shareAVManager.model?.messageId {
            if shareAVManager.isPlaying() == false {
                play()
            }
            
        }else{
        
            play()
        
        }
      
        
        
    }
    
    @objc func longPre(_ long:UILongPressGestureRecognizer){
    
        if long.state == .ended {
            return
        }else if (long.state == .began){
         delegate?.didLongTouchMessageCell!(model, in: bubbleBackgroundView)
        }
        
    }
    
  
    
    func cellStatus(status:CellStatus)
    {
        
        
        switch status {
        case .play:
//            myView.leftBtn.setImage(UIImage.init(named: "playWhite"), for: .normal)
            
        break
        
        case .playIng:
            voiceImage?.isHidden = false
            if .MessageDirection_RECEIVE == self.messageDirection{
               myView.leftBtn.setImage(UIImage.init(named: "pauseBlue"), for: .normal)
            }
            else{
               myView.leftBtn.setImage(UIImage.init(named: "pauseWhite"), for: .normal)
            }
            
            
            break
        case .pause:
            
//            myView.leftBtn.stopAnimation()
            voiceImage?.stopAnimating()
            voiceImage?.isHidden = true
            if .MessageDirection_RECEIVE == self.messageDirection{
                myView.leftBtn.setImage(UIImage.init(named: "playBlue"), for: .normal)
            }
            else{
                myView.leftBtn.setImage(UIImage.init(named: "playWhite"), for: .normal)
            }
            
            break
        case .finish:
            
//            myView.leftBtn.stopAnimation()
            voiceImage?.stopAnimating()
            voiceImage?.isHidden = true
            if .MessageDirection_RECEIVE == self.messageDirection{
                myView.leftBtn.setImage(UIImage.init(named: "playBlue"), for: .normal)
                myView.progressSlider.value = 0
            }
            else{
                myView.leftBtn.setImage(UIImage.init(named: "playWhite"), for: .normal)
                myView.progressSlider.value = 0
            }
            
            myView.timeLable.text = String.init(format: "%.1f ''", myView.number!)
            myView.currentNumber = 0.0
            break
        default: break
            
        }
        
    }
    
    
    //定时器响应
    func timeChange(){
//      print("************************----cell 执行timer------%p",self)
     self.myView.timerChange()
    }
    
    
    
    
    /// 根据语音消息的时间长度去视频播放器的长度
    ///
    /// - Returns: <#return value description#>
    func lengthWithModel()->(CGFloat){
    
     let voiceModel:RCVoiceMessage = self.model!.content as! RCVoiceMessage
        
     let time : CGFloat = (CGFloat((voiceModel.duration-1))/59.0)
     
        var width:CGFloat = 0.0
        if chatWidth < 240 {
            width = 240.0
        }else{
           width = chatWidth
        }
        
     return (width/2.0) + (chatWidth/2.0)*time
    }
    
    
    
    
    
    deinit {
        myView.removeFromSuperview()
       
        bubbleBackgroundView.removeFromSuperview()
    }
}
extension MyVoiceCell:MyVoiceViewDelegate{
    
    //点击了无效的文件
    func clickAbortive(){
    
       
        //        myDelegate?.clickPlay(cell: self, model: self.model)
        if model.receivedStatus != RCReceivedStatus.ReceivedStatus_LISTENED {
            model.receivedStatus = RCReceivedStatus.ReceivedStatus_LISTENED
            RCIMClient.shared().setMessageReceivedStatus(model.messageId, receivedStatus: RCReceivedStatus.ReceivedStatus_LISTENED)
            if voiceUnreadTagView != nil {
                voiceUnreadTagView.isHidden = true
            }
            
        }
        else{
            if voiceUnreadTagView != nil {
                voiceUnreadTagView.isHidden = true
            }
        }
        
         myDelegate?.clickPlayAbortive(model: self.model)
    }
    
    
    func clickPlay() {
        
        if voiceImage?.isAnimating == false {
            voiceImage?.animationStart()
            voiceImage?.isHidden = false
        }
        
        
        myDelegate?.clickPlay(cell: self, model: self.model, progress: Double(myView.currentNumber!))
//        myDelegate?.clickPlay(cell: self, model: self.model)
        if model.receivedStatus != RCReceivedStatus.ReceivedStatus_LISTENED {
           model.receivedStatus = RCReceivedStatus.ReceivedStatus_LISTENED
         RCIMClient.shared().setMessageReceivedStatus(model.messageId, receivedStatus: RCReceivedStatus.ReceivedStatus_LISTENED)
            if voiceUnreadTagView != nil {
               voiceUnreadTagView.isHidden = true
            }
        
        }
        else{
            if voiceUnreadTagView != nil {
                voiceUnreadTagView.isHidden = true
            }
        }
    }
    
    
}
//
//  MyConversationViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/6.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class MyConversationViewController: RCConversationViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
//       语音消息  暂时还没有确定具体样式 self.conversationMessageCollectionView .register(MyVoiceCell.self, forCellWithReuseIdentifier: "voice")
        
        
        
        
        self.conversationMessageCollectionView .register(MyVoiceCell.self, forCellWithReuseIdentifier: "voice")
//        self.chatSessionInputBarControl.delegate = self
        
        NotificationCenter.default.addObserver(self, selector: #selector(click), name: UIResponder.keyboardDidHideNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(clickshow), name: UIResponder.keyboardDidShowNotification, object: nil)
    }
    
   @objc func click(notification: NSNotification)
   {
    if self.chatSessionInputBarControl.frame.origin.y>MAIN_SCREEN_HEIGHT_PX{
      self.view.frame = CGRect.init(x: 0, y: 0, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
    }
    else
    {
     self.view.frame = CGRect.init(x: 0, y: -49, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
    }
   }
    
    @objc func clickshow(notification: NSNotification)
    {
        self.view.frame = CGRect.init(x: 0, y: 0, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
    }
    
    
    
    override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        
    }
    
//    override func pluginBoardView(_ pluginBoardView: RCPluginBoardView!, clickedItemWithTag tag: Int) {
//        
//    }
    override func viewDidAppear(_ animated: Bool) {
        self.view.frame = CGRect.init(x: 0, y: -49, width:kScreenW, height: MAIN_SCREEN_HEIGHT_PX)
        self.view.backgroundColor = UIColor.white
        self.conversationMessageCollectionView.frame = CGRect.init(x: 0, y: 49, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT-49-50)
        self.scrollToBottom(animated: false)
//        make!.top.mas_equalTo()(view)
//        make!.bottom.mas_equalTo()(view)!.mas_offset()(-50)
//        }
//        
//        self.chatSessionInputBarControl.mas_makeConstraints { (make) in
////            make!.top.mas_equalTo()(view)
//            make!.height.mas_equalTo()(50)
//            make!.bottom.mas_equalTo()(view)!.mas_offset()(0)
//        }
    }
//    override func viewWillAppear(_ animated: Bool) {
//        super.viewWillAppear(true)
//        self.conversationMessageCollectionView .frame = CGRect.init(x: 0, y: NAV_HEIGHT, width:kScreenW, height: kScreenH-50-49-NAV_HEIGHT)
//        self.scrollToBottom(animated: false)
//        self.chatSessionInputBarControl.frame = CGRect.init(x: 0, y: kScreenH-50-49, width:kScreenW, height: 50)
//    }
    
//    override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
//        
//        
//        let model:RCMessageModel = self.conversationDataRepository[indexPath.row] as! RCMessageModel
//        if model.objectName == "RC:VcMsg"
//        {
//            let cell:MyVoiceCell = collectionView.dequeueReusableCell(withReuseIdentifier: "voice", for: indexPath) as! MyVoiceCell
//            cell.setDataModel(model)
//            return  cell as UICollectionViewCell
//        }
//        else
//        {
//            return super.collectionView(collectionView, cellForItemAt: indexPath)
//        }
//    }
    
//    override func didLongTouchMessageCell(_ model: RCMessageModel!, in view: UIView!) {
//        
//      }
    
    
}
//extension MyConversationViewController:RCChatSessionInputBarControlDelegate
//{
//    func present(_ viewController: UIViewController!, functionTag: Int) {
//        
//    }
//}
//
//  AVPlayerManager.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/28.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import AVFoundation
/// 播放器管理对象单例
let shareAVManager = AVPlayerManager()
class AVPlayerManager: NSObject {
    typealias finish = (_ isFinished:Bool) ->()
    typealias timeChange = () ->()
    
    var isAuto:Bool? //是否需要自动播放
    var model:RCMessageModel?
    
    /// 播放器
    var player:AVAudioPlayer?
    var timer:Timer?
    
    var finishBlock:finish?
    var timeChangeBlock:timeChange?
    var isOnceMore:Bool?
    
    override init() {
        super.init()
    }
    
    //     func callPhone(notification:Notification){
    //
    //
    //        let type:NSNumber = notification.userInfo?[AVAudioSessionInterruptionTypeKey] as! NSNumber
    //
    //
    //        if type == 1 {
    //
    //            finishBlock?(false)
    //            self.saveProgress(time: 1)
    //            player?.stop()
    //
    //            timerStop()
    //        }
    //        else{
    //
    ////           self.player?.play()
    ////            if self.isPlaying() {
    ////              self.timerStart()
    ////            }
    //
    //        }
    //
    //    }
    
    
    /// 静态方法用来停止播放
    class func avPlayerStop(){
        shareAVManager.stopPlay()
    }
    
    //当前播放进度
    func currentProgress()->(Float){
        if player == nil {
            return 0
        }
        //        if (player?.isPlaying)! {
        //            return (Float)((player?.currentTime)!/(player?.duration)!)
        //        }
        return (Float)((player?.currentTime)!/(player?.duration)!)
    }
    
    func currentTime()->(String){
        if player == nil {
            return "0:00"
        }
        
        let second = Int(round((shareAVManager.player?.currentTime)!))
        
        return ("\(second/60)"+":"+"\(second%60)")
        
        
    }
    
}
extension AVPlayerManager{
    
    
    
    func playAudioWithModel(progress:Double,mModel:RCMessageModel,compete:@escaping finish,action:@escaping timeChange){
        finishBlock = compete
        timeChangeBlock = action
        
        if mModel.receivedStatus != RCReceivedStatus.ReceivedStatus_LISTENED  {
            isAuto = true
        }else{
            isAuto = false
        }
        
        if isOnceMore == true {
            isAuto = true
        }
        
        let voiceModel:RCVoiceMessage = mModel.content as! RCVoiceMessage
        self.model = mModel
        
        
        player = try? AVAudioPlayer.init(data: voiceModel.wavAudioData)
        player?.prepareToPlay()
        player?.delegate = self
        
        if progress > 0 {
            player?.currentTime = progress
        }
        
        player?.play()
        
        timerStart()
        
        
        self.configInfraredSensing()
        //
    }
    
    
    
    
    
    
    func playUrlDataWithModel(progress:Double,mModel:RCMessageModel,compete:@escaping finish,action:@escaping timeChange){
        finishBlock = compete
        timeChangeBlock = action
        isAuto = false
        let voiceModel:ProjectVoiceMessageContent = mModel.content as! ProjectVoiceMessageContent
        self.model = mModel
        if voiceModel.url.isEmpty {
            return
        }
//        DLog(voiceModel.url)
        let playData = try? Data.init(contentsOf: URL(string: voiceModel.url.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!)!)
        if playData == nil {
            return
        }
//        DLog(playData!)
        
        do {
            player = try? AVAudioPlayer.init(data: playData!)
        } catch  {
//            DLog("播放器出现错误了")
        }
        
        player?.prepareToPlay()
        player?.delegate = self
        
        if progress > 0 {
            player?.currentTime = progress
        }
        
        player?.play()
        
        timerStart()
        
        
        self.configInfraredSensing()
        //
    }
    
    
    
    
    
    
    
    
    
    func configInfraredSensing(){
        
        //        let sessionCategory:UInt32 = kAudioSessionCategory_MediaPlayback
        
        
        let audionSession = AVAudioSession.sharedInstance()
        try?  audionSession.setCategory(AVAudioSession.Category.playback)
        
        UIDevice.current.isProximityMonitoringEnabled = true
        NotificationCenter.default.addObserver(self, selector: #selector(stateChange), name: NSNotification.Name(rawValue: "UIDeviceProximityStateDidChangeNotification"), object: nil)
    }
    
    
    
    /// 传感器检测到的状态发生变化
    @objc func stateChange(){
        
        if UIDevice.current.proximityState == true {
            try?  AVAudioSession.sharedInstance().setCategory(AVAudioSession.Category.playAndRecord)
        }else{
            try?  AVAudioSession.sharedInstance().setCategory(AVAudioSession.Category.playback)
            if self.isPlaying() == false{
                UIDevice.current.isProximityMonitoringEnabled = false
                NotificationCenter.default.removeObserver(self)
            }
            
        }
        
    }
    
    
    
    func stopPlay(){
        isOnceMore = false
        if self.isPlaying() {
            player?.stop()
            //            self.saveProgress(time: 1)
            timerStop()
            finishBlock?(false)
            //            finishBlock = nil
            //            timeChangeBlock = nil
            NotificationCenter.default.removeObserver(self)
            UIDevice.current.isProximityMonitoringEnabled = false
        }
        
        
    }
    
    
    func startPlay(){
        isOnceMore = false
        if self.player != nil {
            player?.play()
            
            timerStart()
            //            finishBlock?(false)
            //            finishBlock = nil
            //            timeChangeBlock!()
            //            NotificationCenter.default.removeObserver(self)
            //            UIDevice.current.isProximityMonitoringEnabled = false
            self.configInfraredSensing()
        }
        
        
    }
    
    
    func oncePlay(){
        isOnceMore = true
        player?.stop()
        self.saveProgress(time: 1)
        timerStop()
        finishBlock = nil
        timeChangeBlock = nil
    }
    
    
    func isPlaying()->(Bool){
        
        if player != nil {
            return player!.isPlaying
        }
        
        return false
    }
    
    
    func timerStart(){
        
        if self.timer != nil
        {
            timer?.fireDate = Date.distantPast
            timer?.fire()
        }
        else
        {
            timer = Timer(timeInterval: 0.1, target: self, selector: #selector(timerChange), userInfo: nil, repeats: true)
            RunLoop.current.add(self.timer!, forMode: .common)
            self.timer?.fire()
        }
        
        
    }
    
    func timerStop(){
        timer?.fireDate = Date.distantFuture
        NotificationCenter.default.removeObserver(self)
        UIDevice.current.isProximityMonitoringEnabled = false
        //    timer?.invalidate()
        //    timer = nil
    }
    
    @objc  func timerChange(){
        
        timeChangeBlock?()
    }
    
    
    
    
    func saveProgress(time:Double){
        
        guard model != nil else {
            return
        }
        
        let progressModel = AVPlayerProgressModel()
        progressModel.messageId = String((model?.messageId)!)
        if time != 0 {
            if self.player?.currentTime != nil{
                progressModel.progress = (self.player?.currentTime)!
            }
        }
        else{
            progressModel.progress = 0
        }
        DispatchQueue.main.async {
            DataBaseOperation.addData(rlmObject: progressModel)
        }
        
        
    }
    
}
extension AVPlayerManager:AVAudioPlayerDelegate{
    
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        
        player.stop()
        timerStop()
        self.saveProgress(time: 1)
        
        finishBlock?(true)
        
        
        //        DLog("播放完了++++++++++++++++++++")
        
        //        finishBlock = nil
        //        timeChangeBlock = nil
        
    }
    func audioPlayerDecodeErrorDidOccur(_ player: AVAudioPlayer, error: Error?) {
        
        player.stop()
        self.saveProgress(time: 0)
        timerStop()
        finishBlock?(false)
        finishBlock = nil
        timeChangeBlock = nil
        
        //        NotificationCenter.default.post(name: NSNotification.Name(rawValue: "avFinish"), object: [self.model])
        
    }
    
    
}
//
//  UIConstant.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/2.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
// 屏幕宽高
let SCREEN_WIDTH : CGFloat = UIScreen.main.bounds.width
let SCREEN_HEIGHT : CGFloat = UIScreen.main.bounds.height
let kGreenColor = UIColor.hexString(hexString: "43be5f")
let ispX:Bool = UIScreen.main.bounds.height == 812 ? true :false
//false 在px 上全屏不包含tab最下边的安全区  true 为相反   其他机型还是全屏
let MAIN_SCREEN_HEIGHT_PX = ispX ? false ? SCREEN_HEIGHT : SCREEN_HEIGHT - 34  : SCREEN_HEIGHT
//屏幕适配
func kReal(value : CGFloat) -> CGFloat { return value / 375 * SCREEN_WIDTH }
func kRealHeight(value : CGFloat) -> CGFloat { return value / 667 * SCREEN_HEIGHT }
func kRealFont(value : CGFloat) -> CGFloat { return value / 667 * SCREEN_HEIGHT }
let NAV_HEIGHT : CGFloat = 44.0 + UIApplication.shared.statusBarFrame.size.height                  //导航栏高度
let kFakeTab_HEIGHT : CGFloat = 56.0              //假tab高度
let kNavBackWidth : CGFloat = 30.0               //返回按钮高度
let kNavBackHeight : CGFloat = 30.0               //返回按钮高度
// 字体
let FONT_10 : UIFont = UIFont.systemFont(ofSize: 10)
let FONT_11 : UIFont = UIFont.systemFont(ofSize: 11)
let FONT_12 : UIFont = UIFont.systemFont(ofSize: 12)
let FONT_14 : UIFont = UIFont.systemFont(ofSize: 14)
let FONT_16 : UIFont = UIFont.systemFont(ofSize: 16)
let FONT_18 : UIFont = UIFont.systemFont(ofSize: 18)
// tableView分割线颜色
let separateLine_Color : UIColor = UIColor.hexString(hexString:"D1D1D1")
//群组头像borderColor
let headerBorderColor : String = "C5C5C5"
// 间距
//MARK: - GroupListCell
let LEFT_PADDING : CGFloat = 10.0
//MARK: - GroupSettingWithArrowCell AND GroupSettingWithSwitchCell
let LEFT_PADDING_GS : CGFloat = 15.0
let LEFT_PADDING_BIG : CGFloat = LEFT_PADDING_GS + 25.0
//MARK: - GroupNameEditTextField
let inputTF_height : CGFloat = 40.0
//MARK: - ApplyJoinGroupTextView
let inputTV_height_MIN : CGFloat = 40.0
let inputTV_height_MAX : CGFloat = 120.0
//MARK: - ComboboxView
let TOP_PADDING : CGFloat = 3.0
let oneRow_height : CGFloat = 44.0
//MARK: - BaseSearchView
let searchView_height : CGFloat = 50.0
//MARK: - publicKey
let getRemoteKey:String = "getRemoteKey"
//
//  GroupPluginSwift.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/3/24.
//  Copyright © 2017年 柴进. All rights reserved.
//
let kACCESS_TOKEN = "access_token"
let kIM_TOKEN = "im_token"
import UIKit
class GroupPluginSwift: NSObject {
    @objc class func initWithToken(token:String , next:@escaping (_ dic:NSDictionary)->()) {
        
        RCIM.shared().initWithAppKey(kRCIM_APPKEY)//正式
        sharePublicDataSingle.token = token as NSString;
        UserRequest.getToken(params: ["app_token":token], hadToast: true, fail: { (error) in
            print(error)
        }) { (dis) in
//            print(dis)
            sharePublicDataSingle.publicData.userid = dis["userid"] as! String
            sharePublicDataSingle.publicData.avater = dis["avater"] as! String
            sharePublicDataSingle.publicData.corpid = dis["corpid"] is NSNumber ? (dis["corpid"] as! NSNumber).stringValue : dis["corpid"] as! String
            sharePublicDataSingle.publicData.realname = dis["realname"] as! String
            sharePublicDataSingle.publicData.access_token = dis["access_token"] as! String
            sharePublicDataSingle.publicData.im_token = dis["im_token"] as! String
            sharePublicDataSingle.publicData.im_userid = dis["im_userid"] as! String
//            UserDefaults.standard.setValue(sharePublicDataSingle
//                                            .token, forKey: kACCESS_TOKEN)
//            UserDefaults.standard.setValue(sharePublicDataSingle.publicData
//                                            .im_token, forKey: kIM_TOKEN)
//            UserDefaults.standard.synchronize()
            DataBaseOperation.initDataBase()
            sharePublicDataSingle.startGetMessageNot()
            
            
            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            let getRemote:Bool? = UserDefaults.standard.object(forKey: getRemoteKey + username) as! Bool?
            if getRemote == nil {
                UserDefaults.standard.set(true, forKey: getRemoteKey + username)
            }
            var time:String? = (UserDefaults.standard.object(forKey: username) as? String)
            
            if (time == nil ){
               time = "0"
            }
//            if UserModel.allObjects().count == 0 {
//                UserDefaults.standard.set("0", forKey: username)
//                time = "0"
//            }
            
            UserRequest.initData(params: ["app_token":token,"updatetime":time!], hadToast: true, fail: { (error) in
//                print(error)
            }, success: { (dic) in
//                print(dic)
                RCIM.shared().logout()
                
                RCIM.shared()?.connect(withToken: sharePublicDataSingle.publicData.im_token, dbOpened: { (errorCode) in
                    
                }, success: { (userId) in
                    print("登陆成功。当前登录的用户ID：\(String(describing: userId))")
                    next(NSDictionary.init(dictionaryLiteral: ("code", "1")))
                }, error: { (status) in
                    print("登陆的错误码为:\(status)")
                })
                //本地后台通知
//                RCIM.shared().disableMessageNotificaiton = true
                RCIM.shared().disableMessageAlertSound = true
                RCCall.shared()
            })
//            UserRequest.friends(params: ["app_token":token], hadToast: true, fail: { (error) in
//                print(error)
//            }, success: { (dic) in
//                print(dic)
//            })
        }
    }
    class func open(token:String , next:@escaping (_ dic:NSDictionary)->()) {
//        BaseNavigationController * nav = [[BaseNavigationController alloc] init];
//        UIViewController * vc = [[GroupListViewController alloc] init];
//        [nav addChildViewController:vc];
//        [self.viewController presentViewController:nav animated:YES completion:nil];
//        let nav = BaseNavigationController.init()
//        nav.addChildViewController(GroupListViewController.init())
        
    }
    
    class func logout(){
        RCIM.shared().logout()
    }
}
//
//  PublicDataSingle.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/3/15.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
//import SVProgressHUD
let sharePublicDataSingle = PublicDataSingle()
struct PublicData {
    // structure definition goes here
    var avater = "" //头像地址
    var userid = "" //用户id
    var corpid = "" //公司id
    var realname = "" //真实姓名
    var access_token = "" //accToken
    var im_token = "" //imToken
    var im_userid = "" //im userid
}
class PluginData {
    var initToken = ""//init接口Token
    var openToken = ""//open接口Token
}
class PublicDataSingle: NSObject {
    
    //    static let sharePublicDataSingle = PublicDataSingle()
    var publicData = PublicData()
    var pluginData = PluginData()
    
    var userId:NSString = ""//用户id
    //    var token:NSString = "MDAwMDAwMDAwMJ6tsN_IYpqci3l8Yb20f5uZ3Hyhj3ivm6_LlpmG2oCkgqK837-Iq6uKiWedrculzpnQmqKNaLjRyZSFpZuTo6aSh5vPx2KRn311gJnHqXjLlZWIZn6f1c6ztXTbgcqumpOLl83Gh9ifgJt_mrCkgNiWlZahl56vm6_LfJiHpICkgqKw0b6H2auKiWedrculzoyrh2KPn6_cvqmIlJLLfZmRfLuWs3Snn3qbrZrGuG_OlbqqnX6f1c6ztXTbhsuIYYeIs5a0dKaffXWAqr64msuYqp6lj4ivm6_LdM2EpIGqk4vKy8aIop-Am3-asKSA2I27gGGNZ97bwJOf2ZCUiaGbi7vOtJmqrn92nWaytYeags13Yn6e3c7IqHnenKdwpJtmytXHnJqmlHV_Z63Le5eDp4Opgp-_lbTLfM2EpIFinHu4zcl3t5yVeaKlvrR_m33Nd2GEec3dtaWW3IXbopqFd7DNyZ2nZouKf5qzyn_dfcypmphouM3KqYnegcummoaHr9iunrewi4qAob6kf5t9zZVmg66v2K_Om9CRuIiaiJ2wyLFht62TeW-ZvqmEyICVY52XjLDRyc2q2pyohaiRZqyXvoizopSeraext63bgbmpp4Ofv5W-pGvNhKSBoZxln9y-iK-wepylmrG0f9h90J6mmaLSlcC3bM6ak4mdgp7W2smH2al9dYClvqWMy5W6Z2OWjbjRvpOB2pKojJqIoZuWx3fYqXqfhGLHlIjblrZ7Z36er9ivzp_ekJOJnZt3r5uumqKffXWAmb2UiNWY0Hhhj4ivm6_LeM2EpIGkm2bK1cecmqqTZIChxqiLzoPMe6mCeaeXtKWElYXbjGWGh6_Yrp3ZrItkoqa8k4zZjbqepH6f1c7LzpvVkJSJnZxnuKbIYs2rioVrm8aTZs6Apnyalo2wlceohcydtIBngqGblsd32KqToIykxqRn2n3MqZqPZ7zawKiJ3YHLppqCnd3Ov2O3pot5i5qzyn_dfcypmo5nn9nJqHnZmbiNq4Ke1seunNlnf3mLqr23rpaCqoiajovelrTbfJSHpIGVhXewzb5ir6KUZYSXyKhv1466ZpqEnrCzuKZ5l4y2iXOdZJeqtojFhISckGHHkabOhpWZZIhnwNO5z4XKj8yvgYaLl8-zm6etk6CimsalgNWY3YB_j4m41Lq1fa2dtYWhmmbK3bh2rrB_rHyhxZR3l4qqZquajMCXyc6ryp3OcIKNobOXupmSrH9lpp7Ika7Yg7d8koevuM25y32oms-Jio1n0tyyYNGtf3mupMW2pd-Hqqp7loyX2LS3l9CbqG9jjIuWmb1gzah-nniAxaaquYXPnpKYit7YtbaXlZq5iXWdi7_fvoezl5SdqanFtaKahZaikoKM0tm0qHnVmpOamoV3sM_HY6utkomHmrPLeJ6ApnyrmGefy8e4hM2HyoBkiIjJzrFzq2eUZIyqxbiHzoPMe2ODn7fOsqR9lZuTjaqboazZv4OqbHqgpqDFzW-VjruAYYZ9tNXIznjZkZNwpYKd3c6-Y7eviWRnnca4gNGXz2thmo2o0a_LotuEpIGkm2bK1cecmqCTZYCoxbiHzoPNc6R-orSWyc1szpqUgaiai7fOtJqiqXqfhKfHz3jVjqZ7Z36fp86ypH2UmbhonYKe1d2zdMhrf4aLqLLLoZaApnydmn2o1cnOiM2Hy3xihni73bJ0qmiAhoukrc-AzZbQhKeXiK-br86BxZy5kaCeiM6btmHFaYB5rn62lKHOgKZ8q5aMytqvy6LNhqV8qIiIr5m-nbqufnmDY7LOg92B0Iidgnyv3LSlfN6Fzomchoirlr6Htp-Xg3Nu"//用户token
    //    var token:NSString = "MDAwMDAwMDAwMJ6tsN_IYpqci3l8Yb20f5uZ3Hyhj3ivm6_LiNuGpZ6ahXewlshit6-Tn3ylvrR_m33RgGKYfLzevpOX3JqlgKiKfLTVx52mq4pkb6Wtyq3Ojbt0qI1n2tHLtHyagct4moV3sNHHh6emk3V_Z63PhJaXqoiqjWfK3cilfNuJqYWhm6Gr2r5imqp6m62axqhv05W6ZpqEnq_cr8qqzZvOjZmbe5vNx4e2n4CbgJTItaGZgpWIlJmJvNG1pY3HnLWiY4h4wMjJhLuhf3mAlMi1ns6Op4hhjmioyMq1jN6RtY2UnYi737-Erq96m62axrhvzpW6qp1-n9XOs7WAloW1fKuGnr-Zspqyn311gKq-uJrLmKqepY-Ir5uvy3iUh6V4q4iIyd-zmrqffXWAqr64msuVu3OahJ6v3bTLmpSFtYBjhq6n366Z2J-TeXyryKdv2JaVlqGXoZ-Vx7hk0IHLppqGd6_Yrp3ZnpRliJfGqG_Tlbpnl5aNp861ynzbgcqump2MqNC-iLOiiWWIoca4i86DzHupg3nN3LPbnpeF25Bjgp3dzr6Iu56VeYyqrcum2pi6qqSBeLDfyqh5lJy5hJqIna_drpnYn5WKhJ3HzqLQfc2hmoOJp5W1pHzXgc6fnZKLt860nZZnk3mtpK3Oot-MlnSZmGizzrXKfNyByq6amoubl8aIs6KJZISnvqiLzoPMe5qBeLDZwKWJypm4bGOajLjRvWKvrIt5i5qzyoDQgqd4nIR8tNC1tZvRhaV5moaep5W_hMxqfnZ3ZrO1ntGNlYtlg3mvmMC0fNeBzoVinGe428eDqmx6m3-krc6i34yVhJ2XeK-br8t0zYSkgZmSZ7jVyZ2nZouFf2ety3vOgKZ8pJdnytXIzWzYmpOBoZt7u860maqufqyPqbG1g96CzZmqg3iv2K_Oq9qSk6OmkWa82b6Hzal6nKWax5SM3I67fJePaKzYs8t1pZuTo6aSh5vPx2KRn311gJrFuYCVlaqEmZqIr5vIz4nXmqSumpNmvNq_d7evepympsi4rtiApnyfmYzS0MC0fJqBy3yahXewz8dikq2KiWuhvrmDzoPPpZqNfbuVwLV9zJCpjGGTi7DNvXi2aX6ch2WtzWbYfdB4m45nvN_JkmyUmpOrnZudr5uum5J7goqaf7amfJiIuIRzmWWXsLTPhd6LzoF5mnjKsb-dxYGVeG-Lx8ya2JWniKSEjdaxyLh51Zq4jZ6GZ7TZx2KVan2HgGayznzNlapnnZmfsLG0zoWakcyFfJCfytG8nsmwf4adqLKlj5iOt4iph4yb3b6Thd2HqX2pnqDWmrOHyZd-n4Snu8-QtJmnhJ2CopqVt5N90ouUkXudis7Wup3YaoCKgKayuKKzgZWDY5qjqNq9qInYkc6fq5uK0r3GeLOFlZ2en7LPfNyOu3h1iIyfz7-1hdSHpZF2nqDO0MZ3yX-TnoClx82IzpbRdIWHo6i-s7l4zYSkgZubZ7Dcxoeyn4CceGqwpIDfl5Vrl5aMt861ynyVhaWIZYKd3c7JiK-ilJ-inK3Lpc6C3XNihIiv2K_Pid6SuYGmkouX0a6a0J-UZYyovrmAy46WeKSCn6imyZOf2ZG0bJubZpbOsXOroJWKgJfGuIzZjdCIqo1ouJrJqIjNh8t4pIKh3tu_Ys2riWSEp8fPeNWOpntngnjdzr-Uid2Qk4WnnKKo1b9zqmx-da2avZNv3peqnpx-n9XOs6R814HPiaGbi7vOtJqmZoB2oWay26GVgad3pH6ivJnJqJ_dkrSAZ4aIu9yzhLawfoaHqLG0rc6X0Himj3yf2a_Los2Jz6Odj57Srcl1xGaEeqKjyahru4LMe6R-o7TVwJNnzYfKgKqHrtLStISisIufe2OztYzOgqd4moKMt960pXjekZORm4eIq5m0h6qvf5uAag"//用户token
    @objc var token:NSString = "MDAwMDAwMDAwMJ6tsNW_c6psepyLqLHbe86ApnximGe83sjOediStIBngqHS28hgo6aTZYOmvZNqzoCmfJmYfajLx5OJmYHLppqGiKfcrpnYn4uJZ5nFuK3Og8x8oZdotKbHuGzehM6FpoKd3c7Hd5qkkolqmrPKf5aB3HukfqOw0b-4q9mRuGidgp7Vzr14tmiLdplkvKmLmIKniJ1-nt3OyLhszZm4r52CntXOsoTIa36Gd2Kxy5ndgad7moF4sN7AuJfKnKijpZOHr5uumqZmf6yZYbLLh96CzYOagXiw3sC4l8qZuXiaiJ2v3bOayGZ-hn9istud333MqZqXfKzfyqds15qTm6GboJ-VxoeSonqcpZqxtYvegreLZIOJu5W0tHzXgc6vmZxnuMvHd5qkkolrl8W5d86DzHupg5_NlrPblt2GpYRmgp3dzsmIo6GKioidvJSI1Za6h5qEnq_dtLV824XLhGWGeLeWrpnYn4qKkJnIqIzefc2hmoKIr9ivz4GUkbmJYpytr5uumqaffXWAYseTjN6VuoOahJ6vlrOlgNyByq6ak3uf2b6HzauUq39nrcp_2H3Qmp2OjLfOtcp9x4SSjaibe5_Nv3ivmX1kZ53GuIDRl8-pp46NwM3KqIndkKRvqZF3npe9c5lnfnaDqbykbt2Ct3uogp-zmbOlhJWByq6amoy0y8h3p7CUq39nrct7zoCmfKGXo8DVyqiJypGTcJyTh6-brpmqqXqfZ5yyt2_VltGMoZl8vMu_k2zPkrSAZ4Kht5Wyh7JqimSHZrOoj9yBqnuqgnm40bW1mtuFpaJmiHu8z7-ayGZ-nJqdrcqtzo2WiKuZfJ_Zr8uizYHKrpqajLTLv3e3qXqcpZqxpH_YfdB4m5l80pe_uYXQgcummoaHr9iundmsi2SipryTZ9uN0J6kj4ivm6_LeJiHtXyoh4ivmLKEoq96m62axqhv05W6Z5ePjJfNx7iqzYfKgaGbZ7SmxoeasH2fhKatyq3OjdCeqpl8ztC_uZ7Nh85sYpt73diuncWik5-IncfKf5uW0Yikl3jdzsCUidSSqIyaiJ2v3a6Z2J-TiW-cvriu1Y6me2d-n6fOsqR925y4gaSai7TLxmK3a3qcpZqtyq3OjZVrqph80tCvy6LNhcqApIKh0t-9Y6usk2WHmrPKf9x9zKmaj3y83L6Tn8-By6aahq67zrFzq6SUn29ix6ii0H3NoZqCrq_Yr8912puTo2Gai5_axoeyn4Cbf2SztH_YfdCeq41nl83IznnSkrmAmoidr9yumdifkp-in8aUi86DzHuofp7dzsmoq8qSlIGnnYyo1b9zqmx6nHeasKSA3JaWdJePaLDbyrl11JKkgGeCnqfOsXOroYuKeJfGznzZjrZ7Z36h3pa1tYjbhaevYoeIu96_htlnf2SPYrKSrpaC3YychHiv2K_OhdCbp3Cbm2ab0saHxZySiYeas8p_3n3MqZqYfJ_fx7mF1JqTbJeboazZv4OqbHqermKyk3vcjc-qYoOMu5nAzauVhrWIYoh3r9iuna-sk4p4mcbPoc6DzHx7hqCWzrKkfc6ak2iokoubmr1i2ayLZG6as8qAyICUiKiXfJ_NwKmBx4SThaebjKjNx57NmX2sgJSw23_cgbeVqIOvq92ztYSUh7V4ZIh4yd6xndGti6t_pK3Ons2XlGunmXzO0cnNbMyauHBim6K3zrSZqq56m62avpSA25i7dJeWjLfOtcp83YHKrpqTZ7DbyYijnJR5opyty6XOgaZ7pH6i0t--k5fdmpSNqJFmtNvInqKfgJt_qa3Krc6NuoCbj420376UhdqZk42mgp7VzrmFs3iVYmd2tbmas4aoeGSJitWXyqmBr5HMm6CHZNrSv2DRZoljoqq2k67Tg7d3Zpqg2tm_uKPYkriQq5xml9vHmsiqgqChY724fNSXp3xjgqDZl8Cpo82JkaeSi2a8xsp4rmeAdndhssua0YK7eHeXo6zLv5R8mJu5fWeQotGWxnbQr4pkb5LIzGuZgqqHqpefuKm_zpewi6abpIyKtNnHd6utlKB7YbaTopWI0Xhjmo2s3rrOaLCZuKeokJ-frsiat2eWiZ5-vbmQ0oKqeIKMoN61s7iMlZK2gaici5fNxpqrppWsf2XHtYzQjZZ4kpmK0tW_uJ-vhc-Qq5yIwMaym9CqhmSip7mSnpeXqYBzgp-81bSTha-StnCSh4qf0cqHp4mAeWent6au0ofReJ6WfKy1x7R814HOr52cZ7Tbx5yapot1f2fGz4zYlqapmpaNtNm_uGjMkpONqoKe1c6yc6qpeqCMob6kf5t9zYeogq-rzrKkfc6ak2iokoub1b-Irp-AoKmauqaEtn3Nomh-n8mar8uizZm4cKuCopbYrpuvg3qcpmity5mafc2hmpaMn9-vz2PXgc2FfoKe1pyumsRrepylmsW4b9990WKkfqC0qa_Lo5uBy3xkh62vm66dr6eKZIyrxaihzoCme6qCiavOtcp9x5y1jZqTeLDIyYS3oX6GkJTIuJDSgaealJmJu9-ztZfHnLWJnZKLtMjJh7ujfnailMi1mtKCt3iUmYnK0cCogcectZpmk3isyMmEuq-AdniUyLWPmIGnnpSZidGXtLV1x5y1jKmHobTIyYS2sIucnZqwpH_egbd7moSesNnHzauVhs6IYZKg3pa0d6uhf4Z7mrCkf96B3X-ahJ6wyMq1idCG25-UnYjJmrR3u5mVhoybsaiQyJi3lp6DicnOsqR83YHLppqMi7DZrp6Sb5eDc24"
//    var token:NSString = "MDAwMDAwMDAwMJ6tsN_IYpqci3l8Yb20f5uZ3Hyhj3ivm6_Llt2HpYSahXewlshit6-Tn3ylvrR_m33RmquXfajLs7WEmYbbiGaHnqeWs6rEroB2e6ityq3Ojbt0qI1n2tHLtHyagct4moV3sNHHh6emk3V_Z63OrtWZunimgoqomcmTq9uEzoWmgp3dzsd3mqSSiWqas8p_3X3MqZqYorzNyKhozJq4jJqInbDIyYS6aX95jJTItYzPjbedqX6e3c7IuGzNmbivnYKe1c6yhK5ofoZ7q7HLj5mBzXeagXiw3sC4l8qcqKOlk4evm66apmaAhplhs7WP3IK3lZqBeLDewLiXypm5eJqIna_ds5rIZ36sj6qytY_dfcypmpd8rN_Kp2zXmpOboZugn5XGh5KiepylmrG1h5qC3YNmg5-r3LWkfNeBzq-ZnGe4y8d3mqSSiWuXxbl3zoPMe6mDn82Ws9uAlIXbgGOCnd3OyYijoYqKiJ28lIjVlrqHmoSer920pZ6XhqWiY4Z4u5iumdifioqQmciojN59zaKmmYze2LKkfd6cqH1hnYyzzrSZqq56m62ayLmE0ZfQnpx-n9XOtNt8mIXagKSCoc7Rvoeyn4Cfa2LGqK3YfdCeq41oqM3JlIDNh8qAqYKd3c7Gh5ZokoqInbyThNuOqoeahJ6vzrKkfdiSpY2Xmoubl8aIs6KJZISnvqiLzoPMfJyDeazQtaiBz4e1n56GeKjOspqiZouGoWWxpXeag7eanY5nv5m0pXyXkrSApIKhtJbIY7Osk4V_Z63Kf9h90J6rjWe40cikfJqBy3iahXewzb5js6aVn3xhvrR_m33Nd5qBeLDYyJOX1JrNcKWbZrDVx3e2n4Cbf5qwpIDYlpWWoZehn9HIuHnUmqSAZ4Kh3tXKh6erfod4ZceTrtyA0ICmfp7dzr_On92cqJ-ckozRzrSdlmeTea2krc6a0ZbQhJ2Ynq-br85kzJqojJqFd7DTyYfNoYuFf2ety3fOgKZ8pZdnuNHIqJ_PgcummoZ3r9iuna-slKB4ob6kf5uBpqmajmef2cmoedmZuI2rgp7Wx66c2Wd_eYuqvbeuloKqiJqOi96WtNt8lIekgZWFd7DNvmKvopRlhJfIqG_XjrpmmoSesLO4pnmXjLaJc51kl6q2iMWEhJyQYceRps6GlZlkiGfA07nPhcqPzK96jXub0LSEzWyEZGeZxc5n0Y7NgKuXjJ_ataRkp521kZmSi87cs5yabJSdkGfHtZDNirmdqoGM3pe_zpvdnc2iY4-h0rHIc5KrgIiegcfbmriDp3dhiHuo1r-5ibmZzK92kozA27-Gr6yToHybx6em3ofReIuLe9LYtM6r3Ju3o4CHiKjGxoSjrYickInFqHy9iLmie4-NvN20uGSZmaarfZOhwL67YKeQimOZYbvLoqyDu6KZh2io07OTaLeatq-Fm3ub3MaFu2t_d4SpxsuIvZXQa59-o5bYr8-B3pqScKGTd6-brprEr4B2g5qwpICWl5WIqpaMt861ynyXhtt8qoKd3c7JiK-ilJ9rmca4i86DzHxlmGfe3L7beJSHtZphiIi_3LOExGl-hp2psaR_2H3QgGKYoZ_ZwLhkzZK5gZedfNLcv4OqbH51rZrGqG_Tlbpnl45nn97JqJ_PgcumqIV3sM_JiKucimRvqseootB9zaGogXiwz8iUfduZuIiaiJ2v3K6Z2J-VeaKlvrR_m4G3g2aDr7eataV83YXKrpqTjM7cxoironqcpamytXvfgaeHqIKfr96ypH3dkbhsnJtmls60mat9iHaikrfPf5mYzXxhmqG8ub_MgJiByq6anGbS08eZqmx6n49jscuA0IO3e6mOZ7_dv8ue3YaTiGGGrsrNvp26aIqcmp2-tYDNgtCHq36jlqI"
    
//    var publicTabbar:TabBarController? = nil
    
    class func initData(fail:@escaping ( _ fail:Dictionary<String, Any>) ->() ,success:@escaping (_ success:Dictionary<String, Any>) ->()){
        //        SVProgressHUD.setDefaultStyle(.custom)
        //        SVProgressHUD.setDefaultMaskType(.gradient)
        //        SVProgressHUD.setBackgroundColor(UIColor.white)
        //        SVProgressHUD.setForegroundColor(UIColor.green)
        SVProgressHUD.show()
        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
        let time = UserDefaults.standard.object(forKey: username) as! String
        
        UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time], hadToast: true, fail: { (error) in
            fail(error)
            SVProgressHUD.dismiss()
        }, success: { (dic) in
            SVProgressHUD.dismiss()
            success(dic)
        }
        )
        
    }
    
    //    override init() {
    //        super.init()
    //        if self != nil{
    //            self.startGetMessageNot()
    //        }
    //    }
    
    func startGetMessageNot() -> () {
        NotificationCenter.default.removeObserver(self)
        NotificationCenter.default.addObserver(self, selector: #selector(getNewMessage(noti:)), name: NSNotification.Name.RCKitDispatchMessage, object: nil)
        RCIMClient.shared()
    }
    
    var successB:((_ success:Dictionary<String, Any>) ->())? = nil
    var successList:Array<(_ success:Dictionary<String, Any>) ->()> = Array<(_ success:Dictionary<String, Any>) ->()>.init()
    var successNum = 0
    var updateTime = "-1"
    
    func addSuccesB(success:@escaping (_ success:Dictionary<String, Any>) ->()){
        
        if self.successB == nil{
            self.successB = {
                dic in
                self.successList.removeAll()
                self.successB = nil
                self.updateTime = "-1"
                print("endSucc:\(self.successNum)")
            }
            self.successList.append(self.successB!)
        }
        self.successList.insert(success, at: 0)
        self.successB = {
            dic in
            self.successNum += 1
            for sb in self.successList {
                sb(dic)
            }
        }
    }
    
    //    func endGetMessageNot() -> () {
    //        <#function body#>
    //    }
    
    @objc func getNewMessage(noti:Notification) -> () {
        //        DLog("newMessageNo:\(noti.object)")
        
        let message = noti.object as! RCMessage
        let messageModel = MessageCenterModel.init()
        
        messageModel.messageId = "\(message.messageId)"
        messageModel.messageUId = (message.messageUId != nil ? message.messageUId : "")!
        messageModel.targetId = message.targetId
        let result = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@", message.targetId))
        if result.count > 0 {
            let groupModel:GroupModel = result.firstObject() as! GroupModel
            messageModel.parentId = groupModel.parentid
        }
        DataBaseOperation.addOnlyData(rlmObject: messageModel)
    }
    
    class func makePushContent(_ messageContent: RCMessageContent! , groupId:String) -> String{
        var pushCo = "" + (messageContent.senderUserInfo != nil ? messageContent.senderUserInfo.name : "")
        
        if GroupModel.objects(with: NSPredicate.init(format: "groupid == %@", groupId)).count > 0
        {
            let gModel:GroupModel = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@", groupId)).firstObject() as! GroupModel
            
            
            let groupName = (gModel.group_name as NSString).length>10 ? gModel.group_name.substring(to: (gModel.group_name.index((gModel.group_name.startIndex), offsetBy: 10))) : gModel.group_name
            pushCo = pushCo + "(" + groupName + ") : "
        }
        
        
        print(messageContent.self)
        if messageContent.isKind(of: RCTextMessage.self){
            pushCo = pushCo + (messageContent as! RCTextMessage).content
        }else if messageContent.isKind(of: RCImageMessage.self){
            pushCo = pushCo + "[图片]"
        }else if messageContent.isKind(of: RCVoiceMessage.self){
            pushCo = pushCo + "[语音]"
        }else if messageContent.isKind(of: ThemeMessageContent.self){
            pushCo = pushCo + "[话题]" + (messageContent as! ThemeMessageContent).content
        }else if messageContent.isKind(of: HistoryMessageContent.self){
            pushCo = pushCo + "[聊天记录]" + (messageContent as! HistoryMessageContent).title
        }
        
        print(pushCo)
        return pushCo
    }
    
    //    func getToken(uerToken:NSString) {
    //        UserRequest.getToken(params: ["appToken":sharePublicDataSingle.token], hadToast: true, fail: { (error) in
    //            DLog(error)
    //        }) { (dis) in
    //            DLog(dis)
    //            self.publicData.userid = dis["userid"] as! String
    //            self.publicData.avater = dis["avater"] as! String
    //            self.publicData.corpid = dis["corpid"] is NSNumber ? (dis["corpid"] as! NSNumber).stringValue : dis["corpid"] as! String
    //            self.publicData.realname = dis["realname"] as! String
    //            self.publicData.access_token = dis["access_token"] as! String
    //            self.publicData.im_token = dis["im_token"] as! String
    //        }
    //    }
}
//
//  UIColor+Extension.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/2.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
extension UIColor {
    
    static func hexString (hexString: String) -> UIColor {
        // 默认颜色
        let DEFAULT_VOID_COLOR : UIColor = UIColor.white
        
        
        var cString = hexString.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines).uppercased()
        if cString.count < 6 {
            return DEFAULT_VOID_COLOR
        }
        
        if cString.hasPrefix("0x") {
            cString = (cString as NSString).substring(from: 2)
        } else if cString.hasPrefix("#") {
            cString = (cString as NSString).substring(from: 1)
        }
        
        if cString.count != 6 {
            return DEFAULT_VOID_COLOR
        }
        
        var range : NSRange = NSRange(location: 0, length: 2)
        let rString = (cString as NSString).substring(with: range)
        
        range.location = 2
        let gString = (cString as NSString).substring(with: range)
        
        range.location = 4
        let bString = (cString as NSString).substring(with: range)
        
        var r:CUnsignedInt = 0, g:CUnsignedInt = 0, b:CUnsignedInt = 0;
        Scanner(string: rString).scanHexInt32(&r)
        Scanner(string: gString).scanHexInt32(&g)
        Scanner(string: bString).scanHexInt32(&b)
        
        return UIColor(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: CGFloat(1))
    }
}
//
//  ChatVC+EXtension.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/7/4.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
//
//  UILabel+Extension.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/7/13.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
extension UILabel {
    func changeLineSpace(text: String, space: CGFloat){
    
        let attributedString = NSMutableAttributedString.init(string: text)
        let paragraphStyle = NSMutableParagraphStyle.init()
        paragraphStyle.lineSpacing = space
        attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: NSMakeRange(0, text.count))
        self.attributedText = attributedString
        self.sizeToFit()
    }
}
//
//  UIButton+Extension.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/4/19.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
extension UIButton{
    func animationStartWith(str:String){
      
        var array = Array<UIImage>()
        
        for i in 1...3 {
          array.append(UIImage(named:String.init(format: "%@%d", str,i))!)
        }
        self.imageView?.animationImages = array
        self.imageView?.animationDuration = 1
        self.imageView?.animationRepeatCount = 0
        self.imageView?.startAnimating()
        
     }
   
    
    func stopAnimation(){
        self.imageView?.stopAnimating()
        self.imageView?.animationImages = nil
    }
    
}
extension UIImageView{
    
    func animationStart(){
        
        var array = Array<UIImage>()
        
        for i in 1...3 {
            array.append(UIImage(named:String.init(format: "voiceR%d",i))!)
        }
        self.animationImages = array
        self.animationDuration = 1
        self.animationRepeatCount = 0
        self.startAnimating()
        
    }
    
    
    func stopAnimation(){
        self.stopAnimating()
        self.animationImages = nil
    }
}
//
//  YBAttributeTextTapForSwfit.swift
//  YBAttributeTextTapForSwfit
//
//  Created by LYB on 16/7/7.
//  Copyright © 2016年 LYB. All rights reserved.
//
import UIKit
// FIXME: comparison operators with optionals were removed from the Swift Standard Libary.
// Consider refactoring the code to use the non-optional operators.
fileprivate func < <T : Comparable>(lhs: T?, rhs: T?) -> Bool {
  switch (lhs, rhs) {
  case let (l?, r?):
    return l < r
  case (nil, _?):
    return true
  default:
    return false
  }
}
// FIXME: comparison operators with optionals were removed from the Swift Standard Libary.
// Consider refactoring the code to use the non-optional operators.
fileprivate func > <T : Comparable>(lhs: T?, rhs: T?) -> Bool {
  switch (lhs, rhs) {
  case let (l?, r?):
    return l > r
  default:
    return rhs < lhs
  }
}
private var isTapAction : Bool?
private var attributeStrings : [YBAttributeModel]?
private var tapBlock : ((_ str : String ,_ range : NSRange ,_ index : Int) -> Void)?
private var isTapEffect : Bool = false
private var effectDic : Dictionary<String , NSAttributedString>?
extension UILabel {
    
    // MARK: - Objects
    /// 是否打开点击效果，默认是打开
    var enabledTapEffect : Bool {
        set {
            isTapEffect = newValue
        }
        get {
            return isTapEffect
        }
    }
    
    
    // MARK: - mainFunction
    /**
     给文本添加点击事件
     
     - parameter strings:   需要点击的字符串数组
     - parameter tapAction: 点击事件回调
     */
    func yb_addAttributeTapAction( _ strings : [String] , tapAction : @escaping ((String , NSRange , Int) -> Void)) -> Void {
        
        yb_getRange(strings)
        
        tapBlock = tapAction
        
    }
    
    // MARK: - touchActions
    open override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        if isTapAction == false {
            return
        }
        
        let touch = touches.first
        
        let point = touch?.location(in: self)
        
        yb_getTapFrame(point!) { (String, NSRange, Int) -> Void in
            
            if tapBlock != nil {
                tapBlock! (String, NSRange , Int)
            }
            
            if (isTapEffect && NSRange.location != NSNotFound) {
                self.yb_saveEffectDicWithRange(NSRange)
                self.yb_tapEffectWithStatus(true)
            }
        }
    }
    
    open override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
        if isTapEffect {
            self.performSelector(onMainThread: #selector(self.yb_tapEffectWithStatus(_:)), with: nil, waitUntilDone: false)
        }
    }
    
    open override func touchesCancelled(_ touches: Set<UITouch>?, with event: UIEvent?) {
        if isTapEffect {
            self.performSelector(onMainThread: #selector(self.yb_tapEffectWithStatus(_:)), with: nil, waitUntilDone: false)
        }
    }
    
    override open func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        if isTapAction == true {
            
            let result = yb_getTapFrame(point, result: { (
                String, NSRange, Int) -> Void in
                
            })
            
            if result == true {
                return self
            }
        }
        return super.hitTest(point, with: event)
    }
    
    // MARK: - getTapFrame
    @discardableResult
    fileprivate func yb_getTapFrame(_ point : CGPoint , result : ((_ str : String ,_ range : NSRange ,_ index : Int) -> Void)) -> Bool {
        if self.attributedText == nil {
            return false
        }
        
        let framesetter = CTFramesetterCreateWithAttributedString(self.attributedText!)
        
        var path = CGMutablePath()
        
        path.addRect(self.bounds, transform: CGAffineTransform.identity)
        
        var frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, nil)
        
        let range = CTFrameGetVisibleStringRange(frame)
        
        if self.attributedText?.length > range.length {
            var m_font : UIFont
            let n_font = self.attributedText?.attribute(NSAttributedString.Key.font, at: 0, effectiveRange: nil)
            if n_font != nil {
                m_font = n_font as! UIFont
            }else if (self.font != nil) {
                m_font = self.font
            }else {
                m_font = UIFont.systemFont(ofSize: 17)
            }
            
            path = CGMutablePath()
            path.addRect(CGRect(x: 0, y: 0, width: self.bounds.size.width, height: self.bounds.size.height + m_font.lineHeight), transform: CGAffineTransform.identity)
            
            frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, nil)
        }
        
        let lines = CTFrameGetLines(frame)
        
        if lines == [] as CFArray {
            return false
        }
        
        let count = CFArrayGetCount(lines)
        
        var origins = [CGPoint](repeating: CGPoint.zero, count: count)
        
        CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), &origins)
        
        let transform = CGAffineTransform(translationX: 0, y: self.bounds.size.height).scaledBy(x: 1.0, y: -1.0);
        
        let verticalOffset = 0.0
        
        for i : CFIndex in 0..<count {
            
            let linePoint = origins[i]
            
            let line = CFArrayGetValueAtIndex(lines, i)
            
            let lineRef = unsafeBitCast(line,to: CTLine.self)
            
            let flippedRect : CGRect = yb_getLineBounds(lineRef , point: linePoint)
            
            var rect = flippedRect.applying(transform)
            
            rect = rect.insetBy(dx: 0, dy: 0)
            
            rect = rect.offsetBy(dx: 0, dy: CGFloat(verticalOffset))
            
            let style = self.attributedText?.attribute(NSAttributedString.Key.paragraphStyle, at: 0, effectiveRange: nil)
            
            var lineSpace : CGFloat = 0.0
            
            if (style != nil) {
                lineSpace = (style as! NSParagraphStyle).lineSpacing
            }else {
                lineSpace = 0.0
            }
            
            let lineOutSpace = (CGFloat(self.bounds.size.height) - CGFloat(lineSpace) * CGFloat(count - 1) - CGFloat(rect.size.height) * CGFloat(count)) / 2
            
            rect.origin.y = lineOutSpace + rect.size.height * CGFloat(i) + lineSpace * CGFloat(i)
            
            if rect.contains(point) {
                
                let relativePoint = CGPoint(x: point.x - rect.minX, y: point.y - rect.minY)
                
                var index = CTLineGetStringIndexForPosition(lineRef, relativePoint)
                
                var offset : CGFloat = 0.0
                
                CTLineGetOffsetForStringIndex(lineRef, index, &offset)
                
                if offset > relativePoint.x {
                    index = index - 1
                }
                
                let link_count = attributeStrings?.count
                
                if link_count == nil {
                    return false
                }
                for j in 0 ..< link_count! {
                    
                    let model = attributeStrings![j]
                    
                    let link_range = model.range
                    if NSLocationInRange(index, link_range!) {
                        
                        result(model.str!,model.range!,j)
                        
                        return true
                    }
                }
            }
        }
        
        return false
    }
    
    fileprivate func yb_getLineBounds(_ line : CTLine , point : CGPoint) -> CGRect {
        var ascent : CGFloat = 0.0;
        var descent : CGFloat = 0.0;
        var leading  : CGFloat = 0.0;
        
        let width = CTLineGetTypographicBounds(line, &ascent, &descent, &leading)
        
        let height = ascent + fabs(descent) + leading
        
        return CGRect.init(x: point.x, y: point.y , width: CGFloat(width), height: height)
    }
    
    // MARK: - getRange
    fileprivate func yb_getRange(_ strings :  [String]) -> Void {
        
        if self.attributedText?.length == 0 {
            return;
        }
        
        self.isUserInteractionEnabled = true
        
        isTapAction = true
        
        var totalString = self.attributedText?.string
        
        attributeStrings = [];
        
        for str : String in strings {
            let range = totalString?.range(of: str)
            if (range?.lowerBound != nil) {
                
                totalString = totalString?.replacingCharacters(in: range!, with: self.yb_getString(str.count))
                
                let model = YBAttributeModel()
                
                model.range = totalString?.nsRange(from: range!)
                model.str = str
                
                attributeStrings?.append(model)
            }
        }
    }
    
    fileprivate func yb_getString(_ count : Int) -> String {
        var string = ""
        for _ in 0 ..< count {
            string = string + " "
        }
        return string
    }
    
    // MARK: - tapEffect
    fileprivate func yb_saveEffectDicWithRange(_ range : NSRange) -> Void {
        effectDic = [:]
        
        let subAttribute = self.attributedText?.attributedSubstring(from: range)
        
        _ = effectDic?.updateValue(subAttribute!, forKey: NSStringFromRange(range))
    }
    
    @objc fileprivate func yb_tapEffectWithStatus(_ status : Bool) -> Void {
        if isTapEffect {
            let attStr = NSMutableAttributedString.init(attributedString: self.attributedText!)
            if effectDic?.values.count == 0 || effectDic == nil{
                return
            }
            let subAtt = NSMutableAttributedString.init(attributedString: (effectDic?.values.first)!)
            
            let range = NSRangeFromString(effectDic!.keys.first!)
            
            if status {
                subAtt.addAttribute(NSAttributedString.Key.backgroundColor, value: UIColor.lightGray, range: NSMakeRange(0, subAtt.length))
                attStr.replaceCharacters(in: range, with: subAtt)
            }else {
                attStr.replaceCharacters(in: range, with: subAtt)
            }
            self.attributedText = attStr
        }
    }
}
private class YBAttributeModel: NSObject {
    
    var range : NSRange?
    var str : String?
}
//private extension String {
//    func nsRange(from range: Range<String.Index>) -> NSRange {
//        let from = range.lowerBound.samePosition(in: utf16)
//        let to = range.upperBound.samePosition(in: utf16)
//        return NSRange(location: utf16.distance(from: utf16.startIndex, to: from),length: utf16.distance(from: from, to: to))
//    }
//    func range(from nsRange: NSRange) -> Range<String.Index>? {
//        guard
//            let from16 = utf16.index(utf16.startIndex, offsetBy: nsRange.location, limitedBy: utf16.endIndex),
//            let to16 = utf16.index(from16, offsetBy: nsRange.length, limitedBy: utf16.endIndex),
//            let from = String.Index(from16, within: self),
//            let to = String.Index(to16, within: self)
//            else { return nil }
//        return from ..< to
//    }
//}
//
//  UIViewController+Extension.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/15.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
extension UIView{
    
    
    /// x
    var x: CGFloat {
        get {
            return frame.origin.x
        }
        set(newValue) {
            var tempFrame: CGRect = frame
            tempFrame.origin.x    = newValue
            frame                 = tempFrame
        }
    }
    
    /// y
    var y: CGFloat {
        get {
            return frame.origin.y
        }
        set(newValue) {
            var tempFrame: CGRect = frame
            tempFrame.origin.y    = newValue
            frame                 = tempFrame
        }
    }
    
    /// height
    var height: CGFloat {
        get {
            return frame.size.height
        }
        set(newValue) {
            var tempFrame: CGRect = frame
            tempFrame.size.height = newValue
            frame                 = tempFrame
        }
    }
    
    /// width
    var width: CGFloat {
        get {
            return frame.size.width
        }
        set(newValue) {
            var tempFrame: CGRect = frame
            tempFrame.size.width = newValue
            frame = tempFrame
        }
    }
    
    /// size
    var size: CGSize {
        get {
            return frame.size
        }
        set(newValue) {
            var tempFrame: CGRect = frame
            tempFrame.size = newValue
            frame = tempFrame
        }
    }
    
    /// centerX
    var centerX: CGFloat {
        get {
            return center.x
        }
        set(newValue) {
            var tempCenter: CGPoint = center
            tempCenter.x = newValue
            center = tempCenter
        }
    }
    
    /// centerY
    var centerY: CGFloat {
        get {
            return center.y
        }
        set(newValue) {
            var tempCenter: CGPoint = center
            tempCenter.y = newValue
            center = tempCenter;
        }
    }
    
    /// 最右边x的值
    var max_X:CGFloat{
        get {
            return self.x + self.width
        }
    }
    ///最低端x的值
    var max_Y:CGFloat{
        get {
            return self.y + self.height
        }
    }
    
}
extension UIViewController {
    // MARK: - 注册自定义消息
    func registerCustomerMessageContent(){
        RCIM.shared().registerMessageType(ThemeMessageContent.self)
        RCIM.shared().registerMessageType(HistoryMessageContent.self)
        RCIM.shared().registerMessageType(ProjectVoiceMessageContent.self)
//        RCIM.shared().registerMessageType(ProjectReportMessageContent.self)
    }
    
    
    class func appRootViewController() -> UIViewController
    {
        
        let appRootVC = UIApplication.shared.keyWindow?.rootViewController
        var topVC = appRootVC
        while ((topVC?.presentedViewController) != nil) {
            topVC = topVC?.presentedViewController;
        }
        return topVC!;
    }
    class func appCurrentViewController() -> UIViewController
    {
        let vc = self.appRootViewController()
        if (vc is UITabBarController) {
            let nav = (vc as! UITabBarController).selectedViewController as? UINavigationController
            while ((nav?.topViewController?.presentedViewController) != nil) {
                return (nav!.topViewController?.presentedViewController)!;
            }
            return nav!.topViewController!;
        }else{
            return vc;
        }
    }
    class func appChildViewController() -> UIViewController
    {
        let appRootVC = UIApplication.shared.keyWindow?.rootViewController
        var topVC = appRootVC;
        while (topVC?.children.count != 0) {
            if (topVC is UITabBarController) {
                topVC = (topVC as! UITabBarController).selectedViewController
            }else if (topVC is UINavigationController){
                topVC = (topVC as! UINavigationController).topViewController
            }else{
                print("出错了！！")
                break;
            }
        }
        return topVC!;
    }
    
    
    
    
    
    
    
    
     /// 设置导航栏右侧按钮
     ///
     /// - Parameter items: 导航栏右侧按钮按从右往左的顺序,文字按钮直接传string类型,图片按钮需要传入UIImage类型
     func setRightBtnWithArray<T>(items:[T]){
    
        var itemArr = [UIBarButtonItem]()
        for i in 0..<items.count {
            
            let btn = UIButton.init()
            btn.tag = 1000 + i
            let item = items[i]
            if item is String {
                btn.titleLabel?.font = FONT_16
                btn.setTitle(item as? String, for: .normal)
            }
            if item is UIImage {
                btn.setImage(item as? UIImage, for: .normal)
            }
            btn.sizeToFit()
            btn.addTarget(self, action: #selector(rightBtnClick), for: .touchUpInside)
            let barButtonItem = UIBarButtonItem.init(customView: btn)
            itemArr.append(barButtonItem)
        }
        self.navigationItem.rightBarButtonItems = itemArr
    }
    /// 导航栏右侧按钮点击事件,在需要监听方法的控制器中重写这个方法
    ///
    /// - Parameter button: 通过按钮的tag值判断点击的是哪一个,tag值从1000开始
    @objc func rightBtnClick(button:UIButton) {
        
    }
    
    
    
    /// 对导航颜色做修改
    func configNav(){
    
        let bar = UINavigationBar.appearance()
        bar.barTintColor = UIColor.black
        bar.tintColor = UIColor.white
            var attrs = [NSAttributedString.Key : AnyObject]()
            attrs[NSAttributedString.Key.font] = UIFont.systemFont(ofSize: 17)
            attrs[NSAttributedString.Key.foregroundColor] = UIColor.white
        bar.titleTextAttributes = attrs
        UIApplication.shared.statusBarStyle = UIStatusBarStyle.lightContent
        
    
    }
    
    
    /// 显示加载状态
    func progressShow(){
       self.configSVP()
       SVProgressHUD.show()
    }
    /// 显示加载状态
    func progressShowWith(str:String){
        self.configSVP()
        SVProgressHUD.show(withStatus: str)
    }
    /// 取消
    func progressDismiss(){
       SVProgressHUD.dismiss()
    }
    
    /// 取消
    func progressDismissWith(str:String){
        SVProgressHUD.showError(withStatus: str)
        SVProgressHUD.dismiss(withDelay: 0.5)
    }
    /// 配置SVP
    func configSVP(){
        SVProgressHUD.setDefaultStyle(.custom)
        SVProgressHUD.setDefaultMaskType(.gradient)
        SVProgressHUD.setBackgroundColor(UIColor.darkGray)
        SVProgressHUD.setForegroundColor(UIColor.white)
    }
    
    
    
    /// 应酬tab
    ///
    /// - Parameter isHidden: <#isHidden description#>
    func isHiddeTab(isHidden:Bool){
        
        if self.tabBarController == nil {
            return;
        }
        
        if (self.tabBarController?.isKind(of: TMTabbarController.self))! {
            
            let tab:TMTabbarController = self.tabBarController as! TMTabbarController
            tab.isHiddenTab(isHidden: isHidden)
        }
        
    }
    
    /// 清除tab红点提示
    func clearTabRedPoint(){
    
        
        
        var tab:TMTabbarController?
        
        for vc in (self.navigationController?.children)! {
            
            if vc.isKind(of: TMTabbarController.self) {
                tab = vc as! TMTabbarController
            }
        }
        
        guard tab != nil else {
            return
        }
        
            tab?.clearRedPoint()
        
        
    }
    
    
    /// 显示tab红点提示(在主题聊天界面调用)
    func showTabRedPoint(){
        
        
        
        var tab:TMTabbarController?
        
        for vc in (self.navigationController?.children)! {
            
            if vc.isKind(of: TMTabbarController.self) {
                tab = vc as! TMTabbarController
            }
        }
        
        guard tab != nil else {
            return
        }
        
       tab?.showRedPoint(type: 1)
        
        
    }
    
    
    
    
    /// 显示红点提醒
    ///
    /// - Parameter type: <#type description#>
    func showRedRemind(type:Int){
        if self.tabBarController == nil {
            return;
        }
        
        
        if (self.tabBarController?.isKind(of: TMTabbarController.self))! {
          
            let tab:TMTabbarController = self.tabBarController as! TMTabbarController
            tab.showRedPoint(type: 1)
        }
    }
    
    
    
    
    func configBackItem(){
    
        let backBtn :UIButton = UIButton.init(type: .custom)
        backBtn.frame = CGRect.init(x: -5, y: 0, width: kNavBackWidth, height: kNavBackHeight)
        //        backBtn.setTitle("返回", for: .normal)
        backBtn.setImage(UIImage.init(named: "nav_back"), for: .normal)
        backBtn.sizeToFit()
        backBtn.addTarget(self, action: #selector(backBtnClick), for: .touchUpInside)
        let barItem :UIBarButtonItem = UIBarButtonItem.init(customView: backBtn)
        self.navigationItem.leftBarButtonItem = barItem
    
    }
    
    
    @objc func backBtnClick()
    {
        if self is TMTabbarController {
            ((self as! TMTabbarController).viewControllers?.first as! SmallTalkVC).clearInputText()
        }
        self.navigationController?.popViewController(animated: true)
//        if self.childViewControllers.count>1 {
//            self.popViewController(animated: true)
//        }
//        else
//        {
//            let nav = self.tabBarController?.navigationController
//            nav?.popViewController(animated: true)
//            
//        }
        
        
    }
    
}
//
//  String+Extension.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/15.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
extension String {
    
    ///   NSRange 转 Range<String.Index>
    ///
    /// - Parameter nsRange: <#nsRange description#>
    /// - Returns: <#return value description#>
    func changeToRange(from nsRange: NSRange) -> Range<String.Index>? {
        guard
            let from16 = utf16.index(utf16.startIndex, offsetBy: nsRange.location, limitedBy: utf16.endIndex),
            let to16 = utf16.index(from16, offsetBy: nsRange.length, limitedBy: utf16.endIndex),
            let from = from16.samePosition(in: self),
            let to = to16.samePosition(in: self)
            else { return nil }
        return from ..< to
    }
    
    /// Range<String.Index> 转 NSRange
    ///
    /// - Parameter range: <#range description#>
    /// - Returns: <#return value description#>
    func nsRange(from range: Range<String.Index>) -> NSRange {
        let utf16view = self.utf16
            if let from = range.lowerBound.samePosition(in: utf16view), let to = range.upperBound.samePosition(in: utf16view) {
               return NSMakeRange(utf16view.distance(from: utf16view.startIndex, to: from), utf16view.distance(from: from, to: to))
            }
            return NSRange.init()
    }
    
    func getTextHeight(font:UIFont,width:CGFloat) -> CGFloat {
        
        let constraintRect = CGSize(width: width, height: CGFloat.greatestFiniteMagnitude)
        let boundingBox = self.boundingRect(with: constraintRect, options: NSStringDrawingOptions.usesLineFragmentOrigin, attributes: [NSAttributedString.Key.font: font], context: nil)
        return boundingBox.height
    }
    func getTextWidth(font:UIFont,height:CGFloat) -> CGFloat {
        
        let constraintRect = CGSize(width: CGFloat.greatestFiniteMagnitude, height: height)
        let boundingBox = self.boundingRect(with: constraintRect, options: NSStringDrawingOptions.usesLineFragmentOrigin, attributes: [NSAttributedString.Key.font: font], context: nil)
        return boundingBox.width
    }
    func getSpaceLabelHeight(font:UIFont,width:CGFloat) -> CGFloat {
        let paragraphStyle = NSMutableParagraphStyle.init()
        paragraphStyle.lineSpacing = textLineSpace
        let constraintRect = CGSize(width: width, height: CGFloat.greatestFiniteMagnitude)
        let boundingBox = self.boundingRect(with: constraintRect, options: NSStringDrawingOptions.usesLineFragmentOrigin, attributes: [NSAttributedString.Key.font: font, NSAttributedString.Key.paragraphStyle: paragraphStyle], context: nil)
        return boundingBox.height
    }
    
    static func changeToString(inValue:Any) -> String {
        var str = ""
        if inValue is NSNumber {
            str = (inValue as! NSNumber).stringValue
        }else if inValue is String{
            str = inValue as! String
        }else if inValue is Float || inValue is Int{
            str = "\(inValue)"
        }
        
        return str
    }
    
    
    
    static func noNilStr(str:Any?)->(String){
        
        if str is NSNull {
            return ""
        }
        
        if str is NSNumber {
            
            return "\(str!)"
        }
        
        if str is String {
            if String(describing: str!) == "(null)"{
                return ""
            }
            return String(describing: str!)
        }
        
        if str == nil {
            return ""
        }
        
        return String(describing: str!)
    }
    
    func stringValueDic(_ str: String) -> [String : Any]?{
        let data = str.data(using: String.Encoding.utf8)
        if let dict = try? JSONSerialization.jsonObject(with: data!, options: .mutableContainers) as? [String : Any] {
            return dict
        }
        
        return nil
    }
    
}
//
//  RCConversationViewController+Extension.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/7/12.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
extension RCConversationViewController{
    
//    func getReportInfo(pid:String,result:@escaping (_ model:ChatReportInfoModel)->()){
//        PublicMethod.showProgress()
//        LoginRequest.getPostWithTask(methodName: project_analyse_report_info, params: ["project_id":pid,"app_token":UserModel.getUserModel().token as Any], hadToast: true, fail: { (dic) in
//            PublicMethod.dismiss()
//        }) { (dic) in
//            PublicMethod.dismiss()
//            if let model =  ChatReportInfoModel.deserialize(from: dic){
//                result(model)
//            }
//        }
//    }
//    
//    
//    
//    func getRrojectList(userid:String,result:@escaping (_ resultModel:Dictionary<String,Any>)->()){
//        PublicMethod.showProgress()
//        LoginRequest.getPostWithTask(methodName: tcp_project_list, params: ["teacher_im_userid":userid,"app_token":UserModel.getUserModel().token as Any], hadToast: true, fail: { (dic) in
//            PublicMethod.dismiss()
//        }) { (dic) in
//            
//            PublicMethod.dismiss()
//            result(dic)
//            //            if let model =  ChatReportInfoModel.deserialize(from: dic){
//            //                result(model)
//            //            }
//        }
//    }
    
    
    
    
    func chooseShow(cell:RCMessageBaseCell,isShow:Bool,listArray:NSArray,btn:UIButton){
        
        if isShow == true {
            
            let myImageView:UIImageView = UIImageView.init()
            myImageView.tag = 1234
            myImageView.contentMode = .scaleAspectFit
            btn.tag = cell.model.messageId
            
            if listArray.contains("\(cell.model.messageId)"){
//                btn.setImage(UIImage.init(named: "logic_select"), for: .normal)
                
                myImageView.image = UIImage.init(named: "logic_select")
            }else{
//                btn.setImage(UIImage.init(named: "logic_normal"), for: .normal)
                
                myImageView.image = UIImage.init(named: "logic_normal")
            }
            let subView = cell.value(forKey: "portraitImageView") as! UIImageView
            cell.contentView.addSubview(myImageView)
            cell.contentView.addSubview(btn)
            if cell.model.messageDirection == .MessageDirection_RECEIVE {
            cell.baseContentView.frame = CGRect(x:40, y: cell.baseContentView.frame.origin.y, width: cell.baseContentView.frame.size.width, height: cell.baseContentView.frame.size.height)
//                btn.frame = CGRect(x: 0, y:subView.frame.origin.x+5, width: 30, height: 30)
                //            btn?.center = CGPoint(x: 25, y: subView.center.y)
                
                myImageView.mas_makeConstraints({[weak subView,cell] (make) in
                    
                    make!.centerY.equalTo()(subView)
                    make!.left.equalTo()(cell)?.offset()(15)
                    make!.width.equalTo()(20)
                    make!.height.equalTo()(20)
                })
            }
            else{
                cell.baseContentView.frame = CGRect(x:-40, y: cell.baseContentView.frame.origin.y, width: cell.baseContentView.frame.size.width, height: cell.baseContentView.frame.size.height)
                myImageView.frame = CGRect(x:kScreenW-30, y: subView.frame.origin.x+5, width: 40, height:40)
                
                
                
                
                myImageView.mas_makeConstraints({[weak subView,cell] (make) in
                    make!.centerY.equalTo()(subView)
                    make!.right.equalTo()(cell)?.offset()(-15)
                    make?.width.equalTo()(20)
                    make?.height.equalTo()(20)
                })
                
                
                
            }
            
            cell.baseContentView.isUserInteractionEnabled = false
//            cell.contentView.bringSubview(toFront: btn)
            //            btn?.addTarget(self, action: #selector(btnClick(_:)), for:.touchUpInside )
        }else{
            
            cell.contentView.addSubview(btn)
            
            cell.baseContentView.isUserInteractionEnabled = false
            if cell.model.messageDirection == .MessageDirection_RECEIVE {
                cell.baseContentView.frame = CGRect(x:40, y: cell.baseContentView.frame.origin.y, width: cell.baseContentView.frame.size.width, height: cell.baseContentView.frame.size.height)
            }
            else{
                cell.baseContentView.frame = CGRect(x:-40, y: cell.baseContentView.frame.origin.y, width: cell.baseContentView.frame.size.width, height: cell.baseContentView.frame.size.height)
            }
            
        }
        
        
        btn.mas_makeConstraints({ [weak cell](make) in
            
            make?.top.equalTo()(cell?.contentView)
            make?.bottom.equalTo()(cell?.contentView)
            make?.left.equalTo()(cell?.contentView)
            make?.right.equalTo()(cell?.contentView)
            
        })
        
        
        
    }
    
}
extension RCMessageBaseCell {
  
    
    
    /// 清除cell原本没有的控件 （多选时，自己添加了一些控件）
    func clearCell(){
        let imgview = self.contentView.viewWithTag(1234)
        if imgview != nil {
            imgview?.removeFromSuperview()
        }
        
        for btnView in self.contentView.subviews {
            if btnView.isKind(of: UIButton.self) {
                btnView.removeFromSuperview()
            }
        }
        self.baseContentView.isUserInteractionEnabled = true
    }
}
//
//  UIScrollView+Extension.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/4/25.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
extension UIScrollView{
//    open override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
//        self.next?.touchesBegan(touches, with: event)
//        super.touchesBegan(touches, with: event)
//    }
    
}
//
//  NSDate+Extension.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/2.
//  Copyright © 2017年 柴进. All rights reserved.
//
import Foundation
extension Date {
    // 判断是否是今天
    static func isToday (target : Date) -> Bool {
        let currentDate : Date = Date()
        let dateFormatter : DateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let currentResult : String = dateFormatter.string(from: currentDate)
        let targetResult : String = dateFormatter.string(from: target)
        
        return currentResult == targetResult
    }
    
    // 判断是否是昨天
    static func isLastDay (target : Date) -> Bool {
        let currentDate : Date = Date()
        let dateFormatter : DateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let currentResult : String = dateFormatter.string(from: currentDate)
        let targetResult : String = dateFormatter.string(from: target)
    
        let currentD = dateFormatter.date(from: currentResult)
        let targetD = dateFormatter.date(from: targetResult)
        return (currentD?.timeIntervalSince(targetD!))! <= 24 * 60 * 60
    }
    
    // 判断是否是一周内
    static func isOneWeek (target : Date) -> Bool {
        let currentDate : Date = Date()
        let dateFormatter : DateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let currentResult : String = dateFormatter.string(from: currentDate)
        let targetResult : String = dateFormatter.string(from: target)
        
        let currentD = dateFormatter.date(from: currentResult)
        let targetD = dateFormatter.date(from: targetResult)
        
        return (currentD?.timeIntervalSince(targetD!))! <= 7 * 24 * 60 * 60
    }
    // 日期格式转换yy/MM/dd
    static func formattDay (target : Date) -> String {
        
        let dateFormatter : DateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yy/M/d"
        let targetResult : String = dateFormatter.string(from: target)
        
        return targetResult
    }
    
    // 根据日期获取时间戳
    static func getTimestamp (dateString : String) -> TimeInterval {
        if dateString.count <= 0 {
            return 0
        }
        let newDateStirng = dateString.appending(" 00:00:00")
        
        let formatter : DateFormatter = DateFormatter()
        formatter.dateStyle = DateFormatter.Style.medium
        formatter.dateStyle = DateFormatter.Style.short
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        formatter.timeZone = TimeZone(identifier: "Asia/Beijing")
        
        let dateNow = formatter.date(from: newDateStirng)
        
        return (dateNow?.timeIntervalSince1970)!
    }
    
    // 获取星期
    static func weekWithDateString (target : Date) -> String{
        let dateFormatter : DateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let targetResult : String = dateFormatter.string(from: target)
        let timestamp = Date.getTimestamp(dateString: targetResult)
        let day = Int(timestamp/86400)
        let array : Array = ["星期一","星期二","星期三","星期四","星期五","星期六","星期日"];
        return array[(day-3)%7]
        //        return "星期\((day-3)%7))"
    }
    
}
//
//  DataBaseOperation.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/1.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import Realm
class DataBaseOperation: NSObject
{
    
    
    
    /// 数据库的初始化
    public static func initDataBase()
    {
        
        let  config:RLMRealmConfiguration  = RLMRealmConfiguration.default()
        /// todo  暂时写死  最后需要换成用户相关的唯一标识字段
        let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
        config.fileURL =  config.fileURL?.deletingLastPathComponent().appendingPathComponent(username).appendingPathExtension("realm")
        print("数据库地址：\(config.fileURL!)")
        //数据库迁移
        self.performingMigrationWithConfig(config: config)
        RLMRealmConfiguration.setDefault(config)
        
    }
    
    
    
    /// 清空本地数据库数据
    public static func removeAllData()
    {
        let realm:RLMRealm = RLMRealm.default()
        realm.beginWriteTransaction()
        realm.deleteAllObjects()
        try? realm.commitWriteTransaction()
        
    }
    
    
    
    /// 修改或添加一条数据
    ///
    /// - Parameter rlmObject: 需要修改或添加的数据
    public static func addData(rlmObject:RLMObject)
    {
        let realm = RLMRealm.default()
        realm.beginWriteTransaction()
        realm.addOrUpdate(rlmObject)
        try? realm.commitWriteTransaction()
        
    }
    public static func addOnlyData(rlmObject:RLMObject)
    {
        let realm = RLMRealm.default()
        realm.beginWriteTransaction()
        realm.add(rlmObject)
        try? realm.commitWriteTransaction()
        
    }
    
    /// 批量添加或修改数据
    ///
    /// - Parameters:
    ///   - rlmObjects: 需要添加或者修改的数据
    ///   - aClass: 数据库模型类型
    public static func addDataWithArray(rlmObjects:Array<Any>,aClass:AnyClass)
    {
        let realm = RLMRealm.default()
        realm.beginWriteTransaction()
        for any in rlmObjects {
            if any is Dictionary<String, Any>
            {
                aClass.createOrUpdateInDefaultRealm(withValue: any)
            }
        }
        try? realm.commitWriteTransaction()
    }
    
    
    
    /// 删除一条数据
    ///
    /// - Parameter rlmObject: 需要删除的数据
    public static func removeData(rlmObject:RLMObject?)
    {
        
        guard rlmObject != nil else {
            return
        }
        let realm = RLMRealm.default()
        realm.beginWriteTransaction()
        realm.delete(rlmObject!)
        try? realm.commitWriteTransaction()
        
    }
    
    
    /// 批量删除数据
    ///
    /// - Parameter rlmObjects: 需要删除的数据
    public static func removeDataWithArray(rlmObjects:Any?)
    {
        let realm = RLMRealm.default()
        realm.beginWriteTransaction()
        realm.deleteObjects(rlmObjects! as! NSFastEnumeration)
        try? realm.commitWriteTransaction()
    }
    
    
    
    //    public static func removeDataWithIdentifications(_ idents:Array<Any>,aClass: Swift.AnyClass)
    //    {
    //        let realm = RLMRealm.default()
    //        realm.beginWriteTransaction()
    //        for any in idents
    //        {
    //            if any is String {
    //                model:RLMObject = aClass.objectForPrimaryKey(any)
    //            }
    //        }
    //        try? realm.commitWriteTransaction()
    //
    //
    //    }
    
    
    
    /// 数据库迁移
    ///
    /// - Parameter config: config description
    private static func performingMigrationWithConfig(config:RLMRealmConfiguration)
    {
        config.schemaVersion = 4
        config.migrationBlock = { (migration:RLMMigration,oldSchemaVersion:UInt64)->Void in
            if oldSchemaVersion < 1 {
                
            }
            if oldSchemaVersion < 2 {
                migration.enumerateObjects(GroupModel.className(), block: { (oldObject, newObject) in
                    newObject?["parentid"] = ""
                    newObject?["type"] = ""
                    newObject?["from_msg_uid"] = ""
                    newObject?["img_url"] = ""
                })
            }
            if oldSchemaVersion < 3 {
                migration.enumerateObjects(GroupModel.className(), block: { (oldObject, newObject) in
                    newObject?["is_consult"] = NSNumber(value: 0)
//                    newObject?["consult_info"] = nil
                })
            }
            
            if oldSchemaVersion < 4 {
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                UserDefaults.standard.set("0", forKey: username);
                migration.enumerateObjects(GroupModel.className(), block: { (oldObject, newObject) in
                    newObject?["project_id"] = ""
                })
            }
            
            
        }
    }
    
}
//
//  DataOperation.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/3/21.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class DataOperation: DataBaseOperation {
    class func saveInitData(success:@escaping (_ success:Dictionary<String, Any>) ->()) -> (Dictionary<String, Any>) ->() {
        func temp(dic:Dictionary<String, Any>) ->(){
            DataBaseOperation.addDataWithArray(rlmObjects: dic["groupList"] as! Array<Any>, aClass: GroupModel.self)
            DataBaseOperation.addDataWithArray(rlmObjects: dic["groupUserList"] as! Array<Any>, aClass: GroupUserModel.self)
            DataBaseOperation.addDataWithArray(rlmObjects: dic["subGroupList"] as! Array<Any>, aClass: GroupModel.self)
            DataBaseOperation.addDataWithArray(rlmObjects: dic["userList"] as! Array<Any>, aClass: UserModel.self)
            //保存时间戳
           let time = String.changeToString(inValue: dic["updateTime"] as Any)
            let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
            UserDefaults.standard.set(time, forKey: username)
            success(dic)
        }
        return temp
    }
    
    
    
    class func saveFriendsData(success:@escaping (_ success:Dictionary<String, Any>) ->()) -> (Dictionary<String, Any>) ->() {
        
        
        func temp(dic:Dictionary<String, Any>) ->(){
            
            print(dic)
            if dic["list"] != nil{
                DataBaseOperation.addDataWithArray(rlmObjects: dic["list"] as! Array<Any>, aClass: FriendsModel.self)
            }
            success(dic)
        }
        
         return temp
    }
    class func saveSimpleListDataWithTable(table:AnyClass, success:@escaping (_ success:Dictionary<String, Any>) ->()) -> (Dictionary<String, Any>) ->() {
        
        
        func temp(dic:Dictionary<String, Any>) ->(){
            
            print(dic)
            if dic["list"] != nil{
                DataBaseOperation.addDataWithArray(rlmObjects: dic["list"] as! Array<Any>, aClass: table)
            }
            success(dic)
        }
        
        return temp
    }
    
    
    class func saveThemeInfoData(success:@escaping (_ success:Dictionary<String, Any>) ->()) -> (Dictionary<String, Any>) ->() {
        
        
        func temp(dic:Dictionary<String, Any>) ->(){
            
            
            var myDic = Dictionary<String, AnyObject>()
            myDic.updateValue( dic["is_delete"]  as AnyObject, forKey: "is_delete")
            myDic.updateValue(dic["groupid"]  as AnyObject, forKey: "groupid")
            let array:Array = dic["titleFileList"] as! Array<Any>
            myDic.updateValue(dic["group_name"] as AnyObject, forKey: "group_name")
            myDic.updateValue(array.count  as AnyObject, forKey: "imageNum")
            myDic.updateValue(BaseRequest.makeJsonStringWithObject(object: array as Any)  as AnyObject, forKey: "imageArray")
            
            let arrayf = [myDic]
           
            DataBaseOperation.addDataWithArray(rlmObjects:arrayf, aClass: ThemeInfoModel.self)
            
            success(dic)
        }
        
        return temp
    }
}
//
//  ProjectReportMessageContent.swift
//  SLAPP
//
//  Created by apple on 2018/4/27.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class ProjectReportMessageContent: RCMessageContent {
    var projectId:String = ""
    var projectName:String = ""
    var projectScore:String = ""
    var projectWinIndex:String = ""
    var projectRisk:String = ""
    var url:String = ""
    var extra:String = ""
    var logicId:String = ""
    
    override class func getObjectName() -> String{
        return "ProjectReportMessageContent"
    }
    
    override func encode() -> Data! {
        var dataDict = Dictionary<String, String>.init()
        dataDict["projectId"] = self.projectId
        dataDict["extra"] = self.extra
        dataDict["projectName"] = self.projectName
        dataDict["projectScore"] = self.projectScore
        dataDict["projectWinIndex"] = self.projectWinIndex
        dataDict["projectRisk"] = self.projectRisk
        dataDict["url"] = self.url
        dataDict["logicId"] = self.logicId
        
        let data = try? JSONSerialization.data(withJSONObject: dataDict, options: [])
        return data
    }
    
    
    
    override func decode(with data: Data!) {
        
        let str =  NSString(data:data! ,encoding: String.Encoding.utf8.rawValue)
        
        if !(str?.contains("null"))!{
            let json = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as! Dictionary<String, Any>
            if json == nil {
                return
            }
            let jsonDic = json!
            if jsonDic["projectId"] == nil {
                self.projectId = ""
            }else{
                self.projectId = jsonDic["projectId"]! as! String
            }
            if jsonDic["extra"] == nil {
                self.extra = ""
            }else{
                self.extra = jsonDic["extra"]! as! String
            }
            if jsonDic["url"] == nil {
                self.url = ""
            }else{
                self.url = jsonDic["url"]! as! String
            }
            if jsonDic["projectName"] == nil {
                self.projectName = ""
            }else{
                self.projectName = jsonDic["projectName"]! as! String
            }
            if jsonDic["projectScore"] == nil {
                self.projectScore = ""
            }else{
                self.projectScore = jsonDic["projectScore"]! as! String
            }
            if jsonDic["projectRisk"] == nil {
                self.projectRisk = ""
            }else{
                self.projectRisk = String.noNilStr(str: jsonDic["projectRisk"])
            }
            if jsonDic["projectWinIndex"] == nil {
                self.projectWinIndex = ""
            }else{
                self.projectWinIndex = String.noNilStr(str: jsonDic["projectWinIndex"])
            }
            if jsonDic["logicId"] == nil {
                self.logicId = ""
            }else{
                self.logicId = String.noNilStr(str: jsonDic["logicId"])
            }
        }
        else{
//            self.content = "android发的不能解析" //文字内容
//            self.extra = "android发的不能解析" //扩展信息
//            self.imageURL = "android发的不能解析" //图片url
//            self.thumbnailUrl = "android发的不能解析"//缩略图url
//            self.url = "android发的不能解析" //点击后连接地址
//            self.groupId = "android发的不能解析" //所在组群id
//            self.themeId = "android发的不能解析" //跳转话题id
//            DLog("特殊消息出错了----------------")
        }
        
    }
    
    override func getSearchableWords() -> [String]! {
        //        RCMessageContent.persistentFlag()
        return ["projectName"]
    }
    
    override class func persistentFlag() -> RCMessagePersistent{
        return RCMessagePersistent.MessagePersistent_ISCOUNTED
    }
    
    override func conversationDigest() -> String! {
        return "[特殊消息]"
    }
    
}
//
//  ThemeMessageContent.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/6/7.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ThemeMessageContent: RCMessageContent {
    var content = "" //文字内容
    var extra = "" //扩展信息   ///聊天记录
    var imageURL = "" //图片url
    var thumbnailUrl = ""//缩略图url
    var url = "" //点击后连接地址
    
    var groupId = "" //所在组群id
    
    var themeId = "" //跳转话题id
    
    
    override class func getObjectName() -> String{
        return "ThemeMessageContent"
    }
    
    override func encode() -> Data! {
        var dataDict = Dictionary<String, String>.init()
        dataDict["content"] = self.content
        dataDict["extra"] = self.extra
        dataDict["imageURL"] = self.imageURL
        dataDict["thumbnailUrl"] = self.thumbnailUrl
        dataDict["url"] = self.url
        dataDict["groupId"] = self.groupId
        dataDict["themeId"] = self.themeId
        
        let data = try? JSONSerialization.data(withJSONObject: dataDict, options: [])
        
        return data
    }
    
    override func decode(with data: Data!) {
        
        //        super.decode(with: data)
        print("222222222222222_______\(data)")
        let str =  NSString(data:data! ,encoding: String.Encoding.utf8.rawValue)
        print("662222222222222_______\(str)")
        if !(str?.contains("null"))!{
            let json = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as! Dictionary<String, Any>
            
            print("111111111111111_______\(json)" )
            if json == nil {
                return
            }
            let jsonDic = json!
            
            //            self.content = jsonDic["content"]! //文字内容
            if jsonDic["content"] == nil {
                self.content = ""
            }else{
                self.content = jsonDic["content"] as! String
            }
            if jsonDic["extra"] == nil {
                self.extra = ""
            }else{
                self.extra = jsonDic["extra"] as! String
            }
            if jsonDic["imageURL"] == nil {
                self.imageURL = ""
            }else{
                self.imageURL = jsonDic["imageURL"] as! String
            }
            if jsonDic["thumbnailUrl"] == nil {
                self.thumbnailUrl = ""
            }else{
                self.thumbnailUrl = jsonDic["thumbnailUrl"] as! String
            }
            if jsonDic["url"] == nil {
                self.url = ""
            }else{
                self.url = jsonDic["url"] as! String
            }
            if jsonDic["groupId"] == nil {
                self.groupId = ""
            }else{
                self.groupId = jsonDic["groupId"] as! String
            }
            if jsonDic["themeId"] == nil {
                self.themeId = ""
            }else{
                self.themeId = jsonDic["themeId"] is NSNumber ? (String(describing: jsonDic["themeId"] as! NSNumber)) : (jsonDic["themeId"]  as! String)
            }
            //            self.extra = jsonDic["extra"]! //扩展信息
            //            self.imageURL = jsonDic["imageURL"]! //图片url
            //            self.thumbnailUrl = jsonDic["thumbnailUrl"]!//缩略图url
            //            self.url = jsonDic["url"]! //点击后连接地址
            //            self.groupId = jsonDic["groupId"]! //所在组群id
            //            self.themeId = jsonDic["themeId"]! //跳转话题id
        }
        else{
            self.content = "android发的不能解析" //文字内容
            self.extra = "android发的不能解析" //扩展信息
            self.imageURL = "android发的不能解析" //图片url
            self.thumbnailUrl = "android发的不能解析"//缩略图url
            self.url = "android发的不能解析" //点击后连接地址
            self.groupId = "android发的不能解析" //所在组群id
            self.themeId = "android发的不能解析" //跳转话题id
            print("招 恨")
        }
        
    }
    
    override func getSearchableWords() -> [String]! {
        //        RCMessageContent.persistentFlag()
        return ["content"]
    }
    
    override class func persistentFlag() -> RCMessagePersistent{
        return RCMessagePersistent.MessagePersistent_ISCOUNTED
    }
    
    override func conversationDigest() -> String! {
        return "[话题]"
    }
    
    //    func awa() {
    //        RCMessageContent.getObjectName()
    //    }
    
}
//
//  ProjectVoiceMessageContent.swift
//  SLAPP
//
//  Created by apple on 2018/4/27.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class ProjectVoiceMessageContent: RCMessageContent {
    
    var projectId:String = ""
    var projectName:String = ""
    var duration:String = ""
    var url:String = ""
    var extra:String = ""
    
    override class func getObjectName() -> String{
        return "ProjectVoiceMessageContent"
    }
    
    override func encode() -> Data! {
        var dataDict = Dictionary<String, String>.init()
        dataDict["projectId"] = self.projectId
        dataDict["extra"] = self.extra
        dataDict["projectName"] = self.projectName
        dataDict["duration"] = self.duration
        dataDict["url"] = self.url
        
        let data = try? JSONSerialization.data(withJSONObject: dataDict, options: [])
        return data
    }
    
    
    
    override func decode(with data: Data!) {
        
        let str =  NSString(data:data! ,encoding: String.Encoding.utf8.rawValue)
        
        if !(str?.contains("null"))!{
            let json = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as! Dictionary<String, Any>
            if json == nil {
                return
            }
            let jsonDic = json!
            if jsonDic["projectId"] == nil {
                self.projectId = ""
            }else{
                self.projectId = jsonDic["projectId"]! as! String
            }
            if jsonDic["extra"] == nil {
                self.extra = ""
            }else{
                self.extra = jsonDic["extra"]! as! String
            }
            if jsonDic["url"] == nil {
                self.url = ""
            }else{
                self.url = jsonDic["url"]! as! String
            }
            if jsonDic["projectName"] == nil {
                self.projectName = ""
            }else{
                self.projectName = jsonDic["projectName"]! as! String
            }
            
            if jsonDic["duration"] == nil {
                self.duration = ""
            }else{
                self.duration = jsonDic["duration"]! as! String
            }
            
        }
        else{
            //            self.content = "android发的不能解析" //文字内容
            //            self.extra = "android发的不能解析" //扩展信息
            //            self.imageURL = "android发的不能解析" //图片url
            //            self.thumbnailUrl = "android发的不能解析"//缩略图url
            //            self.url = "android发的不能解析" //点击后连接地址
            //            self.groupId = "android发的不能解析" //所在组群id
            //            self.themeId = "android发的不能解析" //跳转话题id
//            DLog("特殊消息出错了----------------")
        }
        
    }
    
    override func getSearchableWords() -> [String]! {
        //        RCMessageContent.persistentFlag()
        return ["projectName"]
    }
    
    override class func persistentFlag() -> RCMessagePersistent{
        return RCMessagePersistent.MessagePersistent_ISCOUNTED
    }
    
    override func conversationDigest() -> String! {
        return "[特殊消息]"
    }
    
    
}
//
//  HistoryMessageContent.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/6/30.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class HistoryMessageContent: RCMessageContent {
    var content = "" //文字内容
    var extra = "" //扩展信息
    var title = "" //图片url
    var url = "" //点击后连接地址
    
    override class func getObjectName() -> String{
        return "HistoryMessageContent"
    }
    
    override func encode() -> Data! {
        var dataDict = Dictionary<String, String>.init()
        dataDict["content"] = self.content
        dataDict["extra"] = self.extra
        dataDict["url"] = self.url
        dataDict["title"] = self.title
        
        let data = try? JSONSerialization.data(withJSONObject: dataDict, options: [])
        
        return data
    }
    
    override func decode(with data: Data!) {
        let str =  NSString(data:data! ,encoding: String.Encoding.utf8.rawValue)
        if !(str?.contains("null"))!{
            let json = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as! Dictionary<String, String>
            if json == nil {
                return
            }
            let jsonDic = json!
            
            //            self.content = jsonDic["content"]! //文字内容
            if jsonDic["content"] == nil {
                self.content = ""
            }else{
                self.content = jsonDic["content"]!
            }
            if jsonDic["extra"] == nil {
                self.extra = ""
            }else{
                self.extra = jsonDic["extra"]!
            }
            if jsonDic["title"] == nil {
                self.title = ""
            }else{
                self.title = jsonDic["title"]!
            }
            if jsonDic["url"] == nil {
                self.url = ""
            }else{
                self.url = jsonDic["url"]!
            }
        }
        else{
            self.content = "android发的不能解析" //文字内容
            self.extra = "android发的不能解析" //扩展信息
            self.title = "android发的不能解析" //图片url
            self.url = "android发的不能解析" //点击后连接地址
            print("招 恨")
        }
        
    }
    
    override func getSearchableWords() -> [String]! {
        return ["content"]
    }
    
    override class func persistentFlag() -> RCMessagePersistent{
        return RCMessagePersistent.MessagePersistent_ISCOUNTED
    }
    
    override func conversationDigest() -> String! {
        return "[聊天记录]"
    }
}
//
//  ThemeInfoModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/7/5.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ThemeInfoModel: BaseRealMModel {
    @objc dynamic var is_delete = ""    // 用户ID
    @objc dynamic var groupid = ""    // 用户融云ID
    @objc dynamic var imageNum:NSNumber = 0 //图片个数
    @objc dynamic var imageArray = "" //图片数据json串
    @objc dynamic var group_name = ""
    override static func primaryKey()->String
    {
        return "groupid";
    }
    
}
//
//  MessageModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/2.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class MessageModel: BaseRealMModel {
    
    //字段说明： 字段是照着融云的消息类型搬过来的字段  具体打开下边网址
    //http://www.rongcloud.cn/docs/api/ios/imlib/index.html
    //http://www.rongcloud.cn/docs/api/ios/imlib/Classes/RCMessage.html
    
    
    @objc dynamic var conversationType = "" //会话类型
    @objc dynamic var targetId = ""         //目标id
    @objc dynamic var content = ""          //消息内容
    @objc dynamic var messageId = ""      //消息id
    @objc dynamic var messageDirection = "" //消息方向
    @objc dynamic var senderUserId = ""    //发送者id
    @objc dynamic var receivedStatus = ""   //消息的接收状态
    @objc dynamic var sentStatus = ""         //发送状态
    @objc dynamic var receivedTime = ""     //接收时间
    @objc dynamic var objectName = ""      //消息类型名
    @objc dynamic var extra = ""           //附加字段
    @objc dynamic var  messageUId = ""     //全局唯一ID
    @objc dynamic var readReceiptInfo = "" //阅读回执状态
    @objc dynamic var imageUrl = ""       //
    @objc dynamic var thumbnailImage = "" //缩略图
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
//      dynamic var readReceiptInfo = "" //阅读回执状态
    
}
//
//  BaseRealMModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/1.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import Realm
class BaseRealMModel: RLMObject {
    override func value(forUndefinedKey key: String) -> Any? {
        print("meiyou",key)
        return true
    }
}
//
//  GroupModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/1.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
//class Consult_info: BaseRealMModel {
//    dynamic var consult_id = ""    //在线辅导ID
//    dynamic var real_begintime = ""    //辅导实际开始时间戳
//    dynamic var real_endtime = ""    //辅导实际结束时间戳
//    dynamic var consult_status = ""    // 在线辅导状态
//
//    override static func primaryKey()->String
//    {
//        return "consult_id";
//    }
//}
//群组表
class GroupModel: BaseRealMModel {
    @objc dynamic var is_open = ""    // 是否开放（0:私有;1:公开）
    @objc dynamic var user_max = ""   // 用户上限
    @objc dynamic var group_name = "" // 群组名
    @objc dynamic var owner_id = ""   // 群主用户ID
    @objc dynamic var groupid = ""    // 群组ID
    @objc dynamic var user_num = ""   // 用户数
    @objc dynamic var qr_url = ""     // 二维码
    @objc dynamic var auth_code = ""  // 验证码
    @objc dynamic var corpid = ""
    @objc dynamic var inputtime = ""
    @objc dynamic var icon_url = ""
    @objc dynamic var is_delete = ""
    @objc dynamic var updatetime = ""
    @objc dynamic var is_remove = "0" //会话是否被移除,默认值为0(0:否,1:是)
    
    //2.0新增字段
    @objc dynamic var parentid = "" //父群组id
    @objc dynamic var type = "" //类型(0:群组,1:话题)
    @objc dynamic var from_msg_uid = "" //融云消息id
    @objc dynamic var img_url = "" //话题图片url
    
    //在线辅导新增字段
    @objc dynamic var is_consult = NSNumber(value: 0)//是否在线辅导群组（0：否；1：是）;是否在线辅导话题（0：否；1：是）
    /// 1.consult_id在线辅导ID
    /// 2.real_begintime辅导实际开始时间戳
    /// 3.real_endtime辅导实际结束时间戳
    ///4.consult_status 在线辅导状态
    /*1 4 取消
     2 5 辅导中
     3 6 辅导结束*/
//    dynamic var consult_info:Consult_info?
    
    
    //新增字段  迁移版本4.0  项目id
    @objc dynamic var project_id:String = ""
    
    override static func primaryKey()->String
    {
        return "groupid";
    }
    
    override func setValue(_ value: Any?, forUndefinedKey key: String) {
        
    }
}
//
//  AVPlayerProgressModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/29.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class AVPlayerProgressModel: RLMObject {
    
    @objc dynamic var messageId = ""
    @objc dynamic var progress:Double = 0.0
    
    override static func primaryKey()->String
    {
        return "messageId";
    }
}
//
//  MessageCenterModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/1.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class MessageCenterModel: BaseRealMModel {
    /*!
     全局唯一ID
     
     @discussion 服务器消息唯一ID（在同一个Appkey下全局唯一）
     */
    @objc dynamic var messageUId = ""
    /*!
     目标会话ID
     */
    @objc dynamic var targetId = ""
    /*!
     消息的ID
     
     @discussion 本地存储的消息的唯一值（数据库索引唯一值）
     */
    @objc dynamic var messageId = ""
    
    /*!
     消息组群的ID（话题里的消息才需要）
     
     @discussion 本地存储的消息的唯一值（数据库索引唯一值）
     */
    @objc dynamic var parentId = ""
}
//
//  UserModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/7/24.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class UserModel: BaseRealMModel {
    @objc dynamic var userid = ""    // 用户ID
    @objc dynamic var corpid = "0" // 企业ID
    @objc dynamic var realname = "" // 昵称
    @objc dynamic var avater = "" // 头像
    @objc dynamic var updatetime = "" // 更新时间
    @objc dynamic var is_delete = "" // 是否删除
    @objc dynamic var im_userid = ""
    @objc override static func primaryKey()->String?
    {
        return "userid";
    }
}
//
//  PrivateUserModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2018/2/13.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class PrivateUserModel: BaseRealMModel {
    @objc dynamic var id = ""
    override static func primaryKey()->String
    {
        return "id";
    }
}
//
//  ChatContentModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/4/27.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ChatContentModel: NSObject {
    var name:String = ""
    var portraitUri = ""
    var otherInformation = ""
    var objectName = ""
    var time:Int64?
    var messageID:Int?
    
}
//
//  FriendsModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/3.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
//好友表
class FriendsModel: BaseRealMModel {
    
    @objc dynamic var userid = ""    // 用户ID
    @objc dynamic var im_userid = ""    // 用户融云ID
    @objc dynamic var realname = "" // 昵称
    @objc dynamic var avater = "" // 头像
    @objc dynamic var type:NSNumber = 0//1 互粉  2单粉我 3我粉 4陌生人(3和4都属于陌生人)
    @objc dynamic var is_delete = "" // 是否删除
    @objc dynamic var updatetime = "" // 更新时间
    override static func primaryKey()->String
    {
        return "userid";
    }
}
//
//  GroupUserModel.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/3/21.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupUserModel: BaseRealMModel {
    
    @objc dynamic var userid = ""    // 用户ID
    @objc dynamic var realname = "" // 昵称
    @objc dynamic var avater = "" // 头像
    @objc dynamic var groupid = "" // 所在组群id
    @objc dynamic var id = "" // id
    @objc dynamic var updatetime = "" // 更新时间
    @objc dynamic var is_delete = "" // 是否删除
    @objc dynamic var inputtime = "" // 插入时间
    @objc dynamic var join_type = "" // 插入时间
    @objc dynamic var im_userid = ""
    @objc dynamic var is_consult_teacher = ""//是否咨询老师
    override static func primaryKey()->String
    {
        return "id";
    }
}
//
//  GroupSweepView.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/23.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupSweepView: UIView {
  class func initWithImage(url:String)->(GroupSweepView)
    {
       let view = GroupSweepView.init(frame: CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT))
       view.backgroundColor = UIColor.white
       let lable = UILabel.init(frame: CGRect.init(x: 20, y: 20, width: kScreenW-40, height: 40))
        lable.text = "由于您所在的企业内没有其他成员，所以只能通过邀请好友扫描以下二维码加入该群组。"
        lable.font = UIFont.systemFont(ofSize: 13)
        lable.textColor = UIColor.lightGray
        lable.numberOfLines = 0
       let image = UIImageView.init(frame: CGRect.init(x: 20, y: 80, width: kScreenW-40, height: kScreenW-40))
         view.addSubview(image)
       image.sd_setImage(with: NSURL.init(string: url) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
       
       view.addSubview(lable)
       return view
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    /*
    // Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        // Drawing code
    }
    */
}
//
//  GroupSettingTableViewHeader.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/9.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
@objc protocol GroupSettingTableViewHeaderDelegate {
    //点击成员头像
    func userItemDidClick(userId:String)
    //点击添加按钮
    func addBtnDidClick()
    //点击删除按钮
    func delBtnDidClick()
}
class GroupSettingTableViewHeader: UICollectionView {
    var users : Array<GroupUserModel> = Array()
    var isAllowedInviteMember : Bool!
    var isAllowedDeleteMember : Bool!
  weak var myDelegate : GroupSettingTableViewHeaderDelegate?
    
    convenience init() {
        let flowlayout = UICollectionViewFlowLayout.init()
        flowlayout.scrollDirection = UICollectionView.ScrollDirection.vertical
        self.init(frame: CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height: 56), collectionViewLayout: flowlayout)
        self.backgroundColor = UIColor.white
        self.delegate = self
        self.dataSource = self
        self.register(GroupSettingTableViewHeaderItem.self, forCellWithReuseIdentifier: "GroupSettingTableViewHeaderItem")
        
        isAllowedInviteMember = true
        isAllowedDeleteMember = false
    }
}
//MARK: - UICollectionViewDelegate, UICollectionViewDataSource,UICollectionViewDelegateFlowLayout
extension GroupSettingTableViewHeader: UICollectionViewDelegate, UICollectionViewDataSource,UICollectionViewDelegateFlowLayout {
    //MARK: - UICollectionViewDelegateFlowLayout
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return CGSize.init(width: (SCREEN_WIDTH - (SCREEN_WIDTH < 375 ? 100 : kReal(value: 100))) / 4, height: (SCREEN_WIDTH - (SCREEN_WIDTH < 375 ? 100 : kReal(value: 100))) / 4 + 25)
    }
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {
        let flowLayout : UICollectionViewFlowLayout = collectionViewLayout as! UICollectionViewFlowLayout
        flowLayout.minimumLineSpacing = 15
        flowLayout.minimumInteritemSpacing = 20
        return UIEdgeInsets(top: 15, left: SCREEN_WIDTH < 375 ? 20 : kReal(value: 20), bottom: 15, right: SCREEN_WIDTH < 375 ? 20 : kReal(value: 20))
    }
    //MARK: - UICollectionViewDataSource
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        if isAllowedDeleteMember! {
            return users.count + 2;
        } else {
            if isAllowedInviteMember! {
                return users.count + 1;
            } else {
                return users.count;
            }
        }
    }
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell : GroupSettingTableViewHeaderItem = collectionView.dequeueReusableCell(withReuseIdentifier: "GroupSettingTableViewHeaderItem", for: indexPath) as! GroupSettingTableViewHeaderItem
        if users.count != 0 && (users.count - 1 >= indexPath.row) {
            
            cell.model = users[indexPath.row]
            
            cell.avatarImgV.sd_setImage(with: NSURL.init(string: (cell.model?.avater)!) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
            cell.avatarImgV.layer.borderWidth = 0.5
        }else if users.count >= indexPath.row {
            //添加
            cell.model = nil
            cell.avatarImgV.image = UIImage.init(named: "addMember_normal")
            cell.avatarImgV.layer.borderWidth = 0.0
        }else{
            //删除
            cell.model = nil
            cell.avatarImgV.image = UIImage.init(named: "subtractMember_normal")
            cell.avatarImgV.layer.borderWidth = 0.0
        }
        return cell
    }
    //MARK: - UICollectionViewDelegate
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if users.count != 0 && (users.count + 1 == indexPath.row) {
            myDelegate?.delBtnDidClick()
        }else if users.count == indexPath.row{
            myDelegate?.addBtnDidClick()
        }else{
            let model = users[indexPath.row]
            myDelegate?.userItemDidClick(userId: model.userid)
        }
        
    }
   }
//
//  GroupSettingWithSwitchCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/9.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
@objc protocol GroupSettingWithSwitchCellDelegate {
    func onClickSwitchButton(swich:UIButton, title:String)
}
class GroupSettingWithSwitchCell: UITableViewCell {
   weak var delegate : GroupSettingWithSwitchCellDelegate?
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        self.backgroundColor = UIColor.white
        
        self.contentView.addSubview(titleLabel)
        self.contentView.addSubview(swich)
        
        titleLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(LEFT_PADDING_GS)
            make!.centerY.equalTo()(self)
        }
       
        swich.mas_makeConstraints { [unowned self](make) in
            make!.size.equalTo()(CGSize.init(width: 42, height: 30))
            make!.right.equalTo()(-LEFT_PADDING_GS)
            make!.centerY.equalTo()(self)
        }
        
    }
    
    var model: Any? {
        didSet{
            titleLabel.text = (model as! Dictionary<String, Any>).first?.key
            swich.isSelected = String.changeToString(inValue: (model as! Dictionary<String, Any>).first?.value) == "1"
        }
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    class func cell(withTableView tableView: UITableView) -> GroupSettingWithSwitchCell {
        var cell = tableView.dequeueReusableCell(withIdentifier: String(describing: self)) as? GroupSettingWithSwitchCell
        if cell == nil {
            cell = GroupSettingWithSwitchCell.init(style: .default, reuseIdentifier: "GroupSettingWithSwitchCell")
//            cell = GroupSettingWithSwitchCell.init(style: .default, reuseIdentifier: String(describing: self))
            cell?.selectionStyle = .none
        }
        return cell!
    }
    
    @objc func onClickSwitch(button:UIButton) {
//        button.isSelected = !button.isSelected
        delegate?.onClickSwitchButton(swich:button, title: titleLabel.text!)
    }
   
    //MARK: - Getter and Setter
    //标题
    fileprivate lazy var titleLabel: UILabel = {
        var titleLabel = UILabel()
        titleLabel.font = FONT_16
        titleLabel.textColor = UIColor.black
        return titleLabel
    }()
    //开关
    lazy var swich: UIButton = {
        var swich = UIButton()
        swich.showsTouchWhenHighlighted = true
        swich.setImage(UIImage.init(named: "switch_normal"), for: .normal)
        swich.setImage(UIImage.init(named: "switch_select"), for: .selected)
        swich.addTarget(self, action: #selector(onClickSwitch(button:)), for: .touchUpInside)
        return swich
    }()
}
//
//  GroupSettingTableViewHeaderItem.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/9.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupSettingTableViewHeaderItem: UICollectionViewCell {
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.backgroundColor = UIColor.clear
        self.contentView.addSubview(avatarImgV)
        self.contentView.addSubview(nameLabel)
        
        avatarImgV.mas_makeConstraints { [unowned self](make) in
            make!.top.left().equalTo()(self)
            make!.size.equalTo()(CGSize(width: self.frame.size.width, height: self.frame.size.width))
        }
        nameLabel.mas_makeConstraints { [unowned self](make) in
            make!.top.equalTo()(self.avatarImgV.mas_bottom)!.offset()(5)
            make!.left.equalTo()(self.avatarImgV)
            make!.right.equalTo()(self.avatarImgV)
        }
    }
    
    var model: GroupUserModel? {
        didSet{
            if model != nil {
                let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", (model?.userid)!)).firstObject() as! UserModel?
                
                nameLabel.text = userModel?.realname
            }else{
                nameLabel.text = ""
            }
        }
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    //头像
    lazy var avatarImgV: UIImageView = {
        var avatarImgV = UIImageView()
        avatarImgV.layer.cornerRadius = self.frame.size.width/2
        avatarImgV.clipsToBounds = true
        avatarImgV.layer.borderWidth = 0.0
        avatarImgV.layer.borderColor = UIColor.hexString(hexString: headerBorderColor).cgColor
        return avatarImgV
    }()
    //名称
    fileprivate lazy var nameLabel: UILabel = {
        var nameLabel = UILabel()
        nameLabel.font = FONT_12
        nameLabel.textColor = UIColor.darkGray
        nameLabel.textAlignment = .center
        return nameLabel
    }()
}
//
//  PasteView.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/4/26.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class PasteView: UIView {
    typealias sendClickBlock = ()->()
    var click : sendClickBlock?
    
    func sendBtnClick(send:@escaping sendClickBlock){
       click = send
    }
    
    
    @IBAction func sendClick(_ sender: UIButton) {
        
       click?()
        self.removeFromSuperview()
    }
    @IBAction func cancelClick(_ sender: Any) {
        self.removeFromSuperview()
    }
    @IBOutlet weak var sendBtn: UIButton!
    @IBOutlet weak var cancelBtn: UIButton!
    @IBOutlet weak var contentView: UIView!
    @IBOutlet weak var imageView: UIImageView!
    
    
    override func awakeFromNib() {
        super.awakeFromNib()
        self.contentView.layer.cornerRadius = 4
        self.contentView.clipsToBounds = true
        self.contentView.backgroundColor = UIColor.white
        self.contentView.layer.borderColor = UIColor.lightGray.cgColor
        self.contentView.layer.borderWidth = 0.3
        self.backgroundColor = UIColor.black.withAlphaComponent(0.2)
        
    }
    /*
    // Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        // Drawing code
    }
    */
}
//
//  GroupSettingWithArrowCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/9.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupSettingWithArrowCell: UITableViewCell {
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        self.backgroundColor = UIColor.white
        
        self.contentView.addSubview(titleLabel)
        self.contentView.addSubview(detailLabel)
        self.contentView.addSubview(detailImage)
        self.contentView.addSubview(rightArrow)
        titleLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(LEFT_PADDING_GS)
            make!.centerY.equalTo()(self)
        }
        detailLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(self.titleLabel.mas_right)!.offset()(10)
            make!.right.equalTo()(-LEFT_PADDING_BIG)
            make!.centerY.equalTo()(self)
        }
        detailImage.mas_makeConstraints { [unowned self](make) in
            make!.right.equalTo()(-LEFT_PADDING_BIG)
            make!.centerY.equalTo()(self)
            make!.size.equalTo()(CGSize.init(width: 17, height: 17))
        }
        rightArrow.mas_makeConstraints { [unowned self](make) in
            make!.right.equalTo()(-LEFT_PADDING_GS)
            make!.centerY.equalTo()(self)
            make!.size.equalTo()(CGSize.init(width: 16, height: 16))
        }
    }
    
    var model: Any? {
        didSet{
            titleLabel.text = (model as! Dictionary<String, Any>).first?.key
            detailLabel.text = (model as! Dictionary<String, Any>).first?.value as! String?
            titleLabel.sizeToFit()
            if titleLabel.text == "群组公告" && detailLabel.text != "未设置"{
                titleLabel.mas_remakeConstraints { (make) in
                    make!.left.equalTo()(LEFT_PADDING_GS)
                    make!.top.equalTo()(12)
                    make!.width.equalTo()(titleLabel.frame.size.width)
                }
                let height = ((detailLabel.text?.getTextHeight(font: FONT_14, width: SCREEN_WIDTH - LEFT_PADDING_GS - LEFT_PADDING_BIG))! + 0.4) > 60 ? 50.5 : ((detailLabel.text?.getTextHeight(font: FONT_14, width: SCREEN_WIDTH - LEFT_PADDING_GS - LEFT_PADDING_BIG))! + 0.4)
                detailLabel.mas_remakeConstraints { [unowned self](make) in
                    make!.left.equalTo()(self.titleLabel)
                    make!.right.equalTo()(-LEFT_PADDING_BIG)
                    make!.top.equalTo()(self.titleLabel.mas_bottom)!.offset()(5)
                    make!.height.equalTo()(height)
                }
            }else{
                titleLabel.mas_remakeConstraints { [unowned self](make) in
                    make!.left.equalTo()(LEFT_PADDING_GS)
                    make!.centerY.equalTo()(self)
                    make!.width.equalTo()(self.titleLabel.frame.size.width)
                }
                if rightArrow.isHidden{
                    detailLabel.mas_remakeConstraints { [unowned self](make) in
                        make!.left.equalTo()(self.titleLabel.mas_right)!.offset()(10)
                        make!.right.equalTo()(-LEFT_PADDING_GS)
                        make!.centerY.equalTo()(self)
                    }
                }else{
                    detailLabel.mas_remakeConstraints { [unowned self](make) in
                        make!.left.equalTo()(self.titleLabel.mas_right)!.offset()(10)
                        make!.right.equalTo()(-LEFT_PADDING_BIG)
                        make!.centerY.equalTo()(self)
                    }
                }
            }
        }
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    class func cell(withTableView tableView: UITableView) -> GroupSettingWithArrowCell {
        var cell = tableView.dequeueReusableCell(withIdentifier: String(describing: self)) as? GroupSettingWithArrowCell
        if cell == nil {
            cell = GroupSettingWithArrowCell.init(style: .default, reuseIdentifier: "GroupSettingWithArrowCell")
            cell?.selectionStyle = .none
        }
        return cell!
    }
    //MARK: - Getter and Setter
    //标题
    fileprivate lazy var titleLabel: UILabel = {
        var titleLabel = UILabel()
        titleLabel.font = FONT_16
        titleLabel.textColor = UIColor.black
        return titleLabel
    }()
    
    //内容
    lazy var detailLabel: UILabel = {
        var detailLabel = UILabel()
        detailLabel.font = FONT_14
        detailLabel.textColor = UIColor.lightGray
        detailLabel.textAlignment = .right
//        detailLabel.numberOfLines = 3
        return detailLabel
    }()
    
    //图片内容
    lazy var detailImage: UIImageView = {
        var detailImage = UIImageView()
        detailImage.image = UIImage.init(named: "二维码")
        return detailImage
    }()
    
    //箭头
    lazy var rightArrow: UIImageView = {
        var rightArrow = UIImageView()
        rightArrow.image = UIImage.init(named: "rightArrow")
        return rightArrow
    }()
}
//
//  GroupNameEditTextField.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/15.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class GroupNameEditTextField: UITextField {
    convenience init(placeholder:String) {
        self.init()
        self.font = FONT_14
        self.textColor = UIColor.black
        self.layer.cornerRadius = 3
        self.clipsToBounds = true
        self.layer.borderColor = UIColor.hexString(hexString: headerBorderColor).cgColor
        self.layer.borderWidth = 0.5
        self.placeholder = placeholder
        self.clearButtonMode = .whileEditing
    }
    override func placeholderRect(forBounds bounds: CGRect) -> CGRect {
        super.placeholderRect(forBounds: bounds)
        return  CGRect.init(x: bounds.origin.x + 5, y: bounds.origin.y, width: bounds.size.width - 30, height: bounds.size.height)
    }
    override func editingRect(forBounds bounds: CGRect) -> CGRect {
        super.editingRect(forBounds: bounds)
        return  CGRect.init(x: bounds.origin.x + 5, y: bounds.origin.y, width: bounds.size.width - 30, height: bounds.size.height)
    }
    override func textRect(forBounds bounds: CGRect) -> CGRect {
        super.textRect(forBounds: bounds)
        return  CGRect.init(x: bounds.origin.x + 5, y: bounds.origin.y, width: bounds.size.width - 30, height: bounds.size.height)
    }
}
//
//  ApplyJoinGroupTextView.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/16.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
fileprivate let maxTextLength = 30
class ApplyJoinGroupTextView: UITextView {
    override init(frame: CGRect, textContainer: NSTextContainer?) {
        super.init(frame: frame, textContainer: textContainer)
        self.delegate = self
        self.font = FONT_14
        self.textColor = UIColor.black
        self.layer.cornerRadius = 3
        self.clipsToBounds = true
        self.layer.borderColor = UIColor.hexString(hexString: headerBorderColor).cgColor
        self.layer.borderWidth = 0.5
        self.textContainerInset = UIEdgeInsets(top: 12, left: 5, bottom: 0, right: 0)
        self.addSubview(placeholderLabel)
        self.addSubview(textLengthLabel)
        placeholderLabel.text = placeholder
        placeholderLabel.mas_makeConstraints { (make) in
            make!.top.equalTo()(12)
            make!.left.equalTo()(10)
        }
        textLengthLabel.mas_makeConstraints { (make) in
            make!.top.equalTo()(inputTV_height_MAX - 20)
            make!.left.equalTo()(frame.size.width - 40 - 10)
            make!.width.equalTo()(40)
        }
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    var placeholder : String?{
    
        didSet{
            placeholderLabel.text = placeholder
            if (placeholder?.contains("申请消息"))! {
                textLengthLabel.isHidden = false
                textLengthLabel.text = "0/\(maxTextLength)"
            }else{
                textLengthLabel.isHidden = true
            }
        }
    }
    
    lazy var placeholderLabel: UILabel = {
        var placeholderLabel = UILabel.init()
        placeholderLabel.font = FONT_14
        placeholderLabel.textColor = UIColor.lightGray
        return placeholderLabel
    }()
    
    lazy var textLengthLabel: UILabel = {
        var textLengthLabel = UILabel.init()
        textLengthLabel.font = FONT_14
        textLengthLabel.textColor = UIColor.lightGray
        textLengthLabel.textAlignment = .right
        textLengthLabel.text = "0/\(maxTextLength)"
        return textLengthLabel
    }()
}
extension ApplyJoinGroupTextView : UITextViewDelegate{
    func textViewDidChange(_ textView: UITextView) {//同样的代码:适配iOS8
        if textView.textInputMode?.primaryLanguage == "zh-Hans" {
            let selectedRange : UITextRange? = textView.markedTextRange
            var position : UITextPosition? = nil
            if (selectedRange != nil) {
                position = textView.position(from: (selectedRange?.start)!, offset: 0)!
            }
            if position == nil {
                if (textView.text?.count)! > 0 {
                    placeholderLabel.isHidden = true
                }else{
                    placeholderLabel.isHidden = false
                }
                
                if (textView.text?.count)! > maxTextLength {
                    textView.text = textView.text?.substring(to: (textView.text?.index((textView.text?.startIndex)!, offsetBy: maxTextLength))!)
                    textLengthLabel.text = "\(maxTextLength)/\(maxTextLength)"
                    return
                }
                textLengthLabel.text = "\((textView.text?.count)!)/\(maxTextLength)"
            }else{
                
            }
        }else{
            if (textView.text?.count)! > 0 {
                placeholderLabel.isHidden = true
            }else{
                placeholderLabel.isHidden = false
            }
            
            if (textView.text?.count)! > maxTextLength {
                textView.text = textView.text?.substring(to: (textView.text?.index((textView.text?.startIndex)!, offsetBy: maxTextLength))!)
                textLengthLabel.text = "\(maxTextLength)/\(maxTextLength)"
                return
            }
            textLengthLabel.text = "\((textView.text?.count)!)/\(maxTextLength)"
        }
        
    }
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        if text == "\n" {
            return false
        }
        var str = textView.text?.replacingCharacters(in: (textView.text?.changeToRange(from: range)!)!, with: text)
        if textView.textInputMode?.primaryLanguage == "zh-Hans" {
            let selectedRange : UITextRange? = textView.markedTextRange
            var position : UITextPosition? = nil
            if (selectedRange != nil) {
                position = textView.position(from: (selectedRange?.start)!, offset: 0)!
            }
            if position == nil {
                if (str?.count)! > 0 {
                    placeholderLabel.isHidden = true
                }else{
                    placeholderLabel.isHidden = false
                }
                
                if (str?.count)! > maxTextLength {
                    textView.text = str?.substring(to: (str?.index((str?.startIndex)!, offsetBy: maxTextLength))!)
                    textLengthLabel.text = "\(maxTextLength)/\(maxTextLength)"
                    return false
                }
            }else{
                
            }
        }else{
            if (str?.count)! > 0 {
                placeholderLabel.isHidden = true
            }else{
                placeholderLabel.isHidden = false
            }
            
            if (str?.count)! > maxTextLength {
                textView.text = str?.substring(to: (str?.index((str?.startIndex)!, offsetBy: maxTextLength))!)
                textLengthLabel.text = "\(maxTextLength)/\(maxTextLength)"
                return false
            }
        }
        return true
    }
}
//
//  ApplyJoinGroupBottomBtn.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/20.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ApplyJoinGroupBottomBtn: UIButton {
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        self.addSubview(lineView)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        lineView.frame = CGRect.init(x: 0, y: self.frame.size.height - 5, width: self.frame.size.width, height: 0.7)
    }
    
    lazy var lineView: UIView = {
        let lineView = UIView.init()
        lineView.backgroundColor = UIColor.hexString(hexString: "2183DE")
        return lineView
    }()
}
//
//  ChatContentCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/4/27.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ChatContentCell: UITableViewCell {
    @IBOutlet weak var content: UILabel!
    @IBOutlet weak var timeLable: UILabel!
    @IBOutlet weak var nikename: UILabel!
    @IBOutlet weak var imageIcon: UIImageView!
    override func awakeFromNib() {
        super.awakeFromNib()
        imageIcon.layer.cornerRadius = 20
        imageIcon.clipsToBounds = true
        imageIcon.layer.borderColor = UIColor.lightGray.cgColor
        imageIcon.layer.borderWidth = 0.5
        
        // Initialization code
    }
    func setModel(model:ChatContentModel){
     
       nikename.text = model.name
       content.text  = model.otherInformation
       let date = Date.init(timeIntervalSince1970: TimeInterval(model.time!/1000))
       
        timeLable.text = self.convertDate(date: date)
       imageIcon.sd_setImage(with: URL.init(string: model.portraitUri) , placeholderImage: RCKitUtility.imageNamed("default_portrait_msg", ofBundle: "RongCloud.bundle"))
    
    }
    
    func convertDate(date:Date) -> String {
        if Date.isToday(target: date) {
            let dateFormatter : DateFormatter = DateFormatter()
            dateFormatter.dateFormat = "HH:mm"
            return dateFormatter.string(from: date)
        }else if Date.isLastDay(target: date) {
            return "昨天"
        }else if Date.isOneWeek(target: date) {
            return Date.weekWithDateString(target: date)
        }else{
            return Date.formattDay(target: date)
        }
    }
    override func setSelected(_ selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)
        // Configure the view for the selected state
    }
    
}
//
//  GroupListCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/1.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
private let headerImageViewWidth : CGFloat = 44.0
class GroupListCell: RCConversationBaseCell {
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        self.contentView.addSubview(headerImageView)
        self.contentView.addSubview(badgeLb)
        self.contentView.addSubview(nameLabel)
        self.contentView.addSubview(timeLabel)
        self.contentView.addSubview(detailLabel)
        headerImageView.mas_makeConstraints { (make) in
            make!.top.left().equalTo()(LEFT_PADDING)
            make!.size.equalTo()(CGSize(width: headerImageViewWidth, height: headerImageViewWidth))
        }
        nameLabel.mas_makeConstraints { [unowned self](make) in
            make!.top.equalTo()(self.headerImageView)
            make!.left.equalTo()(self.headerImageView.mas_right)!.offset()(LEFT_PADDING)
            make!.right.equalTo()(self.timeLabel.mas_left)!.offset()(-LEFT_PADDING)
        }
        timeLabel.mas_makeConstraints { [unowned self](make) in
            make!.top.equalTo()(self.headerImageView)
            make!.right.equalTo()(-LEFT_PADDING)
        }
        detailLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(self.nameLabel)
            make!.right.equalTo()(-LEFT_PADDING)
            make!.bottom.equalTo()(self.headerImageView)
        }
    }
    override var model: RCConversationModel!{
        didSet {
            self.backgroundColor = model.isTop ? model.topCellBackgroundColor : model.cellBackgroundColor
            self.headerImageView.sd_setImage(with: NSURL.init(string: model.extend != nil ? model.extend as! String : " ") as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
//            self.headerImageView.badgeCenterOffset = CGPoint(x : -2, y : 0)
            
            let groupIdArr : Array<String> = GroupModel.objects(with: NSPredicate.init(format: "parentid == %@", model.targetId)).value(forKeyPath: "groupid") as! Array<String>
            var subGroupMesTotalCount : Int32? = 0
            for targetId in groupIdArr {
                subGroupMesTotalCount = subGroupMesTotalCount! + RCIMClient.shared().getUnreadCount(.ConversationType_GROUP, targetId: targetId)
            }
            if model.unreadMessageCount > 0 || subGroupMesTotalCount! > 0{
//                self.headerImageView.showBadge()
                self.badgeLb.isHidden = false
            }else{
//                self.headerImageView.clearBadge()
                self.badgeLb.isHidden = true
            }
            
            if model.sentTime == 0 {
                self.timeLabel.text = ""
            }else{
                let target : Date = Date.init(timeIntervalSince1970: TimeInterval(model.sentTime / 1000))
                self.timeLabel.text = self.convertDate(date: target)
            }
            self.timeLabel.sizeToFit()
            timeLabel.mas_updateConstraints { [unowned self](make) in
                make!.width.equalTo()(self.timeLabel.frame.size.width)
            }
            self.nameLabel.text = model.conversationTitle
            
            if model.objectName.count > 0 {
                var unreadMessageCountStr : String?
                if model.unreadMessageCount > 1 {
                    unreadMessageCountStr = model.unreadMessageCount > 99 ? "[99条+]" : "[\(model.unreadMessageCount)条]"
                }else{
                    unreadMessageCountStr = ""
                }
                
                var lastSender : String?
                if model.senderUserId == sharePublicDataSingle.publicData.im_userid {
                    lastSender = nil
                }else if model.senderUserId.contains("system"){
                    lastSender="[系统]"
                }else{
                    let groupUserModel = GroupUserModel.objects(with: NSPredicate.init(format:"im_userid == %@ AND is_delete == '0'", model.senderUserId)).firstObject() as? GroupUserModel
                    if groupUserModel != nil {
                        let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", (groupUserModel?.userid)!)).firstObject() as! UserModel?
                        lastSender = userModel?.realname
                    }else {
                        let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "im_userid == %@", model.senderUserId)).firstObject() as! UserModel?
                        
                        if userModel != nil {
                            lastSender = userModel?.realname
                        }
                        
                    }
                    
                }
                var msg : String? = RCKitUtility.formatMessage(model.lastestMessage)
                if model.objectName == RCGroupNotificationMessageIdentifier {
                    let notModel:RCGroupNotificationMessage = model.lastestMessage as! RCGroupNotificationMessage
                    if notModel.operation == GroupNotificationMessage_GroupOperationAdd || notModel.operation == GroupNotificationMessage_GroupOperationKicked {
                        
                        if notModel.message.contains(sharePublicDataSingle.publicData.realname) {
                            msg = notModel.message.replacingOccurrences(of: sharePublicDataSingle.publicData.realname, with: "你")
                        }  else {
                            msg = notModel.message
                        }
                    }
                }
                if model.objectName == RCRecallNotificationMessageIdentifier && lastSender != nil{
                    msg = lastSender! + "撤回了一条消息"
                    lastSender = nil
                }
                if msg == nil {
                    msg = ""
                }
                let detailText  = unreadMessageCountStr! + (model.hasUnreadMentioned ? "[有人@我]" : "") as String + (lastSender == nil ? "" : (lastSender! + " : ")) + msg!
                let attrText = NSMutableAttributedString.init(string: detailText)
                if model.hasUnreadMentioned {
                    let range : Range = detailText.range(of: "[有人@我]")!
                    let nsrange = detailText.nsRange(from: range)
                    attrText.addAttributes([NSAttributedString.Key.foregroundColor : UIColor.red], range: nsrange)
                }
                self.detailLabel.attributedText = attrText
            }
        }
    }
    func convertDate(date:Date) -> String {
        if Date.isToday(target: date) {
            let dateFormatter : DateFormatter = DateFormatter()
            dateFormatter.dateFormat = "HH:mm"
            return dateFormatter.string(from: date)
        }else if Date.isLastDay(target: date) {
            return "昨天"
        }else if Date.isOneWeek(target: date) {
            return Date.weekWithDateString(target: date)
        }else{
            return Date.formattDay(target: date)
        }
    }
    class func cell(withTableView tableView: UITableView) -> GroupListCell {
        var cell = tableView.dequeueReusableCell(withIdentifier: String(describing: self)) as? GroupListCell
        if cell == nil {
            cell = GroupListCell.init(style: .default, reuseIdentifier: String(describing: self))
            cell?.selectionStyle = .none
        }
//        let cell = tableView.dequeueReusableCell(withIdentifier: "GroupListCell") as? GroupListCell
////        let cell = GroupListCell.init(style: .default, reuseIdentifier: String(describing: self))
//        cell?.selectionStyle = .none
            
        return cell!
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    //MARK: - Getter and Setter
    //头像
     lazy var headerImageView: StitchingImageView = {
        var headerImageView = StitchingImageView.init(frame: CGRect(x: 0, y: 0, width: headerImageViewWidth, height: headerImageViewWidth))
        headerImageView.layer.cornerRadius = 4.0
        headerImageView.clipsToBounds = true
        headerImageView.layer.borderColor = UIColor.hexString(hexString: headerBorderColor).cgColor
        headerImageView.layer.borderWidth = 0.5
        return headerImageView
    }()
    //badgeView
    lazy var badgeLb: UILabel = {
        var badgeLb = UILabel.init()
        badgeLb.frame = CGRect.init(x: LEFT_PADDING+headerImageViewWidth - 4, y: LEFT_PADDING - 4, width: 8, height: 8)
        badgeLb.layer.cornerRadius = 4
        badgeLb.layer.masksToBounds = true
        badgeLb.backgroundColor = UIColor.red
        return badgeLb
    }()
    //名称
     lazy var nameLabel: UILabel = {
        var nameLabel = UILabel()
        nameLabel.font = FONT_14
        nameLabel.textColor = UIColor.black
        return nameLabel
    }()
    
    //时间
     lazy var timeLabel: UILabel = {
        var timeLabel = UILabel()
        timeLabel.font = FONT_14
        timeLabel.textColor = UIColor.lightGray
        timeLabel.sizeToFit()
        return timeLabel
    }()
    
    //内容
     lazy var detailLabel: UILabel = {
        var detailLabel = UILabel()
        detailLabel.font = FONT_14
        detailLabel.textColor = UIColor.lightGray
        return detailLabel
    }()
   
}
//
//  SelectMyThemeCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/7/5.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class SelectMyThemeCell: SelectMyGroupCell {
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        self.contentView.addSubview(detailLabel)
        
        self.nameLabel.mas_remakeConstraints { [unowned self](make) in
            make!.top.equalTo()(self.headerImageView)
            make!.left.equalTo()(self.headerImageView.mas_right)!.offset()(LEFT_PADDING)
            make!.right.equalTo()(-LEFT_PADDING)
        }
        detailLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(self.headerImageView.mas_right)!.offset()(LEFT_PADDING)
            make!.right.equalTo()(-LEFT_PADDING)
            make!.bottom.equalTo()(self.headerImageView)
        }
    }
    
    
    override var model : GroupModel?{
        
        didSet{
            let groupModel : GroupModel? = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",(model?.parentid)!)).firstObject() as! GroupModel?
            if let gModel = groupModel{
                detailLabel.text = "来源:" + gModel.group_name
            }else{
                detailLabel.text = "来源不详"
            }
        }
        
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
       //来源
    fileprivate lazy var detailLabel: UILabel = {
        var detailLabel = UILabel()
        detailLabel.font = FONT_14
        detailLabel.textColor = UIColor.lightGray
        return detailLabel
    }()
}
//
//  RepeatMessageView.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/4/21.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class RepeatMessageView: UIView,UITextFieldDelegate {
    /*
    // Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        // Drawing code
    }
    */
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    var inputText = UITextField()
    var enterBtn = UIButton()
    var whiteView = UIView()
    var resourceView = UIView()
    
    
    init(type:String , modelArr:Array<GroupModel> , message:String) {
        super.init(frame: CGRect.init(x: 0, y: 0, width: SCREEN_WIDTH, height: SCREEN_HEIGHT))
        
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(aNotification:)), name: UIResponder.keyboardWillShowNotification, object: nil)
        
        //根据微信截图设置缩放比例
        let scall = SCREEN_WIDTH/640.0
        
        //黑遮罩
        let blackBackView = UIView(frame: self.frame)
        blackBackView.backgroundColor = UIColor.black
        blackBackView.alpha = 0.5
        self.addSubview(blackBackView)
        
        var whiteHeight = SCREEN_WIDTH/8*7 - 60*scall
        
        //定制消息
        if message == "[图片]" {
            whiteHeight += 320*scall
            self.resourceView = UIImageView(frame: CGRect(x: (SCREEN_WIDTH/8*7 - 320*scall)/2, y: 240*scall, width: 320*scall, height: 320*scall))
            self.resourceView.contentMode = UIView.ContentMode.scaleAspectFit
            
        }
        
        //白主体框
        self.whiteView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: SCREEN_WIDTH/8*7, height: whiteHeight))
        self.whiteView.layer.masksToBounds = true
        self.whiteView.layer.cornerRadius = 5.0
        self.whiteView.clipsToBounds = true
//        whiteView.layer.borderWidth = 1.0
//        whiteView.layer.borderColor = UIColor.black.cgColor
        self.whiteView.backgroundColor = UIColor.white
        self.whiteView.alpha = 1.0
        
        
        self.whiteView.addSubview(self.resourceView)
        //发送给
        let sendToText = UILabel(frame: CGRect(x: 40.0*scall, y: 40.0*scall, width: 200.0, height: 20.0))
        sendToText.text = "发送给:"
        sendToText.font = UIFont.boldSystemFont(ofSize: 20)
        self.whiteView.addSubview(sendToText)
        
        //头像
//        let headIcon = UIImageView.init(frame: CGRect(x: 40.0*scall, y: 100.0*scall, width: 80*scall, height: 80*scall))
//        headIcon.sd_setImage(with: URL.init(string: model.icon_url), completed: nil)
//        headIcon.layer.masksToBounds = true
//        headIcon.layer.cornerRadius = 3.0
//        self.whiteView.addSubview(headIcon)
        
        //组群名
        let groupName = UILabel.init(frame: CGRect(x: 40.0*scall, y: 100.0*scall, width: 480*scall, height: 80*scall))
        groupName.numberOfLines = 0
        groupName.font = FONT_14
        groupName.text = ((modelArr as NSArray).value(forKeyPath: "group_name") as! NSArray).componentsJoined(by: ",")
        self.whiteView.addSubview(groupName)
        
        //分割线
        let line0 = UIView(frame: CGRect(x: 40.0*scall, y: 210*scall, width: 480*scall, height: 0.5))
        line0.backgroundColor = UIColor.gray
        line0.alpha = 0.5
        self.whiteView.addSubview(line0)
        
        //消息文字
        let messageText = UILabel(frame: CGRect(x: 40.0*scall, y: 240*scall, width: 480*scall, height: 20.0*scall))
        messageText.text = message
        messageText.font = UIFont.systemFont(ofSize: 18.0)
        messageText.textColor = UIColor.gray
        messageText.alpha = 0.7
        self.whiteView.addSubview(messageText)
        
        //输入框
        self.inputText = UITextField.init(frame: CGRect(x: (SCREEN_WIDTH/8*7-480*scall)/2, y: self.whiteView.frame.height-210*scall, width: 480.0*scall, height: 70*scall))
        self.inputText.placeholder = "给朋友留言"
        self.inputText.borderStyle = UITextField.BorderStyle.roundedRect
        self.inputText.delegate = self
        self.inputText.returnKeyType = UIReturnKeyType.done
        self.whiteView.addSubview(inputText)
        
        
        //确定取消按钮
        let cancelBtn = UIButton(type: UIButton.ButtonType.system)
        self.enterBtn = UIButton(type: UIButton.ButtonType.system)
        cancelBtn.frame = CGRect(x: 0.0, y: self.whiteView.frame.height-100.0*scall, width: self.whiteView.frame.width/2, height: 100.0*scall)
        self.enterBtn.frame = CGRect(x: self.whiteView.frame.width/2, y: self.whiteView.frame.height-100.0*scall, width: self.whiteView.frame.width/2, height: 100.0*scall)
        cancelBtn.setTitle("取消", for: UIControl.State.normal)
        self.enterBtn.setTitle("发送", for: UIControl.State.normal)
        cancelBtn.titleLabel?.font = UIFont.systemFont(ofSize: 20)
        self.enterBtn.titleLabel?.font = UIFont.systemFont(ofSize: 20)
        cancelBtn.setTitleColor(UIColor.black, for: UIControl.State.normal)
        self.enterBtn.setTitleColor(UIColor.green, for: UIControl.State.normal)
        cancelBtn.addTarget(self, action: #selector(self.cleanBtn(btn:)), for: UIControl.Event.touchUpInside)
        
        self.whiteView.addSubview(cancelBtn)
        self.whiteView.addSubview(self.enterBtn)
        
        //按钮分割线
        let line1 = UIView(frame: CGRect(x: 0.0, y: self.whiteView.frame.height-100.0*scall, width: self.whiteView.frame.width, height: 0.5))
        let line2 = UIView(frame: CGRect(x: self.whiteView.frame.width/2, y: self.whiteView.frame.height-100.0*scall, width: 0.5, height: 100.0*scall))
        line1.alpha = 0.5
        line2.alpha = 0.5
        line1.backgroundColor = UIColor.gray
        line2.backgroundColor = UIColor.gray
        self.whiteView.addSubview(line1)
        self.whiteView.addSubview(line2)
            
        
//        if type == "pic" {
//            <#code#>
//        }
        
        self.addSubview(self.whiteView)
       self.whiteView.center = self.center
    }
    
    @objc func cleanBtn(btn:UIButton) {
        self.removeFromSuperview()
    }
    deinit {
         NotificationCenter.default.removeObserver(self)
    }
    var keyHeight = CGFloat()
    
    
    @objc func keyboardWillShow(aNotification: NSNotification) {
        
        let userinfo = aNotification.userInfo!
        
        let nsValue = userinfo[UIResponder.keyboardFrameEndUserInfoKey]
        
        let keyboardRec = (nsValue as AnyObject).cgRectValue
        
        let height = keyboardRec?.size.height
        
        self.keyHeight = height!
        
        UIView.animate(withDuration: 0.5, animations: {
            
            var frame = self.frame
            
            frame.origin.y = -self.keyHeight + (SCREEN_HEIGHT - self.whiteView.frame.height)/2
            
            self.frame = frame
        }, completion: nil)
    }
    func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
        UIView.animate(withDuration: 0.5, animations: {
            
            var frame = self.frame
            
            frame.origin.y = 0
            
            self.frame = frame
            
        }, completion: nil)
        
        return true
    }
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return true
    }
    
//    func textFieldShouldEndEditing(textField: UITextField) -> Bool {
//        
//        UIView.animate(withDuration: 0.5, animations: {
//            
//            var frame = self.frame
//            
//            frame.origin.y = 0
//            
//            self.frame = frame
//            
//        }, completion: nil)
//        
//        return true
//
//    }
}
//
//  SelectMyGroupCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/4/21.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
private let headerImageViewWidth : CGFloat = 35.0
class SelectMyGroupCell: UITableViewCell {
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        self.contentView.addSubview(headerImageView)
        self.contentView.addSubview(nameLabel)
        self.contentView.addSubview(selectImageView)
        self.hiddenSelectImage = true
        
        selectImageView.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(LEFT_PADDING)
            make!.size.equalTo()(CGSize(width: 15, height: 15))
            make!.centerY.equalTo()(self)
        }
        headerImageView.mas_makeConstraints { [unowned self](make) in
            make!.top.equalTo()(5)
            make!.left.equalTo()(self.selectImageView.mas_right)!.offset()(LEFT_PADDING)
//            make!.size.equalTo()(CGSize(width: self.frame.size.height - 10, height: self.frame.size.height - 10))
            make!.centerY.equalTo()(self)
            make!.width.equalTo()(self.headerImageView.mas_height)
        }
        nameLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(self.headerImageView.mas_right)!.offset()(LEFT_PADDING)
            make!.centerY.equalTo()(self)
            make!.right.equalTo()(-LEFT_PADDING)
        }
        
    }
    var model : GroupModel?{
    
        didSet{
            headerImageView.sd_setImage(with: NSURL.init(string: (model?.icon_url)!) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
            nameLabel.text = model?.group_name
        
        }
    
    }
    var hiddenSelectImage : Bool?{
        
        didSet{
            self.selectImageView.isHidden = hiddenSelectImage!
            headerImageView.mas_updateConstraints { [unowned self](make) in
                if self.hiddenSelectImage! {
                    make!.left.equalTo()(LEFT_PADDING)
                }else{
                    make!.left.equalTo()(self.selectImageView.mas_right)!.offset()(LEFT_PADDING)
                }
            }
        }
        
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    
    
    //MARK: - Getter and Setter
    //头像
    var headerImageView: StitchingImageView = {
        var headerImageView = StitchingImageView.init(frame: CGRect(x: 0, y: 0, width: headerImageViewWidth, height: headerImageViewWidth))
        headerImageView.contentMode = .scaleAspectFill
        headerImageView.layer.cornerRadius = 4.0
        headerImageView.clipsToBounds = true
        headerImageView.layer.borderColor = UIColor.hexString(hexString: headerBorderColor).cgColor
        headerImageView.layer.borderWidth = 0.5
        return headerImageView
    }()
    //名称
    lazy var nameLabel: UILabel = {
        var nameLabel = UILabel()
        nameLabel.font = FONT_14
        nameLabel.textColor = UIColor.black
        return nameLabel
    }()
    //选择状态icon
    var selectImageView: UIImageView = {
        var selectImageView = UIImageView.init()
        selectImageView.contentMode = .scaleAspectFit
        selectImageView.image = UIImage.init(named: "logic_normal")
        return selectImageView
    }()
}
//
//  ProjectVoiceMessageContentCell.swift
//  SLAPP
//
//  Created by apple on 2018/4/27.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class ProjectVoiceMessageContentCell: RCMessageCell {
    
    lazy var backView = { () -> UIView in
        let view = UIView()
        return view
    }()
    
    lazy var nameLable = { () -> UILabel in
        let lable = UILabel()
        lable.font = UIFont.systemFont(ofSize: 14)
        return lable
    }()
    
    lazy var btn = { () -> UIButton in
        let btn = UIButton()
        return btn
    }()
    
    lazy var progress = { () -> UIProgressView in
        let btn = UIProgressView()
        return btn
    }()
    
    
    var click:(_ model:RCMessageModel)->() = { _ in
        
    }
    
    lazy var timeLable = { () -> UILabel in
        let lable = UILabel()
        lable.font = UIFont.systemFont(ofSize: 14)
        //        lable.textAlignment = .center
        //        lable.textColor =
        return lable
    }()
    
    lazy var timeLableall = { () -> UILabel in
        let lable = UILabel()
        lable.font = UIFont.systemFont(ofSize: 14)
        //        lable.textAlignment = .center
        //        lable.textColor =
        return lable
    }()
    
    override class func size(for model: RCMessageModel!, withCollectionViewWidth: CGFloat, referenceExtraHeight: CGFloat) -> CGSize {
        if model.isDisplayMessageTime == true{
            return super.size(for: model, withCollectionViewWidth: withCollectionViewWidth, referenceExtraHeight: 200)
        }else{
            return super.size(for: model, withCollectionViewWidth: withCollectionViewWidth, referenceExtraHeight: 120)
        }
        
    }
    
    override init!(frame: CGRect) {
        super.init(frame: frame)
        self.contentView.addSubview(backView)
        
        backView.frame = CGRect(x: 70, y: 60, width: frame.size.width-140, height: 80)
        
        backView.backgroundColor = UIColor.white
        backView.addSubview(btn)
        btn.frame = CGRect(x: 15, y:10, width: 60 , height: 60)
        btn.setImage(UIImage.init(named: "proStart"), for: .normal)
        
        backView.addSubview(nameLable)
        nameLable.frame = CGRect(x: 90 , y: 5, width: backView.width-100, height: 30)
        nameLable.numberOfLines = 0
        
        backView.addSubview(progress)
        progress.frame = CGRect(x: 90, y: 45, width: backView.width-100, height: 5)
        progress.tintColor = UIColor.green
        progress.progress = 0
        
        backView.addSubview(timeLable)
        timeLable.frame = CGRect(x: 90, y: 60, width: (backView.width-100)/2, height: 15)
        timeLable.text = "0:00"
        timeLable.textAlignment = .right
        backView.addSubview(timeLableall)
        timeLableall.frame = CGRect(x: 90+(backView.width-100)/2, y: 60, width: (backView.width-100)/2, height: 15)
        timeLableall.text = ""
        
        btn.addTarget(self, action: #selector(btnClick), for: .touchUpInside)
    }
    
    @objc func btnClick(){
        
        self.click(self.model)
    }
    
    override func setDataModel(_ model: RCMessageModel!) {
        super.setDataModel(model)
        let content:ProjectVoiceMessageContent = model.content as! ProjectVoiceMessageContent
        nameLable.text = content.projectName
        
        let duration = NSString.init(string: content.duration).integerValue/1000
        timeLableall.text = "/" + "\(duration/60)" + ":" + "\(duration%60)"
        if model.isDisplayMessageTime == true{
            backView.frame = CGRect(x: 70, y: 60, width: frame.size.width-140, height: 80)
        }else{
            backView.frame = CGRect(x: 70, y: 30, width: frame.size.width-140, height: 80)
        }
        
    }
    
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
//
//  ThemeMessageCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/6/8.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
var myWidth = kScreenW - (10 + RCIM.shared().globalConversationPortraitSize.width + 10)*2
let extre = "你还:12313123k1kajs\ndajsdkajsddasdlajsdlk\n还行:kajskajsdkjsjdkajsdajdljasdkjasd"
class ThemeMessageCell: RCMessageCell {
    
    
    /*
    // Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        // Drawing code
    }
    */
    
//    var contentView: UIView?
    
    var topView = UIView.init()
    var bottomView = UIView.init()
    
    var contentLable = UILabel.init() //内容
    
    
    
    var headImage = UIImageView.init() //头像
    var lab1 = UILabel.init()
    var munImage = UIImageView.init()
    var numLable = UILabel.init()
    
    var lineView = UIView.init()
    var imageListView = UIView.init()
    var openBtn = UIButton.init(type: .custom)
    
    var extralable = UILabel.init()
    
    
    var joinBtn = UIButton.init(type: .custom)
    
    var didJoin = {
        (themeId:String) in
        print(themeId)
    }
    
    var backView = UIView.init()
    
    var openList:Array<String>?
    
    var didClickOpen = {
        (themeId:String) in
        print(themeId)
    
    }
    
    
    
//    //系统要求重写位置的方法
//    override class func size(for model: RCMessageModel!, withCollectionViewWidth: CGFloat, referenceExtraHeight: CGFloat) -> CGSize {
//        
//        
////        super.size(for: <#T##RCMessageModel!#>, withCollectionViewWidth: <#T##CGFloat#>, referenceExtraHeight: <#T##CGFloat#>)
//    
//    
//        
//        return CGSize.init(width:kScreenW, height: 100)
//    }
////
//    
    
    
    
    
    class func conFigSize(model:RCMessageModel,width:CGFloat,openList:Array<String>)->(CGSize){
        
        if kScreenW <= 320{
          myWidth = 200
        }
        
        let myModel = model.content as! ThemeMessageContent
        
        let bubbleBackgroundViewSize:CGSize = ThemeMessageCell.getBubbleSize(textLabelSize: CGSize.init(width: myWidth, height: 180))
        
        let predicate = NSPredicate(format:"groupid == %@  AND is_delete == '0'",myModel.themeId)
        let r = ThemeInfoModel.objects(with: predicate)
        
        
        if openList.contains("\(model.messageId)") {
            
            var allHeight:CGFloat = 150;
            
            
            if r.count > 0 {
                let infoModel:ThemeInfoModel = r.firstObject() as! ThemeInfoModel
                
                allHeight +=  self.imageHeight(num: infoModel.imageNum, width: myWidth)
                print("图片 \(allHeight)")
                
            }
            
            
            allHeight += self.textHeight(model: myModel, width: bubbleBackgroundViewSize.width - 20)
            if allHeight < 200 {
                allHeight  = 200
            }
            
            allHeight += 30;
            
            if model.isDisplayMessageTime == true{
                 allHeight += 30
            }
            
            
            return CGSize.init(width: width, height: allHeight)
        }
        else{
            
            var extraHeight:CGFloat = 0
            if !myModel.extra.isEmpty {
                extraHeight = self.getTextHeight(textStr: myModel.extra, width: bubbleBackgroundViewSize.width - 20)
            }
            
            extraHeight += 30
            
            if model.isDisplayMessageTime == true{
                extraHeight += 30
            }
            
            var baseHeight:CGFloat = 90
            
            let textHeight  =  self.getTextHeight(textStr: myModel.content, width: bubbleBackgroundViewSize.width - 20)
            
            if textHeight < 63 {
                baseHeight += textHeight
            }
            else{
               baseHeight += 63
               baseHeight += 20
            
            }
            
//            print("高度--\(textHeight)")
            
            
            
            if r.count > 0 {
                let infoModel:ThemeInfoModel = r.firstObject() as! ThemeInfoModel
                
                if infoModel.imageNum.intValue > 0  || baseHeight <=  173{
                    baseHeight += 20
                }
                
            }
            
            return CGSize.init(width: width, height:baseHeight + extraHeight+20)
        }
        
        
    }
    
    
    class func imageHeight(num:NSNumber,width:CGFloat)->(CGFloat) {
        print(num)
        if num == 0 {
            return 0
        }
        let count = (Int(num)-1) / 3
        
      let bubbleBackgroundViewSize:CGSize = ThemeMessageCell.getBubbleSize(textLabelSize: CGSize.init(width: myWidth, height: 180))
        
        return ((bubbleBackgroundViewSize.width-20)/3) * CGFloat(count + 1) + 5 * CGFloat(count+1)
    }
    
    class func textHeight(model:ThemeMessageContent,width:CGFloat)->(CGFloat) {
        
        if !model.extra.isEmpty {
          return self.getTextHeight(textStr: model.content, width: width) + self.getTextHeight(textStr: model.extra, width: width);
        }
        else{
          return self.getTextHeight(textStr: model.content, width: width)
        }
    }
    
    
    
    class func getTextHeight(textStr:String,width:CGFloat) -> CGFloat {
        
        let font = UIFont.systemFont(ofSize: 14)
        let paragraphStyle = NSMutableParagraphStyle.init()
        paragraphStyle.lineSpacing = textLineSpace
        let constraintRect = CGSize(width: width, height: CGFloat.greatestFiniteMagnitude)
        let boundingBox = textStr.boundingRect(with: constraintRect, options: NSStringDrawingOptions.usesLineFragmentOrigin, attributes: [NSAttributedString.Key.font: font, NSAttributedString.Key.paragraphStyle: paragraphStyle], context: nil)
        return boundingBox.height
    }
    
    
    
    
    
    //数据得到时的方法
    override func setDataModel(_ model: RCMessageModel!) {
//                print("hao_____\(cont)")
        for view in self.imageListView.subviews{
            view.removeFromSuperview()
        }
        print(model.objectName)
        
        super.setDataModel(model)
//        self.contentLable.text = cont.content
        
        
        print(myWidth)
        self.setAutoLayout()
        self.requestThemeInfo(model: model)
        
//        self.titleLabel.text = cont.title
    }
    
    class func getBubbleSize(textLabelSize:CGSize)->(CGSize){
    
        var bubbleSize = CGSize.init(width: textLabelSize.width, height: textLabelSize.height)
        if (bubbleSize.width + 12 + 20 > 50) {
            bubbleSize.width = bubbleSize.width + 12 + 20;
        } else {
            bubbleSize.width = 50;
        }
        if (bubbleSize.height + 7 + 7 > 40) {
            bubbleSize.height = bubbleSize.height + 7 + 7;
        } else {
            bubbleSize.height = 40;
        }
        
        return bubbleSize;
        
    }
    
    func setAutoLayout(){
        
        let cont = model.content as! ThemeMessageContent
        if kScreenW <= 320{
            myWidth = 200
        }
//        cont.extra = extre
        let bubbleBackgroundViewSize:CGSize = ThemeMessageCell.getBubbleSize(textLabelSize: CGSize.init(width: myWidth, height: 180))
        var messageContentViewRect:CGRect = self.messageContentView.frame
        if model.isDisplayMessageTime == true {
//            messageContentViewRect.size.height -= 30
//           messageContentViewRect.size.width = myWidth
        }
        
//        messageContentView.frame = messageContentViewRect
        
        
        print(messageContentViewRect.size.height)
//        messageContentViewRect.size.width = bubbleBackgroundViewSize.width;
        
        if .MessageDirection_RECEIVE == self.messageDirection {
        self.messageContentView.frame = CGRect(x: messageContentViewRect.origin.x, y: messageContentViewRect.origin.y, width: bubbleBackgroundViewSize.width, height: messageContentViewRect.size.height)
        }
        else{
//        self.messageContentView.frame = messageContentViewRect
            self.messageContentView.frame = CGRect(x: messageContentViewRect.origin.x-(bubbleBackgroundViewSize.width-messageContentViewRect.width), y: messageContentViewRect.origin.y, width: bubbleBackgroundViewSize.width, height: messageContentViewRect.size.height)
            
        }
        
        self.backView.frame = CGRect(x: 0, y: 0, width: self.messageContentView.frame.size.width, height: self.messageContentView.frame.size.height)
        
        messageContentViewRect.size.width = bubbleBackgroundViewSize.width
        
        self.topView.frame = CGRect(x: 0, y: 0, width: messageContentViewRect.width, height: 30)
        
        
        var extraHeight:CGFloat = 0
        if !cont.extra.isEmpty {
            extraHeight = ThemeMessageCell.getTextHeight(textStr: cont.extra, width: bubbleBackgroundViewSize.width - 20)
        }
        
        
        
        
        self.contentLable.numberOfLines = 0
        self.contentLable.changeLineSpace(text: cont.content, space: textLineSpace)
        
        let conFrame = messageContentViewRect
        //一些子控件UI的调试
        
        let textHeight = ThemeMessageCell.getTextHeight(textStr: self.contentLable.text!, width: conFrame.size.width - 20)
        
        let predicate = NSPredicate(format:"groupid == %@  AND is_delete == '0'",cont.themeId)
        let r = ThemeInfoModel.objects(with: predicate) 
        
        
        if textHeight < 63 {
            self.openBtn.isHidden = true
        }
        else{
            self.openBtn.isHidden = false
        }
        
        
        
        self.subviewsFrameConfig(conFrame: conFrame)
        
        if r.count > 0 {
            let infoModel:ThemeInfoModel = r.firstObject() as! ThemeInfoModel
            if infoModel.imageNum != 0 {
                self.openBtn.isHidden = false
            }
        }
        self.contentLable.frame = CGRect(x: 10, y: 30, width: conFrame.size.width-20, height: textHeight<63 ? textHeight:63)
        
        
        
        
        
        if openList != nil || openList?.count != 0 {
            //是否显示图片
            self.isShowImage(openList: openList!, cont: cont, conFrame: conFrame, textHeight: textHeight, r: r as! RLMResults<RLMObject>)
        }
        
        var bottomY:CGFloat = 0
        if self.imageListView.isHidden == false {
            bottomY =  self.imageListView.frame.origin.y + self.imageListView.frame.size.height
        }
        else{
           bottomY =  self.contentLable.frame.origin.y + self.contentLable.frame.size.height
        }
        
        
        self.bottomView.frame = CGRect(x: 0, y:bottomY, width: messageContentViewRect.width, height: 60 + extraHeight)
        
        
        if extraHeight > 0 {
            
            var extraY:CGFloat = 0
            if self.openBtn.isHidden == false {
                extraY = self.openBtn.frame.origin.y + self.openBtn.frame.size.height
            }
            
            self.extralable.frame = CGRect.init(x: 10, y: extraY+5, width: conFrame.size.width - 20, height: extraHeight)
            self.extralable.isHidden = false
            
            self.openBtn.frame = CGRect.init(x: -3, y: 10, width: 45, height: 30)
            self.extralable.changeLineSpace(text: cont.extra, space: textLineSpace)
            
            self.lineView.frame = CGRect.init(x: 5, y: self.extralable.frame.origin.y+extraHeight+5, width: conFrame.size.width - 10, height: 0.5)
            
            self.joinBtn.frame = CGRect.init(x: conFrame.size.width/4, y:self.lineView.frame.origin.y+5, width: conFrame.size.width/2, height: 30)
            
            
            
            
        }else{
            self.extralable.isHidden = true
            if self.openBtn.isHidden == false {
                self.lineView.frame = CGRect.init(x: 5, y: self.openBtn.frame.origin.y+5+self.openBtn.frame.size.height, width: conFrame.size.width - 10, height: 0.5)
                
                self.joinBtn.frame = CGRect.init(x: conFrame.size.width/4, y:self.lineView.frame.origin.y+5, width: conFrame.size.width/2, height: 30)
            }else{
            
            
                self.lineView.frame = CGRect.init(x: 5, y: 5, width: conFrame.size.width - 10, height: 0.5)
                
                self.joinBtn.frame = CGRect.init(x: conFrame.size.width/4, y:self.lineView.frame.origin.y+5, width: conFrame.size.width/2, height: 30)
            
            
            
            }
            
            
            
            
        }
        
        self.backView.frame = CGRect(x: self.backView.frame.origin.x, y: self.backView.frame.origin.y, width: self.backView.frame.size.width, height: self.bottomView.frame.origin.y + self.joinBtn.frame.size.height + self.joinBtn.frame.origin.y+10)
       self.openBtn.titleLabel?.textAlignment = .left
       }
    
    
    
    func subviewsFrameConfig(conFrame:CGRect){
        
        self.headImage.frame = CGRect.init(x: 5, y: 5, width: 20, height: 20)
        self.headImage.backgroundColor = UIColor.hexString(hexString: "1782D2")
        
        
        self.lab1.frame = CGRect.init(x: 30, y: 5, width: conFrame.size.width/2-30, height: 20)
        self.munImage.frame = CGRect.init(x: 5 + conFrame.size.width-100, y: 5, width: 20, height: 20)
        self.numLable.frame = CGRect.init(x: 5 + conFrame.size.width-80, y: 10, width: 80, height: 10)
        self.numLable.textAlignment = .left
        self.openBtn.frame = CGRect.init(x: -3, y: 10, width: 60, height: 30)
        self.openBtn.setTitle("展开", for: .normal)
        self.lineView.frame = CGRect.init(x: 5, y:  self.bottomView.frame.size.height-36, width: conFrame.size.width - 10, height: 0.5)
        self.lineView.backgroundColor = UIColor.lightGray
        self.joinBtn.frame = CGRect.init(x: conFrame.size.width/4, y:self.bottomView.frame.size.height-33, width: conFrame.size.width/2, height: 30)
        self.joinBtn.backgroundColor = UIColor.hexString(hexString: "1782D2")
        self.joinBtn.setTitle("进入话题", for: .normal)
    
    }
    
    
    //是否显示图片
    func isShowImage(openList:Array<String>,cont:ThemeMessageContent,conFrame:CGRect,textHeight:CGFloat,r:RLMResults<RLMObject>){
        if (openList.contains("\(model.messageId)")) {
            self.contentLable.frame = CGRect(x: 10, y: 30, width: conFrame.size.width-20, height:textHeight)
            
            self.openBtn.setTitle("收起", for: .normal)
            
           
            
            if r.count > 0 {
                 self.imageListView.isHidden = false
                let infoModel:ThemeInfoModel = r.firstObject() as! ThemeInfoModel
                let imageHeight = ThemeMessageCell.imageHeight(num: infoModel.imageNum, width: conFrame.size.height)
                
                self.imageListView.frame = CGRect(x: 0, y: 30+textHeight, width: conFrame.size.width, height: imageHeight)
                
                
                let anyArray = BaseRequest.makeJsonWithString(jsonStr: infoModel.imageArray)
                
                if let array:Array = anyArray as! Array<Any> {
                    
                    if array.count == 0{
                        return
                    }
                    
                    
                    for i in 0...array.count-1 {
                        let dic:Dictionary = array[i] as! Dictionary<String,String>
                        
                        let space:CGFloat = 5
                        let imageWidth:CGFloat = (conFrame.size.width-20)/3
                        let image = UIImageView.init(frame: CGRect(x: space + CGFloat(i%3) * imageWidth+CGFloat(i%3)*space, y:space + CGFloat(i/3) * imageWidth+CGFloat(i/3) * space, width: imageWidth, height: imageWidth))
                        self.imageListView.addSubview(image)
                        image.contentMode = .scaleAspectFill
                        image.clipsToBounds = true
                        image.sd_setImage(with: NSURL.init(string:(dic["thumb_url"])!)! as URL, placeholderImage: UIImage.init(named: "emoji"))
                        image.tag = i
                        let ges = UITapGestureRecognizer.init(target: self, action: #selector(tapped(_:)))
                        ges.numberOfTapsRequired = 1
                        image.addGestureRecognizer(ges)
                        image.isUserInteractionEnabled = true
                    }
                    
                }
            }
        }
        else{
            self.openBtn.setTitle("展开", for: .normal)
            self.imageListView.isHidden = true
        }
    
    }
    
    
    
    
    @objc func tapped(_ tap:UITapGestureRecognizer){
        let image:UIImageView = tap.view as! UIImageView
        
        let photoBrowser = SDPhotoBrowser.init();
        photoBrowser.delegate = self as SDPhotoBrowserDelegate;
        photoBrowser.currentImageIndex = image.tag
        
        photoBrowser.imageCount = (self.imageListView.subviews.count);
        photoBrowser.sourceImagesContainerView = self.imageListView;
        
        photoBrowser.show()
        
    }
    
    /// 刷新话题信息
    ///
    /// - Parameter model: <#model description#>
    func requestThemeInfo(model:RCMessageModel){
    
        GroupRequest.getGroupSubjectInfo(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":(model.content as! ThemeMessageContent).themeId], hadToast: false, fail: { (dic) in
            
        }) { [weak self](dic) in
            print(dic)
            
            self?.headImage.sd_setImage(with: NSURL.init(string: dic["icon_url"] as! String) as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
            self?.numLable.text = dic["user_num"] as! String + "人参与"
            
            
            
            if (dic["titleFileList"] is Array<Dictionary<String, Any>>) {
                var urlArr : Array<Any>? = []
                for dict:Dictionary<String, Any> in (dic["titleFileList"] as! Array<Dictionary<String, Any>>){
                    urlArr?.append(dict)
                }
                //                            strongSelf.selectedUrls = urlArr
                //                            strongSelf.creatImageView()
            }
        }
    }
    
    
    override init!(frame: CGRect) {
        super.init(frame: frame)
    
//        for view in self.imageListView.subviews{
//            view.removeFromSuperview()
//        }
//        
//        for view in self.messageContentView.subviews {
//            view.removeFromSuperview()
//            
//        }
        
        self.openList = nil
        self.initialize()
        
        
    }
    
    func initialize(){
        
//        self.frame = CGRect(x: 0, y: 0, width: kScreenW, height: 200)
        
        
        
//        self.messageContentView.backgroundColor = UIColor.white
       
        //            self.messageContentView.eventBlock =
        
        self.backView.backgroundColor = UIColor.white
        self.backView.layer.cornerRadius = 5
        self.backView.layer.masksToBounds = true
        self.messageContentView.addSubview(self.backView)
        
        self.headImage.image = UIImage.init(named: "mine_avatar")
        //顶部内容
        self.topView.addSubview(self.headImage)
        self.topView.addSubview(self.lab1)
        self.lab1.text = "话题讨论"
        self.topView.addSubview(self.munImage)
        self.topView.addSubview(numLable)
        self.backView.addSubview(self.topView)
        
        
    self.backView.addSubview(self.contentLable)
    self.backView.addSubview(self.imageListView)
        
       
        self.bottomView.addSubview(self.openBtn)
        self.bottomView.addSubview(self.extralable)
        self.bottomView.addSubview(self.lineView)
        self.bottomView.addSubview(self.joinBtn)
        self.backView.addSubview(self.bottomView)
        
        
        
        
//        self.messageContentView.addSubview(self.headImage)
//        self.messageContentView.addSubview(self.lab1)
//        self.messageContentView.addSubview(self.contentLable)
//        
//        //            self.messageContentView.addSubview(self.imageView)
//        self.messageContentView.addSubview(self.munImage)
//        self.messageContentView.addSubview(self.numLable)
//        self.messageContentView.addSubview(self.lineView)
//        self.messageContentView.addSubview(self.imageListView)
//        self.messageContentView.addSubview(self.openBtn)
//        self.messageContentView.addSubview(self.joinBtn)
        
        let longPre = UILongPressGestureRecognizer.init(target: self, action: #selector(longPressed(sender:)))
        self.backView.addGestureRecognizer(longPre)
        let sortPre = UITapGestureRecognizer.init(target: self, action: #selector(singleTap(sender:)))
        self.backView.addGestureRecognizer(sortPre)
        
        print(self.messageContentView.frame.size.height)
        self.lab1.font = UIFont.systemFont(ofSize: 14)
        
        self.munImage.image = UIImage.init(named: "xljm5_Nomal")
        self.numLable.font = UIFont.systemFont(ofSize: 14)
        self.numLable.text = "0人参与"
        
        self.contentLable.font = UIFont.systemFont(ofSize: 14)
        self.extralable.font = UIFont.systemFont(ofSize: 14)
        self.contentLable.textColor = UIColor.darkGray
        self.extralable.textColor = UIColor.lightGray
        
        self.extralable.textAlignment = .left
        self.extralable.numberOfLines = 0
        self.extralable.lineBreakMode = .byCharWrapping
        openBtn.titleLabel?.font = UIFont.systemFont(ofSize: 13)
        openBtn.titleLabel?.textAlignment = NSTextAlignment.left
        openBtn.setTitleColor(UIColor.hexString(hexString: "1782D2"), for: .normal)
        openBtn.addTarget(self, action: #selector(btnClickOpen(btn:)), for: .touchUpInside)
        
        
        joinBtn.titleLabel?.font = UIFont.systemFont(ofSize: 14)
        joinBtn.layer.cornerRadius = 5
        joinBtn.layer.masksToBounds = true
        joinBtn.addTarget(self, action: #selector(btnClick(btn:)), for: .touchUpInside)
        
        self.contentLable.numberOfLines = 0
        self.contentLable.lineBreakMode = .byCharWrapping
        
        
                    self.lab1.font = UIFont.systemFont(ofSize: 14)
        
                    self.munImage.image = UIImage.init(named: "xljm5_Nomal")
                    self.numLable.font = UIFont.systemFont(ofSize: 14)
                    self.numLable.text = "0人参与"
        
//        self.headImage.frame = CGRect.init(x: 5, y: 5, width: 20, height: 20)
//        self.lab1.frame = CGRect.init(x: 30, y: 10, width: conFrame.size.width/2-30, height: 10)
//        self.munImage.frame = CGRect.init(x: 5 + conFrame.size.width/2, y: 5, width: 20, height: 20)
//        self.numLable.frame = CGRect.init(x: 30 + conFrame.size.width/2, y: 10, width: conFrame.size.width/2-30, height: 10)
//        self.openBtn.frame = CGRect.init(x: conFrame.width - 50, y: conFrame.height - 70, width: 45, height: 15)
//
//        self.lineView.frame = CGRect.init(x: 5, y: conFrame.size.height - 50 , width: conFrame.size.width - 10, height: 1)
//        self.joinBtn.frame = CGRect.init(x: conFrame.size.width/4, y: conFrame.size.height - 40, width: conFrame.size.width/2, height: 30)
    }
    
//                self.joinBtn.setTitle("进入话题", for: .normal)
    
    
    
    
//    //初始化的方法
//    override init!(frame: CGRect) {
//        print(frame)
//        super.init(frame: frame)
//        if self != nil {
////            self.messageContentView.frame = CGRect.init(x: 0, y: 0, width: 100, height: 180)
//            
//            
//            
//
//            self.messageContentView.backgroundColor = UIColor.white
//            messageContentView.layer.cornerRadius = 5
//            messageContentView.layer.masksToBounds = true
////            self.messageContentView.eventBlock = 
//            print("跨度")
//            print(self.messageContentView.frame.size.width)
//            
//            self.messageContentView.addSubview(self.headImage)
//            self.messageContentView.addSubview(self.lab1)
//            self.messageContentView.addSubview(self.contentLable)
//           
////            self.messageContentView.addSubview(self.imageView)
//            self.messageContentView.addSubview(self.munImage)
//            self.messageContentView.addSubview(self.numLable)
//            self.messageContentView.addSubview(self.lineView)
//            self.messageContentView.addSubview(self.imageListView)
//            self.messageContentView.addSubview(self.openBtn)
//            self.messageContentView.addSubview(self.joinBtn)
//            
//            let longPre = UILongPressGestureRecognizer.init(target: self, action: #selector(longPressed(sender:)))
//            self.messageContentView.addGestureRecognizer(longPre)
//            let sortPre = UITapGestureRecognizer.init(target: self, action: #selector(singleTap(sender:)))
//            self.messageContentView.addGestureRecognizer(sortPre)
//            
//            
//            self.lab1.font = UIFont.systemFont(ofSize: 14)
//            
//            self.munImage.image = UIImage.init(named: "xljm5_Nomal")
//            self.numLable.font = UIFont.systemFont(ofSize: 14)
//            self.numLable.text = "0人参与"
//            
//            self.contentLable.font = UIFont.systemFont(ofSize: 15)
//            
//            
//            openBtn.titleLabel?.font = UIFont.systemFont(ofSize: 13)
//            openBtn.titleLabel?.textAlignment = NSTextAlignment.right
//            openBtn.setTitleColor(UIColor.hexString(hexString: "1782D2"), for: .normal)
//            openBtn.addTarget(self, action: #selector(btnClickOpen(btn:)), for: .touchUpInside)
//            
//            
//            joinBtn.titleLabel?.font = UIFont.systemFont(ofSize: 14.5)
//            joinBtn.layer.cornerRadius = 5
//            joinBtn.layer.masksToBounds = true
//            joinBtn.addTarget(self, action: #selector(btnClick(btn:)), for: .touchUpInside)
//            
//            self.contentLable.numberOfLines = 0
////            self.contentLable.
//            //系统messageContentView的frame变动是的方法，conFrame是变动后的大小，不要在这里改变messageContentView的大小
////            self.messageContentView.registerFrameChangedEvent({ (conFrame) in
////                //头像
////                self.headImage.frame = CGRect.init(x: 5, y: 5, width: 20, height: 20)
////                self.headImage.backgroundColor = UIColor.hexString(hexString: "1782D2")
////                //话题讨论
////                self.lab1.frame = CGRect.init(x: 30, y: 10, width: conFrame.size.width/2-30, height: 10)
////                self.lab1.backgroundColor = UIColor.white
////                self.lab1.text = "话题讨论"
////                
////               
////                //人数图像
////                self.munImage.frame = CGRect.init(x: 5 + conFrame.size.width/2, y: 5, width: 20, height: 20)
//////                self.munImage.backgroundColor = UIColor.hexString(hexString: "1782D2")
////                //人数文字
////                self.numLable.frame = CGRect.init(x: 30 + conFrame.size.width/2, y: 10, width: conFrame.size.width/2-30, height: 10)
//////                self.numLable.backgroundColor = UIColor.white
//////                self.numLable.text = "话题讨论"
////                
////                if conFrame.height <= 200{
////                  
////                    
////                    self.imageListView.isHidden = true
////                //文字
////                self.contentLable.frame = CGRect.init(x: 10, y: 30, width: conFrame.size.width - 20, height: conFrame.size.height - 30 - 70 )
//////                self.contentLable.backgroundColor = UIColor.green
////                    self.openBtn.setTitle("展开", for: .normal)
////                }
////                else{
////                    
////                   
////                    self.imageListView.isHidden = false
////                   let myModel = self.model.content as! ThemeMessageContent
////                   self.contentLable.frame = CGRect.init(x: 10, y: 30, width: conFrame.size.width-20, height:ThemeMessageCell.getTextHeight(textStr: myModel.content, width: conFrame.size.width) )
////                    self.openBtn.setTitle("合起", for: .normal)
////                    
////                    
////                    
////                    
////                    
////                    let predicate = NSPredicate(format:"groupid == %@  AND is_delete == '0'",myModel.themeId)
////                    let r = ThemeInfoModel.objects(with: predicate)
////                    
////                    if r.count > 0 {
////                        let infoModel:ThemeInfoModel = r.firstObject() as! ThemeInfoModel
////                        let imageheiht = ThemeMessageCell.imageHeight(num: infoModel.imageNum, width: conFrame.size.width)
////                        self.imageListView.backgroundColor = UIColor.red
////                        self.imageListView.frame = CGRect(x: 0, y: conFrame.size.height - 100-imageheiht, width: conFrame.size.width, height: imageheiht)
////                        
////                    }
////
////                    
////                    
////                }
////                
////                self.openBtn.frame = CGRect.init(x: conFrame.width - 50, y: conFrame.height - 70, width: 45, height: 15)
////                
////                
////                self.lineView.frame = CGRect.init(x: 5, y: conFrame.size.height - 50 , width: conFrame.size.width - 10, height: 1)
////                self.lineView.backgroundColor = UIColor.gray
////                
////                self.joinBtn.frame = CGRect.init(x: conFrame.size.width/4, y: conFrame.size.height - 40, width: conFrame.size.width/2, height: 30)
////                self.joinBtn.setTitle("参与讨论", for: .normal)
////                self.joinBtn.backgroundColor = UIColor.hexString(hexString: "1782D2")
////            })
//            
//        }
//    }
    
    
    @objc func btnClickOpen(btn:UIButton){
        didClickOpen("\(model.messageId)")
    }
    
    @objc func btnClick(btn:UIButton){
        let predicate = NSPredicate(format:"userid == %@ AND groupid == %@  AND is_delete == '0'", sharePublicDataSingle.publicData.userid,(model.content as! ThemeMessageContent).themeId)
        let results = GroupUserModel.objects(with: predicate)
        if results.count == 0 {
            SVProgressHUD.setDefaultStyle(.custom)
            SVProgressHUD.setDefaultMaskType(.gradient)
            SVProgressHUD.setBackgroundColor(UIColor.darkGray)
            SVProgressHUD.setForegroundColor(UIColor.white)
            SVProgressHUD.show()
            GroupRequest.joinGroupSubject(params: ["app_token":sharePublicDataSingle.token,"sub_groupid":(self.model.content as! ThemeMessageContent).themeId], hadToast: true, fail: { (error) in
                SVProgressHUD.dismiss()
            }, success: { (dic) in
                
                let username:String = sharePublicDataSingle.publicData.userid + sharePublicDataSingle.publicData.corpid
                var time:String? = UserDefaults.standard.object(forKey: username) as! String?
                
                if time == nil{
                    time = "0"
                }
                UserRequest.initData(params: ["app_token":sharePublicDataSingle.token,"updatetime":time!], hadToast: true, fail: { [weak self](fail) in
                    if let strongSelf = self {
                        SVProgressHUD.dismiss()
                        strongSelf.didJoin((strongSelf.model.content as! ThemeMessageContent).themeId)
                        
                    }
                }, success: {[weak self] (dic) in
                    if let strongSelf = self {
                        SVProgressHUD.dismiss()
                        strongSelf.didJoin((strongSelf.model.content as! ThemeMessageContent).themeId)
                        
                    }
                    }
                )
                
            })
        }else{
            didJoin((model.content as! ThemeMessageContent).themeId)
        }
        
    }
    
    @objc func longPressed(sender:UILongPressGestureRecognizer) -> () {
        if sender.state == .ended {
            return
        }else if sender.state == .began {
            self.delegate.didLongTouchMessageCell!(self.model, in: self)
        }
    }
    @objc func singleTap(sender:UITapGestureRecognizer) -> () {
        self.delegate.didTapMessageCell!(self.model)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
// MARK: - 图片浏览器代理
extension ThemeMessageCell:SDPhotoBrowserDelegate{
    
    func photoBrowser(_ browser: SDPhotoBrowser!, placeholderImageFor index: Int) -> UIImage! {
        
        let imageView:UIImageView = imageListView.subviews[index] as! UIImageView
        return imageView.image
        
    }
    
    func photoBrowser(_ browser: SDPhotoBrowser!, highQualityImageURLFor index: Int) -> URL! {
        
        let cont = model.content as! ThemeMessageContent
        let predicate = NSPredicate(format:"groupid == %@  AND is_delete == '0'",cont.themeId)
        let r = ThemeInfoModel.objects(with: predicate)
        guard r.count>0 else {
            return NSURL.init(string: "")! as URL
        }
        let infoModel:ThemeInfoModel = r.firstObject() as! ThemeInfoModel
        let anyArray = BaseRequest.makeJsonWithString(jsonStr: infoModel.imageArray)
        if let array:Array = anyArray as! Array<Any> {
            let dic:Dictionary = array[index] as! Dictionary<String,String>
            let str = dic["url"]
            return NSURL.init(string: str!)! as URL
        }
        return NSURL.init(string: "")! as URL
    }
    
}
//
//  MoreSelectBottomView.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/6/28.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class MoreSelectBottomView: UIView {
    var btnClickBlock : ((_ btn: UIButton) -> ())?
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.backgroundColor = UIColor.groupTableViewBackground
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    func creatBtnsWithImageNames(ImageNamesArr:Array<String>){
        
        let btnWidth : CGFloat = self.frame.size.width / CGFloat(ImageNamesArr.count);
        
        for i in 0..<ImageNamesArr.count {
            let btn = UIButton()
            btn.tag = i + 10
            btn.addTarget(self, action: #selector(btnClick(btn:)), for: .touchUpInside)
            btn.setImage(UIImage.init(named: ImageNamesArr[i]), for: .normal)
            btn.frame = CGRect.init(x: CGFloat(i) * btnWidth, y: 0, width: btnWidth, height: self.frame.size.height - BottomLine_Height)
            self.addSubview(btn)
            
        }
    }
    func creatBtnsWithTitleNames(TitleNamesArr:Array<String>){
        
        let btnWidth : CGFloat = self.frame.size.width / CGFloat(TitleNamesArr.count);
        
        for i in 0..<TitleNamesArr.count {
            let btn = UIButton()
            btn.tag = i + 10
            btn.addTarget(self, action: #selector(btnClick(btn:)), for: .touchUpInside)
            btn.setTitle(TitleNamesArr[i], for: .normal)
            btn.setTitleColor(UIColor.black, for: .normal)
            btn.frame = CGRect.init(x: CGFloat(i) * btnWidth, y: 0, width: btnWidth, height: self.frame.size.height - BottomLine_Height)
            self.addSubview(btn)
            
        }
    }
}
extension MoreSelectBottomView {
    @objc func btnClick(btn:UIButton){
        if (self.btnClickBlock != nil) {
            self.btnClickBlock!(btn)
        }
    }
}
//
//  HYPrivateListHeaderView.swift
//  SLAPP
//
//  Created by apple on 2018/11/28.
//  Copyright © 2018 柴进. All rights reserved.
//
import UIKit
class HYPrivateListHeaderView: UIView {
//    let search = RCDSearchBar.init(frame: CGRect(x: 0, y: 0, width: SCREEN_WIDTH, height: 44))
//    存放cell 的数组
    var subCellArray:Array<GroupListCell> = Array()
//    cell 点击后的闭包响应
    var cellClickWithTargetId:(_ id:String,_ name:String)->() = { (id,name) in
    }
    override init(frame: CGRect) {
        super.init(frame: frame);
        self.backgroundColor = UIColor.groupTableViewBackground
        self.configUI();
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    func fillSubViews(datas:Array<Dictionary<String,String>>){
        func makeCell() -> GroupListCell{
            let cell = GroupListCell.init(style: .default, reuseIdentifier: "cell")
            cell.backgroundColor = UIColor.white
            cell.badgeLb.isHidden = true
            //cell.frame = CGRect.init(x: 0, y: 44+65*i, width: Int(kScreenW), height: 65);
            cell.addSubview(makeCellLine())
            cell.addSubview(makeCellBtn())
            return cell
        }
        func makeCellLine() -> UIView{
            let line = UIView.init(frame: CGRect(x: 15, y: 65-0.3, width: kScreenW-15, height: 0.3))
            line.backgroundColor = UIColor.groupTableViewBackground
            return line
        }
        func makeCellBtn() -> UIButton{
            let btn = UIButton.init(type: .custom)
            btn.frame = CGRect(x: 0, y: 0, width: kScreenW, height: 65)
            btn.addTarget(self, action: #selector(btnClick(btn: )), for: .touchUpInside)
            return btn
        }
    }
    func configUI(){
//        self.addSubview(search)
//        let targetIdArray = ["systemMessage"]
        let imageArray = ["commenticon"]
        let titleArray = ["系统消息"]
        for i in 0..<titleArray.count {
            let cell = GroupListCell.init(style: .default, reuseIdentifier: "cell")
            cell.backgroundColor = UIColor.white
            cell.frame = CGRect.init(x: 0, y: 65*i, width: Int(kScreenW), height: 65);
            cell.headerImageView.image = UIImage.init(named: imageArray[i])
            cell.nameLabel.text = titleArray[i]
            cell.detailLabel.text = "暂时没有新消息"
            let line = UIView.init(frame: CGRect(x: 15, y: 65-0.3, width: kScreenW-15, height: 0.3))
            cell.addSubview(line)
            line.backgroundColor = UIColor.groupTableViewBackground
            self.addSubview(cell)
//            cell.customTargetId = targetIdArray[i]
            subCellArray.append(cell)
            cell.badgeLb.isHidden = true
            let btn = UIButton.init(type: .custom)
            btn.frame = CGRect(x: 0, y: 0, width: kScreenW, height: 65)
            cell.addSubview(btn)
            btn.addTarget(self, action: #selector(btnClick(btn: )), for: .touchUpInside)
        }
    }
    @objc func btnClick(btn:UIButton){
        if btn.superview!.isKind(of: GroupListCell.self) {
            let cell:GroupListCell = btn.superview as! GroupListCell
            self.cellClickWithTargetId("group_system",cell.nameLabel.text!)
        }
    }
          func refresh(){
        for cell in subCellArray {
            DispatchQueue.global(qos: .default).async
         {
//               查询该回话类型对应的最新的一条消息
                
                let subArray = RCIMClient.shared().getLatestMessages(RCConversationType.ConversationType_SYSTEM, targetId: "group_system", count: 1)
                if !(subArray?.isEmpty)!
                {
                    let model:RCMessage = subArray!.first! as! RCMessage;
                    if model.content .isKind(of: RCTextMessage.self)
                    {
                        DispatchQueue.main.async {
                            cell.detailLabel.text = (model.content as! RCTextMessage).content
                        }
                    }
                    DispatchQueue.global(qos: .default).async{
//                        查询未读数
                        if(RCIMClient.shared().getUnreadCount(RCConversationType.ConversationType_SYSTEM, targetId: "group_system") == 0){
                            DispatchQueue.main.async {
                                cell.badgeLb.isHidden = true
                            }
                        }else{
                            DispatchQueue.main.async {
                                cell.badgeLb.isHidden = false
                            }
                        }
                    }
                 }
         }
    }
 }
}
//
//  HistoryMessageCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/6/30.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
let textLineSpace :CGFloat = 6
class HistoryMessageCell: RCMessageCell {
    var titleLable = UILabel.init()
    var contentLable = UILabel.init()
    var bottomLable = UILabel.init()
    var backView = UIView.init()
    override class func size(for model: RCMessageModel!, withCollectionViewWidth: CGFloat, referenceExtraHeight: CGFloat) -> CGSize {
        super.size(for: model, withCollectionViewWidth: withCollectionViewWidth, referenceExtraHeight: referenceExtraHeight)
        if kScreenW <= 320 {
            myWidth = 200
        }
        let bubbleBackgroundViewSize:CGSize = ThemeMessageCell.getBubbleSize(textLabelSize: CGSize.init(width: myWidth, height: 180))
        let cont = model.content as! HistoryMessageContent
        
        var allHeight : CGFloat = 10 + cont.title.getTextHeight(font: UIFont.systemFont(ofSize: 15), width: bubbleBackgroundViewSize.width - 20) + 10  + 35
        if cont.content.count > 0 {
            allHeight += (cont.content.getSpaceLabelHeight(font: UIFont.systemFont(ofSize: 14), width: bubbleBackgroundViewSize.width - 20) + 10)
        }
//        if model.isDisplayMessageTime == true{
//            allHeight += 60
//        }
        return CGSize.init(width: withCollectionViewWidth, height: allHeight + referenceExtraHeight)
    }
    class func conFigSize(model:RCMessageModel)->(CGSize){
        
        if kScreenW <= 320 {
            myWidth = 200
        }
        let bubbleBackgroundViewSize:CGSize = ThemeMessageCell.getBubbleSize(textLabelSize: CGSize.init(width: myWidth, height: 180))
        let cont = model.content as! HistoryMessageContent
        
        var allHeight : CGFloat = 10 + cont.title.getTextHeight(font: UIFont.systemFont(ofSize: 15), width: bubbleBackgroundViewSize.width - 20) + 10  + 35
        if cont.content.count > 0 {
            allHeight += (cont.content.getSpaceLabelHeight(font: UIFont.systemFont(ofSize: 14), width: bubbleBackgroundViewSize.width - 20) + 10)
        }
        if model.isDisplayMessageTime == true{
            allHeight += 60
        }
        return CGSize.init(width: kScreenW, height: allHeight)
    }
    override func setDataModel(_ model: RCMessageModel!) {
        let cont = model.content as! HistoryMessageContent
        print("hao_____\(cont)")
        super.setDataModel(model)
//        self.contentLable.text = cont.content
        self.contentLable.changeLineSpace(text: cont.content, space: textLineSpace)
        self.titleLable.text = cont.title
        let bubbleBackgroundViewSize:CGSize = ThemeMessageCell.getBubbleSize(textLabelSize: CGSize.init(width: myWidth, height: 180))
        let messageContentViewRect:CGRect = self.messageContentView.frame
        if .MessageDirection_RECEIVE == self.messageDirection {
            self.messageContentView.frame = CGRect(x: messageContentViewRect.origin.x, y: messageContentViewRect.origin.y, width: bubbleBackgroundViewSize.width, height: messageContentViewRect.size.height)
        }
        else{
            self.messageContentView.frame = CGRect(x: messageContentViewRect.origin.x-(bubbleBackgroundViewSize.width-messageContentViewRect.width), y: messageContentViewRect.origin.y, width: bubbleBackgroundViewSize.width, height: messageContentViewRect.size.height)
            
        }
        if kScreenW <= 320 {
            myWidth = 200
        }
        
        var allHeight : CGFloat = 10 + cont.title.getTextHeight(font: UIFont.systemFont(ofSize: 15), width: bubbleBackgroundViewSize.width - 20) + 10  + 35
        if cont.content.count > 0 {
            allHeight += (cont.content.getSpaceLabelHeight(font: UIFont.systemFont(ofSize: 14), width: bubbleBackgroundViewSize.width - 20) + 10)
        }
        
        self.titleLable.frame = CGRect.init(x: 10, y: 10, width: self.messageContentView.frame.width - 20, height: cont.title.getTextHeight(font: UIFont.systemFont(ofSize: 15), width: bubbleBackgroundViewSize.width - 20))
        //文字
        self.contentLable.frame = CGRect.init(x: 10, y: 10 + self.titleLable.frame.size.height + 10, width: self.messageContentView.frame.width - 20, height: cont.content.getSpaceLabelHeight(font: UIFont.systemFont(ofSize: 14), width: bubbleBackgroundViewSize.width - 20))
        
        self.bottomLable.frame = CGRect.init(x: 10, y: allHeight - 35, width: self.messageContentView.frame.size.width - 20, height: 35)
        
        self.backView.frame = CGRect.init(x: 0, y: 0, width: self.messageContentView.frame.size.width, height: allHeight)
    }
    
    override init!(frame: CGRect) {
        print(frame)
        super.init(frame: frame)
        self.messageContentView.backgroundColor = UIColor.clear
        self.backView.backgroundColor = UIColor.white
        self.backView.layer.cornerRadius = 5
        self.backView.layer.masksToBounds = true
        self.messageContentView.addSubview(self.backView)
        
        self.backView.addSubview(self.titleLable)
        self.titleLable.textColor = UIColor.black
        self.backView.addSubview(self.contentLable)
        self.contentLable.textColor = UIColor.gray
        
        let longPre = UILongPressGestureRecognizer.init(target: self, action: #selector(longPressed(sender:)))
        self.backView.addGestureRecognizer(longPre)
        let sortPre = UITapGestureRecognizer.init(target: self, action: #selector(singleTap(sender:)))
        self.backView.addGestureRecognizer(sortPre)
        
        self.titleLable.font = UIFont.systemFont(ofSize: 15)
        
        self.contentLable.font = UIFont.systemFont(ofSize: 14)
        
        self.titleLable.numberOfLines = 0
        self.contentLable.numberOfLines = 0
        
        let seperateLine = UIView.init()
        seperateLine.backgroundColor = UIColor.gray
        self.bottomLable.addSubview(seperateLine)
        seperateLine.mas_makeConstraints { (make) in
            make!.left.top().right().equalTo()(0)
            make!.height.equalTo()(0.5)
        }
        let rightArrow = UIImageView.init(image: UIImage.init(named: "theme_rightArrow"))
        self.bottomLable.addSubview(rightArrow)
        rightArrow.mas_makeConstraints { [unowned self](make) in
            make!.centerY.equalTo()(self.bottomLable)
            make!.right.equalTo()(-5)
            make!.size.equalTo()(CGSize.init(width: 16, height: 16))
        }
        self.bottomLable.font = UIFont.systemFont(ofSize: 12)
        self.bottomLable.textColor = UIColor.gray
        self.bottomLable.text = "聊天记录"
        self.backView.addSubview(self.bottomLable)
        
        //            self.messageContentView.registerFrameChangedEvent({ (conFrame) in
        //                //头像
        //                self.titleLable.frame = CGRect.init(x: 10, y: 10, width: conFrame.width - 20, height: 35)
        ////                self.titleLable.backgroundColor = UIColor.hexString(hexString: "1782D2")
        //                self.titleLable.sizeToFit()
        //                //文字
        //                self.contentLable.frame = CGRect.init(x: 10, y: 30, width: conFrame.size.width - 20, height: conFrame.size.height - 35)
        //                self.contentLable.sizeToFit()
        //            })
    }
    
    @objc func longPressed(sender:UILongPressGestureRecognizer) -> () {
        if sender.state == .ended {
            return
        }else if sender.state == .began {
            self.delegate.didLongTouchMessageCell!(self.model, in: self)
        }
    }
    @objc func singleTap(sender:UITapGestureRecognizer) -> () {
        self.delegate.didTapMessageCell!(self.model)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
//
//  ProjectReportMessageContentCell.swift
//  SLAPP
//
//  Created by apple on 2018/4/27.
//  Copyright © 2018年 柴进. All rights reserved.
//
import UIKit
class ProjectReportMessageContentCell: RCMessageCell {
    var topArray:Array<UILabel> = Array()
     var bottomArray:Array<UILabel> = Array()
    lazy var backView = { () -> UIView in
        let view = UIView()
        return view
    }()
    
    var clickWithUrl:(_ url:String)->() = {_ in 
    
    }
    
    
    lazy var nameLable = { () -> UILabel in
        let lable = UILabel()
        lable.font = UIFont.systemFont(ofSize: 14)
        //        lable.textAlignment = .center
        //        lable.textColor =
        return lable
    }()
    
    
    override class func size(for model: RCMessageModel!, withCollectionViewWidth: CGFloat, referenceExtraHeight: CGFloat) -> CGSize {
        
        if model.isDisplayMessageTime == true{
           return super.size(for: model, withCollectionViewWidth: withCollectionViewWidth, referenceExtraHeight: 280)
        }else{
            
            return super.size(for: model, withCollectionViewWidth: withCollectionViewWidth, referenceExtraHeight: 280)
        }
        
        
    }
    
    override init!(frame: CGRect) {
        super.init(frame: frame)
        
         self.contentView.addSubview(backView)
        backView.frame = CGRect(x: 70, y: 60, width: frame.size.width-140, height: 200)
        
         backView.backgroundColor = UIColor.white
         backView.addSubview(nameLable)
         nameLable.frame = CGRect(x: 5, y: 5, width: backView.width, height: 30)
         nameLable.text = "项目分析报告"
        let width = (backView.width - 4*10)/3
        let height = backView.height - 90
        let array = ["项目得分","赢单指数","风险项"]
        
        for i in 0...2 {
            
            let cardView = UIView.init(frame: CGRect(x:width * CGFloat(i)  + 10 * CGFloat(i)+10, y: nameLable.max_Y+10, width: width, height: height))
            backView.addSubview(cardView)
            cardView.backgroundColor = UIColor.red
            let labletop = UILabel.init(frame: CGRect(x:0, y: 5, width: width, height: 20))
            labletop.textAlignment = .center
            labletop.font = UIFont.systemFont(ofSize: 14)
            let lablebottom = UILabel.init(frame: CGRect(x:  0, y: 25, width: width, height: height-25))
            lablebottom.textAlignment = .center
            lablebottom.font = UIFont.systemFont(ofSize: 17)
            labletop.text = array[i]
            cardView.addSubview(labletop)
            cardView.addSubview(lablebottom)
            if i != 2 {
                labletop.textColor = UIColor.darkGray
                cardView.backgroundColor = kGreenColor
                lablebottom.textColor = UIColor.white
            }else{
                  lablebottom.textColor = UIColor.red
                 labletop.textColor = UIColor.lightGray
                cardView.backgroundColor = UIColor.white
                cardView.layer.borderColor = UIColor.red.cgColor
                cardView.layer.borderWidth = 0.5
            }
            topArray.append(lablebottom)
        }
        
        let btn = UIButton.init(type: .custom)
        btn.backgroundColor = UIColor.blue
        btn.setTitle("查看报告", for: .normal)
        btn.frame = CGRect(x: (backView.width-100)/2.0, y: backView.height-40, width: 100, height: 30)
        backView.addSubview(btn)
        btn.addTarget(self, action: #selector(btnClick), for: .touchUpInside)
    }
    
    @objc func btnClick(){
        let content:ProjectReportMessageContent = model.content as! ProjectReportMessageContent
        self.clickWithUrl(content.url)
    }
     
    override func setDataModel(_ model: RCMessageModel!) {
        super.setDataModel(model)
        let content:ProjectReportMessageContent = model.content as! ProjectReportMessageContent
        
        for i in 0...self.topArray.count-1 {
            let lab = self.topArray[i]
            if i == 0 {
                lab.text = content.projectScore
            }else if i == 1 {
                lab.text = content.projectWinIndex
            }else{
                lab.text = content.projectRisk
            }
        }
         if model.isDisplayMessageTime == true{
            backView.frame = CGRect(x: 70, y: 80, width: frame.size.width-140, height: 200)
         }else{
            backView.frame = CGRect(x: 70, y: 30, width: frame.size.width-140, height: 200)
            
        }
        
    }
    
    
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
//
//  ThemeRetweetView.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/6/26.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
// 代理
protocol ThemeRetweetViewDelegate {
    // 点击菜单
    func selectButtonDidClick(btn:UIButton)
}
class ThemeRetweetView: UIView {
    var delegate: ThemeRetweetViewDelegate?
    var selectedBtn : UIButton?
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.backgroundColor = UIColor.white
        self.addSubview(iconButton)
//        self.addSubview(nameLabel)
        
        iconButton.mas_makeConstraints { (make) in
            make!.left.equalTo()(LEFT_PADDING)
//            make!.size.equalTo()(CGSize(width: 35, height: 35))
            make!.top.bottom().equalTo()(0)
            make!.right.equalTo()(-LEFT_PADDING)
        }
//        nameLabel.mas_makeConstraints { [unowned self](make) in
//            make!.left.equalTo()(self.iconButton.mas_right)!.offset()(5)
//            make!.centerY.equalTo()(self)
//            make!.right.equalTo()(-LEFT_PADDING)
//        }
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    //选择状态icon
    lazy var iconButton: UIButton = {
        var iconButton = UIButton.init()
        iconButton.contentHorizontalAlignment = .left
        iconButton.titleEdgeInsets = UIEdgeInsets(top: 0, left: 10, bottom: 0, right: 0)
//        iconButton.imageEdgeInsets = UIEdgeInsetsMake(0, -30, 0, 30)
        iconButton.addTarget(self, action: #selector(selectButtonClick(btn:)), for: .touchUpInside)
        iconButton.setImage(UIImage.init(named: "logic_normal"), for: .normal)
        iconButton.setImage(UIImage.init(named: "logic_select"), for: .selected)
        iconButton.setTitleColor(UIColor.black, for: .normal)
        iconButton.titleLabel?.font = FONT_14
        return iconButton
    }()
    //名称
    lazy var nameLabel: UILabel = {
        var nameLabel = UILabel()
        nameLabel.font = FONT_14
        nameLabel.textColor = UIColor.black
        return nameLabel
    }()
}
extension ThemeRetweetView {
    
    @objc func selectButtonClick(btn:UIButton){
        delegate?.selectButtonDidClick(btn: btn)
    }
}
//
//  CardView.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/6/8.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
let BottomLine_Height : CGFloat = 2.0
class CardView: UIView {
    var bottomLine : UIView!
    var selectedBtn : UIButton?
    var btnClickBlock : ((_ btn: UIButton) -> ())?
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.backgroundColor = UIColor.groupTableViewBackground
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    func creatBtnsWithTitles(titlesArr:Array<String>){
    
        let btnWidth : CGFloat = self.frame.size.width / CGFloat(titlesArr.count);
        for i in 0..<titlesArr.count {
            let btn = UIButton()
            btn.tag = i + 10
            btn.addTarget(self, action: #selector(btnClick(btn:)), for: .touchUpInside)
            btn.titleLabel?.font = FONT_14
            btn.setTitle(titlesArr[i], for: .normal)
            btn.setTitleColor(UIColor.darkGray, for: .normal)
            btn.frame = CGRect.init(x: CGFloat(i) * btnWidth, y: 0, width: btnWidth, height: self.frame.size.height - BottomLine_Height)
            self.addSubview(btn)
            
        }
        bottomLine = UIView()
        bottomLine.backgroundColor = UIColor.hexString(hexString: "1782D2")
        bottomLine.frame = CGRect.init(x: 30, y: self.frame.size.height - BottomLine_Height, width: btnWidth - 2*30, height: BottomLine_Height)
        self.addSubview(bottomLine)
        
        self .btnClick(btn: self.viewWithTag(10) as! UIButton)
    }
    
}
extension CardView {
    @objc func btnClick(btn:UIButton){
    
        if (selectedBtn == btn) {
            return;
        }
        selectedBtn?.setTitleColor(UIColor.darkGray, for: .normal)
        let btn = self.viewWithTag(btn.tag) as? UIButton
        btn?.setTitleColor(UIColor.hexString(hexString: "1782D2"), for: .normal)
        selectedBtn = btn;
        UIView.animate(withDuration: 0.3) {
            var frame : CGRect = self.bottomLine.frame
            frame.origin.x = (btn?.frame.origin.x)! + 30
            self.bottomLine.frame = frame
        }
        
        if (self.btnClickBlock != nil) {
            self.btnClickBlock!(btn!)
        }
    }
}
//
//  ThemeListCellBottomView.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/6/7.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
private let separateLineViewWidth : CGFloat = 0.5
// 代理
protocol ThemeListCellBottomViewDelegate {
    // 点击菜单
    func menuBtnDidClick(btn:UIButton)
}
class ThemeListCellBottomView: UIView {
    var delegate: ThemeListCellBottomViewDelegate?
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.backgroundColor = UIColor.white
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    func creatBtnsWithTitleImage(btnTitleImages:Array<Array<String>>){
        for i in 0..<btnTitleImages.count {
            let btn = UIButton.init()
            btn.addTarget(self, action: #selector(btnClick(btn:)), for: .touchUpInside)
            btn.setTitleColor(UIColor.lightGray, for: .normal)
            btn.setTitleColor(UIColor.darkGray, for: .highlighted)
            btn.titleLabel?.font = FONT_12
            btn.setTitle(btnTitleImages[i][0], for: .normal)
            btn.setImage(UIImage.init(named: btnTitleImages[i][1]), for: .normal)
            self.addSubview(btn)
            btn.mas_makeConstraints { [unowned self](make) in
                make!.top.equalTo()(self)
                make!.left.equalTo()((SCREEN_WIDTH - CGFloat(btnTitleImages.count - 1) * separateLineViewWidth) / CGFloat(btnTitleImages.count) * CGFloat(i) + CGFloat(i) * separateLineViewWidth)
                make!.height.equalTo()(self)
                make!.width.equalTo()((SCREEN_WIDTH - CGFloat(btnTitleImages.count - 1) * separateLineViewWidth) / CGFloat(btnTitleImages.count))
            }
            if i < btnTitleImages.count - 1 {
                let separateLineView = UIView.init()
                separateLineView.backgroundColor = UIColor.lightGray
                self.addSubview(separateLineView)
                separateLineView.mas_makeConstraints { (make) in
                    make!.left.equalTo()(btn.mas_right)
                    make!.top.equalTo()(8)
                    make!.bottom.equalTo()(-8)
                    make!.width.equalTo()(separateLineViewWidth)
                }
            }
        }
    }
}
extension ThemeListCellBottomView {
    @objc func btnClick(btn:UIButton){
    
        delegate?.menuBtnDidClick(btn: btn)
    }
}
//
//  ThemeInfoView.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/6/27.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
import Foundation
let space:CGFloat = 20.0
let defaultHeight:CGFloat = 40
class ThemeInfoView: UIView {
    
    var themeLable:UILabel?
    var imagesView:UIView?
    var isOpen:Bool?
    var btn : UIButton?
    var backScroll:UIScrollView?
    
    var openUrl:(_ url:String)->() = {_ in 
        
    }
    //展开的回调
    var openBtnClick:()->() = {
        
    }
    
    
    
    var themeName:String?
    var imageArray:Array<Dictionary<String, String>>?
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        backScroll = UIScrollView.init(frame: CGRect(x: 0, y: 0, width: kScreenW, height: frame.size.height))
        backScroll?.backgroundColor = UIColor.black.withAlphaComponent(0.7)
        self.backgroundColor = UIColor.black.withAlphaComponent(0.1)
        addSubview(backScroll!)
        isOpen = false;
       
        let ges = UITapGestureRecognizer.init(target: self, action: #selector(mytapped(_:)))
        ges.numberOfTapsRequired = 1
        self.addGestureRecognizer(ges)
        
    }
    
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    
    /// 创建显示lable  等初始化拿到要显示的数据后在调用
    func configUI(){
        themeLable = UILabel.init(frame: CGRect(x: space, y: 5, width: kScreenW-2*space-20, height: 30))
        themeLable?.numberOfLines = 1;
        themeLable?.textAlignment = .left
        themeLable?.textColor = UIColor.white
        themeLable?.font = UIFont.systemFont(ofSize: 15)
        themeLable?.lineBreakMode = .byCharWrapping
        themeLable?.text = String.init(format: "[话题]%@", themeName!)
        
        themeLable?.enabledTapEffect = true
//
        self.backScroll?.addSubview(themeLable!)
        
        if  self.configHeight(text: themeName!) > 40 ||  (self.imageArray?.count)!>0  {
            btn = UIButton.init(type: .custom)
            
            btn?.frame = CGRect(x: kScreenW-35, y:5, width: 30, height: 30)
            btn?.setImage(UIImage.init(named: "down"), for: .normal)
            btn?.addTarget(self, action: #selector(btnClick), for: .touchUpInside)
            self.backScroll?.addSubview(btn!)
        }
        
       
        
    }
    
    
    
    /// 收缩按钮点击响应
    @objc func btnClick(){
        
        isOpen = !isOpen!
        if isOpen == true {
            self.openBtnClick()
            self.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT)
            
            themeLable?.frame =  CGRect(x: space, y: 5, width: kScreenW-2*space, height: self.getTextHeigh(textStr: (themeLable?.text)!
                ))
            themeLable?.numberOfLines = 0
            themeLable?.enabledTapEffect = true
            
//            let rex = "^(?=^.{3,255}$)(http(s)?://)?(www.)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+(:d+)*(/w+.w+)*([?&]w+=w*)*$"
            let rex = "((http[s]{0,1}|ftp)://[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]{2,4})(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&*+?:_/=<>]*)?)|(www.[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]{2,4})(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&*+?:_/=<>]*)?)"
            
            let reguE = try? NSRegularExpression.init(pattern: rex, options: .caseInsensitive)
            print(reguE)
            print(themeLable?.text)
            let stringChecks = reguE?.matches(in: (themeLable?.text)!, options: NSRegularExpression.MatchingOptions(rawValue: 0), range: NSMakeRange(0, (themeLable?.text as! NSString).length))
            var strings = Array<String>()
            
            for textChe in stringChecks! {
                strings.append((themeLable?.text?.substring(with: (themeLable?.text?.changeToRange(from: textChe.range))!))!)
            }
//            themeLable?.yb_addAttributeTapAction(strings, tapAction: { (str, ran, intValue) in
//                print(str)
////                let webView = UIWebView.init(frame: self.frame)
////                let wbc = BaseViewController.init()
//////                wbc.title = (model.content as! HistoryMessageContent).title
////                wbc.view = webView
////                webView.loadRequest(URLRequest.init(url: URL.init(string: str)!))
//                self.openUrl(str)
////                self.navigationController?.pushViewController(wbc, animated: true)
//            })
            
            btn?.setImage(UIImage.init(named: "up"), for: .normal)
            if imagesView == nil {
                self.addImages()
            }
            else{
               imagesView?.isHidden = false
            }
        }
        else{
            
            self.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: defaultHeight)
            if imagesView != nil {
                imagesView?.isHidden = true
            }
            themeLable?.frame = CGRect(x: space, y: 5, width: kScreenW-2*space-20, height: 30)
            btn?.setImage(UIImage.init(named: "down"), for: .normal)
            themeLable?.numberOfLines = 1;
//            isTapEffect = false
        }
        let size: CGRect = self.getSize(isScroll: false)
        self.frame = CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: size.height)
        self.backScroll?.frame = CGRect.init(x: 0, y: 0, width: kScreenW, height:size.size.height);
        if self.frame.size.height >= MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT {
            self.backScroll?.contentSize = CGSize(width: 0, height: self.getSize(isScroll: true).height)
            btn?.frame = CGRect(x: kScreenW-35, y:(self.backScroll?.contentSize.height)!-30, width: 30, height: 30)
        }
        else{
           self.backScroll?.contentSize = CGSize(width: 0, height: 0)
            
            if isOpen == true{
                btn?.frame = CGRect(x: kScreenW-35, y:self.frame.size.height-30, width: 30, height: 30)
            }else{
                btn?.frame = CGRect(x: kScreenW-35, y:5, width: 30, height: 30)
            }
        }
    }
    
    
    
    /// 返回当前应该显示的size
    ///
    /// - Parameter isScroll: 是否计算的是Scroll
    /// - Returns: 返回对应的size
    func getSize(isScroll:Bool)->(CGRect){
    
        if isOpen! == true {
            
            var textHeight = self.getTextHeigh(textStr: (themeLable?.text)!)
            if textHeight < 40 {
                textHeight = 40
            }
            let imageHeight = self.getImageHeight()
            
            
            if isScroll == true {
                var height = textHeight+imageHeight
                if height < defaultHeight {
                    height = defaultHeight
                }
                return CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: height);
            }
            else{
                
                var height = (textHeight+imageHeight > MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT) ?MAIN_SCREEN_HEIGHT_PX-NAV_HEIGHT:textHeight+imageHeight
                if height < defaultHeight {
                    height = defaultHeight
                }
                return CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height: height);
                
            }
        }
        else{
            return CGRect.init(x: 0, y: NAV_HEIGHT, width: kScreenW, height:40);
        }
        
    }
    
    
    
        func configHeight(text:String)->CGFloat {
    
        if text.isEmpty {
            return 40
        }
        let font = UIFont.systemFont(ofSize: 15)
            let attributes = [NSAttributedString.Key.font: font]
        
        var size = CGRect()
        
        let labelSize = CGSize.init(width: kScreenW-2*space-10, height: CGFloat(MAXFLOAT))
        
        
        size = text.boundingRect(with: labelSize, options: NSStringDrawingOptions.usesLineFragmentOrigin, attributes:attributes, context: nil);
        print( size.height)
        return (size.height < 20.0) ? 40 : 70
        
    }
    
    
    /// 计算文本高度
    ///
    /// - Parameter textStr: 要计算的文本
    /// - Returns: 返回高度
    func getTextHeigh(textStr:String) -> CGFloat {
        
        let font = UIFont.systemFont(ofSize: 15)
        let attributes = [NSAttributedString.Key.font: font]
        
        var size = CGRect()
    
        var spaceOpen:CGFloat = 0;
        if isOpen == false{
           spaceOpen = -10
        }
        let labelSize = CGSize.init(width: kScreenW-2*space+spaceOpen , height: CGFloat(MAXFLOAT))
    
       
        size = textStr.boundingRect(with: labelSize, options: NSStringDrawingOptions.usesLineFragmentOrigin, attributes:attributes, context: nil);
        
        return (size.height<20) ?  40 : size.height
    }
    
    
    
    /// 计算图片显示区域的高度
    ///
    /// - Returns: 返回高度
    func getImageHeight()->(CGFloat){
    
        if imageArray?.count == 0 {
            return 30
        }
        if imageArray?.count != 0 {
            let imageWidth:CGFloat = (kScreenW-4*space)/3
            return (space + imageWidth) * CGFloat((((imageArray?.count)!)-1)/3+1) + space + 50
            
        }
        
        return 0
    }
    
    
    
    
    /// 添加图片显示区域
    func addImages(){
        
        if imageArray?.count == 0 {
            return
        }
        imagesView = UIView.init(frame: CGRect(x: 0, y:self.getTextHeigh(textStr: (themeLable?.text)!), width: kScreenW, height:self.getImageHeight()-30))
        self.backScroll?.addSubview(imagesView!)
        let imageWidth:CGFloat = (kScreenW-4*space)/3
        
        
        for i in 0...(imageArray?.count)!-1{
         
            let image = UIImageView.init(frame: CGRect(x: space+CGFloat(i%3) * imageWidth+CGFloat(i%3)*space, y:space + CGFloat(i/3) * imageWidth+CGFloat(i/3) * space, width: imageWidth, height: imageWidth))
            image.contentMode = .scaleAspectFill
            image.clipsToBounds = true
            imagesView?.addSubview(image)
            let dic = imageArray?[i]
            image.sd_setImage(with: NSURL.init(string:(dic?["thumb_url"])!)! as URL, placeholderImage: UIImage.init(named: "emoji"))
            image.tag = i
            let ges = UITapGestureRecognizer.init(target: self, action: #selector(tapped(_:)))
            ges.numberOfTapsRequired = 1
            image.addGestureRecognizer(ges)
            image.isUserInteractionEnabled = true
        }
    
    }
    
    
    /// 图片点击响应
    ///
    /// - Parameter tap: <#tap description#>
    @objc func tapped(_ tap:UITapGestureRecognizer){
        let image:UIImageView = tap.view as! UIImageView
        
        let photoBrowser = SDPhotoBrowser.init();
        photoBrowser.delegate = self as SDPhotoBrowserDelegate;
        photoBrowser.currentImageIndex = image.tag
        photoBrowser.imageCount = (imageArray?.count)!;
        photoBrowser.sourceImagesContainerView = imagesView;
        
        photoBrowser.show()
    
    }
    
    
    
    /// 遮罩点击响应
    ///
    /// - Parameter tap: <#tap description#>
    @objc func mytapped(_ tap:UITapGestureRecognizer){
//        if self.isOpen == true {
//            self.btnClick()
//        }
        
    }
}
// MARK: - 图片浏览器代理
extension ThemeInfoView:SDPhotoBrowserDelegate{
    
    func photoBrowser(_ browser: SDPhotoBrowser!, placeholderImageFor index: Int) -> UIImage! {
        
        let imageView:UIImageView = imagesView?.subviews[index] as! UIImageView
        return imageView.image
        
    }
    
    func photoBrowser(_ browser: SDPhotoBrowser!, highQualityImageURLFor index: Int) -> URL! {
        
        let dic = imageArray?[index]
        let str = dic?["url"]
        return NSURL.init(string: str!)! as URL
    }
}
//
//  ThemeJoinedListCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/6/7.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ThemeJoinedListCell: ThemeListBaseCell {
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        self.backgroundColor = UIColor.white
        self.contentView.addSubview(bottomView)
        
        bottomView.mas_makeConstraints { [unowned self](make) in
            make!.top.equalTo()(self.bgView.mas_bottom)!.offset()(0.5)
            make!.left.right().equalTo()(self)
            make!.height.equalTo()(40)
        }
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override var model: RCConversationModel!{
        didSet {
            bottomView.backgroundColor = model.isTop ? model.topCellBackgroundColor : model.cellBackgroundColor
            
        }
    }
    override var bottomTitleImgs: Array<Array<String>>?{
        didSet{
            bottomView.creatBtnsWithTitleImage(btnTitleImages: bottomTitleImgs!)
        }
    }
    override class func cell(withTableView tableView: UITableView) -> ThemeJoinedListCell {
                var cell = tableView.dequeueReusableCell(withIdentifier: String(describing: self)) as? ThemeListBaseCell
                if cell == nil {
//                    cell = ThemeListBaseCell(style: .default, reuseIdentifier: String(describing: self))
                    cell = ThemeJoinedListCell.init(style: .default, reuseIdentifier: String(describing: self))
                    cell?.selectionStyle = .none
                }
//        let cell = tableView.dequeueReusableCell(withIdentifier: "ThemeJoinedListCell") as! ThemeJoinedListCell
////        let cell = ThemeJoinedListCell.init(style: .default, reuseIdentifier: String(describing: self))
//        cell.selectionStyle = .none
        
        return cell! as! ThemeJoinedListCell
    }
    //MARK: - Getter and Setter
    //头像
    lazy var bottomView: ThemeListCellBottomView = {
        var bottomView = ThemeListCellBottomView()
        bottomView.backgroundColor = UIColor.white
        bottomView.delegate = self
        return bottomView
    }()
}
extension ThemeJoinedListCell : ThemeListCellBottomViewDelegate{
    func menuBtnDidClick(btn: UIButton) {
        if self.btnClickBlock != nil {
            self.btnClickBlock!(btn)
        }
    }
}
//
//  ThemeListBaseCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/6/7.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
private let headerImageViewWidth : CGFloat = 44.0
private let rightArrowWidth : CGFloat = 16.0
private let lb_rightArrow_margin : CGFloat = 5.0
class ThemeListBaseCell: RCConversationBaseCell {
    var btnClickBlock : ((_ btn: UIButton) -> ())?
    var bottomTitleImgs: Array<Array<String>>? = []
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        self.selectionStyle = .none
        self.contentView.backgroundColor = UIColor.groupTableViewBackground
        self.contentView.addSubview(bgView)
        bgView.addSubview(headerImageView)
        bgView.addSubview(badgeLb)
        bgView.addSubview(nameLabel)
        bgView.addSubview(timeLabel)
        bgView.addSubview(detailLabel)
        bgView.addSubview(rightArrow)
        
        bgView.mas_makeConstraints { [unowned self](make) in
            make!.top.left().right().equalTo()(self)
            make!.height.equalTo()(64)
        }
        headerImageView.mas_makeConstraints { (make) in
            make!.top.left().equalTo()(LEFT_PADDING)
            make!.size.equalTo()(CGSize(width: headerImageViewWidth, height: headerImageViewWidth))
        }
        nameLabel.mas_makeConstraints { [unowned self](make) in
            make!.top.equalTo()(self.headerImageView)
            make!.left.equalTo()(self.headerImageView.mas_right)!.offset()(LEFT_PADDING)
            make!.right.equalTo()(-LEFT_PADDING - rightArrowWidth - lb_rightArrow_margin)
        }
        timeLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(self.headerImageView.mas_right)!.offset()(LEFT_PADDING)
            make!.bottom.equalTo()(self.headerImageView)
        }
        detailLabel.mas_makeConstraints { [unowned self](make) in
            make!.left.equalTo()(self.timeLabel.mas_right)!.offset()(LEFT_PADDING)
            make!.right.equalTo()(-LEFT_PADDING - rightArrowWidth - lb_rightArrow_margin)
            make!.bottom.equalTo()(self.headerImageView)
        }
        rightArrow.mas_makeConstraints { [unowned self](make) in
            make!.centerY.equalTo()(self.headerImageView)
            make!.right.equalTo()(-LEFT_PADDING)
            make!.size.equalTo()(CGSize.init(width: rightArrowWidth, height: rightArrowWidth))
        }
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    override var model: RCConversationModel!{
        didSet {
//            self.backgroundColor = model.isTop ? model.topCellBackgroundColor : model.cellBackgroundColor
//            bgView.backgroundColor = model.isTop ? model.topCellBackgroundColor : model.cellBackgroundColor
            self.headerImageView.sd_setImage(with: NSURL.init(string: model.extend != nil ? model.extend as! String : " ") as URL?, placeholderImage: UIImage.init(named: "mine_avatar"))
            //            self.headerImageView.badgeCenterOffset = CGPoint(x : -2, y : 0)
            
            if model.unreadMessageCount > 0 {
                //                self.headerImageView.showBadge()
                self.badgeLb.isHidden = false
            }else{
                //                self.headerImageView.clearBadge()
                self.badgeLb.isHidden = true
            }
            
            self.nameLabel.text = model.conversationTitle
            
            if model.sentTime == 0 {
                self.timeLabel.text = ""
            }else{
                let target : Date = Date.init(timeIntervalSince1970: TimeInterval(model.sentTime))
                self.timeLabel.text = self.convertDate(date: target)
            }
            self.timeLabel.sizeToFit()
            timeLabel.mas_updateConstraints { [unowned self](make) in
                make!.width.equalTo()(self.timeLabel.frame.size.width)
            }
            let groupModel = GroupModel.objects(with: NSPredicate.init(format: "groupid == %@",model.targetId)).firstObject() as? GroupModel
//            let groupUserModels = GroupUserModel.objects(with: NSPredicate.init(format: "groupid == %@ AND is_delete == '0'",(groupModel?.groupid)!))
//
//            let ownUserModel = GroupUserModel.objects(with: NSPredicate.init(format: "groupid == %@ AND userid == %@ AND is_delete == '0'",(groupModel?.groupid)!,(groupModel?.owner_id)!)).firstObject() as! GroupUserModel?
//            if let own = ownUserModel {
//                self.detailLabel.text = own.realname + " · \(groupModel?.is_delete == "1" ? 1 : groupUserModels.count)人参与"
//            }
            let ownUserModel = GroupUserModel.objects(with: NSPredicate.init(format: "userid == %@",(groupModel?.owner_id)!)).firstObject() as! GroupUserModel?
            let userModel : UserModel? = UserModel.objects(with: NSPredicate.init(format: "userid == %@", ownUserModel?.userid != nil ? (ownUserModel?.userid)! : "")).firstObject() as! UserModel?
            self.detailLabel.text = userModel?.realname != nil ? (userModel?.realname)! : "" + " · " + ((groupModel?.is_delete)! == "1" ? "已解散" : ((groupModel?.user_num)! + "人参与"))
            
        }
    }
    func convertDate(date:Date) -> String {
        if Date.isToday(target: date) {
            let dateFormatter : DateFormatter = DateFormatter()
            dateFormatter.dateFormat = "HH:mm"
            return dateFormatter.string(from: date)
//        }else if Date.isLastDay(target: date) {
//            return "昨天"
//        }else if Date.isOneWeek(target: date) {
//            return Date.weekWithDateString(target: date)
        }else{
            return Date.formattDay(target: date)
        }
    }
    class func cell(withTableView tableView: UITableView) -> ThemeListBaseCell {
            var cell = tableView.dequeueReusableCell(withIdentifier: String(describing: self)) as? ThemeListBaseCell
            if cell == nil {
                cell = ThemeListBaseCell(style: .default, reuseIdentifier: String(describing: self))
                cell?.selectionStyle = .none
            }
//        let cell = tableView.dequeueReusableCell(withIdentifier: "ThemeListBaseCell") as! ThemeListBaseCell
////        let cell = ThemeListBaseCell.init(style: .default, reuseIdentifier: String(describing: self))
//        cell.selectionStyle = .none
        
        return cell!
    }
    
    //MARK: - Getter and Setter
    //背景view
    lazy var bgView: UIView = {
        var bgView = UIView()
        bgView.backgroundColor = UIColor.white
        return bgView
    }()
    //头像
    lazy var headerImageView: StitchingImageView = {
        var headerImageView = StitchingImageView.init(frame: CGRect(x: 0, y: 0, width: headerImageViewWidth, height: headerImageViewWidth))
        headerImageView.contentMode = .scaleAspectFill
        headerImageView.layer.cornerRadius = 4.0
        headerImageView.clipsToBounds = true
        headerImageView.layer.borderColor = UIColor.hexString(hexString: headerBorderColor).cgColor
        headerImageView.layer.borderWidth = 0.5
        return headerImageView
    }()
    //badgeView
    lazy var badgeLb: UILabel = {
        var badgeLb = UILabel.init()
        badgeLb.frame = CGRect.init(x: LEFT_PADDING+headerImageViewWidth - 4, y: LEFT_PADDING - 4, width: 8, height: 8)
        badgeLb.layer.cornerRadius = 4
        badgeLb.layer.masksToBounds = true
        badgeLb.backgroundColor = UIColor.red
        return badgeLb
    }()
    //名称
    lazy var nameLabel: UILabel = {
        var nameLabel = UILabel()
        nameLabel.font = FONT_14
        nameLabel.textColor = UIColor.black
        return nameLabel
    }()
    
    //时间
    lazy var timeLabel: UILabel = {
        var timeLabel = UILabel()
        timeLabel.font = FONT_12
        timeLabel.textColor = UIColor.lightGray
        timeLabel.sizeToFit()
        return timeLabel
    }()
    
    //内容
    lazy var detailLabel: UILabel = {
        var detailLabel = UILabel()
        detailLabel.font = FONT_12
        detailLabel.textColor = UIColor.lightGray
        return detailLabel
    }()
    //右箭头
    lazy var rightArrow: UIImageView = {
        var rightArrow = UIImageView()
        rightArrow.image = UIImage.init(named: "theme_rightArrow")
        return rightArrow
    }()
}
//
//  StitchingImageView.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/1.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
private let margin : CGFloat = 2.0
private var imageViewWidth :CGFloat = 0.0
class StitchingImageView: UIImageView {
    override init(frame: CGRect) {
        super.init(frame: frame)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    func stitchingOnImageView(imageViews:Array<Any>){
        var imageViews = imageViews
        
        if imageViews.count == 1 {
            imageViewWidth = (self.frame.size.width - margin * 3) / 2
        } else if imageViews.count >= 2 && imageViews.count <= 4 {
            imageViewWidth = (self.frame.size.width - margin * 3) / 2
        } else {
            imageViewWidth = (self.frame.size.width - margin * 4) / 3
        }
        
        if imageViews.count == 1
        {
            let imageView_1 : UIImageView = imageViews[0] as! UIImageView
            imageView_1.frame = CGRect(x: (self.frame.size.width - imageViewWidth) / 2, y: (self.frame.size.height - imageViewWidth) / 2, width: imageViewWidth, height: imageViewWidth)
        }
        else if imageViews.count == 2
        {
            let row_1_origin_y : CGFloat = (self.frame.size.height - imageViewWidth) / 2
            imageViews = self.generatorArr(imageViews: imageViews, beginOriginY: row_1_origin_y)
        }
        else if imageViews.count == 3
        {
            let row_1_origin_y : CGFloat = (self.frame.size.height - imageViewWidth * 2) / 3
            
            let imageView_1 : UIImageView = imageViews[0] as! UIImageView
            imageView_1.frame = CGRect(x: (self.frame.size.width - imageViewWidth) / 2, y: row_1_origin_y, width: imageViewWidth, height: imageViewWidth)
            imageViews = self.generatorArr(imageViews: imageViews, beginOriginY: row_1_origin_y + imageViewWidth + margin)
        }
        else if imageViews.count == 4
        {
            let row_1_origin_y : CGFloat = (self.frame.size.height - imageViewWidth * 2) / 3
            imageViews = self.generatorArr(imageViews: imageViews, beginOriginY: row_1_origin_y)
        }
        else if imageViews.count == 5
        {
            let row_1_origin_y = (self.frame.size.height - imageViewWidth * 2 - margin) / 2
            
            let imageView_1 : UIImageView = imageViews[0] as! UIImageView
            imageView_1.frame = CGRect(x: (self.frame.size.width - 2 * imageViewWidth - margin) / 2, y: row_1_origin_y, width: imageViewWidth, height: imageViewWidth)
            
            let imageView_2 : UIImageView = imageViews[1] as! UIImageView
            imageView_2.frame = CGRect(x: imageView_1.frame.origin.x + imageView_1.frame.size.width + margin, y: row_1_origin_y, width: imageViewWidth, height: imageViewWidth)
            
            imageViews = self.generatorArr(imageViews: imageViews, beginOriginY: row_1_origin_y + imageViewWidth + margin)
        }
        else if imageViews.count == 6
        {
            let row_1_origin_y : CGFloat = (self.frame.size.height - imageViewWidth * 2 - margin) / 2
            imageViews = self.generatorArr(imageViews: imageViews, beginOriginY: row_1_origin_y)
        }
        else if imageViews.count == 7
        {
            let row_1_origin_y = (self.frame.size.height - imageViewWidth * 3) / 4
            
            let imageView_1 : UIImageView = imageViews[0] as! UIImageView
            imageView_1.frame = CGRect(x: (self.frame.size.width - imageViewWidth) / 2, y: row_1_origin_y, width: imageViewWidth, height: imageViewWidth)
            imageViews = self.generatorArr(imageViews: imageViews, beginOriginY: row_1_origin_y + imageViewWidth + margin)
        }
        else if imageViews.count == 8
        {
            let row_1_origin_y : CGFloat = (self.frame.size.height - imageViewWidth * 3) / 4
            
            let imageView_1 : UIImageView = imageViews[0] as! UIImageView
            imageView_1.frame = CGRect(x: (self.frame.size.width - 2 * imageViewWidth - margin) / 2, y: row_1_origin_y, width: imageViewWidth, height: imageViewWidth)
            
            let imageView_2 : UIImageView = imageViews[1] as! UIImageView
            imageView_2.frame = CGRect(x: imageView_1.frame.origin.x + imageView_1.frame.size.width + margin, y: row_1_origin_y, width: imageViewWidth, height: imageViewWidth)
            imageViews = self.generatorArr(imageViews: imageViews, beginOriginY: row_1_origin_y + imageViewWidth + margin)
            
        }
        else if imageViews.count == 9
        {
            let row_1_origin_y = (self.frame.size.height - imageViewWidth * 3) / 4
            imageViews = self.generatorArr(imageViews: imageViews, beginOriginY: row_1_origin_y)
        }
        
        for imageView in imageViews {
            self.addSubview(imageView as! UIImageView)
        }
    }
    fileprivate func generatorArr(imageViews:Array<Any> , beginOriginY:CGFloat) -> Array<Any> {
        
        var cellCount : Int
        var maxRow : Int
        var maxColumn : Int
        var ignoreCountOfBegining : Int
        
        if imageViews.count <= 4
        {
            maxRow = 2
            maxColumn = 2
            ignoreCountOfBegining = imageViews.count % 2
            cellCount = 4
        }
        else
        {
            maxRow = 3
            maxColumn = 3
            ignoreCountOfBegining = imageViews.count % 3
            cellCount = 9
        }
        for index in 0..<cellCount {
            if index > imageViews.count - 1 {
                break
            }
            if index < ignoreCountOfBegining {
                continue
            }
            let row = (index - ignoreCountOfBegining) / maxRow
            let column = (index - ignoreCountOfBegining) % maxColumn
            let origin_x = margin + imageViewWidth * CGFloat(column) + margin * CGFloat(column)
            let origin_y = beginOriginY + imageViewWidth * CGFloat(row) + margin * CGFloat(row)
            let imageView : UIImageView = imageViews[index] as! UIImageView
            imageView.frame = CGRect(x: origin_x, y: origin_y, width: imageViewWidth, height: imageViewWidth)
        }
        return imageViews
    }
    
}
//
//  ThemeListCell.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/8.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class ThemeListCell: UITableViewCell {
    override func awakeFromNib() {
        super.awakeFromNib()
        // Initialization code
    }
    override func setSelected(_ selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)
        // Configure the view for the selected state
    }
    
}
//
//  FakeTabView.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/4/24.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
enum fakeType {
    case friend
    case group
    case finding
    case course
    case helpingStatus
    case mine
}
class FakeTabView: UIView {
    
    typealias myBlcok = (_ type:fakeType)->()
    var clickType:myBlcok?
    
    var myRedCount = 0
    
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        //        congigUI(menuList: nil)
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    func congigUI(menuList:Array<String>?){
        //        self.backgroundColor = UIColor.hexString(hexString: "272727")
        
        if self.subviews.count != 0  {
            self.removeAllSubview()
        }
        var newMenuList = Array<String>()
        
        
        if menuList == nil {
            newMenuList = ["group","helpingStatus","find","classes","center"]
        }
        else{
            newMenuList = menuList!
        }
        
        print(newMenuList)
        print(self)
        
        let btnW = kScreenW/CGFloat(newMenuList.count)
        //        let btnW:CGFloat = 100
        //        var titleArray = ["朋友圈","群组","发现","课程","我的"]
        //        var imageArray = ["friend","groups","find","class","my"]
        var titleArray = Array<String>()
        var imageArray = Array<String>()
        for menu in newMenuList {
            switch menu {
            case "friends":
                titleArray.append("朋友圈")
                imageArray.append("friend")
            case "group":
                titleArray.append("群组")
                imageArray.append("groups")
            case "find":
                titleArray.append("发现")
                imageArray.append("find")
            case "classes":
                titleArray.append("课程")
                imageArray.append("class")
            case "center":
                titleArray.append("我的")
                imageArray.append("my")
            case "helpingStatus":
                titleArray.append("辅导")
                imageArray.append("helpingStatus")
            default:
                titleArray.append("我的")
                imageArray.append("my")
            }
        }
        
        print(titleArray)
        
        for i in 0...titleArray.count-1 {
            
            let btn = CustomBtn.init(type: .custom)
            btn.frame = CGRect(x: 0 + CGFloat(i) * btnW , y: 0, width: btnW, height: 56)
            
            btn.setImage(UIImage.init(named: imageArray[i]), for: .normal)
            btn.setImage(UIImage.init(named: imageArray[i]), for: .selected)
            btn.setTitle(titleArray[i], for: .normal)
            btn.setImage(UIImage.init(named: imageArray[i]), for: .selected)
            btn.setTitle(titleArray[i], for: .disabled)
            
            let btnName = btn.title(for: .normal)!
            
            switch btnName {
            case "朋友圈":
                btn.tag = 1000
                break
            case "群组":
                btn.tag = 1001
                break
            case "发现":
                btn.tag = 1002
                break
            case "课程":
                btn.tag = 1003
                break
            case "我的":
                btn.tag = 1004
                break
            case "辅导":
                btn.tag = 1005
                break
            default:
                break
            }
            
            self.addSubview(btn)
            btn.addTarget(self, action: #selector(btnClick(btn: )), for: .touchUpInside)
            if btn.tag == 1001 {
                //                btn.isEnabled = false
                btn.backgroundColor = UIColor.hexString(hexString: "1782D2")
            }
            else{
                btn.backgroundColor = UIColor.hexString(hexString: "272727")
            }
        }
        if myRedCount != 0 {
            self.showBage(type: .mine, bage: myRedCount)
        }
        self.showBage(type: .group, bage: Int(RCIMClient.shared().getUnreadCount([RCConversationType.ConversationType_PRIVATE,RCConversationType.ConversationType_GROUP])))
    }
    
    func removeAllSubview(){
        for subView in self.subviews {
            subView.removeFromSuperview()
        }
    }
    
    
    
    @objc func btnClick(btn:CustomBtn){
        let name = btn.title(for: UIControl.State.normal)!
        
        switch name {
        case "朋友圈":
            clickType?(.friend)
            break
        case "群组":
            clickType?(.group)
            break
        case "发现":
            clickType?(.finding)
            break
        case "课程":
            clickType?(.course)
            break
        case "我的":
            clickType?(.mine)
            break
        case "辅导":
            clickType?(.helpingStatus)
            break
        default:
            break
        }
        
        
        
    }
    
    
    
    /// 点击tab按钮的响应
    ///
    /// - Parameter type: 会传入具体的类型
    func fakeType(type:@escaping myBlcok){
        clickType = type
    }
    
    
    /// 显示提示个数的小红点
    ///
    /// - Parameters:
    ///   - type: 显示到哪个按钮
    ///   - bage: 红点个数
    func showBage(type:fakeType,bage:Int){
        
        var btn : CustomBtn?
        switch type {
        case .friend:
            btn = self.viewWithTag(1000) as? CustomBtn
            break
        case .group:
            btn = self.viewWithTag(1001) as? CustomBtn
            break
        case .finding:
            btn = self.viewWithTag(1002) as? CustomBtn
            break
        case .course:
            btn = self.viewWithTag(1003) as? CustomBtn
            break
        case .helpingStatus:
            btn = self.viewWithTag(1005) as? CustomBtn
            break
        case .mine:
            btn = self.viewWithTag(1004) as? CustomBtn
            myRedCount = bage
            break
        default:
            break
        }
        
        if btn != nil {
            btn?.badgeCenterOffset = CGPoint.init(x: -34, y: 13)
            btn?.showBadge(with: .number, value: bage, animationType: .none)
        }
        
    }
    
}
//
//  CustomBtn.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 2017/4/24.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class CustomBtn: UIButton {
    
    /*
     // Only override draw() if you perform custom drawing.
     // An empty implementation adversely affects performance during animation.
     override func draw(_ rect: CGRect) {
     // Drawing code
     }
     */
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        
        
        let btnW = self.frame.size.width
        let imageW:CGFloat = 22.0
        self.imageView?.frame = CGRect(x: (btnW - imageW)/2.0, y: 5.5, width: imageW+0.5, height: imageW+0.5)
        
        self.titleLabel?.font = UIFont.systemFont(ofSize: 14)
        self.titleLabel?.textAlignment = .center
        self.titleLabel?.frame = CGRect(x: 0, y: 30, width: btnW, height: (self.titleLabel?.frame.size.height)! + 2.0)
        self.titleLabel?.backgroundColor = UIColor.clear
        //        self.titleLabel?.font = UIFont.systemFont(ofSize: 15)
    }
    
}
//
//  ComboboxView.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/21.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
@objc protocol ComboboxViewDelegate {
    func comboboxViewOneRowClick(button:UIButton)
}
class ComboboxView: UIView {
    
    weak var delegate : ComboboxViewDelegate?
    var btnList = Array<UIButton>()
    convenience init(titles : Array<String>, imageNames : Array<Array<String>>?, bgImgName : String?, frame:CGRect) {
        self.init()
        self.frame = UIScreen.main.bounds
        self.backgroundColor = UIColor.clear
        
        let comboboxView = UIView.init(frame: frame)
        self.addSubview(comboboxView)
        //顶部边距
        let topPadding : CGFloat = TOP_PADDING
        //背景颜色
        if bgImgName == nil {
            comboboxView.backgroundColor = UIColor.black
            comboboxView.alpha = 0.5
        } else {
            let imgBG = UIImageView.init(frame: comboboxView.bounds)
            imgBG.image = UIImage.init(named: bgImgName!)
            comboboxView.addSubview(imgBG)
        }
        
        //留白
        let blankSpace = UIView.init(frame: CGRect.init(x: 0, y: 0, width: frame.size.width, height: topPadding))
        blankSpace.backgroundColor = UIColor.clear
        comboboxView.addSubview(blankSpace)
        for index in 0..<titles.count {
            let oneRow = UIButton.init(frame: CGRect.init(x: 0, y: CGFloat(index) * oneRow_height + topPadding + 1, width: frame.size.width, height: oneRow_height))
            oneRow.tag = index + 10
            oneRow.contentVerticalAlignment = .center
            //文字
            let finalText = (imageNames?.count)! > 0 ? "  ".appending(titles[index]) : titles[index]
            oneRow.setTitleColor(UIColor.white, for: .normal)
            oneRow.titleLabel?.font = FONT_14
            oneRow.setTitle(finalText, for: .normal)
            
            //图片
            if (imageNames?.count)! > 0 {
                let norImgName : String? = imageNames?[0][index]
                let selImgName : String? = imageNames?[1][index]
                oneRow.setImage(UIImage.init(named: norImgName!), for: .normal)
                oneRow.setImage(UIImage.init(named: selImgName!), for: .highlighted)
            }
            oneRow.addTarget(self, action: #selector(clickOneRow), for: .touchUpInside)
            comboboxView.addSubview(oneRow)
            btnList.append(oneRow)
            
            if (index > 0) {
                //分割线
                let line = UIView.init(frame: CGRect.init(x: 0, y: CGFloat(index) * oneRow_height + topPadding, width: frame.size.width, height: 1))
                line.backgroundColor = UIColor.hexString(hexString: "d6d2d2")
                comboboxView.addSubview(line)
            }
        }
    }
    @objc func clickOneRow(button:UIButton) {
        self.removeFromSuperview()
        delegate?.comboboxViewOneRowClick(button: button)
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.removeFromSuperview()
    }
    
}
//
//  CellMenuView.swift
//  GroupChatPlungSwiftPro
//
//  Created by harry on 17/3/9.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
//TODO:(harry标注)--类型还没填完全
enum MenuType {
    case MenuType_Copy
}
class CellMenuView: UIView {
   
  typealias clickBlock = (_ type:MenuType)->()
  fileprivate  var block : clickBlock?
    
    
   @objc fileprivate func click(notification: NSNotification)
    {
     self.removeFromSuperview()
    }
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    
   
  fileprivate  override init(frame: CGRect) {
        super.init(frame: frame)
    NotificationCenter.default.addObserver(self, selector: #selector(click), name: UIMenuController.willHideMenuNotification, object: nil)
        
    }
    
    
    override var canBecomeFirstResponder: Bool
    {
        return true
    }
    
    override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
        
        return true
        if action == #selector(copyClick1(item:)) || action == #selector(copyClick2(item:)) || action == #selector(copyClick3(item:))
        {
            return true
            
        }
        else
        {
            return false
        }
    }
    
    
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
//MARK: - ---------------------类内部私有方法----------------------
extension CellMenuView{
    fileprivate  func configItem(menu:UIMenuController) {
        
        let copy1 = UIMenuItem.init(title: "复制1", action: #selector(copyClick1(item:)))
        let copy2 = UIMenuItem.init(title: "复制1", action: #selector(copyClick2(item:)))
        let copy3 = UIMenuItem.init(title: "复制1", action: #selector(copyClick3(item:)))
        menu.menuItems = [copy1,copy2,copy3]
    }
}
//MARK: - ---------------------按钮点击响应方法----------------------
extension CellMenuView{
    
    @objc fileprivate func copyClick1(item:UIMenuItem) -> () {
        block?(MenuType.MenuType_Copy)
    }
    @objc fileprivate func copyClick2(item:UIMenuItem) -> () {
        block?(MenuType.MenuType_Copy)
    }
    @objc fileprivate func copyClick3(item:UIMenuItem) -> () {
        block?(MenuType.MenuType_Copy)
    }
}
//MARK: - ---------------------对外接口----------------------
extension CellMenuView{
    
    
    /// 初始化菜单
    ///
    /// - Parameter inview: 传入将要作为被处理的View
    /// - Returns: 返回CellMenuView 对象 用来做按钮点击后的回调用
    public static func configWith(inview:UIView)->(CellMenuView)
    {
        let myView = CellMenuView.init(frame: CGRect.init(x: 0, y: 0, width: 0, height: 0))
        inview.addSubview(myView)
        myView.becomeFirstResponder()
        
        
        let menuVC = UIMenuController.shared
        myView.configItem(menu: menuVC)
        menuVC.setTargetRect(CGRect.init(x: 0, y: 0, width: 100, height: 30), in:inview )
        menuVC.setMenuVisible(true, animated: false)
        return myView
    }
    
    /// 菜单按钮点击回调闭包
    ///
    /// - Parameter type: 返回点击的类型
    public func menuClickWithType(type:@escaping clickBlock)
    {
        block = type
    }
}
//
//  RongDemoViewController.swift
//  GroupChatPlungSwiftPro
//
//  Created by 柴进 on 2017/3/1.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class RongDemoViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        RCIM.shared().initWithAppKey("m7ua80gbm7bgm")
        
//        RCIM.shared().connect(withToken: "MjQqsfL9QMLYUd2X3XTT/1B2V+2Y3XGjyhArGfi6/pMfyDKJUVq0bT/evBgpGQxSXva54fobkQu8Ck4pHtVifw==", success: { (userId) in
//            print("登陆成功。当前登录的用户ID：\(userId)")
//            let rcb = RCConversationViewController.init(conversationType: RCConversationType.ConversationType_PRIVATE, targetId: "2222")
//            DispatchQueue.main.async {
//                self.present(rcb!, animated: true, completion: nil)
//            }
//        }, error: { (status) in
//            print("登陆的错误码为:\(status)")
//        }) {
//            print("token错误")
//        }
        //2222
//        RCIM.shared().initWithAppKey("m7ua80gbm7bgm")
//        RCIM.shared().connect(withToken: "ymwQ4+vs5yrA+uFi3S1YZQuG3tBEDnpU3tFaQ1AXlymv+iOvift2KeE28gDsFOcjUHVfMMBayUBfOxUqEilUyA==", success: { (userId) in
//            print("登陆成功。当前登录的用户ID：\(userId)")
//            let rcb = RCConversationViewController.init(conversationType: RCConversationType.ConversationType_PRIVATE, targetId: "1111")
//            DispatchQueue.main.async {
//                self.present(rcb!, animated: true, completion: nil)
//            }
//        }, error: { (status) in
//            print("登陆的错误码为:\(status)")
//        }) {
//            print("token错误")
//        }
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    /*
    // MARK: - Navigation
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */
}
//
//  RongTestVC.swift
//  GroupChatPlungSwiftPro
//
//  Created by rms on 17/3/6.
//  Copyright © 2017年 柴进. All rights reserved.
//
import UIKit
class RongTestVC: RCConversationViewController {
}
//  SwiftyJSON.swift
//
//  Copyright (c) 2014 - 2017 Ruoyu Fu, Pinglin Tang
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
// MARK: - Error
// swiftlint:disable line_length
public enum SwiftyJSONError: Int, Swift.Error {
    case unsupportedType = 999
    case indexOutOfBounds = 900
    case elementTooDeep = 902
    case wrongType = 901
    case notExist = 500
    case invalidJSON = 490
}
extension SwiftyJSONError: CustomNSError {
    /// return the error domain of SwiftyJSONError
    public static var errorDomain: String { return "com.swiftyjson.SwiftyJSON" }
    /// return the error code of SwiftyJSONError
    public var errorCode: Int { return self.rawValue }
    /// return the userInfo of SwiftyJSONError
    public var errorUserInfo: [String: Any] {
        switch self {
        case .unsupportedType:
            return [NSLocalizedDescriptionKey: "It is an unsupported type."]
        case .indexOutOfBounds:
            return [NSLocalizedDescriptionKey: "Array Index is out of bounds."]
        case .wrongType:
            return [NSLocalizedDescriptionKey: "Couldn't merge, because the JSONs differ in type on top level."]
        case .notExist:
            return [NSLocalizedDescriptionKey: "Dictionary key does not exist."]
        case .invalidJSON:
            return [NSLocalizedDescriptionKey: "JSON is invalid."]
        case .elementTooDeep:
            return [NSLocalizedDescriptionKey: "Element too deep. Increase maxObjectDepth and make sure there is no reference loop."]
        }
    }
}
// MARK: - JSON Type
/**
JSON's type definitions.
See http://www.json.org
*/
public enum Type: Int {
	case number
	case string
	case bool
	case array
	case dictionary
	case null
	case unknown
}
// MARK: - JSON Base
public struct JSON {
	/**
	 Creates a JSON using the data.
	
	 - parameter data: The NSData used to convert to json.Top level object in data is an NSArray or NSDictionary
	 - parameter opt: The JSON serialization reading options. `[]` by default.
	
	 - returns: The created JSON
	 */
    public init(data: Data, options opt: JSONSerialization.ReadingOptions = []) throws {
        let object: Any = try JSONSerialization.jsonObject(with: data, options: opt)
        self.init(jsonObject: object)
    }
    /**
	 Creates a JSON object
	 - note: this does not parse a `String` into JSON, instead use `init(parseJSON: String)`
	
	 - parameter object: the object
	 - returns: the created JSON object
	 */
    public init(_ object: Any) {
        switch object {
        case let object as Data:
            do {
                try self.init(data: object)
            } catch {
                self.init(jsonObject: NSNull())
            }
        default:
            self.init(jsonObject: object)
        }
    }
	/**
	 Parses the JSON string into a JSON object
	
	 - parameter json: the JSON string
	
	 - returns: the created JSON object
	*/
	public init(parseJSON jsonString: String) {
		if let data = jsonString.data(using: .utf8) {
			self.init(data)
		} else {
			self.init(NSNull())
		}
	}
	/**
	 Creates a JSON using the object.
	
	 - parameter jsonObject:  The object must have the following properties: All objects are NSString/String, NSNumber/Int/Float/Double/Bool, NSArray/Array, NSDictionary/Dictionary, or NSNull; All dictionary keys are NSStrings/String; NSNumbers are not NaN or infinity.
	
	 - returns: The created JSON
	 */
    fileprivate init(jsonObject: Any) {
        object = jsonObject
    }
	/**
	 Merges another JSON into this JSON, whereas primitive values which are not present in this JSON are getting added,
	 present values getting overwritten, array values getting appended and nested JSONs getting merged the same way.
 
	 - parameter other: The JSON which gets merged into this JSON
	
	 - throws `ErrorWrongType` if the other JSONs differs in type on the top level.
	 */
    public mutating func merge(with other: JSON) throws {
        try self.merge(with: other, typecheck: true)
    }
	/**
	 Merges another JSON into this JSON and returns a new JSON, whereas primitive values which are not present in this JSON are getting added,
	 present values getting overwritten, array values getting appended and nested JSONS getting merged the same way.
	
	 - parameter other: The JSON which gets merged into this JSON
	
	 - throws `ErrorWrongType` if the other JSONs differs in type on the top level.
	
	 - returns: New merged JSON
	 */
    public func merged(with other: JSON) throws -> JSON {
        var merged = self
        try merged.merge(with: other, typecheck: true)
        return merged
    }
    /**
     Private woker function which does the actual merging
     Typecheck is set to true for the first recursion level to prevent total override of the source JSON
 	*/
 	fileprivate mutating func merge(with other: JSON, typecheck: Bool) throws {
        if type == other.type {
            switch type {
            case .dictionary:
                for (key, _) in other {
                    try self[key].merge(with: other[key], typecheck: false)
                }
            case .array:
                self = JSON(arrayValue + other.arrayValue)
            default:
                self = other
            }
        } else {
            if typecheck {
                throw SwiftyJSONError.wrongType
            } else {
                self = other
            }
        }
    }
    /// Private object
    fileprivate var rawArray: [Any] = []
    fileprivate var rawDictionary: [String: Any] = [:]
    fileprivate var rawString: String = ""
    fileprivate var rawNumber: NSNumber = 0
    fileprivate var rawNull: NSNull = NSNull()
    fileprivate var rawBool: Bool = false
    /// JSON type, fileprivate setter
    public fileprivate(set) var type: Type = .null
    /// Error in JSON, fileprivate setter
    public fileprivate(set) var error: SwiftyJSONError?
    /// Object in JSON
    public var object: Any {
        get {
            switch type {
            case .array:      return rawArray
            case .dictionary: return rawDictionary
            case .string:     return rawString
            case .number:     return rawNumber
            case .bool:       return rawBool
            default:          return rawNull
            }
        }
        set {
            error = nil
            switch unwrap(newValue) {
            case let number as NSNumber:
                if number.isBool {
                    type = .bool
                    rawBool = number.boolValue
                } else {
                    type = .number
                    rawNumber = number
                }
            case let string as String:
                type = .string
                rawString = string
            case _ as NSNull:
                type = .null
            case nil:
                type = .null
            case let array as [Any]:
                type = .array
                rawArray = array
            case let dictionary as [String: Any]:
                type = .dictionary
                rawDictionary = dictionary
            default:
                type = .unknown
                error = SwiftyJSONError.unsupportedType
            }
        }
    }
    /// The static null JSON
    @available(*, unavailable, renamed:"null")
    public static var nullJSON: JSON { return null }
    public static var null: JSON { return JSON(NSNull()) }
}
/// Private method to unwarp an object recursively
private func unwrap(_ object: Any) -> Any {
    switch object {
    case let json as JSON:
        return unwrap(json.object)
    case let array as [Any]:
        return array.map(unwrap)
    case let dictionary as [String: Any]:
        var d = dictionary
        dictionary.forEach { pair in
            d[pair.key] = unwrap(pair.value)
        }
        return d
    default:
        return object
    }
}
public enum Index<T: Any>: Comparable {
    case array(Int)
    case dictionary(DictionaryIndex<String, T>)
    case null
    static public func == (lhs: Index, rhs: Index) -> Bool {
        switch (lhs, rhs) {
        case (.array(let left), .array(let right)):           return left == right
        case (.dictionary(let left), .dictionary(let right)): return left == right
        case (.null, .null):                                  return true
        default:                                              return false
        }
    }
    static public func < (lhs: Index, rhs: Index) -> Bool {
        switch (lhs, rhs) {
        case (.array(let left), .array(let right)):           return left < right
        case (.dictionary(let left), .dictionary(let right)): return left < right
        default:                                              return false
        }
    }
}
public typealias JSONIndex = Index<JSON>
public typealias JSONRawIndex = Index<Any>
extension JSON: Swift.Collection {
    public typealias Index = JSONRawIndex
    public var startIndex: Index {
        switch type {
        case .array:      return .array(rawArray.startIndex)
        case .dictionary: return .dictionary(rawDictionary.startIndex)
        default:          return .null
        }
    }
    public var endIndex: Index {
        switch type {
        case .array:      return .array(rawArray.endIndex)
        case .dictionary: return .dictionary(rawDictionary.endIndex)
        default:          return .null
        }
    }
    public func index(after i: Index) -> Index {
        switch i {
        case .array(let idx):      return .array(rawArray.index(after: idx))
        case .dictionary(let idx): return .dictionary(rawDictionary.index(after: idx))
        default:                   return .null
        }
    }
    public subscript (position: Index) -> (String, JSON) {
        switch position {
        case .array(let idx):      return (String(idx), JSON(rawArray[idx]))
        case .dictionary(let idx): return (rawDictionary[idx].key, JSON(rawDictionary[idx].value))
        default:                   return ("", JSON.null)
        }
    }
}
// MARK: - Subscript
/**
 *  To mark both String and Int can be used in subscript.
 */
public enum JSONKey {
    case index(Int)
    case key(String)
}
public protocol JSONSubscriptType {
    var jsonKey: JSONKey { get }
}
extension Int: JSONSubscriptType {
    public var jsonKey: JSONKey {
        return JSONKey.index(self)
    }
}
extension String: JSONSubscriptType {
    public var jsonKey: JSONKey {
        return JSONKey.key(self)
    }
}
extension JSON {
    /// If `type` is `.array`, return json whose object is `array[index]`, otherwise return null json with error.
    fileprivate subscript(index index: Int) -> JSON {
        get {
            if type != .array {
                var r = JSON.null
                r.error = self.error ?? SwiftyJSONError.wrongType
                return r
            } else if rawArray.indices.contains(index) {
                return JSON(rawArray[index])
            } else {
                var r = JSON.null
                r.error = SwiftyJSONError.indexOutOfBounds
                return r
            }
        }
        set {
            if type == .array &&
                rawArray.indices.contains(index) &&
                newValue.error == nil {
                rawArray[index] = newValue.object
            }
        }
    }
    /// If `type` is `.dictionary`, return json whose object is `dictionary[key]` , otherwise return null json with error.
    fileprivate subscript(key key: String) -> JSON {
        get {
            var r = JSON.null
            if type == .dictionary {
                if let o = rawDictionary[key] {
                    r = JSON(o)
                } else {
                    r.error = SwiftyJSONError.notExist
                }
            } else {
                r.error = self.error ?? SwiftyJSONError.wrongType
            }
            return r
        }
        set {
            if type == .dictionary && newValue.error == nil {
                rawDictionary[key] = newValue.object
            }
        }
    }
    /// If `sub` is `Int`, return `subscript(index:)`; If `sub` is `String`,  return `subscript(key:)`.
    fileprivate subscript(sub sub: JSONSubscriptType) -> JSON {
        get {
            switch sub.jsonKey {
            case .index(let index): return self[index: index]
            case .key(let key):     return self[key: key]
            }
        }
        set {
            switch sub.jsonKey {
            case .index(let index): self[index: index] = newValue
            case .key(let key):     self[key: key] = newValue
            }
        }
    }
	/**
	 Find a json in the complex data structures by using array of Int and/or String as path.
	
	 Example:
	
	 ```
	 let json = JSON[data]
	 let path = [9,"list","person","name"]
	 let name = json[path]
	 ```
	
	 The same as: let name = json[9]["list"]["person"]["name"]
	
	 - parameter path: The target json's path.
	
	 - returns: Return a json found by the path or a null json with error
	 */
    public subscript(path: [JSONSubscriptType]) -> JSON {
        get {
            return path.reduce(self) { $0[sub: $1] }
        }
        set {
            switch path.count {
            case 0: return
            case 1: self[sub:path[0]].object = newValue.object
            default:
                var aPath = path
                aPath.remove(at: 0)
                var nextJSON = self[sub: path[0]]
                nextJSON[aPath] = newValue
                self[sub: path[0]] = nextJSON
            }
        }
    }
    /**
     Find a json in the complex data structures by using array of Int and/or String as path.
     - parameter path: The target json's path. Example:
     let name = json[9,"list","person","name"]
     The same as: let name = json[9]["list"]["person"]["name"]
     - returns: Return a json found by the path or a null json with error
     */
    public subscript(path: JSONSubscriptType...) -> JSON {
        get {
            return self[path]
        }
        set {
            self[path] = newValue
        }
    }
}
// MARK: - LiteralConvertible
extension JSON: Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: StringLiteralType) {
        self.init(value)
    }
    public init(extendedGraphemeClusterLiteral value: StringLiteralType) {
        self.init(value)
    }
    public init(unicodeScalarLiteral value: StringLiteralType) {
        self.init(value)
    }
}
extension JSON: Swift.ExpressibleByIntegerLiteral {
    public init(integerLiteral value: IntegerLiteralType) {
        self.init(value)
    }
}
extension JSON: Swift.ExpressibleByBooleanLiteral {
    public init(booleanLiteral value: BooleanLiteralType) {
        self.init(value)
    }
}
extension JSON: Swift.ExpressibleByFloatLiteral {
    public init(floatLiteral value: FloatLiteralType) {
        self.init(value)
    }
}
extension JSON: Swift.ExpressibleByDictionaryLiteral {
    public init(dictionaryLiteral elements: (String, Any)...) {
        let dictionary = elements.reduce(into: [String: Any](), { $0[$1.0] = $1.1})
        self.init(dictionary)
    }
}
extension JSON: Swift.ExpressibleByArrayLiteral {
    public init(arrayLiteral elements: Any...) {
        self.init(elements)
    }
}
// MARK: - Raw
extension JSON: Swift.RawRepresentable {
    public init?(rawValue: Any) {
        if JSON(rawValue).type == .unknown {
            return nil
        } else {
            self.init(rawValue)
        }
    }
    public var rawValue: Any {
        return object
    }
    public func rawData(options opt: JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Data {
        guard JSONSerialization.isValidJSONObject(object) else {
            throw SwiftyJSONError.invalidJSON
        }
        return try JSONSerialization.data(withJSONObject: object, options: opt)
	}
	public func rawString(_ encoding: String.Encoding = .utf8, options opt: JSONSerialization.WritingOptions = .prettyPrinted) -> String? {
		do {
			return try _rawString(encoding, options: [.jsonSerialization: opt])
		} catch {
			print("Could not serialize object to JSON because:", error.localizedDescription)
			return nil
		}
	}
	public func rawString(_ options: [writingOptionsKeys: Any]) -> String? {
		let encoding = options[.encoding] as? String.Encoding ?? String.Encoding.utf8
		let maxObjectDepth = options[.maxObjextDepth] as? Int ?? 10
		do {
			return try _rawString(encoding, options: options, maxObjectDepth: maxObjectDepth)
		} catch {
			print("Could not serialize object to JSON because:", error.localizedDescription)
			return nil
		}
	}
	fileprivate func _rawString(_ encoding: String.Encoding = .utf8, options: [writingOptionsKeys: Any], maxObjectDepth: Int = 10) throws -> String? {
        guard maxObjectDepth > 0 else { throw SwiftyJSONError.invalidJSON }
        switch type {
        case .dictionary:
			do {
				if !(options[.castNilToNSNull] as? Bool ?? false) {
					let jsonOption = options[.jsonSerialization] as? JSONSerialization.WritingOptions ?? JSONSerialization.WritingOptions.prettyPrinted
					let data = try rawData(options: jsonOption)
					return String(data: data, encoding: encoding)
				}
				guard let dict = object as? [String: Any?] else {
					return nil
				}
				let body = try dict.keys.map { key throws -> String in
					guard let value = dict[key] else {
						return "\"\(key)\": null"
					}
					guard let unwrappedValue = value else {
						return "\"\(key)\": null"
					}
					let nestedValue = JSON(unwrappedValue)
					guard let nestedString = try nestedValue._rawString(encoding, options: options, maxObjectDepth: maxObjectDepth - 1) else {
						throw SwiftyJSONError.elementTooDeep
					}
					if nestedValue.type == .string {
						return "\"\(key)\": \"\(nestedString.replacingOccurrences(of: "\\", with: "\\\\").replacingOccurrences(of: "\"", with: "\\\""))\""
					} else {
						return "\"\(key)\": \(nestedString)"
					}
				}
				return "{\(body.joined(separator: ","))}"
			} catch _ {
				return nil
			}
        case .array:
            do {
				if !(options[.castNilToNSNull] as? Bool ?? false) {
					let jsonOption = options[.jsonSerialization] as? JSONSerialization.WritingOptions ?? JSONSerialization.WritingOptions.prettyPrinted
					let data = try rawData(options: jsonOption)
					return String(data: data, encoding: encoding)
				}
                guard let array = object as? [Any?] else {
                    return nil
                }
                let body = try array.map { value throws -> String in
                    guard let unwrappedValue = value else {
                        return "null"
                    }
                    let nestedValue = JSON(unwrappedValue)
                    guard let nestedString = try nestedValue._rawString(encoding, options: options, maxObjectDepth: maxObjectDepth - 1) else {
                        throw SwiftyJSONError.invalidJSON
                    }
                    if nestedValue.type == .string {
                        return "\"\(nestedString.replacingOccurrences(of: "\\", with: "\\\\").replacingOccurrences(of: "\"", with: "\\\""))\""
                    } else {
                        return nestedString
                    }
                }
                return "[\(body.joined(separator: ","))]"
            } catch _ {
                return nil
            }
        case .string: return rawString
        case .number: return rawNumber.stringValue
        case .bool:   return rawBool.description
        case .null:   return "null"
        default:      return nil
        }
    }
}
// MARK: - Printable, DebugPrintable
extension JSON: Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
    public var description: String {
        return rawString(options: .prettyPrinted) ?? "unknown"
    }
    public var debugDescription: String {
        return description
    }
}
// MARK: - Array
extension JSON {
    //Optional [JSON]
    public var array: [JSON]? {
        return type == .array ? rawArray.map { JSON($0) } : nil
    }
    //Non-optional [JSON]
    public var arrayValue: [JSON] {
        return self.array ?? []
    }
    //Optional [Any]
    public var arrayObject: [Any]? {
        get {
            switch type {
            case .array: return rawArray
            default:     return nil
            }
        }
        set {
            self.object = newValue ?? NSNull()
        }
    }
}
// MARK: - Dictionary
extension JSON {
    //Optional [String : JSON]
    public var dictionary: [String: JSON]? {
        if type == .dictionary {
            var d = [String: JSON](minimumCapacity: rawDictionary.count)
            rawDictionary.forEach { pair in
                d[pair.key] = JSON(pair.value)
            }
            return d
        } else {
            return nil
        }
    }
    //Non-optional [String : JSON]
    public var dictionaryValue: [String: JSON] {
        return dictionary ?? [:]
    }
    //Optional [String : Any]
    public var dictionaryObject: [String: Any]? {
        get {
            switch type {
            case .dictionary: return rawDictionary
            default:          return nil
            }
        }
        set {
            object = newValue ?? NSNull()
        }
    }
}
// MARK: - Bool
extension JSON { // : Swift.Bool
    //Optional bool
    public var bool: Bool? {
        get {
            switch type {
            case .bool: return rawBool
            default:    return nil
            }
        }
        set {
            object = newValue ?? NSNull()
        }
    }
    //Non-optional bool
    public var boolValue: Bool {
        get {
            switch type {
            case .bool:   return rawBool
            case .number: return rawNumber.boolValue
            case .string: return ["true", "y", "t", "yes", "1"].contains { rawString.caseInsensitiveCompare($0) == .orderedSame }
            default:      return false
            }
        }
        set {
            object = newValue
        }
    }
}
// MARK: - String
extension JSON {
    //Optional string
    public var string: String? {
        get {
            switch type {
            case .string: return object as? String
            default:      return nil
            }
        }
        set {
            object = newValue ?? NSNull()
        }
    }
    //Non-optional string
    public var stringValue: String {
        get {
            switch type {
            case .string: return object as? String ?? ""
            case .number: return rawNumber.stringValue
            case .bool:   return (object as? Bool).map { String($0) } ?? ""
            default:      return ""
            }
        }
        set {
            object = newValue
        }
    }
}
// MARK: - Number
extension JSON {
    //Optional number
    public var number: NSNumber? {
        get {
            switch type {
            case .number: return rawNumber
            case .bool:   return NSNumber(value: rawBool ? 1 : 0)
            default:      return nil
            }
        }
        set {
            object = newValue ?? NSNull()
        }
    }
    //Non-optional number
    public var numberValue: NSNumber {
        get {
            switch type {
            case .string:
                let decimal = NSDecimalNumber(string: object as? String)
                return decimal == .notANumber ? .zero : decimal
            case .number: return object as? NSNumber ?? NSNumber(value: 0)
            case .bool: return NSNumber(value: rawBool ? 1 : 0)
            default: return NSNumber(value: 0.0)
            }
        }
        set {
            object = newValue
        }
    }
}
// MARK: - Null
extension JSON {
    public var null: NSNull? {
        set {
            object = NSNull()
        }
        get {
            switch type {
            case .null: return rawNull
            default:    return nil
            }
        }
    }
    public func exists() -> Bool {
        if let errorValue = error, (400...1000).contains(errorValue.errorCode) {
            return false
        }
        return true
    }
}
// MARK: - URL
extension JSON {
    //Optional URL
    public var url: URL? {
        get {
            switch type {
            case .string:
                // Check for existing percent escapes first to prevent double-escaping of % character
                if rawString.range(of: "%[0-9A-Fa-f]{2}", options: .regularExpression, range: nil, locale: nil) != nil {
                    return Foundation.URL(string: rawString)
                } else if let encodedString_ = rawString.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) {
                    // We have to use `Foundation.URL` otherwise it conflicts with the variable name.
                    return Foundation.URL(string: encodedString_)
                } else {
                    return nil
                }
            default:
                return nil
            }
        }
        set {
            object = newValue?.absoluteString ?? NSNull()
        }
    }
}
// MARK: - Int, Double, Float, Int8, Int16, Int32, Int64
extension JSON {
    public var double: Double? {
        get {
            return number?.doubleValue
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object = NSNull()
            }
        }
    }
    public var doubleValue: Double {
        get {
            return numberValue.doubleValue
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var float: Float? {
        get {
            return number?.floatValue
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object = NSNull()
            }
        }
    }
    public var floatValue: Float {
        get {
            return numberValue.floatValue
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var int: Int? {
        get {
            return number?.intValue
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object = NSNull()
            }
        }
    }
    public var intValue: Int {
        get {
            return numberValue.intValue
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var uInt: UInt? {
        get {
            return number?.uintValue
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object = NSNull()
            }
        }
    }
    public var uIntValue: UInt {
        get {
            return numberValue.uintValue
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var int8: Int8? {
        get {
            return number?.int8Value
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: Int(newValue))
            } else {
                object =  NSNull()
            }
        }
    }
    public var int8Value: Int8 {
        get {
            return numberValue.int8Value
        }
        set {
            object = NSNumber(value: Int(newValue))
        }
    }
    public var uInt8: UInt8? {
        get {
            return number?.uint8Value
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object =  NSNull()
            }
        }
    }
    public var uInt8Value: UInt8 {
        get {
            return numberValue.uint8Value
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var int16: Int16? {
        get {
            return number?.int16Value
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object =  NSNull()
            }
        }
    }
    public var int16Value: Int16 {
        get {
            return numberValue.int16Value
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var uInt16: UInt16? {
        get {
            return number?.uint16Value
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object =  NSNull()
            }
        }
    }
    public var uInt16Value: UInt16 {
        get {
            return numberValue.uint16Value
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var int32: Int32? {
        get {
            return number?.int32Value
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object =  NSNull()
            }
        }
    }
    public var int32Value: Int32 {
        get {
            return numberValue.int32Value
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var uInt32: UInt32? {
        get {
            return number?.uint32Value
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object =  NSNull()
            }
        }
    }
    public var uInt32Value: UInt32 {
        get {
            return numberValue.uint32Value
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var int64: Int64? {
        get {
            return number?.int64Value
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object =  NSNull()
            }
        }
    }
    public var int64Value: Int64 {
        get {
            return numberValue.int64Value
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
    public var uInt64: UInt64? {
        get {
            return number?.uint64Value
        }
        set {
            if let newValue = newValue {
                object = NSNumber(value: newValue)
            } else {
                object =  NSNull()
            }
        }
    }
    public var uInt64Value: UInt64 {
        get {
            return numberValue.uint64Value
        }
        set {
            object = NSNumber(value: newValue)
        }
    }
}
// MARK: - Comparable
extension JSON: Swift.Comparable {}
public func == (lhs: JSON, rhs: JSON) -> Bool {
    switch (lhs.type, rhs.type) {
    case (.number, .number): return lhs.rawNumber == rhs.rawNumber
    case (.string, .string): return lhs.rawString == rhs.rawString
    case (.bool, .bool):     return lhs.rawBool == rhs.rawBool
    case (.array, .array):   return lhs.rawArray as NSArray == rhs.rawArray as NSArray
    case (.dictionary, .dictionary): return lhs.rawDictionary as NSDictionary == rhs.rawDictionary as NSDictionary
    case (.null, .null):     return true
    default:                 return false
    }
}
public func <= (lhs: JSON, rhs: JSON) -> Bool {
    switch (lhs.type, rhs.type) {
    case (.number, .number): return lhs.rawNumber <= rhs.rawNumber
    case (.string, .string): return lhs.rawString <= rhs.rawString
    case (.bool, .bool):     return lhs.rawBool == rhs.rawBool
    case (.array, .array):   return lhs.rawArray as NSArray == rhs.rawArray as NSArray
    case (.dictionary, .dictionary): return lhs.rawDictionary as NSDictionary == rhs.rawDictionary as NSDictionary
    case (.null, .null):     return true
    default:                 return false
    }
}
public func >= (lhs: JSON, rhs: JSON) -> Bool {
    switch (lhs.type, rhs.type) {
    case (.number, .number): return lhs.rawNumber >= rhs.rawNumber
    case (.string, .string): return lhs.rawString >= rhs.rawString
    case (.bool, .bool):     return lhs.rawBool == rhs.rawBool
    case (.array, .array):   return lhs.rawArray as NSArray == rhs.rawArray as NSArray
    case (.dictionary, .dictionary): return lhs.rawDictionary as NSDictionary == rhs.rawDictionary as NSDictionary
    case (.null, .null):     return true
    default:                 return false
    }
}
public func > (lhs: JSON, rhs: JSON) -> Bool {
    switch (lhs.type, rhs.type) {
    case (.number, .number): return lhs.rawNumber > rhs.rawNumber
    case (.string, .string): return lhs.rawString > rhs.rawString
    default:                 return false
    }
}
public func < (lhs: JSON, rhs: JSON) -> Bool {
    switch (lhs.type, rhs.type) {
    case (.number, .number): return lhs.rawNumber < rhs.rawNumber
    case (.string, .string): return lhs.rawString < rhs.rawString
    default:                 return false
    }
}
private let trueNumber = NSNumber(value: true)
private let falseNumber = NSNumber(value: false)
private let trueObjCType = String(cString: trueNumber.objCType)
private let falseObjCType = String(cString: falseNumber.objCType)
// MARK: - NSNumber: Comparable
extension NSNumber {
    fileprivate var isBool: Bool {
        let objCType = String(cString: self.objCType)
        if (self.compare(trueNumber) == .orderedSame && objCType == trueObjCType) || (self.compare(falseNumber) == .orderedSame && objCType == falseObjCType) {
            return true
        } else {
            return false
        }
    }
}
func == (lhs: NSNumber, rhs: NSNumber) -> Bool {
    switch (lhs.isBool, rhs.isBool) {
    case (false, true): return false
    case (true, false): return false
    default:            return lhs.compare(rhs) == .orderedSame
    }
}
func != (lhs: NSNumber, rhs: NSNumber) -> Bool {
    return !(lhs == rhs)
}
func < (lhs: NSNumber, rhs: NSNumber) -> Bool {
    switch (lhs.isBool, rhs.isBool) {
    case (false, true): return false
    case (true, false): return false
    default:            return lhs.compare(rhs) == .orderedAscending
    }
}
func > (lhs: NSNumber, rhs: NSNumber) -> Bool {
    switch (lhs.isBool, rhs.isBool) {
    case (false, true): return false
    case (true, false): return false
    default:            return lhs.compare(rhs) == ComparisonResult.orderedDescending
    }
}
func <= (lhs: NSNumber, rhs: NSNumber) -> Bool {
    switch (lhs.isBool, rhs.isBool) {
    case (false, true): return false
    case (true, false): return false
    default:            return lhs.compare(rhs) != .orderedDescending
    }
}
func >= (lhs: NSNumber, rhs: NSNumber) -> Bool {
    switch (lhs.isBool, rhs.isBool) {
    case (false, true): return false
    case (true, false): return false
    default:            return lhs.compare(rhs) != .orderedAscending
    }
}
public enum writingOptionsKeys {
	case jsonSerialization
	case castNilToNSNull
	case maxObjextDepth
	case encoding
}
// MARK: - JSON: Codable
extension JSON: Codable {
    private static var codableTypes: [Codable.Type] {
        return [
            Bool.self,
            Int.self,
            Int8.self,
            Int16.self,
            Int32.self,
            Int64.self,
            UInt.self,
            UInt8.self,
            UInt16.self,
            UInt32.self,
            UInt64.self,
            Double.self,
            String.self,
            [JSON].self,
            [String: JSON].self
        ]
    }
    public init(from decoder: Decoder) throws {
        var object: Any?
        if let container = try? decoder.singleValueContainer(), !container.decodeNil() {
            for type in JSON.codableTypes {
                if object != nil {
                    break
                }
                // try to decode value
                switch type {
                case let boolType as Bool.Type:
                    object = try? container.decode(boolType)
                case let intType as Int.Type:
                    object = try? container.decode(intType)
                case let int8Type as Int8.Type:
                    object = try? container.decode(int8Type)
                case let int32Type as Int32.Type:
                    object = try? container.decode(int32Type)
                case let int64Type as Int64.Type:
                    object = try? container.decode(int64Type)
                case let uintType as UInt.Type:
                    object = try? container.decode(uintType)
                case let uint8Type as UInt8.Type:
                    object = try? container.decode(uint8Type)
                case let uint16Type as UInt16.Type:
                    object = try? container.decode(uint16Type)
                case let uint32Type as UInt32.Type:
                    object = try? container.decode(uint32Type)
                case let uint64Type as UInt64.Type:
                    object = try? container.decode(uint64Type)
                case let doubleType as Double.Type:
                    object = try? container.decode(doubleType)
                case let stringType as String.Type:
                    object = try? container.decode(stringType)
                case let jsonValueArrayType as [JSON].Type:
                    object = try? container.decode(jsonValueArrayType)
                case let jsonValueDictType as [String: JSON].Type:
                    object = try? container.decode(jsonValueDictType)
                default:
                    break
                }
            }
        }
        self.init(object ?? NSNull())
    }
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if object is NSNull {
            try container.encodeNil()
            return
        }
        switch object {
        case let intValue as Int:
            try container.encode(intValue)
        case let int8Value as Int8:
            try container.encode(int8Value)
        case let int32Value as Int32:
            try container.encode(int32Value)
        case let int64Value as Int64:
            try container.encode(int64Value)
        case let uintValue as UInt:
            try container.encode(uintValue)
        case let uint8Value as UInt8:
            try container.encode(uint8Value)
        case let uint16Value as UInt16:
            try container.encode(uint16Value)
        case let uint32Value as UInt32:
            try container.encode(uint32Value)
        case let uint64Value as UInt64:
            try container.encode(uint64Value)
        case let doubleValue as Double:
            try container.encode(doubleValue)
        case let boolValue as Bool:
            try container.encode(boolValue)
        case let stringValue as String:
            try container.encode(stringValue)
        case is [Any]:
            let jsonValueArray = array ?? []
            try container.encode(jsonValueArray)
        case is [String: Any]:
            let jsonValueDictValue = dictionary ?? [:]
            try container.encode(jsonValueDictValue)
        default:
            break
        }
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public protocol ConstraintMultiplierTarget {
    
    var constraintMultiplierTargetValue: CGFloat { get }
    
}
extension Int: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}
extension UInt: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}
extension Float: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}
extension Double: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return CGFloat(self)
    }
    
}
extension CGFloat: ConstraintMultiplierTarget {
    
    public var constraintMultiplierTargetValue: CGFloat {
        return self
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public protocol LayoutConstraintItem: class {
}
@available(iOS 9.0, OSX 10.11, *)
extension ConstraintLayoutGuide : LayoutConstraintItem {
}
extension ConstraintView : LayoutConstraintItem {
}
extension LayoutConstraintItem {
    
    internal func prepare() {
        if let view = self as? ConstraintView {
            view.translatesAutoresizingMaskIntoConstraints = false
        }
    }
    
    internal var superview: ConstraintView? {
        if let view = self as? ConstraintView {
            return view.superview
        }
        
        if #available(iOS 9.0, OSX 10.11, *), let guide = self as? ConstraintLayoutGuide {
            return guide.owningView
        }
        
        return nil
    }
    internal var constraints: [Constraint] {
        return self.constraintsSet.allObjects as! [Constraint]
    }
    
    internal func add(constraints: [Constraint]) {
        let constraintsSet = self.constraintsSet
        for constraint in constraints {
            constraintsSet.add(constraint)
        }
    }
    
    internal func remove(constraints: [Constraint]) {
        let constraintsSet = self.constraintsSet
        for constraint in constraints {
            constraintsSet.remove(constraint)
        }
    }
    
    private var constraintsSet: NSMutableSet {
        let constraintsSet: NSMutableSet
        
        if let existing = objc_getAssociatedObject(self, &constraintsKey) as? NSMutableSet {
            constraintsSet = existing
        } else {
            constraintsSet = NSMutableSet()
            objc_setAssociatedObject(self, &constraintsKey, constraintsSet, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
        return constraintsSet
        
    }
    
}
private var constraintsKey: UInt8 = 0
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public class ConstraintDescription {
    
    internal let item: LayoutConstraintItem
    internal var attributes: ConstraintAttributes
    internal var relation: ConstraintRelation? = nil
    internal var sourceLocation: (String, UInt)? = nil
    internal var label: String? = nil
    internal var related: ConstraintItem? = nil
    internal var multiplier: ConstraintMultiplierTarget = 1.0
    internal var constant: ConstraintConstantTarget = 0.0
    internal var priority: ConstraintPriorityTarget = 1000.0
    internal lazy var constraint: Constraint? = {
        guard let relation = self.relation,
              let related = self.related,
              let sourceLocation = self.sourceLocation else {
            return nil
        }
        let from = ConstraintItem(target: self.item, attributes: self.attributes)
        
        return Constraint(
            from: from,
            to: related,
            relation: relation,
            sourceLocation: sourceLocation,
            label: self.label,
            multiplier: self.multiplier,
            constant: self.constant,
            priority: self.priority
        )
    }()
    
    // MARK: Initialization
    
    internal init(item: LayoutConstraintItem, attributes: ConstraintAttributes) {
        self.item = item
        self.attributes = attributes
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public class ConstraintMakerPriortizable: ConstraintMakerFinalizable {
    
    @discardableResult
    public func priority(_ amount: ConstraintPriority) -> ConstraintMakerFinalizable {
        self.description.priority = amount.value
        return self
    }
    
    @discardableResult
    public func priority(_ amount: ConstraintPriorityTarget) -> ConstraintMakerFinalizable {
        self.description.priority = amount
        return self
    }
    
    @available(*, deprecated:3.0, message:"Use priority(.required) instead.")
    @discardableResult
    public func priorityRequired() -> ConstraintMakerFinalizable {
        return self.priority(.required)
    }
    
    @available(*, deprecated:3.0, message:"Use priority(.high) instead.")
    @discardableResult
    public func priorityHigh() -> ConstraintMakerFinalizable {
        return self.priority(.high)
    }
    
    @available(*, deprecated:3.0, message:"Use priority(.medium) instead.")
    @discardableResult
    public func priorityMedium() -> ConstraintMakerFinalizable {
        return self.priority(.medium)
    }
    
    @available(*, deprecated:3.0, message:"Use priority(.low) instead.")
    @discardableResult
    public func priorityLow() -> ConstraintMakerFinalizable {
        return self.priority(.low)
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
internal struct ConstraintAttributes : OptionSet, ExpressibleByIntegerLiteral {
    
    typealias IntegerLiteralType = UInt
    
    internal init(rawValue: UInt) {
        self.rawValue = rawValue
    }
    internal init(_ rawValue: UInt) {
        self.init(rawValue: rawValue)
    }
    internal init(nilLiteral: ()) {
        self.rawValue = 0
    }
    internal init(integerLiteral rawValue: IntegerLiteralType) {
        self.init(rawValue: rawValue)
    }
    
    internal private(set) var rawValue: UInt
    internal static var allZeros: ConstraintAttributes { return 0 }
    internal static func convertFromNilLiteral() -> ConstraintAttributes { return 0 }
    internal var boolValue: Bool { return self.rawValue != 0 }
    
    internal func toRaw() -> UInt { return self.rawValue }
    internal static func fromRaw(_ raw: UInt) -> ConstraintAttributes? { return self.init(raw) }
    internal static func fromMask(_ raw: UInt) -> ConstraintAttributes { return self.init(raw) }
    
    // normal
    
    internal static var none: ConstraintAttributes { return 0 }
    internal static var left: ConstraintAttributes { return 1 }
    internal static var top: ConstraintAttributes {  return 2 }
    internal static var right: ConstraintAttributes { return 4 }
    internal static var bottom: ConstraintAttributes { return 8 }
    internal static var leading: ConstraintAttributes { return 16 }
    internal static var trailing: ConstraintAttributes { return 32 }
    internal static var width: ConstraintAttributes { return 64 }
    internal static var height: ConstraintAttributes { return 128 }
    internal static var centerX: ConstraintAttributes { return 256 }
    internal static var centerY: ConstraintAttributes { return 512 }
    internal static var lastBaseline: ConstraintAttributes { return 1024 }
    
    @available(iOS 8.0, OSX 10.11, *)
    internal static var firstBaseline: ConstraintAttributes { return 2048 }
    
    @available(iOS 8.0, *)
    internal static var leftMargin: ConstraintAttributes { return 4096 }
    
    @available(iOS 8.0, *)
    internal static var rightMargin: ConstraintAttributes { return 8192 }
    
    @available(iOS 8.0, *)
    internal static var topMargin: ConstraintAttributes { return 16384 }
    
    @available(iOS 8.0, *)
    internal static var bottomMargin: ConstraintAttributes { return 32768 }
    
    @available(iOS 8.0, *)
    internal static var leadingMargin: ConstraintAttributes { return 65536 }
    
    @available(iOS 8.0, *)
    internal static var trailingMargin: ConstraintAttributes { return 131072 }
    
    @available(iOS 8.0, *)
    internal static var centerXWithinMargins: ConstraintAttributes { return 262144 }
    
    @available(iOS 8.0, *)
    internal static var centerYWithinMargins: ConstraintAttributes { return 524288 }
    
    // aggregates
    
    internal static var edges: ConstraintAttributes { return 15 }
    internal static var size: ConstraintAttributes { return 192 }
    internal static var center: ConstraintAttributes { return 768 }
    
    @available(iOS 8.0, *)
    internal static var margins: ConstraintAttributes { return 61440 }
    
    @available(iOS 8.0, *)
    internal static var centerWithinMargins: ConstraintAttributes { return 786432 }
    
    internal var layoutAttributes:[LayoutAttribute] {
        var attrs = [LayoutAttribute]()
        if (self.contains(ConstraintAttributes.left)) {
            attrs.append(.left)
        }
        if (self.contains(ConstraintAttributes.top)) {
            attrs.append(.top)
        }
        if (self.contains(ConstraintAttributes.right)) {
            attrs.append(.right)
        }
        if (self.contains(ConstraintAttributes.bottom)) {
            attrs.append(.bottom)
        }
        if (self.contains(ConstraintAttributes.leading)) {
            attrs.append(.leading)
        }
        if (self.contains(ConstraintAttributes.trailing)) {
            attrs.append(.trailing)
        }
        if (self.contains(ConstraintAttributes.width)) {
            attrs.append(.width)
        }
        if (self.contains(ConstraintAttributes.height)) {
            attrs.append(.height)
        }
        if (self.contains(ConstraintAttributes.centerX)) {
            attrs.append(.centerX)
        }
        if (self.contains(ConstraintAttributes.centerY)) {
            attrs.append(.centerY)
        }
        if (self.contains(ConstraintAttributes.lastBaseline)) {
            attrs.append(.lastBaseline)
        }
        
        #if os(iOS) || os(tvOS)
            if (self.contains(ConstraintAttributes.firstBaseline)) {
                attrs.append(.firstBaseline)
            }
            if (self.contains(ConstraintAttributes.leftMargin)) {
                attrs.append(.leftMargin)
            }
            if (self.contains(ConstraintAttributes.rightMargin)) {
                attrs.append(.rightMargin)
            }
            if (self.contains(ConstraintAttributes.topMargin)) {
                attrs.append(.topMargin)
            }
            if (self.contains(ConstraintAttributes.bottomMargin)) {
                attrs.append(.bottomMargin)
            }
            if (self.contains(ConstraintAttributes.leadingMargin)) {
                attrs.append(.leadingMargin)
            }
            if (self.contains(ConstraintAttributes.trailingMargin)) {
                attrs.append(.trailingMargin)
            }
            if (self.contains(ConstraintAttributes.centerXWithinMargins)) {
                attrs.append(.centerXWithinMargins)
            }
            if (self.contains(ConstraintAttributes.centerYWithinMargins)) {
                attrs.append(.centerYWithinMargins)
            }
        #endif
        
        return attrs
    }
}
internal func + (left: ConstraintAttributes, right: ConstraintAttributes) -> ConstraintAttributes {
    return left.union(right)
}
internal func +=(left: inout ConstraintAttributes, right: ConstraintAttributes) {
    left.formUnion(right)
}
internal func -=(left: inout ConstraintAttributes, right: ConstraintAttributes) {
    left.subtract(right)
}
internal func ==(left: ConstraintAttributes, right: ConstraintAttributes) -> Bool {
    return left.rawValue == right.rawValue
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public struct ConstraintViewDSL: ConstraintAttributesDSL {
    
    @discardableResult
    public func prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return ConstraintMaker.prepareConstraints(item: self.view, closure: closure)
    }
    
    public func makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.makeConstraints(item: self.view, closure: closure)
    }
    
    public func remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.remakeConstraints(item: self.view, closure: closure)
    }
    
    public func updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.updateConstraints(item: self.view, closure: closure)
    }
    
    public func removeConstraints() {
        ConstraintMaker.removeConstraints(item: self.view)
    }
    
    public var contentHuggingHorizontalPriority: Float {
        get {
            return self.view.contentHuggingPriority(for: .horizontal).rawValue
        }
        set {
            self.view.setContentHuggingPriority(LayoutPriority(rawValue: newValue), for: .horizontal)
        }
    }
    
    public var contentHuggingVerticalPriority: Float {
        get {
            return self.view.contentHuggingPriority(for: .vertical).rawValue
        }
        set {
            self.view.setContentHuggingPriority(LayoutPriority(rawValue: newValue), for: .vertical)
        }
    }
    
    public var contentCompressionResistanceHorizontalPriority: Float {
        get {
            return self.view.contentCompressionResistancePriority(for: .horizontal).rawValue
        }
        set {
            self.view.setContentCompressionResistancePriority(LayoutPriority(rawValue: newValue), for: .horizontal)
        }
    }
    
    public var contentCompressionResistanceVerticalPriority: Float {
        get {
            return self.view.contentCompressionResistancePriority(for: .vertical).rawValue
        }
        set {
            self.view.setContentCompressionResistancePriority(LayoutPriority(rawValue: newValue), for: .vertical)
        }
    }
    
    public var target: AnyObject? {
        return self.view
    }
    
    internal let view: ConstraintView
    
    internal init(view: ConstraintView) {
        self.view = view
        
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public protocol ConstraintPriorityTarget {
    
    var constraintPriorityTargetValue: Float { get }
    
}
extension Int: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}
extension UInt: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}
extension Float: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return self
    }
    
}
extension Double: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}
extension CGFloat: ConstraintPriorityTarget {
    
    public var constraintPriorityTargetValue: Float {
        return Float(self)
    }
    
}
#if os(iOS) || os(tvOS)
extension UILayoutPriority: ConstraintPriorityTarget {
    public var constraintPriorityTargetValue: Float {
        return self.rawValue
    }
}
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
#if os(iOS) || os(tvOS)
    public typealias ConstraintInsets = UIEdgeInsets
#else
    public typealias ConstraintInsets = NSEdgeInsets
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public class ConstraintMakerFinalizable {
    
    internal let description: ConstraintDescription
    
    internal init(_ description: ConstraintDescription) {
        self.description = description
    }
    
    @discardableResult
    public func labeled(_ label: String) -> ConstraintMakerFinalizable {
        self.description.label = label
        return self
    }
    
    public var constraint: Constraint {
        return self.description.constraint!
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public protocol ConstraintDSL {
    
    var target: AnyObject? { get }
    
    func setLabel(_ value: String?)
    func label() -> String?
    
}
extension ConstraintDSL {
    
    public func setLabel(_ value: String?) {
        objc_setAssociatedObject(self.target as Any, &labelKey, value, .OBJC_ASSOCIATION_COPY_NONATOMIC)
    }
    public func label() -> String? {
        return objc_getAssociatedObject(self.target as Any, &labelKey) as? String
    }
    
}
private var labelKey: UInt8 = 0
public protocol ConstraintBasicAttributesDSL : ConstraintDSL {
}
extension ConstraintBasicAttributesDSL {
    
    // MARK: Basics
    
    public var left: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.left)
    }
    
    public var top: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.top)
    }
    
    public var right: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.right)
    }
    
    public var bottom: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottom)
    }
    
    public var leading: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leading)
    }
    
    public var trailing: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.trailing)
    }
    
    public var width: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.width)
    }
    
    public var height: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.height)
    }
    
    public var centerX: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerX)
    }
    
    public var centerY: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerY)
    }
    
    public var edges: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.edges)
    }
    
    public var size: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.size)
    }
    
    public var center: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.center)
    }
    
}
public protocol ConstraintAttributesDSL : ConstraintBasicAttributesDSL {
}
extension ConstraintAttributesDSL {
    
    // MARK: Baselines
    
    @available(*, deprecated:3.0, message:"Use .lastBaseline instead")
    public var baseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var lastBaseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.firstBaseline)
    }
    
    // MARK: Margins
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leftMargin)
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.topMargin)
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.rightMargin)
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottomMargin)
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.leadingMargin)
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.trailingMargin)
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerXWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerYWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.margins)
    }
    
    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.centerWithinMargins)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public class ConstraintMakerExtendable: ConstraintMakerRelatable {
    
    public var left: ConstraintMakerExtendable {
        self.description.attributes += .left
        return self
    }
    
    public var top: ConstraintMakerExtendable {
        self.description.attributes += .top
        return self
    }
    
    public var bottom: ConstraintMakerExtendable {
        self.description.attributes += .bottom
        return self
    }
    
    public var right: ConstraintMakerExtendable {
        self.description.attributes += .right
        return self
    }
    
    public var leading: ConstraintMakerExtendable {
        self.description.attributes += .leading
        return self
    }
    
    public var trailing: ConstraintMakerExtendable {
        self.description.attributes += .trailing
        return self
    }
    
    public var width: ConstraintMakerExtendable {
        self.description.attributes += .width
        return self
    }
    
    public var height: ConstraintMakerExtendable {
        self.description.attributes += .height
        return self
    }
    
    public var centerX: ConstraintMakerExtendable {
        self.description.attributes += .centerX
        return self
    }
    
    public var centerY: ConstraintMakerExtendable {
        self.description.attributes += .centerY
        return self
    }
    
    @available(*, deprecated:3.0, message:"Use lastBaseline instead")
    public var baseline: ConstraintMakerExtendable {
        self.description.attributes += .lastBaseline
        return self
    }
    
    public var lastBaseline: ConstraintMakerExtendable {
        self.description.attributes += .lastBaseline
        return self
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintMakerExtendable {
        self.description.attributes += .firstBaseline
        return self
    }
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintMakerExtendable {
        self.description.attributes += .leftMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintMakerExtendable {
        self.description.attributes += .rightMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintMakerExtendable {
        self.description.attributes += .topMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintMakerExtendable {
        self.description.attributes += .bottomMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintMakerExtendable {
        self.description.attributes += .leadingMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintMakerExtendable {
        self.description.attributes += .trailingMargin
        return self
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerXWithinMargins
        return self
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerYWithinMargins
        return self
    }
    
    public var edges: ConstraintMakerExtendable {
        self.description.attributes += .edges
        return self
    }
    public var size: ConstraintMakerExtendable {
        self.description.attributes += .size
        return self
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintMakerExtendable {
        self.description.attributes += .margins
        return self
    }
    
    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintMakerExtendable {
        self.description.attributes += .centerWithinMargins
        return self
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public struct ConstraintPriority : ExpressibleByFloatLiteral, Equatable, Strideable {
    public typealias FloatLiteralType = Float
    
    public let value: Float
    
    public init(floatLiteral value: Float) {
        self.value = value
    }
    
    public init(_ value: Float) {
        self.value = value
    }
    
    public static var required: ConstraintPriority {
        return 1000.0
    }
    
    public static var high: ConstraintPriority {
        return 750.0
    }
    
    public static var medium: ConstraintPriority {
        #if os(OSX)
            return 501.0
        #else
            return 500.0
        #endif
        
    }
    
    public static var low: ConstraintPriority {
        return 250.0
    }
    
    public static func ==(lhs: ConstraintPriority, rhs: ConstraintPriority) -> Bool {
        return lhs.value == rhs.value
    }
    // MARK: Strideable
    public func advanced(by n: FloatLiteralType) -> ConstraintPriority {
        return ConstraintPriority(floatLiteral: value + n)
    }
    public func distance(to other: ConstraintPriority) -> FloatLiteralType {
        return other.value - value
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public protocol ConstraintInsetTarget: ConstraintConstantTarget {
}
extension Int: ConstraintInsetTarget {
}
extension UInt: ConstraintInsetTarget {
}
extension Float: ConstraintInsetTarget {
}
extension Double: ConstraintInsetTarget {
}
extension CGFloat: ConstraintInsetTarget {
}
extension ConstraintInsets: ConstraintInsetTarget {
}
extension ConstraintInsetTarget {
    internal var constraintInsetTargetValue: ConstraintInsets {
        if let amount = self as? ConstraintInsets {
            return amount
        } else if let amount = self as? Float {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? Double {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? CGFloat {
            return ConstraintInsets(top: amount, left: amount, bottom: amount, right: amount)
        } else if let amount = self as? Int {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else if let amount = self as? UInt {
            return ConstraintInsets(top: CGFloat(amount), left: CGFloat(amount), bottom: CGFloat(amount), right: CGFloat(amount))
        } else {
            return ConstraintInsets(top: 0, left: 0, bottom: 0, right: 0)
        }
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
    public typealias ConstraintInterfaceLayoutDirection = UIUserInterfaceLayoutDirection
#else
    import AppKit
    public typealias ConstraintInterfaceLayoutDirection = NSUserInterfaceLayoutDirection
#endif
public struct ConstraintConfig {
    
    public static var interfaceLayoutDirection: ConstraintInterfaceLayoutDirection = .leftToRight
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#endif
    
@available(iOS 8.0, *)
public extension ConstraintLayoutSupport {
    
    public var snp: ConstraintLayoutSupportDSL {
        return ConstraintLayoutSupportDSL(support: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
#if os(iOS) || os(tvOS)
    public typealias ConstraintView = UIView
#else
    public typealias ConstraintView = NSView
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
#if os(iOS) || os(tvOS)
    @available(iOS 9.0, *)
    public typealias ConstraintLayoutGuide = UILayoutGuide
#else
    @available(OSX 10.11, *)
    public typealias ConstraintLayoutGuide = NSLayoutGuide
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
#if os(iOS) || os(tvOS)
    @available(iOS 8.0, *)
    public typealias ConstraintLayoutSupport = UILayoutSupport
#else
    public class ConstraintLayoutSupport {}
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
#if os(iOS) || os(tvOS)
    import UIKit
#if swift(>=4.2)
    typealias LayoutRelation = NSLayoutConstraint.Relation
    typealias LayoutAttribute = NSLayoutConstraint.Attribute
#else
    typealias LayoutRelation = NSLayoutRelation
    typealias LayoutAttribute = NSLayoutAttribute
#endif
    typealias LayoutPriority = UILayoutPriority
#else
    import AppKit
    typealias LayoutRelation = NSLayoutConstraint.Relation
    typealias LayoutAttribute = NSLayoutConstraint.Attribute
    typealias LayoutPriority = NSLayoutConstraint.Priority
#endif
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public protocol ConstraintConstantTarget {
}
extension CGPoint: ConstraintConstantTarget {
}
extension CGSize: ConstraintConstantTarget {    
}
extension ConstraintInsets: ConstraintConstantTarget {
}
extension ConstraintConstantTarget {
    
    internal func constraintConstantTargetValueFor(layoutAttribute: LayoutAttribute) -> CGFloat {
        if let value = self as? CGFloat {
            return value
        }
        
        if let value = self as? Float {
            return CGFloat(value)
        }
        
        if let value = self as? Double {
            return CGFloat(value)
        }
        
        if let value = self as? Int {
            return CGFloat(value)
        }
        
        if let value = self as? UInt {
            return CGFloat(value)
        }
        
        if let value = self as? CGSize {
            if layoutAttribute == .width {
                return value.width
            } else if layoutAttribute == .height {
                return value.height
            } else {
                return 0.0
            }
        }
        
        if let value = self as? CGPoint {
            #if os(iOS) || os(tvOS)
                switch layoutAttribute {
                case .left, .right, .leading, .trailing, .centerX, .leftMargin, .rightMargin, .leadingMargin, .trailingMargin, .centerXWithinMargins:
                    return value.x
                case .top, .bottom, .centerY, .topMargin, .bottomMargin, .centerYWithinMargins, .lastBaseline, .firstBaseline:
                    return value.y
                case .width, .height, .notAnAttribute:
                    return 0.0
                }
            #else
                switch layoutAttribute {
                case .left, .right, .leading, .trailing, .centerX:
                    return value.x
                case .top, .bottom, .centerY, .lastBaseline, .firstBaseline:
                    return value.y
                case .width, .height, .notAnAttribute:
                    return 0.0
                }
            #endif
        }
        
        if let value = self as? ConstraintInsets {
            #if os(iOS) || os(tvOS)
                switch layoutAttribute {
                case .left, .leftMargin, .centerX, .centerXWithinMargins:
                    return value.left
                case .top, .topMargin, .centerY, .centerYWithinMargins, .lastBaseline, .firstBaseline:
                    return value.top
                case .right, .rightMargin:
                    return -value.right
                case .bottom, .bottomMargin:
                    return -value.bottom
                case .leading, .leadingMargin:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? value.left : value.right
                case .trailing, .trailingMargin:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? -value.right : -value.left
                case .width:
                    return -(value.left + value.right)
                case .height:
                    return -(value.top + value.bottom)
                case .notAnAttribute:
                    return 0.0
                }
            #else
                switch layoutAttribute {
                case .left, .centerX:
                    return value.left
                case .top, .centerY, .lastBaseline, .firstBaseline:
                    return value.top
                case .right:
                    return -value.right
                case .bottom:
                    return -value.bottom
                case .leading:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? value.left : value.right
                case .trailing:
                    return (ConstraintConfig.interfaceLayoutDirection == .leftToRight) ? -value.right : -value.left
                case .width:
                    return -(value.left + value.right)
                case .height:
                    return -(value.top + value.bottom)
                case .notAnAttribute:
                    return 0.0
                }
            #endif
        }
        
        return 0.0
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public protocol ConstraintOffsetTarget: ConstraintConstantTarget {
}
extension Int: ConstraintOffsetTarget {
}
extension UInt: ConstraintOffsetTarget {
}
extension Float: ConstraintOffsetTarget {
}
extension Double: ConstraintOffsetTarget {
}
extension CGFloat: ConstraintOffsetTarget {
}
extension ConstraintOffsetTarget {
    
    internal var constraintOffsetTargetValue: CGFloat {
        let offset: CGFloat
        if let amount = self as? Float {
            offset = CGFloat(amount)
        } else if let amount = self as? Double {
            offset = CGFloat(amount)
        } else if let amount = self as? CGFloat {
            offset = CGFloat(amount)
        } else if let amount = self as? Int {
            offset = CGFloat(amount)
        } else if let amount = self as? UInt {
            offset = CGFloat(amount)
        } else {
            offset = 0.0
        }
        return offset
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public class ConstraintMakerEditable: ConstraintMakerPriortizable {
    @discardableResult
    public func multipliedBy(_ amount: ConstraintMultiplierTarget) -> ConstraintMakerEditable {
        self.description.multiplier = amount
        return self
    }
    
    @discardableResult
    public func dividedBy(_ amount: ConstraintMultiplierTarget) -> ConstraintMakerEditable {
        return self.multipliedBy(1.0 / amount.constraintMultiplierTargetValue)
    }
    
    @discardableResult
    public func offset(_ amount: ConstraintOffsetTarget) -> ConstraintMakerEditable {
        self.description.constant = amount.constraintOffsetTargetValue
        return self
    }
    
    @discardableResult
    public func inset(_ amount: ConstraintInsetTarget) -> ConstraintMakerEditable {
        self.description.constant = amount.constraintInsetTargetValue
        return self
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public class ConstraintMaker {
    
    public var left: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.left)
    }
    
    public var top: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.top)
    }
    
    public var bottom: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.bottom)
    }
    
    public var right: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.right)
    }
    
    public var leading: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leading)
    }
    
    public var trailing: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.trailing)
    }
    
    public var width: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.width)
    }
    
    public var height: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.height)
    }
    
    public var centerX: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerX)
    }
    
    public var centerY: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerY)
    }
    
    @available(*, deprecated:3.0, message:"Use lastBaseline instead")
    public var baseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.lastBaseline)
    }
    
    public var lastBaseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.lastBaseline)
    }
    
    @available(iOS 8.0, OSX 10.11, *)
    public var firstBaseline: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.firstBaseline)
    }
    
    @available(iOS 8.0, *)
    public var leftMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leftMargin)
    }
    
    @available(iOS 8.0, *)
    public var rightMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.rightMargin)
    }
    
    @available(iOS 8.0, *)
    public var topMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.topMargin)
    }
    
    @available(iOS 8.0, *)
    public var bottomMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.bottomMargin)
    }
    
    @available(iOS 8.0, *)
    public var leadingMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.leadingMargin)
    }
    
    @available(iOS 8.0, *)
    public var trailingMargin: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.trailingMargin)
    }
    
    @available(iOS 8.0, *)
    public var centerXWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerXWithinMargins)
    }
    
    @available(iOS 8.0, *)
    public var centerYWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerYWithinMargins)
    }
    
    public var edges: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.edges)
    }
    public var size: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.size)
    }
    public var center: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.center)
    }
    
    @available(iOS 8.0, *)
    public var margins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.margins)
    }
    
    @available(iOS 8.0, *)
    public var centerWithinMargins: ConstraintMakerExtendable {
        return self.makeExtendableWithAttributes(.centerWithinMargins)
    }
    
    private let item: LayoutConstraintItem
    private var descriptions = [ConstraintDescription]()
    
    internal init(item: LayoutConstraintItem) {
        self.item = item
        self.item.prepare()
    }
    
    internal func makeExtendableWithAttributes(_ attributes: ConstraintAttributes) -> ConstraintMakerExtendable {
        let description = ConstraintDescription(item: self.item, attributes: attributes)
        self.descriptions.append(description)
        return ConstraintMakerExtendable(description)
    }
    
    internal static func prepareConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        let maker = ConstraintMaker(item: item)
        closure(maker)
        var constraints: [Constraint] = []
        for description in maker.descriptions {
            guard let constraint = description.constraint else {
                continue
            }
            constraints.append(constraint)
        }
        return constraints
    }
    
    internal static func makeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        let constraints = prepareConstraints(item: item, closure: closure)
        for constraint in constraints {
            constraint.activateIfNeeded(updatingExisting: false)
        }
    }
    
    internal static func remakeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        self.removeConstraints(item: item)
        self.makeConstraints(item: item, closure: closure)
    }
    
    internal static func updateConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -> Void) {
        guard item.constraints.count > 0 else {
            self.makeConstraints(item: item, closure: closure)
            return
        }
        
        let constraints = prepareConstraints(item: item, closure: closure)
        for constraint in constraints {
            constraint.activateIfNeeded(updatingExisting: true)
        }
    }
    
    internal static func removeConstraints(item: LayoutConstraintItem) {
        let constraints = item.constraints
        for constraint in constraints {
            constraint.deactivateIfNeeded()
        }
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
internal enum ConstraintRelation : Int {
    case equal = 1
    case lessThanOrEqual
    case greaterThanOrEqual
    
    internal var layoutRelation: LayoutRelation {
        get {
            switch(self) {
            case .equal:
                return .equal
            case .lessThanOrEqual:
                return .lessThanOrEqual
            case .greaterThanOrEqual:
                return .greaterThanOrEqual
            }
        }
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
@available(iOS 9.0, OSX 10.11, *)
public struct ConstraintLayoutGuideDSL: ConstraintAttributesDSL {
    
    @discardableResult
    public func prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return ConstraintMaker.prepareConstraints(item: self.guide, closure: closure)
    }
    
    public func makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.makeConstraints(item: self.guide, closure: closure)
    }
    
    public func remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.remakeConstraints(item: self.guide, closure: closure)
    }
    
    public func updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        ConstraintMaker.updateConstraints(item: self.guide, closure: closure)
    }
    
    public func removeConstraints() {
        ConstraintMaker.removeConstraints(item: self.guide)
    }
    
    public var target: AnyObject? {
        return self.guide
    }
    
    internal let guide: ConstraintLayoutGuide
    
    internal init(guide: ConstraintLayoutGuide) {
        self.guide = guide
        
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public extension ConstraintView {
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_left: ConstraintItem { return self.snp.left }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_top: ConstraintItem { return self.snp.top }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_right: ConstraintItem { return self.snp.right }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_bottom: ConstraintItem { return self.snp.bottom }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_leading: ConstraintItem { return self.snp.leading }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_trailing: ConstraintItem { return self.snp.trailing }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_width: ConstraintItem { return self.snp.width }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_height: ConstraintItem { return self.snp.height }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_centerX: ConstraintItem { return self.snp.centerX }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_centerY: ConstraintItem { return self.snp.centerY }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_baseline: ConstraintItem { return self.snp.baseline }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, OSX 10.11, *)
    public var snp_lastBaseline: ConstraintItem { return self.snp.lastBaseline }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, OSX 10.11, *)
    public var snp_firstBaseline: ConstraintItem { return self.snp.firstBaseline }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_leftMargin: ConstraintItem { return self.snp.leftMargin }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_topMargin: ConstraintItem { return self.snp.topMargin }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_rightMargin: ConstraintItem { return self.snp.rightMargin }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_bottomMargin: ConstraintItem { return self.snp.bottomMargin }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_leadingMargin: ConstraintItem { return self.snp.leadingMargin }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_trailingMargin: ConstraintItem { return self.snp.trailingMargin }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_centerXWithinMargins: ConstraintItem { return self.snp.centerXWithinMargins }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_centerYWithinMargins: ConstraintItem { return self.snp.centerYWithinMargins }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_edges: ConstraintItem { return self.snp.edges }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_size: ConstraintItem { return self.snp.size }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public var snp_center: ConstraintItem { return self.snp.center }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_margins: ConstraintItem { return self.snp.margins }
    
    @available(iOS, deprecated:3.0, message:"Use newer snp.* syntax.")
    @available(iOS 8.0, *)
    public var snp_centerWithinMargins: ConstraintItem { return self.snp.centerWithinMargins }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public func snp_prepareConstraints(_ closure: (_ make: ConstraintMaker) -> Void) -> [Constraint] {
        return self.snp.prepareConstraints(closure)
    }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public func snp_makeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.makeConstraints(closure)
    }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public func snp_remakeConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.remakeConstraints(closure)
    }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public func snp_updateConstraints(_ closure: (_ make: ConstraintMaker) -> Void) {
        self.snp.updateConstraints(closure)
    }
    
    @available(*, deprecated:3.0, message:"Use newer snp.* syntax.")
    public func snp_removeConstraints() {
        self.snp.removeConstraints()
    }
    
    public var snp: ConstraintViewDSL {
        return ConstraintViewDSL(view: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public final class ConstraintItem {
    
    internal weak var target: AnyObject?
    internal let attributes: ConstraintAttributes
    
    internal init(target: AnyObject?, attributes: ConstraintAttributes) {
        self.target = target
        self.attributes = attributes
    }
    
    internal var layoutConstraintItem: LayoutConstraintItem? {
        return self.target as? LayoutConstraintItem
    }
    
}
public func ==(lhs: ConstraintItem, rhs: ConstraintItem) -> Bool {
    // pointer equality
    guard lhs !== rhs else {
        return true
    }
    
    // must both have valid targets and identical attributes
    guard let target1 = lhs.target,
          let target2 = rhs.target,
          target1 === target2 && lhs.attributes == rhs.attributes else {
            return false
    }
    
    return true
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public final class Constraint {
    internal let sourceLocation: (String, UInt)
    internal let label: String?
    private let from: ConstraintItem
    private let to: ConstraintItem
    private let relation: ConstraintRelation
    private let multiplier: ConstraintMultiplierTarget
    private var constant: ConstraintConstantTarget {
        didSet {
            self.updateConstantAndPriorityIfNeeded()
        }
    }
    private var priority: ConstraintPriorityTarget {
        didSet {
          self.updateConstantAndPriorityIfNeeded()
        }
    }
    public var layoutConstraints: [LayoutConstraint]
    
    public var isActive: Bool {
        set {
            if newValue {
                activate()
            }
            else {
                deactivate()
            }
        }
        
        get {
            for layoutConstraint in self.layoutConstraints {
                if layoutConstraint.isActive {
                    return true
                }
            }
            return false
        }
    }
    
    // MARK: Initialization
    internal init(from: ConstraintItem,
                  to: ConstraintItem,
                  relation: ConstraintRelation,
                  sourceLocation: (String, UInt),
                  label: String?,
                  multiplier: ConstraintMultiplierTarget,
                  constant: ConstraintConstantTarget,
                  priority: ConstraintPriorityTarget) {
        self.from = from
        self.to = to
        self.relation = relation
        self.sourceLocation = sourceLocation
        self.label = label
        self.multiplier = multiplier
        self.constant = constant
        self.priority = priority
        self.layoutConstraints = []
        // get attributes
        let layoutFromAttributes = self.from.attributes.layoutAttributes
        let layoutToAttributes = self.to.attributes.layoutAttributes
        // get layout from
        let layoutFrom = self.from.layoutConstraintItem!
        // get relation
        let layoutRelation = self.relation.layoutRelation
        for layoutFromAttribute in layoutFromAttributes {
            // get layout to attribute
            let layoutToAttribute: LayoutAttribute
            #if os(iOS) || os(tvOS)
                if layoutToAttributes.count > 0 {
                    if self.from.attributes == .edges && self.to.attributes == .margins {
                        switch layoutFromAttribute {
                        case .left:
                            layoutToAttribute = .leftMargin
                        case .right:
                            layoutToAttribute = .rightMargin
                        case .top:
                            layoutToAttribute = .topMargin
                        case .bottom:
                            layoutToAttribute = .bottomMargin
                        default:
                            fatalError()
                        }
                    } else if self.from.attributes == .margins && self.to.attributes == .edges {
                        switch layoutFromAttribute {
                        case .leftMargin:
                            layoutToAttribute = .left
                        case .rightMargin:
                            layoutToAttribute = .right
                        case .topMargin:
                            layoutToAttribute = .top
                        case .bottomMargin:
                            layoutToAttribute = .bottom
                        default:
                            fatalError()
                        }
                    } else if self.from.attributes == self.to.attributes {
                        layoutToAttribute = layoutFromAttribute
                    } else {
                        layoutToAttribute = layoutToAttributes[0]
                    }
                } else {
                    if self.to.target == nil && (layoutFromAttribute == .centerX || layoutFromAttribute == .centerY) {
                        layoutToAttribute = layoutFromAttribute == .centerX ? .left : .top
                    } else {
                        layoutToAttribute = layoutFromAttribute
                    }
                }
            #else
                if self.from.attributes == self.to.attributes {
                    layoutToAttribute = layoutFromAttribute
                } else if layoutToAttributes.count > 0 {
                    layoutToAttribute = layoutToAttributes[0]
                } else {
                    layoutToAttribute = layoutFromAttribute
                }
            #endif
            // get layout constant
            let layoutConstant: CGFloat = self.constant.constraintConstantTargetValueFor(layoutAttribute: layoutToAttribute)
            // get layout to
            var layoutTo: AnyObject? = self.to.target
            // use superview if possible
            if layoutTo == nil && layoutToAttribute != .width && layoutToAttribute != .height {
                layoutTo = layoutFrom.superview
            }
            // create layout constraint
            let layoutConstraint = LayoutConstraint(
                item: layoutFrom,
                attribute: layoutFromAttribute,
                relatedBy: layoutRelation,
                toItem: layoutTo,
                attribute: layoutToAttribute,
                multiplier: self.multiplier.constraintMultiplierTargetValue,
                constant: layoutConstant
            )
            // set label
            layoutConstraint.label = self.label
            // set priority
            layoutConstraint.priority = LayoutPriority(rawValue: self.priority.constraintPriorityTargetValue)
            // set constraint
            layoutConstraint.constraint = self
            // append
            self.layoutConstraints.append(layoutConstraint)
        }
    }
    // MARK: Public
    @available(*, deprecated:3.0, message:"Use activate().")
    public func install() {
        self.activate()
    }
    @available(*, deprecated:3.0, message:"Use deactivate().")
    public func uninstall() {
        self.deactivate()
    }
    public func activate() {
        self.activateIfNeeded()
    }
    public func deactivate() {
        self.deactivateIfNeeded()
    }
    @discardableResult
    public func update(offset: ConstraintOffsetTarget) -> Constraint {
        self.constant = offset.constraintOffsetTargetValue
        return self
    }
    @discardableResult
    public func update(inset: ConstraintInsetTarget) -> Constraint {
        self.constant = inset.constraintInsetTargetValue
        return self
    }
    @discardableResult
    public func update(priority: ConstraintPriorityTarget) -> Constraint {
        self.priority = priority.constraintPriorityTargetValue
        return self
    }
    @discardableResult
    public func update(priority: ConstraintPriority) -> Constraint {
        self.priority = priority.value
        return self
    }
    @available(*, deprecated:3.0, message:"Use update(offset: ConstraintOffsetTarget) instead.")
    public func updateOffset(amount: ConstraintOffsetTarget) -> Void { self.update(offset: amount) }
    @available(*, deprecated:3.0, message:"Use update(inset: ConstraintInsetTarget) instead.")
    public func updateInsets(amount: ConstraintInsetTarget) -> Void { self.update(inset: amount) }
    @available(*, deprecated:3.0, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriority(amount: ConstraintPriorityTarget) -> Void { self.update(priority: amount) }
    @available(*, obsoleted:3.0, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityRequired() -> Void {}
    @available(*, obsoleted:3.0, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityHigh() -> Void { fatalError("Must be implemented by Concrete subclass.") }
    @available(*, obsoleted:3.0, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityMedium() -> Void { fatalError("Must be implemented by Concrete subclass.") }
    @available(*, obsoleted:3.0, message:"Use update(priority: ConstraintPriorityTarget) instead.")
    public func updatePriorityLow() -> Void { fatalError("Must be implemented by Concrete subclass.") }
    // MARK: Internal
    internal func updateConstantAndPriorityIfNeeded() {
        for layoutConstraint in self.layoutConstraints {
            let attribute = (layoutConstraint.secondAttribute == .notAnAttribute) ? layoutConstraint.firstAttribute : layoutConstraint.secondAttribute
            layoutConstraint.constant = self.constant.constraintConstantTargetValueFor(layoutAttribute: attribute)
            let requiredPriority = ConstraintPriority.required.value
            if (layoutConstraint.priority.rawValue < requiredPriority), (self.priority.constraintPriorityTargetValue != requiredPriority) {
                layoutConstraint.priority = LayoutPriority(rawValue: self.priority.constraintPriorityTargetValue)
            }
        }
    }
    internal func activateIfNeeded(updatingExisting: Bool = false) {
        guard let item = self.from.layoutConstraintItem else {
            print("WARNING: SnapKit failed to get from item from constraint. Activate will be a no-op.")
            return
        }
        let layoutConstraints = self.layoutConstraints
        if updatingExisting {
            var existingLayoutConstraints: [LayoutConstraint] = []
            for constraint in item.constraints {
                existingLayoutConstraints += constraint.layoutConstraints
            }
            for layoutConstraint in layoutConstraints {
                let existingLayoutConstraint = existingLayoutConstraints.first { $0 == layoutConstraint }
                guard let updateLayoutConstraint = existingLayoutConstraint else {
                    fatalError("Updated constraint could not find existing matching constraint to update: \(layoutConstraint)")
                }
                let updateLayoutAttribute = (updateLayoutConstraint.secondAttribute == .notAnAttribute) ? updateLayoutConstraint.firstAttribute : updateLayoutConstraint.secondAttribute
                updateLayoutConstraint.constant = self.constant.constraintConstantTargetValueFor(layoutAttribute: updateLayoutAttribute)
            }
        } else {
            NSLayoutConstraint.activate(layoutConstraints)
            item.add(constraints: [self])
        }
    }
    internal func deactivateIfNeeded() {
        guard let item = self.from.layoutConstraintItem else {
            print("WARNING: SnapKit failed to get from item from constraint. Deactivate will be a no-op.")
            return
        }
        let layoutConstraints = self.layoutConstraints
        NSLayoutConstraint.deactivate(layoutConstraints)
        item.remove(constraints: [self])
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public extension LayoutConstraint {
    
    override public var description: String {
        var description = "<"
        
        description += descriptionForObject(self)
        
        if let firstItem = conditionalOptional(from: self.firstItem) {
            description += " \(descriptionForObject(firstItem))"
        }
        
        if self.firstAttribute != .notAnAttribute {
            description += ".\(descriptionForAttribute(self.firstAttribute))"
        }
        
        description += " \(descriptionForRelation(self.relation))"
        
        if let secondItem = self.secondItem {
            description += " \(descriptionForObject(secondItem))"
        }
        
        if self.secondAttribute != .notAnAttribute {
            description += ".\(descriptionForAttribute(self.secondAttribute))"
        }
        
        if self.multiplier != 1.0 {
            description += " * \(self.multiplier)"
        }
        
        if self.secondAttribute == .notAnAttribute {
            description += " \(self.constant)"
        } else {
            if self.constant > 0.0 {
                description += " + \(self.constant)"
            } else if self.constant < 0.0 {
                description += " - \(abs(self.constant))"
            }
        }
        
        if self.priority.rawValue != 1000.0 {
            description += " ^\(self.priority)"
        }
        
        description += ">"
        
        return description
    }
    
}
private func descriptionForRelation(_ relation: LayoutRelation) -> String {
    switch relation {
    case .equal:                return "=="
    case .greaterThanOrEqual:   return ">="
    case .lessThanOrEqual:      return "<="
    }
}
private func descriptionForAttribute(_ attribute: LayoutAttribute) -> String {
    #if os(iOS) || os(tvOS)
        switch attribute {
        case .notAnAttribute:       return "notAnAttribute"
        case .top:                  return "top"
        case .left:                 return "left"
        case .bottom:               return "bottom"
        case .right:                return "right"
        case .leading:              return "leading"
        case .trailing:             return "trailing"
        case .width:                return "width"
        case .height:               return "height"
        case .centerX:              return "centerX"
        case .centerY:              return "centerY"
        case .lastBaseline:         return "lastBaseline"
        case .firstBaseline:        return "firstBaseline"
        case .topMargin:            return "topMargin"
        case .leftMargin:           return "leftMargin"
        case .bottomMargin:         return "bottomMargin"
        case .rightMargin:          return "rightMargin"
        case .leadingMargin:        return "leadingMargin"
        case .trailingMargin:       return "trailingMargin"
        case .centerXWithinMargins: return "centerXWithinMargins"
        case .centerYWithinMargins: return "centerYWithinMargins"
        }
    #else
        switch attribute {
        case .notAnAttribute:       return "notAnAttribute"
        case .top:                  return "top"
        case .left:                 return "left"
        case .bottom:               return "bottom"
        case .right:                return "right"
        case .leading:              return "leading"
        case .trailing:             return "trailing"
        case .width:                return "width"
        case .height:               return "height"
        case .centerX:              return "centerX"
        case .centerY:              return "centerY"
        case .lastBaseline:         return "lastBaseline"
        case .firstBaseline:        return "firstBaseline"
        }
    #endif
}
private func conditionalOptional<T>(from object: Optional<T>) -> Optional<T> {
    return object
}
private func conditionalOptional<T>(from object: T) -> Optional<T> {
    return Optional.some(object)
}
private func descriptionForObject(_ object: AnyObject) -> String {
    let pointerDescription = String(format: "%p", UInt(bitPattern: ObjectIdentifier(object)))
    var desc = ""
    
    desc += type(of: object).description()
    
    if let object = object as? ConstraintView {
        desc += ":\(object.snp.label() ?? pointerDescription)"
    } else if let object = object as? LayoutConstraint {
        desc += ":\(object.label ?? pointerDescription)"
    } else {
        desc += ":\(pointerDescription)"
    }
    
    if let object = object as? LayoutConstraint, let file = object.constraint?.sourceLocation.0, let line = object.constraint?.sourceLocation.1 {
        desc += "@\((file as NSString).lastPathComponent)#\(line)"
    }
    
    desc += ""
    return desc
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public protocol ConstraintRelatableTarget {
}
extension Int: ConstraintRelatableTarget {
}
extension UInt: ConstraintRelatableTarget {
}
extension Float: ConstraintRelatableTarget {
}
extension Double: ConstraintRelatableTarget {
}
extension CGFloat: ConstraintRelatableTarget {
}
extension CGSize: ConstraintRelatableTarget {
}
extension CGPoint: ConstraintRelatableTarget {
}
extension ConstraintInsets: ConstraintRelatableTarget {
}
extension ConstraintItem: ConstraintRelatableTarget {
}
extension ConstraintView: ConstraintRelatableTarget {
}
@available(iOS 9.0, OSX 10.11, *)
extension ConstraintLayoutGuide: ConstraintRelatableTarget {
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public class LayoutConstraint : NSLayoutConstraint {
    
    public var label: String? {
        get {
            return self.identifier
        }
        set {
            self.identifier = newValue
        }
    }
    
    internal weak var constraint: Constraint? = nil
    
}
internal func ==(lhs: LayoutConstraint, rhs: LayoutConstraint) -> Bool {
    guard lhs.firstItem === rhs.firstItem &&
          lhs.secondItem === rhs.secondItem &&
          lhs.firstAttribute == rhs.firstAttribute &&
          lhs.secondAttribute == rhs.secondAttribute &&
          lhs.relation == rhs.relation &&
          lhs.priority == rhs.priority &&
          lhs.multiplier == rhs.multiplier else {
        return false
    }
    return true
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#endif
    
    
@available(iOS 9.0, OSX 10.11, *)
public extension ConstraintLayoutGuide {
    
    public var snp: ConstraintLayoutGuideDSL {
        return ConstraintLayoutGuideDSL(guide: self)
    }
    
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
@available(iOS 8.0, *)
public struct ConstraintLayoutSupportDSL: ConstraintDSL {
    
    public var target: AnyObject? {
        return self.support
    }
    
    internal let support: ConstraintLayoutSupport
    
    internal init(support: ConstraintLayoutSupport) {
        self.support = support
        
    }
    
    public var top: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.top)
    }
    
    public var bottom: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.bottom)
    }
    
    public var height: ConstraintItem {
        return ConstraintItem(target: self.target, attributes: ConstraintAttributes.height)
    }
}
//
//  SnapKit
//
//  Copyright (c) 2011-Present SnapKit Team - https://github.com/SnapKit
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
    import UIKit
#else
    import AppKit
#endif
public class ConstraintMakerRelatable {
    
    internal let description: ConstraintDescription
    
    internal init(_ description: ConstraintDescription) {
        self.description = description
    }
    
    internal func relatedTo(_ other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt) -> ConstraintMakerEditable {
        let related: ConstraintItem
        let constant: ConstraintConstantTarget
        
        if let other = other as? ConstraintItem {
            guard other.attributes == ConstraintAttributes.none ||
                  other.attributes.layoutAttributes.count <= 1 ||
                  other.attributes.layoutAttributes == self.description.attributes.layoutAttributes ||
                  other.attributes == .edges && self.description.attributes == .margins ||
                  other.attributes == .margins && self.description.attributes == .edges else {
                fatalError("Cannot constraint to multiple non identical attributes. (\(file), \(line))");
            }
            
            related = other
            constant = 0.0
        } else if let other = other as? ConstraintView {
            related = ConstraintItem(target: other, attributes: ConstraintAttributes.none)
            constant = 0.0
        } else if let other = other as? ConstraintConstantTarget {
            related = ConstraintItem(target: nil, attributes: ConstraintAttributes.none)
            constant = other
        } else if #available(iOS 9.0, OSX 10.11, *), let other = other as? ConstraintLayoutGuide {
            related = ConstraintItem(target: other, attributes: ConstraintAttributes.none)
            constant = 0.0
        } else {
            fatalError("Invalid constraint. (\(file), \(line))")
        }
        
        let editable = ConstraintMakerEditable(self.description)
        editable.description.sourceLocation = (file, line)
        editable.description.relation = relation
        editable.description.related = related
        editable.description.constant = constant
        return editable
    }
    
    @discardableResult
    public func equalTo(_ other: ConstraintRelatableTarget, _ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .equal, file: file, line: line)
    }
    
    @discardableResult
    public func equalToSuperview(_ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `equalToSuperview`.")
        }
        return self.relatedTo(other, relation: .equal, file: file, line: line)
    }
    
    @discardableResult
    public func lessThanOrEqualTo(_ other: ConstraintRelatableTarget, _ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .lessThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func lessThanOrEqualToSuperview(_ file: String = #file, _ line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `lessThanOrEqualToSuperview`.")
        }
        return self.relatedTo(other, relation: .lessThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func greaterThanOrEqualTo(_ other: ConstraintRelatableTarget, _ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        return self.relatedTo(other, relation: .greaterThanOrEqual, file: file, line: line)
    }
    
    @discardableResult
    public func greaterThanOrEqualToSuperview(_ file: String = #file, line: UInt = #line) -> ConstraintMakerEditable {
        guard let other = self.description.item.superview else {
            fatalError("Expected superview but found nil when attempting make constraint `greaterThanOrEqualToSuperview`.")
        }
        return self.relatedTo(other, relation: .greaterThanOrEqual, file: file, line: line)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2015 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
import Realm.Private
extension Realm {
    /**
     A `Configuration` instance describes the different options used to create an instance of a Realm.
     `Configuration` instances are just plain Swift structs. Unlike `Realm`s and `Object`s, they can be freely shared
     between threads as long as you do not mutate them.
     Creating configuration values for class subsets (by setting the `objectClasses` property) can be expensive. Because
     of this, you will normally want to cache and reuse a single configuration value for each distinct configuration
     rather than creating a new value each time you open a Realm.
     */
    public struct Configuration {
        // MARK: Default Configuration
        /**
         The default `Configuration` used to create Realms when no configuration is explicitly specified (i.e.
         `Realm()`)
         */
        public static var defaultConfiguration: Configuration {
            get {
                return fromRLMRealmConfiguration(RLMRealmConfiguration.default())
            }
            set {
                RLMRealmConfiguration.setDefault(newValue.rlmConfiguration)
            }
        }
        // MARK: Initialization
        /**
         Creates a `Configuration` which can be used to create new `Realm` instances.
         - note: The `fileURL`, `inMemoryIdentifier`, and `syncConfiguration` parameters are mutually exclusive. Only
                 set one of them, or none if you wish to use the default file URL.
         - parameter fileURL:            The local URL to the Realm file.
         - parameter inMemoryIdentifier: A string used to identify a particular in-memory Realm.
         - parameter syncConfiguration:  For Realms intended to sync with the Realm Object Server, a sync configuration.
         - parameter encryptionKey:      An optional 64-byte key to use to encrypt the data.
         - parameter readOnly:           Whether the Realm is read-only (must be true for read-only files).
         - parameter schemaVersion:      The current schema version.
         - parameter migrationBlock:     The block which migrates the Realm to the current version.
         - parameter deleteRealmIfMigrationNeeded: If `true`, recreate the Realm file with the provided
                                                   schema if a migration is required.
         - parameter shouldCompactOnLaunch: A block called when opening a Realm for the first time during the
                                            life of a process to determine if it should be compacted before being
                                            returned to the user. It is passed the total file size (data + free space)
                                            and the total bytes used by data in the file.
                                            Return `true ` to indicate that an attempt to compact the file should be made.
                                            The compaction will be skipped if another process is accessing it.
         - parameter objectTypes:        The subset of `Object` subclasses persisted in the Realm.
        */
        public init(fileURL: URL? = URL(fileURLWithPath: RLMRealmPathForFile("default.realm"), isDirectory: false),
                    inMemoryIdentifier: String? = nil,
                    syncConfiguration: SyncConfiguration? = nil,
                    encryptionKey: Data? = nil,
                    readOnly: Bool = false,
                    schemaVersion: UInt64 = 0,
                    migrationBlock: MigrationBlock? = nil,
                    deleteRealmIfMigrationNeeded: Bool = false,
                    shouldCompactOnLaunch: ((Int, Int) -> Bool)? = nil,
                    objectTypes: [Object.Type]? = nil) {
                self.fileURL = fileURL
                if let inMemoryIdentifier = inMemoryIdentifier {
                    self.inMemoryIdentifier = inMemoryIdentifier
                }
                if let syncConfiguration = syncConfiguration {
                    self.syncConfiguration = syncConfiguration
                }
                self.encryptionKey = encryptionKey
                self.readOnly = readOnly
                self.schemaVersion = schemaVersion
                self.migrationBlock = migrationBlock
                self.deleteRealmIfMigrationNeeded = deleteRealmIfMigrationNeeded
                self.shouldCompactOnLaunch = shouldCompactOnLaunch
                self.objectTypes = objectTypes
        }
        // MARK: Configuration Properties
        /**
         A configuration value used to configure a Realm for synchronization with the Realm Object Server. Mutually
         exclusive with `inMemoryIdentifier`.
         */
        public var syncConfiguration: SyncConfiguration? {
            get {
                return _syncConfiguration
            }
            set {
                _inMemoryIdentifier = nil
                _syncConfiguration = newValue
            }
        }
        private var _syncConfiguration: SyncConfiguration?
        /// The local URL of the Realm file. Mutually exclusive with `inMemoryIdentifier`.
        public var fileURL: URL? {
            get {
                return _path.map { URL(fileURLWithPath: $0) }
            }
            set {
                _inMemoryIdentifier = nil
                _path = newValue?.path
            }
        }
        private var _path: String?
        /// A string used to identify a particular in-memory Realm. Mutually exclusive with `fileURL` and
        /// `syncConfiguration`.
        public var inMemoryIdentifier: String? {
            get {
                return _inMemoryIdentifier
            }
            set {
                _path = nil
                _syncConfiguration = nil
                _inMemoryIdentifier = newValue
            }
        }
        private var _inMemoryIdentifier: String?
        /// A 64-byte key to use to encrypt the data, or `nil` if encryption is not enabled.
        public var encryptionKey: Data?
        /**
         Whether to open the Realm in read-only mode.
         For non-synchronized Realms, this is required to be able to open Realm files which are not
         writeable or are in a directory which is not writeable.  This should only be used on files
         which will not be modified by anyone while they are open, and not just to get a read-only
         view of a file which may be written to by another thread or process. Opening in read-only
         mode requires disabling Realm's reader/writer coordination, so committing a write
         transaction from another process will result in crashes.
         Syncronized Realms must always be writeable (as otherwise no synchronization could happen),
         and this instead merely disallows performing write transactions on the Realm. In addition,
         it will skip some automatic writes made to the Realm, such as to initialize the Realm's
         schema. Setting `readOnly = YES` is not strictly required for Realms which the sync user
         does not have write access to, but is highly recommended as it will improve error reporting
         and catch some errors earlier.
         Realms using query-based sync cannot be opened in read-only mode.
         */
        public var readOnly: Bool = false
        /// The current schema version.
        public var schemaVersion: UInt64 = 0
        /// The block which migrates the Realm to the current version.
        public var migrationBlock: MigrationBlock?
        /**
         Whether to recreate the Realm file with the provided schema if a migration is required. This is the case when
         the stored schema differs from the provided schema or the stored schema version differs from the version on
         this configuration. Setting this property to `true` deletes the file if a migration would otherwise be required
         or executed.
         - note: Setting this property to `true` doesn't disable file format migrations.
         */
        public var deleteRealmIfMigrationNeeded: Bool = false
        /**
         A block called when opening a Realm for the first time during the
         life of a process to determine if it should be compacted before being
         returned to the user. It is passed the total file size (data + free space)
         and the total bytes used by data in the file.
         Return `true ` to indicate that an attempt to compact the file should be made.
         The compaction will be skipped if another process is accessing it.
         */
        public var shouldCompactOnLaunch: ((Int, Int) -> Bool)?
        /// The classes managed by the Realm.
        public var objectTypes: [Object.Type]? {
            get {
                return self.customSchema.map { $0.objectSchema.compactMap { $0.objectClass as? Object.Type } }
            }
            set {
                self.customSchema = newValue.map { RLMSchema(objectClasses: $0) }
            }
        }
        /**
         The maximum number of live versions in the Realm file before an exception will
         be thrown when attempting to start a write transaction.
         Realm provides MVCC snapshot isolation, meaning that writes on one thread do
         not overwrite data being read on another thread, and instead write a new copy
         of that data. When a Realm refreshes it updates to the latest version of the
         data and releases the old versions, allowing them to be overwritten by
         subsequent write transactions.
         Under normal circumstances this is not a problem, but if the number of active
         versions grow too large, it will have a negative effect on the filesize on
         disk. This can happen when performing writes on many different threads at
         once, when holding on to frozen objects for an extended time, or when
         performing long operations on background threads which do not allow the Realm
         to refresh.
         Setting this property to a non-zero value makes it so that exceeding the set
         number of versions will instead throw an exception. This can be used with a
         low value during development to help identify places that may be problematic,
         or in production use to cause the app to crash rather than produce a Realm
         file which is too large to be oened.
         */
        public var maximumNumberOfActiveVersions: UInt?
        /// A custom schema to use for the Realm.
        private var customSchema: RLMSchema?
        /// If `true`, disables automatic format upgrades when accessing the Realm.
        internal var disableFormatUpgrade: Bool = false
        // MARK: Private Methods
        internal var rlmConfiguration: RLMRealmConfiguration {
            let configuration = RLMRealmConfiguration()
            if let syncConfiguration = syncConfiguration {
                configuration.syncConfiguration = syncConfiguration.asConfig()
            }
            if let fileURL = fileURL {
                configuration.fileURL = fileURL
            } else if let inMemoryIdentifier = inMemoryIdentifier {
                configuration.inMemoryIdentifier = inMemoryIdentifier
            } else if syncConfiguration == nil {
                fatalError("A Realm Configuration must specify a path or an in-memory identifier.")
            }
            configuration.encryptionKey = self.encryptionKey
            configuration.readOnly = self.readOnly
            configuration.schemaVersion = self.schemaVersion
            configuration.migrationBlock = self.migrationBlock.map { accessorMigrationBlock($0) }
            configuration.deleteRealmIfMigrationNeeded = self.deleteRealmIfMigrationNeeded
            if let shouldCompactOnLaunch = self.shouldCompactOnLaunch {
                configuration.shouldCompactOnLaunch = ObjectiveCSupport.convert(object: shouldCompactOnLaunch)
            } else {
                configuration.shouldCompactOnLaunch = nil
            }
            configuration.setCustomSchemaWithoutCopying(self.customSchema)
            configuration.disableFormatUpgrade = self.disableFormatUpgrade
            configuration.maximumNumberOfActiveVersions = self.maximumNumberOfActiveVersions ?? 0
            return configuration
        }
        internal static func fromRLMRealmConfiguration(_ rlmConfiguration: RLMRealmConfiguration) -> Configuration {
            var configuration = Configuration()
            configuration._path = rlmConfiguration.fileURL?.path
            configuration._inMemoryIdentifier = rlmConfiguration.inMemoryIdentifier
            if let objcSyncConfig = rlmConfiguration.syncConfiguration {
                configuration._syncConfiguration = SyncConfiguration(config: objcSyncConfig)
            } else {
                configuration._syncConfiguration = nil
            }
            configuration.encryptionKey = rlmConfiguration.encryptionKey
            configuration.readOnly = rlmConfiguration.readOnly
            configuration.schemaVersion = rlmConfiguration.schemaVersion
            configuration.migrationBlock = rlmConfiguration.migrationBlock.map { rlmMigration in
                return { migration, schemaVersion in
                    rlmMigration(migration.rlmMigration, schemaVersion)
                }
            }
            configuration.deleteRealmIfMigrationNeeded = rlmConfiguration.deleteRealmIfMigrationNeeded
            configuration.shouldCompactOnLaunch = rlmConfiguration.shouldCompactOnLaunch.map(ObjectiveCSupport.convert)
            configuration.customSchema = rlmConfiguration.customSchema
            configuration.disableFormatUpgrade = rlmConfiguration.disableFormatUpgrade
            configuration.maximumNumberOfActiveVersions = rlmConfiguration.maximumNumberOfActiveVersions
            return configuration
        }
    }
}
// MARK: CustomStringConvertible
extension Realm.Configuration: CustomStringConvertible {
    /// A human-readable description of the configuration value.
    public var description: String {
        return gsub(pattern: "\\ARLMRealmConfiguration",
                    template: "Realm.Configuration",
                    string: rlmConfiguration.description) ?? ""
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
import Realm.Private
/**
 A `Realm` instance (also referred to as "a Realm") represents a Realm database.
 Realms can either be stored on disk (see `init(path:)`) or in memory (see `Configuration`).
 `Realm` instances are cached internally, and constructing equivalent `Realm` objects (for example,
 by using the same path or identifier) produces limited overhead.
 If you specifically want to ensure a `Realm` instance is destroyed (for example, if you wish to
 open a Realm, check some property, and then possibly delete the Realm file and re-open it), place
 the code which uses the Realm within an `autoreleasepool {}` and ensure you have no other strong
 references to it.
 - warning Non-frozen `RLMRealm` instances are thread-confined and cannot be
 shared across threads or dispatch queues. Trying to do so will cause an
 exception to be thrown. You must obtain an instance of `RLMRealm` on each
 thread or queue you want to interact with the Realm on. Realms can be confined
 to a dispatch queue rather than the thread they are opened on by explicitly
 passing in the queue when obtaining the `RLMRealm` instance. If this is not
 done, trying to use the same instance in multiple blocks dispatch to the same
 queue may fail as queues are not always run on the same thread.
 */
public struct Realm {
    // MARK: Properties
    /// The `Schema` used by the Realm.
    public var schema: Schema { return Schema(rlmRealm.schema) }
    /// The `Configuration` value that was used to create the `Realm` instance.
    public var configuration: Configuration { return Configuration.fromRLMRealmConfiguration(rlmRealm.configuration) }
    /// Indicates if the Realm contains any objects.
    public var isEmpty: Bool { return rlmRealm.isEmpty }
    // MARK: Initializers
    /**
     Obtains an instance of the default Realm.
     The default Realm is persisted as *default.realm* under the *Documents* directory of your Application on iOS, and
     in your application's *Application Support* directory on OS X.
     The default Realm is created using the default `Configuration`, which can be changed by setting the
     `Realm.Configuration.defaultConfiguration` property to a new value.
     - parameter queue: An optional dispatch queue to confine the Realm to. If
                        given, this Realm instance can be used from within
                        blocks dispatched to the given queue rather than on the
                        current thread.
     - throws: An `NSError` if the Realm could not be initialized.
     */
    public init(queue: DispatchQueue? = nil) throws {
        let rlmRealm = try RLMRealm(configuration: RLMRealmConfiguration.rawDefault(), queue: queue)
        self.init(rlmRealm)
    }
    /**
     Obtains a `Realm` instance with the given configuration.
     - parameter configuration: A configuration value to use when creating the Realm.
     - parameter queue: An optional dispatch queue to confine the Realm to. If
                        given, this Realm instance can be used from within
                        blocks dispatched to the given queue rather than on the
                        current thread.
     - throws: An `NSError` if the Realm could not be initialized.
     */
    public init(configuration: Configuration, queue: DispatchQueue? = nil) throws {
        let rlmRealm = try RLMRealm(configuration: configuration.rlmConfiguration, queue: queue)
        self.init(rlmRealm)
    }
    /**
     Obtains a `Realm` instance persisted at a specified file URL.
     - parameter fileURL: The local URL of the file the Realm should be saved at.
     - throws: An `NSError` if the Realm could not be initialized.
     */
    public init(fileURL: URL) throws {
        var configuration = Configuration.defaultConfiguration
        configuration.fileURL = fileURL
        try self.init(configuration: configuration)
    }
    // MARK: Async
    /**
     Asynchronously open a Realm and deliver it to a block on the given queue.
     Opening a Realm asynchronously will perform all work needed to get the Realm to
     a usable state (such as running potentially time-consuming migrations) on a
     background thread before dispatching to the given queue. In addition,
     synchronized Realms wait for all remote content available at the time the
     operation began to be downloaded and available locally.
     The Realm passed to the callback function is confined to the callback
     queue as if `Realm(configuration:queue:)` was used.
     - parameter configuration: A configuration object to use when opening the Realm.
     - parameter callbackQueue: The dispatch queue on which the callback should be run.
     - parameter callback:      A callback block. If the Realm was successfully opened, an
                                it will be passed in as an argument.
                                Otherwise, a `Swift.Error` describing what went wrong will be
                                passed to the block instead.
     - returns: A task object which can be used to observe or cancel the async open.
     */
    @discardableResult
    public static func asyncOpen(configuration: Realm.Configuration = .defaultConfiguration,
                                 callbackQueue: DispatchQueue = .main,
                                 callback: @escaping (Realm?, Swift.Error?) -> Void) -> AsyncOpenTask {
        return AsyncOpenTask(rlmTask: RLMRealm.asyncOpen(with: configuration.rlmConfiguration, callbackQueue: callbackQueue) { rlmRealm, error in
            callback(rlmRealm.flatMap(Realm.init), error)
        })
    }
    /**
     A task object which can be used to observe or cancel an async open.
     When a synchronized Realm is opened asynchronously, the latest state of the
     Realm is downloaded from the server before the completion callback is
     invoked. This task object can be used to observe the state of the download
     or to cancel it. This should be used instead of trying to observe the
     download via the sync session as the sync session itself is created
     asynchronously, and may not exist yet when Realm.asyncOpen() returns.
     */
    public struct AsyncOpenTask {
        fileprivate let rlmTask: RLMAsyncOpenTask
        /**
         Cancel the asynchronous open.
         Any download in progress will be cancelled, and the completion block for this
         async open will never be called. If multiple async opens on the same Realm are
         happening concurrently, all other opens will fail with the error "operation cancelled".
         */
        public func cancel() { rlmTask.cancel() }
        /**
         Register a progress notification block.
         Each registered progress notification block is called whenever the sync
         subsystem has new progress data to report until the task is either cancelled
         or the completion callback is called. Progress notifications are delivered on
         the supplied queue.
         - parameter queue: The queue to deliver progress notifications on.
         - parameter block: The block to invoke when notifications are available.
         */
        public func addProgressNotification(queue: DispatchQueue = .main,
                                            block: @escaping (SyncSession.Progress) -> Void) {
            rlmTask.addProgressNotification(on: queue) { transferred, transferrable in
                block(SyncSession.Progress(transferred: transferred, transferrable: transferrable))
            }
        }
    }
    // MARK: Transactions
    /**
     Performs actions contained within the given block inside a write transaction.
     If the block throws an error, the transaction will be canceled and any
     changes made before the error will be rolled back.
     Only one write transaction can be open at a time for each Realm file. Write
     transactions cannot be nested, and trying to begin a write transaction on a
     Realm which is already in a write transaction will throw an exception.
     Calls to `write` from `Realm` instances for the same Realm file in other
     threads or other processes will block until the current write transaction
     completes or is cancelled.
     Before beginning the write transaction, `write` updates the `Realm`
     instance to the latest Realm version, as if `refresh()` had been called,
     and generates notifications if applicable. This has no effect if the Realm
     was already up to date.
     You can skip notifiying specific notification blocks about the changes made
     in this write transaction by passing in their associated notification
     tokens. This is primarily useful when the write transaction is saving
     changes already made in the UI and you do not want to have the notification
     block attempt to re-apply the same changes.
     The tokens passed to this function must be for notifications for this Realm
     which were added on the same thread as the write transaction is being
     performed on. Notifications for different threads cannot be skipped using
     this method.
     - parameter tokens: An array of notification tokens which were returned
                         from adding callbacks which you do not want to be
                         notified for the changes made in this write transaction.
     - parameter block: The block containing actions to perform.
     - returns: The value returned from the block, if any.
     - throws: An `NSError` if the transaction could not be completed successfully.
               If `block` throws, the function throws the propagated `ErrorType` instead.
     */
    @discardableResult
    public func write<Result>(withoutNotifying tokens: [NotificationToken] = [], _ block: (() throws -> Result)) throws -> Result {
        beginWrite()
        var ret: Result!
        do {
            ret = try block()
        } catch let error {
            if isInWriteTransaction { cancelWrite() }
            throw error
        }
        if isInWriteTransaction { try commitWrite(withoutNotifying: tokens) }
        return ret
    }
    /**
     Begins a write transaction on the Realm.
     Only one write transaction can be open at a time for each Realm file. Write
     transactions cannot be nested, and trying to begin a write transaction on a
     Realm which is already in a write transaction will throw an exception.
     Calls to `beginWrite` from `Realm` instances for the same Realm file in
     other threads or other processes will block until the current write
     transaction completes or is cancelled.
     Before beginning the write transaction, `beginWrite` updates the `Realm`
     instance to the latest Realm version, as if `refresh()` had been called,
     and generates notifications if applicable. This has no effect if the Realm
     was already up to date.
     It is rarely a good idea to have write transactions span multiple cycles of
     the run loop, but if you do wish to do so you will need to ensure that the
     Realm participating in the write transaction is kept alive until the write
     transaction is committed.
     */
    public func beginWrite() {
        rlmRealm.beginWriteTransaction()
    }
    /**
     Commits all write operations in the current write transaction, and ends
     the transaction.
     After saving the changes and completing the write transaction, all
     notification blocks registered on this specific `Realm` instance are called
     synchronously. Notification blocks for `Realm` instances on other threads
     and blocks registered for any Realm collection (including those on the
     current thread) are scheduled to be called synchronously.
     You can skip notifiying specific notification blocks about the changes made
     in this write transaction by passing in their associated notification
     tokens. This is primarily useful when the write transaction is saving
     changes already made in the UI and you do not want to have the notification
     block attempt to re-apply the same changes.
     The tokens passed to this function must be for notifications for this Realm
     which were added on the same thread as the write transaction is being
     performed on. Notifications for different threads cannot be skipped using
     this method.
     - warning: This method may only be called during a write transaction.
     - parameter tokens: An array of notification tokens which were returned
                         from adding callbacks which you do not want to be
                         notified for the changes made in this write transaction.
     - throws: An `NSError` if the transaction could not be written due to
               running out of disk space or other i/o errors.
     */
    public func commitWrite(withoutNotifying tokens: [NotificationToken] = []) throws {
        try rlmRealm.commitWriteTransactionWithoutNotifying(tokens)
    }
    /**
     Reverts all writes made in the current write transaction and ends the transaction.
     This rolls back all objects in the Realm to the state they were in at the
     beginning of the write transaction, and then ends the transaction.
     This restores the data for deleted objects, but does not revive invalidated
     object instances. Any `Object`s which were added to the Realm will be
     invalidated rather than becoming unmanaged.
     Given the following code:
     ```swift
     let oldObject = objects(ObjectType).first!
     let newObject = ObjectType()
     realm.beginWrite()
     realm.add(newObject)
     realm.delete(oldObject)
     realm.cancelWrite()
     ```
     Both `oldObject` and `newObject` will return `true` for `isInvalidated`,
     but re-running the query which provided `oldObject` will once again return
     the valid object.
     KVO observers on any objects which were modified during the transaction
     will be notified about the change back to their initial values, but no
     other notifcations are produced by a cancelled write transaction.
     - warning: This method may only be called during a write transaction.
     */
    public func cancelWrite() {
        rlmRealm.cancelWriteTransaction()
    }
    /**
     Indicates whether the Realm is currently in a write transaction.
     - warning:  Do not simply check this property and then start a write transaction whenever an object needs to be
                 created, updated, or removed. Doing so might cause a large number of write transactions to be created,
                 degrading performance. Instead, always prefer performing multiple updates during a single transaction.
     */
    public var isInWriteTransaction: Bool {
        return rlmRealm.inWriteTransaction
    }
    // MARK: Adding and Creating objects
    /**
     What to do when an object being added to or created in a Realm has a primary key that already exists.
     */
    public enum UpdatePolicy: Int {
        /**
         Throw an exception. This is the default when no policy is specified for `add()` or `create()`.
         This behavior is the same as passing `update: false` to `add()` or `create()`.
         */
        case error = 1
        /**
         Overwrite only properties in the existing object which are different from the new values. This results
         in change notifications reporting only the properties which changed, and influences the sync merge logic.
         If few or no of the properties are changing this will be faster than .all and reduce how much data has
         to be written to the Realm file. If all of the properties are changing, it may be slower than .all (but
         will never result in *more* data being written).
         */
        case modified = 3
        /**
         Overwrite all properties in the existing object with the new values, even if they have not changed. This
         results in change notifications reporting all properties as changed, and influences the sync merge logic.
         This behavior is the same as passing `update: true` to `add()` or `create()`.
         */
        case all = 2
    }
    /// :nodoc:
    @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
    public func add(_ object: Object, update: Bool) {
        fatalError()
    }
    /**
     Adds an unmanaged object to this Realm.
     If an object with the same primary key already exists in this Realm, it is updated with the property values from
     this object as specified by the `UpdatePolicy` selected. The update policy must be `.error` for objects with no
     primary key.
     Adding an object to a Realm will also add all child relationships referenced by that object (via `Object` and
     `List<Object>` properties). Those objects must also be valid objects to add to this Realm, and the value of
     the `update:` parameter is propagated to those adds.
     The object to be added must either be an unmanaged object or a valid object which is already managed by this
     Realm. Adding an object already managed by this Realm is a no-op, while adding an object which is managed by
     another Realm or which has been deleted from any Realm (i.e. one where `isInvalidated` is `true`) is an error.
     To copy a managed object from one Realm to another, use `create()` instead.
     - warning: This method may only be called during a write transaction.
     - parameter object: The object to be added to this Realm.
     - parameter update: What to do if an object with the same primary key alredy exists. Must be `.error` for objects
     without a primary key.
     */
    public func add(_ object: Object, update: UpdatePolicy = .error) {
        if update != .error && object.objectSchema.primaryKeyProperty == nil {
            throwRealmException("'\(object.objectSchema.className)' does not have a primary key and can not be updated")
        }
        RLMAddObjectToRealm(object, rlmRealm, RLMUpdatePolicy(rawValue: UInt(update.rawValue))!)
    }
    /// :nodoc:
    @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
    public func add<S: Sequence>(_ objects: S, update: Bool) where S.Iterator.Element: Object {
        fatalError()
    }
    /**
     Adds all the objects in a collection into the Realm.
     - see: `add(_:update:)`
     - warning: This method may only be called during a write transaction.
     - parameter objects: A sequence which contains objects to be added to the Realm.
     - parameter update: How to handle
     without a primary key.
     - parameter update: How to handle objects in the collection with a primary key that alredy exists in this
     Realm. Must be `.error` for object types without a primary key.
     */
    public func add<S: Sequence>(_ objects: S, update: UpdatePolicy = .error) where S.Iterator.Element: Object {
        for obj in objects {
            add(obj, update: update)
        }
    }
    /// :nodoc:
    @discardableResult
    @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
    public func create<T: Object>(_ type: T.Type, value: Any = [:], update: Bool) -> T {
        fatalError()
    }
    /**
     Creates a Realm object with a given value, adding it to the Realm and returning it.
     The `value` argument can be a Realm object, a key-value coding compliant object, an array
     or dictionary returned from the methods in `NSJSONSerialization`, or an `Array` containing
     one element for each managed property. Do not pass in a `LinkingObjects` instance, either
     by itself or as a member of a collection. If the `value` argument is an array, all properties
     must be present, valid and in the same order as the properties defined in the model.
     If the object type does not have a primary key or no object with the specified primary key
     already exists, a new object is created in the Realm. If an object already exists in the Realm
     with the specified primary key and the update policy is `.modified` or `.all`, the existing
     object will be updated and a reference to that object will be returned.
     If the object is being updated, all properties defined in its schema will be set by copying
     from `value` using key-value coding. If the `value` argument does not respond to `value(forKey:)`
     for a given property name (or getter name, if defined), that value will remain untouched.
     Nullable properties on the object can be set to nil by using `NSNull` as the updated value,
     or (if you are passing in an instance of an `Object` subclass) setting the corresponding
     property on `value` to nil.
     - warning: This method may only be called during a write transaction.
     - parameter type:   The type of the object to create.
     - parameter value:  The value used to populate the object.
     - parameter update: What to do if an object with the same primary key alredy exists. Must be `.error` for object
     types without a primary key.
     - returns: The newly created object.
     */
    @discardableResult
    public func create<T: Object>(_ type: T.Type, value: Any = [:], update: UpdatePolicy = .error) -> T {
        if update != .error {
            RLMVerifyHasPrimaryKey(type)
        }
        let typeName = (type as Object.Type).className()
        return unsafeDowncast(RLMCreateObjectInRealmWithValue(rlmRealm, typeName, value,
                                                              RLMUpdatePolicy(rawValue: UInt(update.rawValue))!), to: type)
    }
    /// :nodoc:
    @discardableResult
    @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
    public func dynamicCreate(_ typeName: String, value: Any = [:], update: Bool) -> DynamicObject {
        fatalError()
    }
    /**
     This method is useful only in specialized circumstances, for example, when building
     components that integrate with Realm. If you are simply building an app on Realm, it is
     recommended to use the typed method `create(_:value:update:)`.
     Creates or updates an object with the given class name and adds it to the `Realm`, populating
     the object with the given value.
     The `value` argument can be a Realm object, a key-value coding compliant object, an array
     or dictionary returned from the methods in `NSJSONSerialization`, or an `Array` containing
     one element for each managed property. Do not pass in a `LinkingObjects` instance, either
     by itself or as a member of a collection. If the `value` argument is an array, all properties
     must be present, valid and in the same order as the properties defined in the model.
     If the object type does not have a primary key or no object with the specified primary key
     already exists, a new object is created in the Realm. If an object already exists in the Realm
     with the specified primary key and the update policy is `.modified` or `.all`, the existing
     object will be updated and a reference to that object will be returned.
     If the object is being updated, all properties defined in its schema will be set by copying
     from `value` using key-value coding. If the `value` argument does not respond to `value(forKey:)`
     for a given property name (or getter name, if defined), that value will remain untouched.
     Nullable properties on the object can be set to nil by using `NSNull` as the updated value,
     or (if you are passing in an instance of an `Object` subclass) setting the corresponding
     property on `value` to nil.
     - warning: This method can only be called during a write transaction.
     - parameter className:  The class name of the object to create.
     - parameter value:      The value used to populate the object.
     - parameter update:     What to do if an object with the same primary key alredy exists.
     Must be `.error` for object types without a primary key.
     - returns: The created object.
     :nodoc:
     */
    @discardableResult
    public func dynamicCreate(_ typeName: String, value: Any = [:], update: UpdatePolicy = .error) -> DynamicObject {
        if update != .error && schema[typeName]?.primaryKeyProperty == nil {
            throwRealmException("'\(typeName)' does not have a primary key and can not be updated")
        }
        return noWarnUnsafeBitCast(RLMCreateObjectInRealmWithValue(rlmRealm, typeName, value,
                                                                   RLMUpdatePolicy(rawValue: UInt(update.rawValue))!),
                                   to: DynamicObject.self)
    }
    // MARK: Deleting objects
    /**
     Deletes an object from the Realm. Once the object is deleted it is considered invalidated.
     - warning: This method may only be called during a write transaction.
     - parameter object: The object to be deleted.
     */
    public func delete(_ object: Object) {
        RLMDeleteObjectFromRealm(object, rlmRealm)
    }
    /**
     Deletes zero or more objects from the Realm.
     Do not pass in a slice to a `Results` or any other auto-updating Realm collection
     type (for example, the type returned by the Swift `suffix(_:)` standard library
     method). Instead, make a copy of the objects to delete using `Array()`, and pass
     that instead. Directly passing in a view into an auto-updating collection may
     result in 'index out of bounds' exceptions being thrown.
     - warning: This method may only be called during a write transaction.
     - parameter objects:   The objects to be deleted. This can be a `List<Object>`,
                            `Results<Object>`, or any other Swift `Sequence` whose
                            elements are `Object`s (subject to the caveats above).
     */
    public func delete<S: Sequence>(_ objects: S) where S.Iterator.Element: Object {
        for obj in objects {
            delete(obj)
        }
    }
    /**
     Deletes zero or more objects from the Realm.
     - warning: This method may only be called during a write transaction.
     - parameter objects: A list of objects to delete.
     :nodoc:
     */
    public func delete<Element: Object>(_ objects: List<Element>) {
        rlmRealm.deleteObjects(objects._rlmArray)
    }
    /**
     Deletes zero or more objects from the Realm.
     - warning: This method may only be called during a write transaction.
     - parameter objects: A `Results` containing the objects to be deleted.
     :nodoc:
     */
    public func delete<Element: Object>(_ objects: Results<Element>) {
        rlmRealm.deleteObjects(objects.rlmResults)
    }
    /**
     Deletes all objects from the Realm.
     - warning: This method may only be called during a write transaction.
     */
    public func deleteAll() {
        RLMDeleteAllObjectsFromRealm(rlmRealm)
    }
    // MARK: Object Retrieval
    /**
     Returns all objects of the given type stored in the Realm.
     - parameter type: The type of the objects to be returned.
     - returns: A `Results` containing the objects.
     */
    public func objects<Element: Object>(_ type: Element.Type) -> Results<Element> {
        return Results(RLMGetObjects(rlmRealm, type.className(), nil))
    }
    /**
     This method is useful only in specialized circumstances, for example, when building
     components that integrate with Realm. If you are simply building an app on Realm, it is
     recommended to use the typed method `objects(type:)`.
     Returns all objects for a given class name in the Realm.
     - parameter typeName: The class name of the objects to be returned.
     - returns: All objects for the given class name as dynamic objects
     :nodoc:
     */
    public func dynamicObjects(_ typeName: String) -> Results<DynamicObject> {
        return Results<DynamicObject>(RLMGetObjects(rlmRealm, typeName, nil))
    }
    /**
     Retrieves the single instance of a given object type with the given primary key from the Realm.
     This method requires that `primaryKey()` be overridden on the given object class.
     - see: `Object.primaryKey()`
     - parameter type: The type of the object to be returned.
     - parameter key:  The primary key of the desired object.
     - returns: An object of type `type`, or `nil` if no instance with the given primary key exists.
     */
    public func object<Element: Object, KeyType>(ofType type: Element.Type, forPrimaryKey key: KeyType) -> Element? {
        return unsafeBitCast(RLMGetObject(rlmRealm, (type as Object.Type).className(),
                                          dynamicBridgeCast(fromSwift: key)) as! RLMObjectBase?,
                             to: Optional<Element>.self)
    }
    /**
     This method is useful only in specialized circumstances, for example, when building
     components that integrate with Realm. If you are simply building an app on Realm, it is
     recommended to use the typed method `objectForPrimaryKey(_:key:)`.
     Get a dynamic object with the given class name and primary key.
     Returns `nil` if no object exists with the given class name and primary key.
     This method requires that `primaryKey()` be overridden on the given subclass.
     - see: Object.primaryKey()
     - warning: This method is useful only in specialized circumstances.
     - parameter className:  The class name of the object to be returned.
     - parameter key:        The primary key of the desired object.
     - returns: An object of type `DynamicObject` or `nil` if an object with the given primary key does not exist.
     :nodoc:
     */
    public func dynamicObject(ofType typeName: String, forPrimaryKey key: Any) -> DynamicObject? {
        return unsafeBitCast(RLMGetObject(rlmRealm, typeName, key) as! RLMObjectBase?, to: Optional<DynamicObject>.self)
    }
    // MARK: Notifications
    /**
     Adds a notification handler for changes made to this Realm, and returns a notification token.
     Notification handlers are called after each write transaction is committed, independent of the thread or process.
     Handler blocks are called on the same thread that they were added on, and may only be added on threads which are
     currently within a run loop. Unless you are specifically creating and running a run loop on a background thread,
     this will normally only be the main thread.
     Notifications can't be delivered as long as the run loop is blocked by other activity. When notifications can't be
     delivered instantly, multiple notifications may be coalesced.
     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
     updates, call `invalidate()` on the token.
     - parameter block: A block which is called to process Realm notifications. It receives the following parameters:
                        `notification`: the incoming notification; `realm`: the Realm for which the notification
                        occurred.
     - returns: A token which must be held for as long as you wish to continue receiving change notifications.
     */
    public func observe(_ block: @escaping NotificationBlock) -> NotificationToken {
        return rlmRealm.addNotificationBlock { rlmNotification, _ in
            switch rlmNotification {
            case RLMNotification.DidChange:
                block(.didChange, self)
            case RLMNotification.RefreshRequired:
                block(.refreshRequired, self)
            default:
                fatalError("Unhandled notification type: \(rlmNotification)")
            }
        }
    }
    // MARK: Autorefresh and Refresh
    /**
     Set this property to `true` to automatically update this Realm when changes happen in other threads.
     If set to `true` (the default), changes made on other threads will be reflected in this Realm on the next cycle of
     the run loop after the changes are committed.  If set to `false`, you must manually call `refresh()` on the Realm
     to update it to get the latest data.
     Note that by default, background threads do not have an active run loop and you will need to manually call
     `refresh()` in order to update to the latest version, even if `autorefresh` is set to `true`.
     Even with this property enabled, you can still call `refresh()` at any time to update the Realm before the
     automatic refresh would occur.
     Notifications are sent when a write transaction is committed whether or not automatic refreshing is enabled.
     Disabling `autorefresh` on a `Realm` without any strong references to it will not have any effect, and
     `autorefresh` will revert back to `true` the next time the Realm is created. This is normally irrelevant as it
     means that there is nothing to refresh (as managed `Object`s, `List`s, and `Results` have strong references to the
     `Realm` that manages them), but it means that setting `autorefresh = false` in
     `application(_:didFinishLaunchingWithOptions:)` and only later storing Realm objects will not work.
     Defaults to `true`.
     */
    public var autorefresh: Bool {
        get {
            return rlmRealm.autorefresh
        }
        nonmutating set {
            rlmRealm.autorefresh = newValue
        }
    }
    /**
     Updates the Realm and outstanding objects managed by the Realm to point to the most recent data.
     - returns: Whether there were any updates for the Realm. Note that `true` may be returned even if no data actually
     changed.
     */
    @discardableResult
    public func refresh() -> Bool {
        return rlmRealm.refresh()
    }
    // MARK: Frozen Realms
    /// Returns if this Realm is frozen.
    public var isFrozen: Bool {
        return rlmRealm.isFrozen
    }
    /**
     Returns a frozen (immutable) snapshot of this Realm.
     A frozen Realm is an immutable snapshot view of a particular version of a Realm's data. Unlike
     normal Realm instances, it does not live-update to reflect writes made to the Realm, and can be
     accessed from any thread. Writing to a frozen Realm is not allowed, and attempting to begin a
     write transaction will throw an exception.
     All objects and collections read from a frozen Realm will also be frozen.
     - warning: Holding onto a frozen Realm for an extended period while performing write
     transaction on the Realm may result in the Realm file growing to large sizes. See
     `Realm.Configuration.maximumNumberOfActiveVersions` for more information.
     */
    public func freeze() -> Realm {
        return isFrozen ? self : Realm(rlmRealm.freeze())
    }
    /**
     Returns a frozen (immutable) snapshot of the given object.
     The frozen copy is an immutable object which contains the same data as the given object
     currently contains, but will not update when writes are made to the containing Realm. Unlike
     live objects, frozen objects can be accessed from any thread.
     - warning: Holding onto a frozen object for an extended period while performing write
     transaction on the Realm may result in the Realm file growing to large sizes. See
     `Realm.Configuration.maximumNumberOfActiveVersions` for more information.
     */
    public func freeze<T: Object>(_ obj: T) -> T {
        return RLMObjectFreeze(obj) as! T
    }
    /**
     Returns a frozen (immutable) snapshot of the given collection.
     The frozen copy is an immutable collection which contains the same data as the given
     collection currently contains, but will not update when writes are made to the containing
     Realm. Unlike live collections, frozen collections can be accessed from any thread.
     - warning: This method cannot be called during a write transaction, or when the Realm is read-only.
     - warning: Holding onto a frozen collection for an extended period while performing write
     transaction on the Realm may result in the Realm file growing to large sizes. See
     `Realm.Configuration.maximumNumberOfActiveVersions` for more information.
    */
    public func freeze<Collection: RealmCollection>(_ collection: Collection) -> Collection {
        return collection.freeze()
    }
    // MARK: Invalidation
    /**
     Invalidates all `Object`s, `Results`, `LinkingObjects`, and `List`s managed by the Realm.
     A Realm holds a read lock on the version of the data accessed by it, so
     that changes made to the Realm on different threads do not modify or delete the
     data seen by this Realm. Calling this method releases the read lock,
     allowing the space used on disk to be reused by later write transactions rather
     than growing the file. This method should be called before performing long
     blocking operations on a background thread on which you previously read data
     from the Realm which you no longer need.
     All `Object`, `Results` and `List` instances obtained from this `Realm` instance on the current thread are
     invalidated. `Object`s and `Array`s cannot be used. `Results` will become empty. The Realm itself remains valid,
     and a new read transaction is implicitly begun the next time data is read from the Realm.
     Calling this method multiple times in a row without reading any data from the
     Realm, or before ever reading any data from the Realm, is a no-op. This method
     may not be called on a read-only Realm.
     */
    public func invalidate() {
        rlmRealm.invalidate()
    }
    // MARK: File Management
    /**
     Writes a compacted and optionally encrypted copy of the Realm to the given local URL.
     The destination file cannot already exist.
     Note that if this method is called from within a write transaction, the *current* data is written, not the data
     from the point when the previous write transaction was committed.
     - parameter fileURL:       Local URL to save the Realm to.
     - parameter encryptionKey: Optional 64-byte encryption key to encrypt the new file with.
     - throws: An `NSError` if the copy could not be written.
     */
    public func writeCopy(toFile fileURL: URL, encryptionKey: Data? = nil) throws {
        try rlmRealm.writeCopy(to: fileURL, encryptionKey: encryptionKey)
    }
    /**
     Checks if the Realm file for the given configuration exists locally on disk.
     For non-synchronized, non-in-memory Realms, this is equivalent to
     `FileManager.default.fileExists(atPath:)`. For synchronized Realms, it
     takes care of computing the actual path on disk based on the server,
     virtual path, and user as is done when opening the Realm.
     @param config A Realm configuration to check the existence of.
     @return true if the Realm file for the given configuration exists on disk, false otherwise.
     */
    public static func fileExists(for config: Configuration) -> Bool {
        return RLMRealm.fileExists(for: config.rlmConfiguration)
    }
    /**
     Deletes the local Realm file and associated temporary files for the given configuration.
     This deletes the ".realm", ".note" and ".management" files which would be
     created by opening the Realm with the given configuration. It does not
     delete the ".lock" file (which contains no persisted data and is recreated
     from scratch every time the Realm file is opened).
     The Realm must not be currently open on any thread or in another process.
     If it is, this will throw the error .alreadyOpen. Attempting to open the
     Realm on another thread while the deletion is happening will block, and
     then create a new Realm and open that afterwards.
     If the Realm already does not exist this will return `false`.
     @param config A Realm configuration identifying the Realm to be deleted.
     @return true if any files were deleted, false otherwise.
     */
    public static func deleteFiles(for config: Configuration) throws -> Bool {
        return try RLMRealm.deleteFiles(for: config.rlmConfiguration)
    }
    // MARK: Internal
    internal var rlmRealm: RLMRealm
    internal init(_ rlmRealm: RLMRealm) {
        self.rlmRealm = rlmRealm
    }
}
// MARK: Equatable
extension Realm: Equatable {
    /// Returns whether two `Realm` instances are equal.
    public static func == (lhs: Realm, rhs: Realm) -> Bool {
        return lhs.rlmRealm == rhs.rlmRealm
    }
}
// MARK: Notifications
extension Realm {
    /// A notification indicating that changes were made to a Realm.
    public enum Notification: String {
        /**
         This notification is posted when the data in a Realm has changed.
         `didChange` is posted after a Realm has been refreshed to reflect a write transaction, This can happen when an
         autorefresh occurs, `refresh()` is called, after an implicit refresh from `write(_:)`/`beginWrite()`, or after
         a local write transaction is committed.
         */
        case didChange = "RLMRealmDidChangeNotification"
        /**
         This notification is posted when a write transaction has been committed to a Realm on a different thread for
         the same file.
         It is not posted if `autorefresh` is enabled, or if the Realm is refreshed before the notification has a chance
         to run.
         Realms with autorefresh disabled should normally install a handler for this notification which calls
         `refresh()` after doing some work. Refreshing the Realm is optional, but not refreshing the Realm may lead to
         large Realm files. This is because an extra copy of the data must be kept for the stale Realm.
         */
        case refreshRequired = "RLMRealmRefreshRequiredNotification"
    }
}
/// The type of a block to run for notification purposes when the data in a Realm is modified.
public typealias NotificationBlock = (_ notification: Realm.Notification, _ realm: Realm) -> Void
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
// These types don't change when wrapping in Swift
// so we just typealias them to remove the 'RLM' prefix
// MARK: Aliases
/**
 `PropertyType` is an enum describing all property types supported in Realm models.
 For more information, see [Realm Models](https://realm.io/docs/swift/latest/#models).
 ### Primitive types
 * `Int`
 * `Bool`
 * `Float`
 * `Double`
 ### Object types
 * `String`
 * `Data`
 * `Date`
 ### Relationships: Array (in Swift, `List`) and `Object` types
 * `Object`
 * `Array`
*/
public typealias PropertyType = RLMPropertyType
/**
 An opaque token which is returned from methods which subscribe to changes to a Realm.
 - see: `Realm.observe(_:)`
 */
public typealias NotificationToken = RLMNotificationToken
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
/**
 `Property` instances represent properties managed by a Realm in the context of an object schema. Such properties may be
 persisted to a Realm file or computed from other data in the Realm.
 When using Realm, property instances allow performing migrations and introspecting the database's schema.
 Property instances map to columns in the core database.
 */
public struct Property: CustomStringConvertible {
    // MARK: Properties
    internal let rlmProperty: RLMProperty
    /// The name of the property.
    public var name: String { return rlmProperty.name }
    /// The type of the property.
    public var type: PropertyType { return rlmProperty.type }
    /// Indicates whether this property is an array of the property type.
    public var isArray: Bool { return rlmProperty.array }
    /// Indicates whether this property is indexed.
    public var isIndexed: Bool { return rlmProperty.indexed }
    /// Indicates whether this property is optional. (Note that certain numeric types must be wrapped in a
    /// `RealmOptional` instance in order to be declared as optional.)
    public var isOptional: Bool { return rlmProperty.optional }
    /// For `Object` and `List` properties, the name of the class of object stored in the property.
    public var objectClassName: String? { return rlmProperty.objectClassName }
    /// A human-readable description of the property object.
    public var description: String { return rlmProperty.description }
    // MARK: Initializers
    internal init(_ rlmProperty: RLMProperty) {
        self.rlmProperty = rlmProperty
    }
}
// MARK: Equatable
extension Property: Equatable {
    /// Returns whether the two properties are equal.
    public static func == (lhs: Property, rhs: Property) -> Bool {
        return lhs.rlmProperty.isEqual(to: rhs.rlmProperty)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Realm
extension Realm {
    /**
     Struct that describes the error codes within the Realm error domain.
     The values can be used to catch a variety of _recoverable_ errors, especially those
     happening when initializing a Realm instance.
     ```swift
     let realm: Realm?
     do {
         realm = try Realm()
     } catch Realm.Error.incompatibleLockFile {
         print("Realm Browser app may be attached to Realm on device?")
     }
     ```
    */
    public struct Error {
        public typealias Code = RLMError.Code
        /// Error thrown by Realm if no other specific error is returned when a realm is opened.
        public static let fail: Code = .fail
        /// Error thrown by Realm for any I/O related exception scenarios when a realm is opened.
        public static let fileAccess: Code = .fileAccess
        /// Error thrown by Realm if the user does not have permission to open or create
        /// the specified file in the specified access mode when the realm is opened.
        public static let filePermissionDenied: Code = .filePermissionDenied
        /// Error thrown by Realm if the file already exists when a copy should be written.
        public static let fileExists: Code = .fileExists
        /// Error thrown by Realm if no file was found when a realm was opened as
        /// read-only or if the directory part of the specified path was not found
        /// when a copy should be written.
        public static let fileNotFound: Code = .fileNotFound
        /// Error thrown by Realm if the database file is currently open in another process which
        /// cannot share with the current process due to an architecture mismatch.
        public static let incompatibleLockFile: Code = .incompatibleLockFile
        /// Error thrown by Realm if a file format upgrade is required to open the file,
        /// but upgrades were explicitly disabled.
        public static let fileFormatUpgradeRequired: Code = .fileFormatUpgradeRequired
        /// Error thrown by Realm if there is insufficient available address space.
        public static let addressSpaceExhausted: Code = .addressSpaceExhausted
        /// Error thrown by Realm if there is a schema version mismatch, so that a migration is required.
        public static let schemaMismatch: Code = .schemaMismatch
        /// :nodoc:
        public var code: Code {
            return (_nsError as! RLMError).code
        }
        /// :nodoc:
        public let _nsError: NSError
        /// :nodoc:
        public init(_nsError error: NSError) {
            _nsError = error
        }
        /// Realm configuration that can be used to open the backup copy of a Realm file
        ///
        //// Only applicable to `incompatibleSyncedFile`. Will be `nil` for all other errors.
        public var backupConfiguration: Realm.Configuration? {
            let configuration = userInfo[RLMBackupRealmConfigurationErrorKey] as! RLMRealmConfiguration?
            return configuration.map(Realm.Configuration.fromRLMRealmConfiguration)
        }
    }
}
/// :nodoc:
// Provide bridging from errors with domain RLMErrorDomain to Error.
extension Realm.Error: _BridgedStoredNSError {
    /// :nodoc:
    public static let _nsErrorDomain = RLMErrorDomain
    /// :nodoc:
    public static let errorDomain = RLMErrorDomain
}
// MARK: Equatable
extension Realm.Error: Equatable {}
/// Returns a Boolean indicating whether the errors are identical.
public func == (lhs: Error, rhs: Error) -> Bool {
    return lhs._code == rhs._code
        && lhs._domain == rhs._domain
}
// MARK: Pattern Matching
/**
 Pattern matching matching for `Realm.Error`, so that the instances can be used with Swift's
 `do { ... } catch { ... }` syntax.
*/
public func ~= (lhs: Realm.Error, rhs: Error) -> Bool {
    return lhs == rhs
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
/**
 An iterator for a `RealmCollection` instance.
 */
public struct RLMIterator<Element: RealmCollectionValue>: IteratorProtocol {
    private var generatorBase: NSFastEnumerationIterator
    init(collection: RLMCollection) {
        generatorBase = NSFastEnumerationIterator(collection)
    }
    /// Advance to the next element and return it, or `nil` if no next element exists.
    public mutating func next() -> Element? {
        let next = generatorBase.next()
        if next is NSNull {
            return Element._nilValue()
        }
        if let next = next as? Object? {
            if next == nil {
                return nil as Element?
            }
            return unsafeBitCast(next, to: Optional<Element>.self)
        }
        return dynamicBridgeCast(fromObjectiveC: next as Any)
    }
}
/**
 A `RealmCollectionChange` value encapsulates information about changes to collections
 that are reported by Realm notifications.
 The change information is available in two formats: a simple array of row
 indices in the collection for each type of change, and an array of index paths
 in a requested section suitable for passing directly to `UITableView`'s batch
 update methods.
 The arrays of indices in the `.update` case follow `UITableView`'s batching
 conventions, and can be passed as-is to a table view's batch update functions after being converted to index paths.
 For example, for a simple one-section table view, you can do the following:
 ```swift
 self.notificationToken = results.observe { changes in
     switch changes {
     case .initial:
         // Results are now populated and can be accessed without blocking the UI
         self.tableView.reloadData()
         break
     case .update(_, let deletions, let insertions, let modifications):
         // Query results have changed, so apply them to the TableView
         self.tableView.beginUpdates()
         self.tableView.insertRows(at: insertions.map { IndexPath(row: $0, section: 0) },
            with: .automatic)
         self.tableView.deleteRows(at: deletions.map { IndexPath(row: $0, section: 0) },
            with: .automatic)
         self.tableView.reloadRows(at: modifications.map { IndexPath(row: $0, section: 0) },
            with: .automatic)
         self.tableView.endUpdates()
         break
     case .error(let err):
         // An error occurred while opening the Realm file on the background worker thread
         fatalError("\(err)")
         break
     }
 }
 ```
 */
public enum RealmCollectionChange<CollectionType> {
    /**
     `.initial` indicates that the initial run of the query has completed (if
     applicable), and the collection can now be used without performing any
     blocking work.
     */
    case initial(CollectionType)
    /**
     `.update` indicates that a write transaction has been committed which
     either changed which objects are in the collection, and/or modified one
     or more of the objects in the collection.
     All three of the change arrays are always sorted in ascending order.
     - parameter deletions:     The indices in the previous version of the collection which were removed from this one.
     - parameter insertions:    The indices in the new collection which were added in this version.
     - parameter modifications: The indices of the objects in the new collection which were modified in this version.
     */
    case update(CollectionType, deletions: [Int], insertions: [Int], modifications: [Int])
    /**
     If an error occurs, notification blocks are called one time with a `.error`
     result and an `NSError` containing details about the error. This can only
     currently happen if opening the Realm on a background thread to calcuate
     the change set fails. The callback will never be called again after it is
     invoked with a .error value.
     */
    case error(Error)
    static func fromObjc(value: CollectionType?, change: RLMCollectionChange?, error: Error?) -> RealmCollectionChange {
        if let error = error {
            return .error(error)
        }
        if let change = change {
            return .update(value!,
                deletions: forceCast(change.deletions, to: [Int].self),
                insertions: forceCast(change.insertions, to: [Int].self),
                modifications: forceCast(change.modifications, to: [Int].self))
        }
        return .initial(value!)
    }
}
private func forceCast<A, U>(_ from: A, to type: U.Type) -> U {
    return from as! U
}
/// A type which can be stored in a Realm List or Results.
///
/// Declaring additional types as conforming to this protocol will not make them
/// actually work. Most of the logic for how to store values in Realm is not
/// implemented in Swift and there is currently no extension mechanism for
/// supporting more types.
public protocol RealmCollectionValue: Equatable {
    /// :nodoc:
    static func _rlmArray() -> RLMArray<AnyObject>
    /// :nodoc:
    static func _nilValue() -> Self
}
extension RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return RLMArray(objectType: .int, optional: false)
    }
    /// :nodoc:
    public static func _nilValue() -> Self {
        fatalError("unexpected NSNull for non-Optional type")
    }
}
private func arrayType<T>(_ type: T.Type) -> RLMArray<AnyObject> {
    switch type {
    case is Int.Type, is Int8.Type, is Int16.Type, is Int32.Type, is Int64.Type:
        return RLMArray(objectType: .int, optional: true)
    case is Bool.Type:   return RLMArray(objectType: .bool, optional: true)
    case is Float.Type:  return RLMArray(objectType: .float, optional: true)
    case is Double.Type: return RLMArray(objectType: .double, optional: true)
    case is String.Type: return RLMArray(objectType: .string, optional: true)
    case is Data.Type:   return RLMArray(objectType: .data, optional: true)
    case is Date.Type:   return RLMArray(objectType: .date, optional: true)
    default: fatalError("Unsupported type for List: \(type)?")
    }
}
extension Optional: RealmCollectionValue where Wrapped: RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return arrayType(Wrapped.self)
    }
    /// :nodoc:
    public static func _nilValue() -> Optional {
        return nil
    }
}
extension Int: RealmCollectionValue {}
extension Int8: RealmCollectionValue {}
extension Int16: RealmCollectionValue {}
extension Int32: RealmCollectionValue {}
extension Int64: RealmCollectionValue {}
extension Float: RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return RLMArray(objectType: .float, optional: false)
    }
}
extension Double: RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return RLMArray(objectType: .double, optional: false)
    }
}
extension Bool: RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return RLMArray(objectType: .bool, optional: false)
    }
}
extension String: RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return RLMArray(objectType: .string, optional: false)
    }
}
extension Date: RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return RLMArray(objectType: .date, optional: false)
    }
}
extension Data: RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return RLMArray(objectType: .data, optional: false)
    }
}
/// :nodoc:
public protocol _RealmCollectionEnumerator {
    // swiftlint:disable:next identifier_name
    func _asNSFastEnumerator() -> Any
}
/// :nodoc:
public protocol RealmCollectionBase: RandomAccessCollection, LazyCollectionProtocol, CustomStringConvertible, ThreadConfined where Element: RealmCollectionValue {
    // This typealias was needed with Swift 3.1. It no longer is, but remains
    // just in case someone was depending on it
    typealias ElementType = Element
}
/**
 A homogenous collection of `Object`s which can be retrieved, filtered, sorted, and operated upon.
*/
public protocol RealmCollection: RealmCollectionBase, _RealmCollectionEnumerator {
    // Must also conform to `AssistedObjectiveCBridgeable`
    // MARK: Properties
    /// The Realm which manages the collection, or `nil` for unmanaged collections.
    var realm: Realm? { get }
    /**
     Indicates if the collection can no longer be accessed.
     The collection can no longer be accessed if `invalidate()` is called on the `Realm` that manages the collection.
     */
    var isInvalidated: Bool { get }
    /// The number of objects in the collection.
    var count: Int { get }
    /// A human-readable description of the objects contained in the collection.
    var description: String { get }
    // MARK: Index Retrieval
    /**
     Returns the index of an object in the collection, or `nil` if the object is not present.
     - parameter object: An object.
     */
    func index(of object: Element) -> Int?
    /**
     Returns the index of the first object matching the predicate, or `nil` if no objects match.
     - parameter predicate: The predicate to use to filter the objects.
     */
    func index(matching predicate: NSPredicate) -> Int?
    /**
     Returns the index of the first object matching the predicate, or `nil` if no objects match.
     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
     */
    func index(matching predicateFormat: String, _ args: Any...) -> Int?
    // MARK: Filtering
    /**
     Returns a `Results` containing all objects matching the given predicate in the collection.
     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
     */
    func filter(_ predicateFormat: String, _ args: Any...) -> Results<Element>
    /**
     Returns a `Results` containing all objects matching the given predicate in the collection.
     - parameter predicate: The predicate to use to filter the objects.
     */
    func filter(_ predicate: NSPredicate) -> Results<Element>
    // MARK: Sorting
    /**
     Returns a `Results` containing the objects in the collection, but sorted.
     Objects are sorted based on the values of the given key path. For example, to sort a collection of `Student`s from
     youngest to oldest based on their `age` property, you might call
     `students.sorted(byKeyPath: "age", ascending: true)`.
     - warning: Collections may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                floating point, integer, and string types.
     - parameter keyPath:   The key path to sort by.
     - parameter ascending: The direction to sort in.
     */
    func sorted(byKeyPath keyPath: String, ascending: Bool) -> Results<Element>
    /**
     Returns a `Results` containing the objects in the collection, but sorted.
     - warning: Collections may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                floating point, integer, and string types.
     - see: `sorted(byKeyPath:ascending:)`
     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
     */
    func sorted<S: Sequence>(by sortDescriptors: S) -> Results<Element> where S.Iterator.Element == SortDescriptor
    // MARK: Aggregate Operations
    /**
     Returns the minimum (lowest) value of the given property among all the objects in the collection, or `nil` if the
     collection is empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    func min<T: MinMaxType>(ofProperty property: String) -> T?
    /**
     Returns the maximum (highest) value of the given property among all the objects in the collection, or `nil` if the
     collection is empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    func max<T: MinMaxType>(ofProperty property: String) -> T?
    /**
    Returns the sum of the given property for objects in the collection, or `nil` if the collection is empty.
    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
    - parameter property: The name of a property conforming to `AddableType` to calculate sum on.
    */
    func sum<T: AddableType>(ofProperty property: String) -> T
    /**
     Returns the average value of a given property over all the objects in the collection, or `nil` if
     the collection is empty.
     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose values should be summed.
     */
    func average(ofProperty property: String) -> Double?
    // MARK: Key-Value Coding
    /**
     Returns an `Array` containing the results of invoking `valueForKey(_:)` with `key` on each of the collection's
     objects.
     - parameter key: The name of the property whose values are desired.
     */
    func value(forKey key: String) -> Any?
    /**
     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` with `keyPath` on each of the
     collection's objects.
     - parameter keyPath: The key path to the property whose values are desired.
     */
    func value(forKeyPath keyPath: String) -> Any?
    /**
     Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified `value` and `key`.
     - warning: This method may only be called during a write transaction.
     - parameter value: The object value.
     - parameter key:   The name of the property whose value should be set on each object.
     */
    func setValue(_ value: Any?, forKey key: String)
    // MARK: Notifications
    /**
     Registers a block to be called each time the collection changes.
     The block will be asynchronously called with the initial results, and then called again after each write
     transaction which changes either any of the objects in the collection, or which objects are in the collection.
     The `change` parameter that is passed to the block reports, in the form of indices within the collection, which of
     the objects were added, removed, or modified during each write transaction. See the `RealmCollectionChange`
     documentation for more information on the change information supplied and an example of how to use it to update a
     `UITableView`.
     At the time when the block is called, the collection will be fully evaluated and up-to-date, and as long as you do
     not perform a write transaction on the same thread or explicitly call `realm.refresh()`, accessing it will never
     perform blocking work.
     If no queue is given, notifications are delivered via the standard run loop, and so can't be delivered while the
     run loop is blocked by other activity. If a queue is given, notifications are delivered to that queue instead. When
     notifications can't be delivered instantly, multiple notifications may be coalesced into a single notification.
     This can include the notification with the initial collection.
     For example, the following code performs a write transaction immediately after adding the notification block, so
     there is no opportunity for the initial notification to be delivered first. As a result, the initial notification
     will reflect the state of the Realm after the write transaction.
     ```swift
     let results = realm.objects(Dog.self)
     print("dogs.count: \(dogs?.count)") // => 0
     let token = dogs.observe { changes in
     switch changes {
         case .initial(let dogs):
             // Will print "dogs.count: 1"
             print("dogs.count: \(dogs.count)")
             break
         case .update:
             // Will not be hit in this example
             break
         case .error:
             break
         }
     }
     try! realm.write {
         let dog = Dog()
         dog.name = "Rex"
         person.dogs.append(dog)
     }
     // end of run loop execution context
     ```
     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
     updates, call `invalidate()` on the token.
     - warning: This method cannot be called during a write transaction, or when the containing Realm is read-only.
     - parameter queue: The serial dispatch queue to receive notification on. If
                        `nil`, notifications are delivered to the current thread.
     - parameter block: The block to be called whenever a change occurs.
     - returns: A token which must be held for as long as you want updates to be delivered.
     */
    func observe(on queue: DispatchQueue?, _ block: @escaping (RealmCollectionChange<Self>) -> Void) -> NotificationToken
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    func _observe(_ queue: DispatchQueue?, _ block: @escaping (RealmCollectionChange<AnyRealmCollection<Element>>) -> Void) -> NotificationToken
    // MARK: Frozen Objects
    /// Returns if this collection is frozen
    var isFrozen: Bool { get }
    /**
     Returns a frozen (immutable) snapshot of this collection.
     The frozen copy is an immutable collection which contains the same data as this collection
    currently contains, but will not update when writes are made to the containing Realm. Unlike
    live collections, frozen collections can be accessed from any thread.
     - warning: This method cannot be called during a write transaction, or when the containing
    Realm is read-only.
     - warning: Holding onto a frozen collection for an extended period while performing write
     transaction on the Realm may result in the Realm file growing to large sizes. See
     `Realm.Configuration.maximumNumberOfActiveVersions` for more information.
    */
    func freeze() -> Self
}
public extension RealmCollection {
    /**
     Returns the index of the first object matching the given predicate, or `nil` if no objects match.
     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
     */
    func index(matching predicateFormat: String, _ args: Any...) -> Int? {
        return index(matching: NSPredicate(format: predicateFormat, argumentArray: unwrapOptionals(in: args)))
    }
    /**
     Returns a `Results` containing all objects matching the given predicate in the collection.
     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
     */
    func filter(_ predicateFormat: String, _ args: Any...) -> Results<Element> {
        return filter(NSPredicate(format: predicateFormat, argumentArray: unwrapOptionals(in: args)))
    }
}
/// :nodoc:
public protocol OptionalProtocol {
    associatedtype Wrapped
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    func _rlmInferWrappedType() -> Wrapped
}
extension Optional: OptionalProtocol {
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _rlmInferWrappedType() -> Wrapped { return self! }
}
public extension RealmCollection where Element: MinMaxType {
    /**
     Returns the minimum (lowest) value of the collection, or `nil` if the collection is empty.
     */
    func min() -> Element? {
        return min(ofProperty: "self")
    }
    /**
     Returns the maximum (highest) value of the collection, or `nil` if the collection is empty.
     */
    func max() -> Element? {
        return max(ofProperty: "self")
    }
}
public extension RealmCollection where Element: OptionalProtocol, Element.Wrapped: MinMaxType {
    /**
     Returns the minimum (lowest) value of the collection, or `nil` if the collection is empty.
     */
    func min() -> Element.Wrapped? {
        return min(ofProperty: "self")
    }
    /**
     Returns the maximum (highest) value of the collection, or `nil` if the collection is empty.
     */
    func max() -> Element.Wrapped? {
        return max(ofProperty: "self")
    }
}
public extension RealmCollection where Element: AddableType {
    /**
     Returns the sum of the values in the collection, or `nil` if the collection is empty.
     */
    func sum() -> Element {
        return sum(ofProperty: "self")
    }
    /**
     Returns the average of all of the values in the collection.
     */
    func average() -> Double? {
        return average(ofProperty: "self")
    }
}
public extension RealmCollection where Element: OptionalProtocol, Element.Wrapped: AddableType {
    /**
     Returns the sum of the values in the collection, or `nil` if the collection is empty.
     */
    func sum() -> Element.Wrapped {
        return sum(ofProperty: "self")
    }
    /**
     Returns the average of all of the values in the collection.
     */
    func average() -> Double? {
        return average(ofProperty: "self")
    }
}
public extension RealmCollection where Element: Comparable {
    /**
     Returns a `Results` containing the objects in the collection, but sorted.
     Objects are sorted based on their values. For example, to sort a collection of `Date`s from
     neweset to oldest based, you might call `dates.sorted(ascending: true)`.
     - parameter ascending: The direction to sort in.
     */
    func sorted(ascending: Bool = true) -> Results<Element> {
        return sorted(byKeyPath: "self", ascending: ascending)
    }
}
public extension RealmCollection where Element: OptionalProtocol, Element.Wrapped: Comparable {
    /**
     Returns a `Results` containing the objects in the collection, but sorted.
     Objects are sorted based on their values. For example, to sort a collection of `Date`s from
     neweset to oldest based, you might call `dates.sorted(ascending: true)`.
     - parameter ascending: The direction to sort in.
     */
    func sorted(ascending: Bool = true) -> Results<Element> {
        return sorted(byKeyPath: "self", ascending: ascending)
    }
}
private class _AnyRealmCollectionBase<T: RealmCollectionValue>: AssistedObjectiveCBridgeable {
    typealias Wrapper = AnyRealmCollection<Element>
    typealias Element = T
    var realm: Realm? { fatalError() }
    var isInvalidated: Bool { fatalError() }
    var count: Int { fatalError() }
    var description: String { fatalError() }
    func index(of object: Element) -> Int? { fatalError() }
    func index(matching predicate: NSPredicate) -> Int? { fatalError() }
    func filter(_ predicate: NSPredicate) -> Results<Element> { fatalError() }
    func sorted(byKeyPath keyPath: String, ascending: Bool) -> Results<Element> { fatalError() }
    func sorted<S: Sequence>(by sortDescriptors: S) -> Results<Element> where S.Iterator.Element == SortDescriptor {
        fatalError()
    }
    func min<T: MinMaxType>(ofProperty property: String) -> T? { fatalError() }
    func max<T: MinMaxType>(ofProperty property: String) -> T? { fatalError() }
    func sum<T: AddableType>(ofProperty property: String) -> T { fatalError() }
    func average(ofProperty property: String) -> Double? { fatalError() }
    subscript(position: Int) -> Element { fatalError() }
    func makeIterator() -> RLMIterator<T> { fatalError() }
    var startIndex: Int { fatalError() }
    var endIndex: Int { fatalError() }
    func value(forKey key: String) -> Any? { fatalError() }
    func value(forKeyPath keyPath: String) -> Any? { fatalError() }
    func setValue(_ value: Any?, forKey key: String) { fatalError() }
    // swiftlint:disable:next identifier_name
    func _observe(_ queue: DispatchQueue?, _ block: @escaping (RealmCollectionChange<Wrapper>) -> Void)
        -> NotificationToken { fatalError() }
    class func bridging(from objectiveCValue: Any, with metadata: Any?) -> Self { fatalError() }
    var bridged: (objectiveCValue: Any, metadata: Any?) { fatalError() }
    // swiftlint:disable:next identifier_name
    func _asNSFastEnumerator() -> Any { fatalError() }
    var isFrozen: Bool { fatalError() }
    func freeze() -> AnyRealmCollection<T> { fatalError() }
}
private final class _AnyRealmCollection<C: RealmCollection>: _AnyRealmCollectionBase<C.Element> {
    let base: C
    init(base: C) {
        self.base = base
    }
    // MARK: Properties
    override var realm: Realm? { return base.realm }
    override var isInvalidated: Bool { return base.isInvalidated }
    override var count: Int { return base.count }
    override var description: String { return base.description }
    // MARK: Index Retrieval
    override func index(of object: C.Element) -> Int? { return base.index(of: object) }
    override func index(matching predicate: NSPredicate) -> Int? { return base.index(matching: predicate) }
    // MARK: Filtering
    override func filter(_ predicate: NSPredicate) -> Results<C.Element> { return base.filter(predicate) }
    // MARK: Sorting
    override func sorted(byKeyPath keyPath: String, ascending: Bool) -> Results<C.Element> {
        return base.sorted(byKeyPath: keyPath, ascending: ascending)
    }
    override func sorted<S: Sequence>
        (by sortDescriptors: S) -> Results<C.Element> where S.Iterator.Element == SortDescriptor {
        return base.sorted(by: sortDescriptors)
    }
    // MARK: Aggregate Operations
    override func min<T: MinMaxType>(ofProperty property: String) -> T? {
        return base.min(ofProperty: property)
    }
    override func max<T: MinMaxType>(ofProperty property: String) -> T? {
        return base.max(ofProperty: property)
    }
    override func sum<T: AddableType>(ofProperty property: String) -> T {
        return base.sum(ofProperty: property)
    }
    override func average(ofProperty property: String) -> Double? {
        return base.average(ofProperty: property)
    }
    // MARK: Sequence Support
    override subscript(position: Int) -> C.Element {
        return base[position as! C.Index]
    }
    override func makeIterator() -> RLMIterator<Element> {
        // FIXME: it should be possible to avoid this force-casting
        return base.makeIterator() as! RLMIterator<Element>
    }
    /// :nodoc:
    override func _asNSFastEnumerator() -> Any {
        return base._asNSFastEnumerator()
    }
    // MARK: Collection Support
    override var startIndex: Int {
        // FIXME: it should be possible to avoid this force-casting
        return base.startIndex as! Int
    }
    override var endIndex: Int {
        // FIXME: it should be possible to avoid this force-casting
        return base.endIndex as! Int
    }
    // MARK: Key-Value Coding
    override func value(forKey key: String) -> Any? { return base.value(forKey: key) }
    override func value(forKeyPath keyPath: String) -> Any? { return base.value(forKeyPath: keyPath) }
    override func setValue(_ value: Any?, forKey key: String) { base.setValue(value, forKey: key) }
    // MARK: Notifications
    /// :nodoc:
    override func _observe(_ queue: DispatchQueue?, _ block: @escaping (RealmCollectionChange<Wrapper>) -> Void)
        -> NotificationToken { return base._observe(queue, block) }
    // MARK: AssistedObjectiveCBridgeable
    override class func bridging(from objectiveCValue: Any, with metadata: Any?) -> _AnyRealmCollection {
        return _AnyRealmCollection(
            base: (C.self as! AssistedObjectiveCBridgeable.Type).bridging(from: objectiveCValue, with: metadata) as! C)
    }
    override var bridged: (objectiveCValue: Any, metadata: Any?) {
        return (base as! AssistedObjectiveCBridgeable).bridged
    }
    override var isFrozen: Bool {
        return base.isFrozen
    }
    override func freeze() -> AnyRealmCollection<Element> {
        return AnyRealmCollection(base.freeze())
    }
}
/**
 A type-erased `RealmCollection`.
 Instances of `RealmCollection` forward operations to an opaque underlying collection having the same `Element` type.
 */
public struct AnyRealmCollection<Element: RealmCollectionValue>: RealmCollection {
    /// The type of the objects contained within the collection.
    public typealias ElementType = Element
    public func index(after i: Int) -> Int { return i + 1 }
    public func index(before i: Int) -> Int { return i - 1 }
    /// The type of the objects contained in the collection.
    fileprivate let base: _AnyRealmCollectionBase<Element>
    fileprivate init(base: _AnyRealmCollectionBase<Element>) {
        self.base = base
    }
    /// Creates an `AnyRealmCollection` wrapping `base`.
    public init<C: RealmCollection>(_ base: C) where C.Element == Element {
        self.base = _AnyRealmCollection(base: base)
    }
    // MARK: Properties
    /// The Realm which manages the collection, or `nil` if the collection is unmanaged.
    public var realm: Realm? { return base.realm }
    /**
     Indicates if the collection can no longer be accessed.
     The collection can no longer be accessed if `invalidate()` is called on the containing `realm`.
     */
    public var isInvalidated: Bool { return base.isInvalidated }
    /// The number of objects in the collection.
    public var count: Int { return base.count }
    /// A human-readable description of the objects contained in the collection.
    public var description: String { return base.description }
    // MARK: Index Retrieval
    /**
     Returns the index of the given object, or `nil` if the object is not in the collection.
     - parameter object: An object.
     */
    public func index(of object: Element) -> Int? { return base.index(of: object) }
    /**
     Returns the index of the first object matching the given predicate, or `nil` if no objects match.
     - parameter predicate: The predicate with which to filter the objects.
     */
    public func index(matching predicate: NSPredicate) -> Int? { return base.index(matching: predicate) }
    // MARK: Filtering
    /**
     Returns a `Results` containing all objects matching the given predicate in the collection.
     - parameter predicate: The predicate with which to filter the objects.
     - returns: A `Results` containing objects that match the given predicate.
     */
    public func filter(_ predicate: NSPredicate) -> Results<Element> { return base.filter(predicate) }
    // MARK: Sorting
    /**
     Returns a `Results` containing the objects in the collection, but sorted.
     Objects are sorted based on the values of the given key path. For example, to sort a collection of `Student`s from
     youngest to oldest based on their `age` property, you might call
     `students.sorted(byKeyPath: "age", ascending: true)`.
     - warning:  Collections may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                 floating point, integer, and string types.
     - parameter keyPath:  The key path to sort by.
     - parameter ascending: The direction to sort in.
     */
    public func sorted(byKeyPath keyPath: String, ascending: Bool) -> Results<Element> {
        return base.sorted(byKeyPath: keyPath, ascending: ascending)
    }
    /**
     Returns a `Results` containing the objects in the collection, but sorted.
     - warning:  Collections may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                 floating point, integer, and string types.
     - see: `sorted(byKeyPath:ascending:)`
     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
     */
    public func sorted<S: Sequence>(by sortDescriptors: S) -> Results<Element>
        where S.Iterator.Element == SortDescriptor {
        return base.sorted(by: sortDescriptors)
    }
    // MARK: Aggregate Operations
    /**
     Returns the minimum (lowest) value of the given property among all the objects in the collection, or `nil` if the
     collection is empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    public func min<T: MinMaxType>(ofProperty property: String) -> T? {
        return base.min(ofProperty: property)
    }
    /**
     Returns the maximum (highest) value of the given property among all the objects in the collection, or `nil` if the
     collection is empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    public func max<T: MinMaxType>(ofProperty property: String) -> T? {
        return base.max(ofProperty: property)
    }
    /**
     Returns the sum of the values of a given property over all the objects in the collection.
     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose values should be summed.
     */
    public func sum<T: AddableType>(ofProperty property: String) -> T { return base.sum(ofProperty: property) }
    /**
     Returns the average value of a given property over all the objects in the collection, or `nil` if the collection is
     empty.
     - warning: Only the name of a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose average value should be calculated.
     */
    public func average(ofProperty property: String) -> Double? { return base.average(ofProperty: property) }
    // MARK: Sequence Support
    /**
     Returns the object at the given `index`.
     - parameter index: The index.
     */
    public subscript(position: Int) -> Element { return base[position] }
    /// Returns a `RLMIterator` that yields successive elements in the collection.
    public func makeIterator() -> RLMIterator<Element> { return base.makeIterator() }
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _asNSFastEnumerator() -> Any { return base._asNSFastEnumerator() }
    // MARK: Collection Support
    /// The position of the first element in a non-empty collection.
    /// Identical to endIndex in an empty collection.
    public var startIndex: Int { return base.startIndex }
    /// The collection's "past the end" position.
    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
    /// zero or more applications of successor().
    public var endIndex: Int { return base.endIndex }
    // MARK: Key-Value Coding
    /**
     Returns an `Array` containing the results of invoking `valueForKey(_:)` with `key` on each of the collection's
     objects.
     - parameter key: The name of the property whose values are desired.
     */
    public func value(forKey key: String) -> Any? { return base.value(forKey: key) }
    /**
     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` with `keyPath` on each of the
     collection's objects.
     - parameter keyPath: The key path to the property whose values are desired.
     */
    public func value(forKeyPath keyPath: String) -> Any? { return base.value(forKeyPath: keyPath) }
    /**
     Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified `value` and `key`.
     - warning: This method may only be called during a write transaction.
     - parameter value: The value to set the property to.
     - parameter key:   The name of the property whose value should be set on each object.
     */
    public func setValue(_ value: Any?, forKey key: String) { base.setValue(value, forKey: key) }
    // MARK: Notifications
    /**
     Registers a block to be called each time the collection changes.
     The block will be asynchronously called with the initial results, and then called again after each write
     transaction which changes either any of the objects in the collection, or which objects are in the collection.
     The `change` parameter that is passed to the block reports, in the form of indices within the collection, which of
     the objects were added, removed, or modified during each write transaction. See the `RealmCollectionChange`
     documentation for more information on the change information supplied and an example of how to use it to update a
     `UITableView`.
     At the time when the block is called, the collection will be fully evaluated and up-to-date, and as long as you do
     not perform a write transaction on the same thread or explicitly call `realm.refresh()`, accessing it will never
     perform blocking work.
     Notifications are delivered via the standard run loop, and so can't be delivered while the run loop is blocked by
     other activity. When notifications can't be delivered instantly, multiple notifications may be coalesced into a
     single notification. This can include the notification with the initial collection.
     For example, the following code performs a write transaction immediately after adding the notification block, so
     there is no opportunity for the initial notification to be delivered first. As a result, the initial notification
     will reflect the state of the Realm after the write transaction.
     ```swift
     let results = realm.objects(Dog.self)
     print("dogs.count: \(dogs?.count)") // => 0
     let token = dogs.observe { changes in
         switch changes {
         case .initial(let dogs):
             // Will print "dogs.count: 1"
             print("dogs.count: \(dogs.count)")
             break
         case .update:
             // Will not be hit in this example
             break
         case .error:
             break
         }
     }
     try! realm.write {
         let dog = Dog()
         dog.name = "Rex"
         person.dogs.append(dog)
     }
     // end of run loop execution context
     ```
     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
     updates, call `invalidate()` on the token.
     - warning: This method cannot be called during a write transaction, or when the containing Realm is read-only.
     - parameter block: The block to be called whenever a change occurs.
     - returns: A token which must be held for as long as you want updates to be delivered.
     */
    public func observe(on queue: DispatchQueue? = nil,
                        _ block: @escaping (RealmCollectionChange<AnyRealmCollection>) -> Void)
        -> NotificationToken { return base._observe(queue, block) }
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _observe(_ queue: DispatchQueue?, _ block: @escaping (RealmCollectionChange<AnyRealmCollection>) -> Void)
        -> NotificationToken { return base._observe(queue, block) }
    // MARK: Frozen Objects
    /// Returns if this collection is frozen.
    public var isFrozen: Bool { return base.isFrozen }
    /**
     Returns a frozen (immutable) snapshot of this collection.
     The frozen copy is an immutable collection which contains the same data as this collection
    currently contains, but will not update when writes are made to the containing Realm. Unlike
    live collections, frozen collections can be accessed from any thread.
     - warning: This method cannot be called during a write transaction, or when the containing
    Realm is read-only.
     - warning: Holding onto a frozen collection for an extended period while performing write
     transaction on the Realm may result in the Realm file growing to large sizes. See
     `Realm.Configuration.maximumNumberOfActiveVersions` for more information.
    */
    public func freeze() -> AnyRealmCollection { return base.freeze() }
}
// MARK: AssistedObjectiveCBridgeable
private struct AnyRealmCollectionBridgingMetadata<T: RealmCollectionValue> {
    var baseMetadata: Any?
    var baseType: _AnyRealmCollectionBase<T>.Type
}
extension AnyRealmCollection: AssistedObjectiveCBridgeable {
    internal static func bridging(from objectiveCValue: Any, with metadata: Any?) -> AnyRealmCollection {
        guard let metadata = metadata as? AnyRealmCollectionBridgingMetadata<Element> else { preconditionFailure() }
        return AnyRealmCollection(base: metadata.baseType.bridging(from: objectiveCValue, with: metadata.baseMetadata))
    }
    internal var bridged: (objectiveCValue: Any, metadata: Any?) {
        return (
            objectiveCValue: base.bridged.objectiveCValue,
            metadata: AnyRealmCollectionBridgingMetadata(baseMetadata: base.bridged.metadata, baseType: type(of: base))
        )
    }
}
// MARK: Collection observation helpers
internal protocol ObservableCollection: RealmCollection {
    associatedtype BackingObjcCollection
    func isSameObjcCollection(_ objc: BackingObjcCollection) -> Bool
    init(objc: BackingObjcCollection)
}
extension ObservableCollection {
    // We want to pass the same object instance to the change callback each time.
    // If the callback is being called on the source thread the instance should
    // be `self`, but if it's on a different thread it needs to be a new Swift
    // wrapper for the obj-c type, which we'll construct the first time the
    // callback is called.
    internal typealias ObjcCollectionChange = (BackingObjcCollection?, RLMCollectionChange?, Error?) -> Void
    internal func wrapObserveBlock(_ block: @escaping (RealmCollectionChange<AnyRealmCollection<Element>>) -> Void) -> ObjcCollectionChange {
        var anyCollection: AnyRealmCollection<Element>?
        return { collection, change, error in
            if anyCollection == nil, let collection = collection {
                anyCollection = AnyRealmCollection(self.isSameObjcCollection(collection) ? self : Self(objc: collection))
            }
            block(RealmCollectionChange.fromObjc(value: anyCollection, change: change, error: error))
        }
    }
    internal func wrapObserveBlock(_ block: @escaping (RealmCollectionChange<Self>) -> Void) -> ObjcCollectionChange {
        var list: Self?
        return { array, change, error in
            if list == nil, let array = array {
                list = self.isSameObjcCollection(array) ? self : Self(objc: array)
            }
            block(RealmCollectionChange.fromObjc(value: list, change: change, error: error))
        }
    }
}
extension List: ObservableCollection {
    internal typealias BackingObjcCollection = RLMArray<AnyObject>
    internal func isSameObjcCollection(_ rlmArray: BackingObjcCollection) -> Bool {
        return _rlmArray === rlmArray
    }
}
extension Results: ObservableCollection {
    internal typealias BackingObjcCollection = RLMResults<AnyObject>
    internal func isSameObjcCollection(_ objc: RLMResults<AnyObject>) -> Bool {
        return objc === rlmResults
    }
}
extension LinkingObjects: ObservableCollection {
    internal typealias BackingObjcCollection = RLMResults<AnyObject>
    internal func isSameObjcCollection(_ objc: RLMResults<AnyObject>) -> Bool {
        return objc === rlmResults
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2016 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Realm
import Realm.Private
/**
 An object representing a Realm Object Server user.
 - see: `RLMSyncUser`
 */
public typealias SyncUser = RLMSyncUser
/**
 An immutable data object representing information retrieved from the Realm Object
 Server about a particular user.
 - see: `RLMSyncUserInfo`
 */
public typealias SyncUserInfo = RLMSyncUserInfo
/**
 An immutable data object representing an account belonging to a particular user.
 - see: `SyncUserInfo`, `RLMSyncUserAccountInfo`
 */
public typealias SyncUserAccountInfo = RLMSyncUserAccountInfo
/**
 A singleton which configures and manages the Realm Object Server synchronization-related
 functionality.
 - see: `RLMSyncManager`
 */
public typealias SyncManager = RLMSyncManager
extension SyncManager {
    /// The sole instance of the singleton.
    public static var shared: SyncManager {
        return __shared()
    }
}
/**
 Options for configuring timeouts and intervals in the sync client.
  - see: `RLMSyncTimeoutOptions`
 */
public typealias SyncTimeoutOptions = RLMSyncTimeoutOptions
/**
 A session object which represents communication between the client and server for a specific
 Realm.
 - see: `RLMSyncSession`
 */
public typealias SyncSession = RLMSyncSession
/**
 A closure type for a closure which can be set on the `SyncManager` to allow errors to be reported
 to the application.
 - see: `RLMSyncErrorReportingBlock`
 */
public typealias ErrorReportingBlock = RLMSyncErrorReportingBlock
/**
 A closure type for a closure which is used by certain APIs to asynchronously return a `SyncUser`
 object to the application.
 - see: `RLMUserCompletionBlock`
 */
public typealias UserCompletionBlock = RLMUserCompletionBlock
/**
 An error associated with the SDK's synchronization functionality. All errors reported by
 an error handler registered on the `SyncManager` are of this type.
 - see: `RLMSyncError`
 */
public typealias SyncError = RLMSyncError
extension SyncError {
    /**
     An opaque token allowing the user to take action after certain types of
     errors have been reported.
     - see: `RLMSyncErrorActionToken`
     */
    public typealias ActionToken = RLMSyncErrorActionToken
    /**
     Given a client reset error, extract and return the recovery file path
     and the action token.
     The action token can be passed into `SyncSession.immediatelyHandleError(_:)`
     to immediately delete the local copy of the Realm which experienced the
     client reset error. The local copy of the Realm must be deleted before
     your application attempts to open the Realm again.
     The recovery file path is the path to which the current copy of the Realm
     on disk will be saved once the client reset occurs.
     - warning: Do not call `SyncSession.immediatelyHandleError(_:)` until you are
                sure that all references to the Realm and managed objects belonging
                to the Realm have been nil'ed out, and that all autorelease pools
                containing these references have been drained.
     - see: `SyncError.ActionToken`, `SyncSession.immediatelyHandleError(_:)`
     */
    public func clientResetInfo() -> (String, SyncError.ActionToken)? {
        if code == SyncError.clientResetError,
            let recoveryPath = userInfo[kRLMSyncPathOfRealmBackupCopyKey] as? String,
            let token = _nsError.__rlmSync_errorActionToken() {
            return (recoveryPath, token)
        }
        return nil
    }
    /**
     Given a permission denied error, extract and return the action token.
     This action token can be passed into `SyncSession.immediatelyHandleError(_:)`
     to immediately delete the local copy of the Realm which experienced the
     permission denied error. The local copy of the Realm must be deleted before
     your application attempts to open the Realm again.
     - warning: Do not call `SyncSession.immediatelyHandleError(_:)` until you are
                sure that all references to the Realm and managed objects belonging
                to the Realm have been nil'ed out, and that all autorelease pools
                containing these references have been drained.
     - see: `SyncError.ActionToken`, `SyncSession.immediatelyHandleError(_:)`
     */
    public func deleteRealmUserInfo() -> SyncError.ActionToken? {
        return _nsError.__rlmSync_errorActionToken()
    }
}
/**
 An error associated with network requests made to the authentication server. This type of error
 may be returned in the callback block to `SyncUser.logIn()` upon certain types of failed login
 attempts (for example, if the request is malformed or if the server is experiencing an issue).
 - see: `RLMSyncAuthError`
 */
public typealias SyncAuthError = RLMSyncAuthError
/**
 An enum which can be used to specify the level of logging.
 - see: `RLMSyncLogLevel`
 */
public typealias SyncLogLevel = RLMSyncLogLevel
/**
 A data type whose values represent different authentication providers that can be used with
 the Realm Object Server.
 - see: `RLMIdentityProvider`
 */
public typealias Provider = RLMIdentityProvider
/**
 * How the Realm client should validate the identity of the server for secure connections.
 *
 * By default, when connecting to the Realm Object Server over HTTPS, Realm will
 * validate the server's HTTPS certificate using the system trust store and root
 * certificates. For additional protection against man-in-the-middle (MITM)
 * attacks and similar vulnerabilities, you can pin a certificate or public key,
 * and reject all others, even if they are signed by a trusted CA.
 */
public enum ServerValidationPolicy {
    /// Perform no validation and accept potentially invalid certificates.
    ///
    /// - warning: DO NOT USE THIS OPTION IN PRODUCTION.
    case none
    /// Use the default server trust evaluation based on the system-wide CA
    /// store. Any certificate signed by a trusted CA will be accepted.
    case system
    /// Use a specific pinned certificate to validate the server identify.
    ///
    /// This will only connect to a server if one of the server certificates
    /// matches the certificate stored at the given local path and that
    /// certificate has a valid trust chain.
    ///
    /// On macOS, the certificate files may be in any of the formats supported
    /// by SecItemImport(), including PEM and .cer (see SecExternalFormat for a
    /// complete list of possible formats). On iOS and other platforms, only
    /// DER .cer files are supported.
    case pinCertificate(path: URL)
}
/**
 A `SyncConfiguration` represents configuration parameters for Realms intended to sync with
 a Realm Object Server.
 */
public struct SyncConfiguration {
    /// The `SyncUser` who owns the Realm that this configuration should open.
    public let user: SyncUser
    /**
     The URL of the Realm on the Realm Object Server that this configuration should open.
     - warning: The URL must be absolute (e.g. `realms://example.com/~/foo`), and cannot end with
                `.realm`, `.realm.lock` or `.realm.management`.
     */
    public let realmURL: URL
    /**
     A policy that determines what should happen when all references to Realms opened by this
     configuration go out of scope.
     */
    internal let stopPolicy: RLMSyncStopPolicy
    /**
     How the SSL certificate of the Realm Object Server should be validated.
     */
    public let serverValidationPolicy: ServerValidationPolicy
    /// :nodoc:
    @available(*, unavailable, message: "Use serverValidationPolicy instead")
    public var enableSSLValidation: Bool {
        fatalError()
    }
    /// :nodoc:
    @available(*, unavailable, message: "Use fullSynchronization instead")
    public var isPartial: Bool {
        fatalError()
    }
    /**
     Whether this Realm should be a fully synchronized Realm.
     Synchronized Realms comes in two flavors: Query-based and Fully synchronized.
     A fully synchronized Realm will automatically synchronize the entire Realm in the background
     while a query-based Realm will only synchronize the data being subscribed to.
     Synchronized realms are by default query-based unless this boolean is set.
     */
    public let fullSynchronization: Bool
    /**
     The prefix that is prepended to the path in the HTTP request
     that initiates a sync connection. The value specified must match with the server's expectation.
     Changing the value of `urlPrefix` should be matched with a corresponding
     change of the server's configuration.
     If no value is specified here then the default `/realm-sync` path is used.
     */
    public let urlPrefix: String?
    /**
     By default, Realm.asyncOpen() swallows non-fatal connection errors such as
     a connection attempt timing out and simply retries until it succeeds. If
     this is set to `true`, instead the error will be reported to the callback
     and the async open will be cancelled.
     */
    public let cancelAsyncOpenOnNonFatalErrors: Bool
    internal init(config: RLMSyncConfiguration) {
        self.user = config.user
        self.realmURL = config.realmURL
        self.stopPolicy = config.stopPolicy
        if let certificateURL = config.pinnedCertificateURL {
            self.serverValidationPolicy = .pinCertificate(path: certificateURL)
        } else {
            self.serverValidationPolicy = config.enableSSLValidation ? .system : .none
        }
        self.fullSynchronization = config.fullSynchronization
        self.urlPrefix = config.urlPrefix
        self.cancelAsyncOpenOnNonFatalErrors = config.cancelAsyncOpenOnNonFatalErrors
    }
    func asConfig() -> RLMSyncConfiguration {
        var validateSSL = true
        var certificate: URL?
        switch serverValidationPolicy {
        case .none:
            validateSSL = false
        case .system:
            break
        case .pinCertificate(let path):
            certificate = path
        }
        let c = RLMSyncConfiguration(user: user, realmURL: realmURL,
                                     isPartial: !fullSynchronization,
                                     urlPrefix: urlPrefix,
                                     stopPolicy: stopPolicy,
                                     enableSSLValidation: validateSSL,
                                     certificatePath: certificate)
        c.cancelAsyncOpenOnNonFatalErrors = cancelAsyncOpenOnNonFatalErrors
        return c
    }
    /// :nodoc:
    @available(*, unavailable, message: "Use SyncUser.configuration() instead")
    public init(user: SyncUser, realmURL: URL, enableSSLValidation: Bool = true, isPartial: Bool = false, urlPrefix: String? = nil) {
        fatalError()
    }
    /// :nodoc:
    @available(*, unavailable, message: "Use SyncUser.configuration() instead")
    public static func automatic() -> Realm.Configuration {
        fatalError()
    }
    /// :nodoc:
    @available(*, unavailable, message: "Use SyncUser.configuration() instead")
    public static func automatic(user: SyncUser) -> Realm.Configuration {
        fatalError()
    }
}
/// A `SyncCredentials` represents data that uniquely identifies a Realm Object Server user.
public struct SyncCredentials {
    /// An account token serialized as a string
    public typealias Token = String
    internal var token: Token
    internal var provider: Provider
    internal var userInfo: [String: Any]
    /**
     Initialize new credentials using a custom token, authentication provider, and user information
     dictionary. In most cases, the convenience initializers should be used instead.
     */
    public init(customToken token: Token, provider: Provider, userInfo: [String: Any] = [:]) {
        self.token = token
        self.provider = provider
        self.userInfo = userInfo
    }
    internal init(_ credentials: RLMSyncCredentials) {
        self.token = credentials.token
        self.provider = credentials.provider
        self.userInfo = credentials.userInfo
    }
    /// Initialize new credentials using a Facebook account token.
    public static func facebook(token: Token) -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials(facebookToken: token))
    }
    /// Initialize new credentials using a Google account token.
    public static func google(token: Token) -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials(googleToken: token))
    }
    /// Initialize new credentials using a CloudKit account token.
    public static func cloudKit(token: Token) -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials(cloudKitToken: token))
    }
    /// Initialize new credentials using a Realm Object Server username and password.
    public static func usernamePassword(username: String,
                                        password: String,
                                        register: Bool = false) -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials(username: username, password: password, register: register))
    }
    /// Initialize new credentials using a Realm Object Server access token.
    public static func accessToken(_ accessToken: String, identity: String) -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials(accessToken: accessToken, identity: identity))
    }
    /// Initialize new credentials using a JSON Web Token.
    public static func jwt(_ token: Token) -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials(jwt: token))
    }
    /// Initialize new credentials using a nickname.
    @available(*, deprecated, message: "Use usernamePassword instead.")
    public static func nickname(_ nickname: String, isAdmin: Bool = false) -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials(nickname: nickname, isAdmin: isAdmin))
    }
    /// Initialize new credentials anonymously
    public static func anonymous() -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials.anonymous())
    }
    /// Initialize new credentials using an externally-issued refresh token
    public static func customRefreshToken(_ token: String, identity: String, isAdmin: Bool = false) -> SyncCredentials {
        return SyncCredentials(RLMSyncCredentials(customRefreshToken: token, identity: identity, isAdmin: isAdmin))
    }
}
extension RLMSyncCredentials {
    internal convenience init(_ credentials: SyncCredentials) {
        self.init(customToken: credentials.token, provider: credentials.provider, userInfo: credentials.userInfo)
    }
}
extension SyncUser {
    /**
     Log in a user and asynchronously retrieve a user object.
     If the log in completes successfully, the completion block will be called, and a
     `SyncUser` representing the logged-in user will be passed to it. This user object
     can be used to open `Realm`s and retrieve `SyncSession`s. Otherwise, the
     completion block will be called with an error.
     - parameter credentials: A `SyncCredentials` object representing the user to log in.
     - parameter authServerURL: The URL of the authentication server (e.g. "http://realm.example.org:9080").
     - parameter timeout: How long the network client should wait, in seconds, before timing out.
     - parameter callbackQueue: The dispatch queue upon which the callback should run. Defaults to the main queue.
     - parameter completion: A callback block to be invoked once the log in completes.
     */
    public static func logIn(with credentials: SyncCredentials,
                             server authServerURL: URL,
                             timeout: TimeInterval = 30,
                             callbackQueue queue: DispatchQueue = DispatchQueue.main,
                             onCompletion completion: @escaping UserCompletionBlock) {
        return SyncUser.__logIn(with: RLMSyncCredentials(credentials),
                                authServerURL: authServerURL,
                                timeout: timeout,
                                callbackQueue: queue,
                                onCompletion: completion)
    }
    /// A dictionary of all valid, logged-in user identities corresponding to their `SyncUser` objects.
    public static var all: [String: SyncUser] {
        return __allUsers()
    }
    /**
     The logged-in user. `nil` if none exists. Only use this property if your application expects
     no more than one logged-in user at any given time.
     - warning: Throws an Objective-C exception if more than one logged-in user exists.
     */
    public static var current: SyncUser? {
        return __current()
    }
    /**
     An optional error handler which can be set to notify the host application when
     the user encounters an error.
     - note: Check for `.invalidAccessToken` to see if the user has been remotely logged
             out because its refresh token expired, or because the third party authentication
             service providing the user's identity has logged the user out.
     - warning: Regardless of whether an error handler is defined, certain user errors
                will automatically cause the user to enter the logged out state.
     */
    @nonobjc public var errorHandler: ((SyncUser, SyncAuthError) -> Void)? {
        get {
            return __errorHandler
        }
        set {
            if let newValue = newValue {
                __errorHandler = { (user, error) in
                    newValue(user, error as! SyncAuthError)
                }
            } else {
                __errorHandler = nil
            }
        }
    }
    /**
     Create a permission offer for a Realm.
     A permission offer is used to grant access to a Realm this user manages to another
     user. Creating a permission offer produces a string token which can be passed to the
     recepient in any suitable way (for example, via e-mail).
     The operation will take place asynchronously. The token can be accepted by the recepient
     using the `SyncUser.acceptOffer(forToken:, callback:)` method.
     - parameter url: The URL of the Realm for which the permission offer should pertain. This
                      may be the URL of any Realm which this user is allowed to manage. If the URL
                      has a `~` wildcard it will be replaced with this user's user identity.
     - parameter accessLevel: What access level to grant to whoever accepts the token.
     - parameter expiration: Optionally, a date which indicates when the offer expires. If the
                             recepient attempts to accept the offer after the date it will be rejected.
                             If nil, the offer will never expire.
     - parameter callback: A callback indicating whether the operation succeeded or failed. If it
                           succeeded the token will be passed in as a string.
     */
    public func createOfferForRealm(at url: URL,
                                    accessLevel: SyncAccessLevel,
                                    expiration: Date? = nil,
                                    callback: @escaping (String?, Error?) -> Void) {
        self.__createOfferForRealm(at: url, accessLevel: accessLevel, expiration: expiration, callback: callback)
    }
    /**
     Create a sync configuration instance.
     Additional settings can be optionally specified. Descriptions of these
     settings follow.
     `enableSSLValidation` is true by default. It can be disabled for debugging
     purposes.
     - warning: The URL must be absolute (e.g. `realms://example.com/~/foo`), and cannot end with
     `.realm`, `.realm.lock` or `.realm.management`.
     - warning: NEVER disable SSL validation for a system running in production.
     */
    public func configuration(realmURL: URL? = nil, fullSynchronization: Bool = false,
                              enableSSLValidation: Bool, urlPrefix: String? = nil) -> Realm.Configuration {
        let config = self.__configuration(with: realmURL,
                                          fullSynchronization: fullSynchronization,
                                          enableSSLValidation: enableSSLValidation,
                                          urlPrefix: urlPrefix)
        return ObjectiveCSupport.convert(object: config)
    }
    /**
     Create a sync configuration instance.
     - parameter realmURL: The URL to connect to. If not set, the default Realm
     derived from the authentication URL is used. The URL must be absolute (e.g.
     `realms://example.com/~/foo`), and cannot end with `.realm`, `.realm.lock`
     or `.realm.management`.
     - parameter serverValidationPolicy: How the SSL certificate of the Realm Object
     Server should be validated. By default the system SSL validation is used,
     but it can be set to `.pinCertificate` to pin a specific SSL certificate,
     or `.none` for debugging.
     - parameter fullSynchronization: Whether this Realm should be a fully
     synchronized or a query-based Realm.
     - parameter urlPrefix: The prefix that is prepended to the path in the HTTP
     request that initiates a sync connection. The value specified must match
     with the server's expectation, and this parameter only needs to be set if
     you have changed the configuration of the server.
     - parameter cancelAsyncOpenOnNonFatalErrors: By default, Realm.asyncOpen()
     swallows non-fatal connection errors such as a connection attempt timing
     out and simply retries until it succeeds. If this is set to `true`, instead
     the error will be reported to the callback and the async open will be
     cancelled.
     - warning: NEVER disable SSL validation for a system running in production.
     */
    public func configuration(realmURL: URL? = nil, fullSynchronization: Bool = false,
                              serverValidationPolicy: ServerValidationPolicy = .system,
                              urlPrefix: String? = nil,
                              cancelAsyncOpenOnNonFatalErrors: Bool = false) -> Realm.Configuration {
        let config = self.__configuration(with: realmURL, fullSynchronization: fullSynchronization)
        let syncConfig = config.syncConfiguration!
        syncConfig.urlPrefix = urlPrefix
        syncConfig.cancelAsyncOpenOnNonFatalErrors = cancelAsyncOpenOnNonFatalErrors
        switch serverValidationPolicy {
        case .none:
            syncConfig.enableSSLValidation = false
        case .system:
            break
        case .pinCertificate(let path):
            syncConfig.pinnedCertificateURL = path
        }
        config.syncConfiguration = syncConfig
        return ObjectiveCSupport.convert(object: config)
    }
}
/**
 A value which represents a permission granted to a user to interact
 with a Realm. These values are passed into APIs on `SyncUser`, and
 returned from `SyncPermissionResults`.
 - see: `RLMSyncPermission`
 */
public typealias SyncPermission = RLMSyncPermission
/**
 An enumeration describing possible access levels.
 - see: `RLMSyncAccessLevel`
 */
public typealias SyncAccessLevel = RLMSyncAccessLevel
public extension SyncSession {
    /**
     The current state of the session represented by a session object.
     - see: `RLMSyncSessionState`
     */
    typealias State = RLMSyncSessionState
    /**
     The current state of a sync session's connection.
     - see: `RLMSyncConnectionState`
     */
    typealias ConnectionState = RLMSyncConnectionState
    /**
     The transfer direction (upload or download) tracked by a given progress notification block.
     Progress notification blocks can be registered on sessions if your app wishes to be informed
     how many bytes have been uploaded or downloaded, for example to show progress indicator UIs.
     */
    enum ProgressDirection {
        /// For monitoring upload progress.
        case upload
        /// For monitoring download progress.
        case download
    }
    /**
     The desired behavior of a progress notification block.
     Progress notification blocks can be registered on sessions if your app wishes to be informed
     how many bytes have been uploaded or downloaded, for example to show progress indicator UIs.
     */
    enum ProgressMode {
        /**
         The block will be called forever, or until it is unregistered by calling
         `ProgressNotificationToken.invalidate()`.
         Notifications will always report the latest number of transferred bytes, and the
         most up-to-date number of total transferrable bytes.
         */
        case reportIndefinitely
        /**
         The block will, upon registration, store the total number of bytes
         to be transferred. When invoked, it will always report the most up-to-date number
         of transferrable bytes out of that original number of transferrable bytes.
         When the number of transferred bytes reaches or exceeds the
         number of transferrable bytes, the block will be unregistered.
         */
        case forCurrentlyOutstandingWork
    }
    /**
     A token corresponding to a progress notification block.
     Call `invalidate()` on the token to stop notifications. If the notification block has already
     been automatically stopped, calling `invalidate()` does nothing. `invalidate()` should be called
     before the token is destroyed.
     */
    typealias ProgressNotificationToken = RLMProgressNotificationToken
    /**
     A struct encapsulating progress information, as well as useful helper methods.
     */
    struct Progress {
        /// The number of bytes that have been transferred.
        public let transferredBytes: Int
        /**
         The total number of transferrable bytes (bytes that have been transferred,
         plus bytes pending transfer).
         If the notification block is tracking downloads, this number represents the size of the
         changesets generated by all other clients using the Realm.
         If the notification block is tracking uploads, this number represents the size of the
         changesets representing the local changes on this client.
         */
        public let transferrableBytes: Int
        /// The fraction of bytes transferred out of all transferrable bytes. If this value is 1,
        /// no bytes are waiting to be transferred (either all bytes have already been transferred,
        /// or there are no bytes to be transferred in the first place).
        public var fractionTransferred: Double {
            if transferrableBytes == 0 {
                return 1
            }
            let percentage = Double(transferredBytes) / Double(transferrableBytes)
            return percentage > 1 ? 1 : percentage
        }
        /// Whether all pending bytes have already been transferred.
        public var isTransferComplete: Bool {
            return transferredBytes >= transferrableBytes
        }
        internal init(transferred: UInt, transferrable: UInt) {
            transferredBytes = Int(transferred)
            transferrableBytes = Int(transferrable)
        }
    }
    /**
     Register a progress notification block.
     If the session has already received progress information from the
     synchronization subsystem, the block will be called immediately. Otherwise, it
     will be called as soon as progress information becomes available.
     Multiple blocks can be registered with the same session at once. Each block
     will be invoked on a side queue devoted to progress notifications.
     The token returned by this method must be retained as long as progress
     notifications are desired, and the `invalidate()` method should be called on it
     when notifications are no longer needed and before the token is destroyed.
     If no token is returned, the notification block will never be called again.
     There are a number of reasons this might be true. If the session has previously
     experienced a fatal error it will not accept progress notification blocks. If
     the block was configured in the `forCurrentlyOutstandingWork` mode but there
     is no additional progress to report (for example, the number of transferrable bytes
     and transferred bytes are equal), the block will not be called again.
     - parameter direction: The transfer direction (upload or download) to track in this progress notification block.
     - parameter mode:      The desired behavior of this progress notification block.
     - parameter block:     The block to invoke when notifications are available.
     - returns: A token which must be held for as long as you want notifications to be delivered.
     - see: `ProgressDirection`, `Progress`, `ProgressNotificationToken`
     */
    func addProgressNotification(for direction: ProgressDirection,
                                 mode: ProgressMode,
                                 block: @escaping (Progress) -> Void) -> ProgressNotificationToken? {
        return __addProgressNotification(for: (direction == .upload ? .upload : .download),
                                         mode: (mode == .reportIndefinitely
                                            ? .reportIndefinitely
                                            : .forCurrentlyOutstandingWork)) { transferred, transferrable in
                                                block(Progress(transferred: transferred, transferrable: transferrable))
        }
    }
}
extension Realm {
    /// :nodoc:
    @available(*, unavailable, message: "Use Results.subscribe()")
    public func subscribe<T: Object>(to objects: T.Type, where: String,
                                     completion: @escaping (Results<T>?, Swift.Error?) -> Void) {
        fatalError()
    }
    /**
     Get the SyncSession used by this Realm. Will be nil if this is not a
     synchronized Realm.
    */
    public var syncSession: SyncSession? {
        return SyncSession(for: rlmRealm)
    }
}
// MARK: - Permissions and permission results
extension SyncPermission: RealmCollectionValue { }
/**
 An array containing sync permission results.
 */
public typealias SyncPermissionResults = [SyncPermission]
// MARK: - Partial sync subscriptions
/// The possible states of a sync subscription.
public enum SyncSubscriptionState: Equatable {
    /// The subscription is being created, but has not yet been written to the synced Realm.
    case creating
    /// The subscription has been created, and is waiting to be processed by the server.
    case pending
    /// The subscription has been processed by the server, and objects matching the subscription
    /// are now being synchronized to this client.
    case complete
    /// The subscription has been removed.
    case invalidated
    /// An error occurred while creating the subscription or while the server was processing it.
    case error(Error)
    internal init(_ rlmSubscription: RLMSyncSubscription) {
        switch rlmSubscription.state {
        case .creating:
            self = .creating
        case .pending:
            self = .pending
        case .complete:
            self = .complete
        case .invalidated:
            self = .invalidated
        case .error:
            self = .error(rlmSubscription.error!)
        }
    }
    public static func == (lhs: SyncSubscriptionState, rhs: SyncSubscriptionState) -> Bool {
        switch (lhs, rhs) {
        case (.creating, .creating), (.pending, .pending), (.complete, .complete), (.invalidated, .invalidated):
            return true
        case (.error(let e1), .error(let e2)):
            return e1 == e2
        default:
            return false
        }
    }
}
/// `SyncSubscription` represents a subscription to a set of objects in a synced Realm.
///
/// When partial sync is enabled for a synced Realm, the only objects that the server synchronizes to the
/// client are those that match a sync subscription registered by that client. A subscription consists of
/// of a query (represented by a `Results`) and an optional name.
///
/// Changes to the state of the subscription can be observed using `SyncSubscription.observe(_:options:_:)`.
///
/// Subscriptions are created using `Results.subscribe()` or `Results.subscribe(named:)`.
public struct SyncSubscription: RealmCollectionValue {
    private let rlmSubscription: RLMSyncSubscription
    /// The name of the subscription.
    ///
    /// This will be `nil` if a name was not provided when the subscription was created.
    public var name: String? { return rlmSubscription.name }
    /// The state of the subscription.
    public var state: SyncSubscriptionState { return SyncSubscriptionState(rlmSubscription) }
    /**
     The raw query which this subscription is running on the server.
     This string is a serialized representation of the Results which the
     subscription was created from. This representation does *not* use NSPredicate
     syntax, and is not guaranteed to remain consistent between versions of Realm.
     Any use of this other than manual inspection when debugging is likely to be
     incorrect.
     This is `nil` while the subscription is in the Creating state.
     */
    public var query: String? { return rlmSubscription.query }
    /**
     When this subscription was first created.
     This value will be `nil` for subscriptions created with older versions of
     Realm which did not store the creation date. Newly created subscriptions
     should always have a non-nil creation date.
     */
    public var createdAt: Date? { return rlmSubscription.createdAt }
    /**
     When this subscription was last updated.
     This value will be `nil` for subscriptions created with older versions of
     Realm which did not store the update date. Newly created subscriptions
     should always have a non-nil update date.
     The update date is the time when the subscription was last updated by a call
     to `Results.subscribe()`, and not when the set of objects which match the
     subscription last changed.
     */
    public var updatedAt: Date? { return rlmSubscription.updatedAt }
    /**
     When this subscription will be automatically removed.
     If the `timeToLive` parameter is set when creating a sync subscription, the
     subscription will be automatically removed the first time that any subscription
     is created, modified, or deleted after that time has elapsed.
     This property will be `nil` if the `timeToLive` option was not enabled.
     */
    public var expiresAt: Date? { return rlmSubscription.expiresAt }
    /**
     How long this subscription will persist after last being updated.
     If the `timeToLive` parameter is set when creating a sync subscription, the
     subscription will be automatically removed the first time that any subscription
     is created, modified, or deleted after that time has elapsed.
     This property will be nil if the `timeToLive` option was not enabled.
     */
    public var timeToLive: TimeInterval? {
        let ttl = rlmSubscription.timeToLive
        return ttl.isNaN ? nil : ttl
    }
    internal init(_ rlmSubscription: RLMSyncSubscription) {
        self.rlmSubscription = rlmSubscription
    }
    public static func == (lhs: SyncSubscription, rhs: SyncSubscription) -> Bool {
        return lhs.rlmSubscription == rhs.rlmSubscription
    }
    /// Observe the subscription for state changes.
    ///
    /// When the state of the subscription changes, `block` will be invoked and
    /// passed the new state.
    ///
    /// The token returned from this function does not hold a strong reference to
    /// this subscription object. This means that you must hold a reference to
    /// the subscription object itself along with the returned token in order to
    /// actually receive updates about the state.
    ///
    /// - parameter keyPath: The path to observe. Must be `\.state`.
    /// - parameter options: Options for the observation. Only `NSKeyValueObservingOptions.initial` option is
    ///                      is supported at this time.
    /// - parameter block: The block to be called whenever a change occurs.
    /// - returns: A token which must be held for as long as you want updates to be delivered.
    public func observe(_ keyPath: KeyPath<SyncSubscription, SyncSubscriptionState>,
                        options: NSKeyValueObservingOptions = [],
                        _ block: @escaping (SyncSubscriptionState) -> Void) -> NotificationToken {
        let observation = rlmSubscription.observe(\.state, options: options) { rlmSubscription, _ in
            block(SyncSubscriptionState(rlmSubscription))
        }
        return KeyValueObservationNotificationToken(observation)
    }
    /// Remove this subscription
    ///
    /// Removing a subscription will delete all objects from the local Realm that were matched
    /// only by that subscription and not any remaining subscriptions. The deletion is performed
    /// by the server, and so has no immediate impact on the contents of the local Realm. If the
    /// device is currently offline, the removal will not be processed until the device returns online.
    public func unsubscribe() {
        rlmSubscription.unsubscribe()
    }
}
// :nodoc:
extension SyncSubscription: CustomObjectiveCBridgeable {
    internal static func bridging(objCValue: Any) -> SyncSubscription {
        return ObjectiveCSupport.convert(object: RLMCastToSyncSubscription(objCValue))
    }
    internal var objCValue: Any {
        return 0
    }
}
extension Results {
    // MARK: Sync
    /// Subscribe to the query represented by this `Results`
    ///
    /// Subscribing to a query asks the server to synchronize all objects to the
    /// client which match the query, along with all objects which are reachable
    /// from those objects via links. This happens asynchronously, and the local
    /// client Realm may not immediately have all objects which match the query.
    /// Observe the `state` property of the returned subscription object to be
    /// notified of when the subscription has been processed by the server and
    /// all objects matching the query are available.
    ///
    /// ---
    ///
    /// Creating a new subscription with the same name and query as an existing
    /// subscription will not create a new subscription, but instead will return
    /// an object referring to the existing sync subscription. This means that
    /// performing the same subscription twice followed by removing it once will
    /// result in no subscription existing.
    ///
    /// By default trying to create a subscription with a name as an existing
    /// subscription with a different query or options will fail. If `update` is
    /// `true`, instead the existing subscription will be changed to use the
    /// query and options from the new subscription. This only works if the new
    /// subscription is for the same type of objects as the existing
    /// subscription, and trying to overwrite a subscription with a subscription
    /// of a different type of objects will still fail.
    ///
    /// ---
    ///
    /// The number of top-level objects which are included in the subscription
    /// can optionally be limited by setting the `limit` paramter. If more
    /// top-level objects than the limit match the query, only the first
    /// `limit` objects will be included. This respects the sort and distinct
    /// order of the query being subscribed to for the determination of what the
    /// "first" objects are.
    ///
    /// The limit does not count or apply to objects which are added indirectly
    /// due to being linked to by the objects in the subscription or due to
    /// being listed in `includeLinkingObjects`. If the limit is larger than the
    /// number of objects which match the query, all objects will be
    /// included.
    ///
    /// ---
    ///
    /// By default subscriptions are persistent, and last until they are
    /// explicitly removed by calling `unsubscribe()`. Subscriptions can instead
    /// be made temporary by setting the time to live to how long the
    /// subscription should remain. After that time has elapsed the subscription
    /// will be automatically removed.
    ///
    /// ---
    ///
    /// Outgoing links (i.e. `List` and `Object` properties) are automatically
    /// included in sync subscriptions. That is, if you subscribe to a query
    /// which matches one object, every object which is reachable via links
    /// from that object are also included in the subscription. By default,
    /// `LinkingObjects` properties do not work this way and instead, they only
    /// report objects which happen to be included in a subscription. Specific
    /// `LinkingObjects` properties can be explicitly included in the
    /// subscription by naming them in the `includingLinkingObjects` array. Any
    /// keypath which ends in a `LinkingObjects` property can be included in
    /// this array, including ones involving intermediate links.
    ///
    /// ---
    ///
    /// Creating a subscription is an asynchronous operation and the newly
    /// created subscription will not be reported by Realm.subscriptions() until
    /// it has transitioned from the `.creating` state to `.pending`,
    /// `.created` or `.error`.
    ///
    /// - parameter subscriptionName: An optional name for the subscription.
    /// - parameter limit: The maximum number of top-level objects to include
    /// in the subscription.
    /// - parameter update: Whether an existing subscription with the same name
    /// should be updated or if it should be an error.
    /// - parameter timeToLive: How long in seconds this subscription should
    /// remain active.
    /// - parameter includingLinkingObjects: Which `LinkingObjects` properties
    /// should pull in the contained objects.
    /// - returns: The subscription.
    public func subscribe(named subscriptionName: String? = nil, limit: Int? = nil,
                          update: Bool = false, timeToLive: TimeInterval? = nil,
                          includingLinkingObjects: [String] = []) -> SyncSubscription {
        let options = RLMSyncSubscriptionOptions()
        options.name = subscriptionName
        options.overwriteExisting = update
        if let limit = limit {
            options.limit = UInt(limit)
        }
        if let timeToLive = timeToLive {
            options.timeToLive = timeToLive
        }
        options.includeLinkingObjectProperties = includingLinkingObjects
        return SyncSubscription(rlmResults.subscribe(with: options))
    }
}
internal class KeyValueObservationNotificationToken: NotificationToken {
    public var observation: NSKeyValueObservation?
    public init(_ observation: NSKeyValueObservation) {
        super.init()
        self.observation = observation
    }
    public override func invalidate() {
        self.observation = nil
    }
}
// MARK: - Permissions
/**
 A permission which can be applied to a Realm, Class, or specific Object.
 Permissions are applied by adding the permission to the RealmPermission singleton
 object, the ClassPermission object for the desired class, or to a user-defined
 List<Permission> property on a specific Object instance. The meaning of each of
 the properties of Permission depend on what the permission is applied to, and so are
 left undocumented here. See `RealmPrivileges`, `ClassPrivileges`, and
 `ObjectPrivileges` for details about what each of the properties mean when applied to
 that type.
 */
@objc(RealmSwiftPermission)
public class Permission: Object {
    /// The Role which this Permission applies to. All users within the Role are
    /// granted the permissions specified by the fields below any
    /// objects/classes/realms which use this Permission.
    ///
    /// This property cannot be modified once set.
    @objc dynamic public var role: PermissionRole?
    /// Whether the user can read the object to which this Permission is attached.
    @objc dynamic public var canRead = false
    /// Whether the user can modify the object to which this Permission is attached.
    @objc dynamic public var canUpdate = false
    /// Whether the user can delete the object to which this Permission is attached.
    ///
    /// This field is only applicable to Permissions attached to Objects, and not
    /// to Realms or Classes.
    @objc dynamic public var canDelete = false
    /// Whether the user can add or modify Permissions for the object which this
    /// Permission is attached to.
    @objc dynamic public var canSetPermissions = false
    /// Whether the user can subscribe to queries for this object type.
    ///
    /// This field is only applicable to Permissions attached to Classes, and not
    /// to Realms or Objects.
    @objc dynamic public var canQuery = false
    /// Whether the user can create new objects of the type this Permission is attached to.
    ///
    /// This field is only applicable to Permissions attached to Classes, and not
    /// to Realms or Objects.
    @objc dynamic public var canCreate = false
    /// Whether the user can modify the schema of the Realm which this
    /// Permission is attached to.
    ///
    /// This field is only applicable to Permissions attached to Realms, and not
    /// to Realms or Objects.
    @objc dynamic public var canModifySchema = false
    /// :nodoc:
    @objc override public class func _realmObjectName() -> String {
        return "__Permission"
    }
}
/**
 A Role within the permissions system.
 A Role consists of a name for the role and a list of users which are members of the role.
 Roles are granted privileges on Realms, Classes and Objects, and in turn grant those
 privileges to all users which are members of the role.
 A role named "everyone" is automatically created in new Realms, and all new users which
 connect to the Realm are automatically added to it. Any other roles you wish to use are
 managed as normal Realm objects.
 */
@objc(RealmSwiftPermissionRole)
public class PermissionRole: Object {
    /// The name of the Role
    @objc dynamic public var name = ""
    /// The users which belong to the role
    public let users = List<PermissionUser>()
    /// :nodoc:
    @objc override public class func _realmObjectName() -> String {
        return "__Role"
    }
    /// :nodoc:
    @objc override public class func primaryKey() -> String {
        return "name"
    }
    /// :nodoc:
    @objc override public class func _realmColumnNames() -> [String: String] {
        return ["users": "members"]
    }
}
/**
 A representation of a sync user within the permissions system.
 PermissionUser objects are created automatically for each sync user which connects to
 a Realm, and can also be created manually if you wish to grant permissions to a user
 which has not yet connected to this Realm. When creating a PermissionUser manually, you
 must also manually add it to the "everyone" Role.
 */
@objc(RealmSwiftPermissionUser)
public class PermissionUser: Object {
    /// The unique Realm Object Server user ID string identifying this user. This will
    /// have the same value as `SyncUser.identity`
    @objc dynamic public var identity = ""
    /// The user's private role. This will be initialized to a role named for the user's
    /// identity that contains this user as its only member.
    @objc dynamic public var role: PermissionRole?
    /// Roles which this user belongs to.
    public let roles = LinkingObjects(fromType: PermissionRole.self, property: "users")
    /// :nodoc:
    @objc override public class func _realmObjectName() -> String {
        return "__User"
    }
    /// :nodoc:
    @objc override public class func primaryKey() -> String {
        return "identity"
    }
    /// :nodoc:
    @objc override public class func _realmColumnNames() -> [String: String] {
        return ["identity": "id", "role": "role"]
    }
}
/**
 A singleton object which describes Realm-wide permissions.
 An object of this type is automatically created in the Realm for you, and more objects
 cannot be created manually.
 See `RealmPrivileges` for the meaning of permissions applied to a Realm.
 */
@objc(RealmSwiftRealmPermission)
public class RealmPermission: Object {
    @objc private var id = 0
    /// The permissions for the Realm.
    public let permissions = List<Permission>()
    /// :nodoc:
    @objc override public class func _realmObjectName() -> String {
        return "__Realm"
    }
    /// :nodoc:
    @objc override public class func primaryKey() -> String {
        return "id"
    }
}
/**
 An object which describes class-wide permissions.
 An instance of this object is automatically created in the Realm for class in your schema,
 and should not be created manually.
 */
@objc(RealmSwiftClassPermission)
public class ClassPermission: Object {
    /// The name of the class which these permissions apply to.
    @objc dynamic public var name = ""
    /// The permissions for this class.
    public let permissions = List<Permission>()
    /// :nodoc:
    @objc override public class func _realmObjectName() -> String {
        return "__Class"
    }
    /// :nodoc:
    @objc override public class func primaryKey() -> String {
        return "name"
    }
}
private func optionSetDescription<T: OptionSet>(_ optionSet: T,
                                                _ allValues: [(T.Element, String)]) -> String {
    let valueStr = allValues.filter({ value, _ in optionSet.contains(value) })
                            .map({ _, name in name })
                            .joined(separator: ", ")
    return "\(String(describing: T.self))[\(valueStr)]"
}
/**
 A description of the actual privileges which apply to a Realm.
 This is a combination of all of the privileges granted to all of the Roles which the
 current User is a member of, obtained by calling `realm.getPrivileges()`.
 By default, all operations are permitted, and each privilege field indicates an operation
 which may be forbidden.
 */
public struct RealmPrivileges: OptionSet, CustomDebugStringConvertible {
    public let rawValue: UInt8
    public init(rawValue: RawValue) {
        self.rawValue = rawValue
    }
    /// :nodoc:
    public var debugDescription: String {
        return optionSetDescription(self, [(.read, "read"),
                                           (.update, "update"),
                                           (.setPermissions, "setPermissions"),
                                           (.modifySchema, "modifySchema")])
    }
    /// If `false`, the current User is not permitted to see the Realm at all. This can
    /// happen only if the Realm was created locally and has not yet been synchronized.
    public static let read = RealmPrivileges(rawValue: 1 << 0)
    /// If `false`, no modifications to the Realm are permitted. Write transactions can
    /// be performed locally, but any changes made will be reverted by the server.
    /// `setPermissions` and `modifySchema` will always be `false` when this is `false`.
    public static let update = RealmPrivileges(rawValue: 1 << 1)
    /// If `false`, no modifications to the permissions property of the RLMRealmPermissions
    /// object for are permitted. Write transactions can be performed locally, but any
    /// changes made will be reverted by the server.
    ///
    /// Note that if invalide privilege changes are made, `-[RLMRealm privilegesFor*:]`
    /// will return results reflecting those invalid changes until synchronization occurs.
    ///
    /// Even if this field is `true`, note that the user will be unable to grant
    /// privileges to a Role which they do not themselves have.
    ///
    /// Adding or removing Users from a Role is controlled by Update privileges on that
    /// Role, and not by this value.
    public static let setPermissions = RealmPrivileges(rawValue: 1 << 3)
    /// If `false`, the user is not permitted to add new object types to the Realm or add
    /// new properties to existing objec types. Defining new RLMObject subclasses (and not
    /// excluding them from the schema with `-[RLMRealmConfiguration setObjectClasses:]`)
    /// will result in the application crashing if the object types are not first added on
    /// the server by a more privileged user.
    public static let modifySchema = RealmPrivileges(rawValue: 1 << 6)
}
/**
 A description of the actual privileges which apply to a Class within a Realm.
 This is a combination of all of the privileges granted to all of the Roles which the
 current User is a member of, obtained by calling `realm.getPrivileges(ObjectClass.self)`
 or `realm.getPrivileges(forClassNamed: "className")`
 By default, all operations are permitted, and each privilege field indicates an operation
 which may be forbidden.
 */
public struct ClassPrivileges: OptionSet, CustomDebugStringConvertible {
    public let rawValue: UInt8
    public init(rawValue: RawValue) {
        self.rawValue = rawValue
    }
    /// :nodoc:
    public var debugDescription: String {
        return optionSetDescription(self, [(.read, "read"),
                                           (.create, "create"),
                                           (.update, "update"),
                                           (.subscribe, "subscribe"),
                                           (.setPermissions, "setPermissions")])
    }
    /// If `false`, the current User is not permitted to see objects of this type, and
    /// attempting to query this class will always return empty results.
    ///
    /// Note that Read permissions are transitive, and so it may be possible to read an
    /// object which the user does not directly have Read permissions for by following a
    /// link to it from an object they do have Read permissions for. This does not apply
    /// to any of the other permission types.
    public static let read = ClassPrivileges(rawValue: 1 << 0)
    /// If `false`, creating new objects of this type is not permitted. Write transactions
    /// creating objects can be performed locally, but the objects will be deleted by the
    /// server when synchronization occurs.
    ///
    /// For objects with Primary Keys, it may not be locally determinable if Create or
    /// Update privileges are applicable. It may appear that you are creating a new object,
    /// but an object with that Primary Key may already exist and simply not be visible to
    /// you, in which case it is actually an Update operation.
    /// Deleting an object is considered a modification, and is governed by this privilege.
    public static let create = ClassPrivileges(rawValue: 1 << 5)
    /// If `false`, no modifications to objects of this type are permitted. Write
    /// transactions modifying the objects can be performed locally, but any changes made
    /// will be reverted by the server.
    ///
    /// Deleting an object is considered a modification, and is governed by this privilege.
    public static let update = ClassPrivileges(rawValue: 1 << 1)
    /// If `false`, the User is not permitted to create new subscriptions for this class.
    /// Local queries against the objects within the Realm will work, but new
    /// subscriptions will never add objects to the Realm.
    public static let subscribe = ClassPrivileges(rawValue: 1 << 4)
    /// If `false`, no modifications to the permissions property of the RLMClassPermissions
    /// object for this type are permitted. Write transactions can be performed locally,
    /// but any changes made will be reverted by the server.
    ///
    /// Note that if invalid privilege changes are made, `-[Realm privilegesFor*:]`
    /// will return results reflecting those invalid changes until synchronization occurs.
    ///
    /// Even if this field is `true`, note that the user will be unable to grant
    /// privileges to a Role which they do not themselves have.
    public static let setPermissions = ClassPrivileges(rawValue: 1 << 3)
}
/**
 A description of the actual privileges which apply to a specific Object.
 This is a combination of all of the privileges granted to all of the Roles which the
 current User is a member of, obtained by calling `realm.getPrivileges(object)`.
 By default, all operations are permitted, and each privilege field indicates an operation
 which may be forbidden.
 */
public struct ObjectPrivileges: OptionSet, CustomDebugStringConvertible {
    public let rawValue: UInt8
    public init(rawValue: RawValue) {
        self.rawValue = rawValue
    }
    /// :nodoc:
    public var debugDescription: String {
        return optionSetDescription(self, [(.read, "read"),
                                           (.update, "update"),
                                           (.delete, "delete"),
                                           (.setPermissions, "setPermissions")])
    }
    /// If `false`, the current User is not permitted to read this object directly.
    ///
    /// Objects which cannot be read by a user will appear in a Realm due to that read
    /// permissions are transitive. All objects which a readable object links to are
    /// themselves implicitly readable. If the link to an object with `read=false` is
    /// removed, the object will be deleted from the local Realm.
    public static let read = ObjectPrivileges(rawValue: 1 << 0)
    /// If `false`, modifying the fields of this type is not permitted. Write
    /// transactions modifying the objects can be performed locally, but any changes made
    /// will be reverted by the server.
    ///
    /// Note that even if this is `true`, the user may not be able to modify the
    /// `List<Permission>` property of the object (if it exists), as that is
    /// governed by `setPermissions`.
    public static let update = ObjectPrivileges(rawValue: 1 << 1)
    /// If `false`, deleting this object is not permitted. Write transactions which delete
    /// the object can be performed locally, but the server will restore it.
    ///
    /// It is possible to have `update` but not `delete` privileges, or vice versa. For
    /// objects with primary keys, `delete` but not `update` is ill-advised, as an object
    /// can be updated by deleting and recreating it.
    public static let delete = ObjectPrivileges(rawValue: 1 << 2)
    /// If `false`, modifying the privileges of this specific object is not permitted.
    ///
    /// Object-specific permissions are set by declaring a `List<Permission>`
    /// property on the `Object` subclass. Modifications to this property are
    /// controlled by `setPermissions` rather than `update`.
    ///
    /// Even if this field is `true`, note that the user will be unable to grant
    /// privileges to a Role which they do not themselves have.
    public static let setPermissions = ObjectPrivileges(rawValue: 1 << 3)
}
extension Realm {
    // MARK: Sync - Permissions
    /**
    Returns the computed privileges which the current user has for this Realm.
    This combines all privileges granted on the Realm by all Roles which the
    current User is a member of into the final privileges which will be
    enforced by the server.
    The privilege calculation is done locally using cached data, and inherently
    may be stale. It is possible that this method may indicate that an
    operation is permitted but the server will still reject it if permission is
    revoked before the changes have been integrated on the server.
    Non-synchronized and fully-synchronized Realms always have permission to
    perform all operations.
     - returns: The privileges which the current user has for the current Realm.
     */
    public func getPrivileges() -> RealmPrivileges {
        return RealmPrivileges(rawValue: RLMGetComputedPermissions(rlmRealm, nil))
    }
    /**
    Returns the computed privileges which the current user has for the given object.
    This combines all privileges granted on the object by all Roles which the
    current User is a member of into the final privileges which will be
    enforced by the server.
    The privilege calculation is done locally using cached data, and inherently
    may be stale. It is possible that this method may indicate that an
    operation is permitted but the server will still reject it if permission is
    revoked before the changes have been integrated on the server.
    Non-synchronized and fully-synchronized Realms always have permission to
    perform all operations.
    The object must be a valid object managed by this Realm. Passing in an
    invalidated object, an unmanaged object, or an object managed by a
    different Realm will throw an exception.
     - parameter object: A managed object to get the privileges for.
     - returns: The privileges which the current user has for the given object.
    */
    public func getPrivileges(_ object: Object) -> ObjectPrivileges {
        return ObjectPrivileges(rawValue: RLMGetComputedPermissions(rlmRealm, object))
    }
    /**
    Returns the computed privileges which the current user has for the given class.
    This combines all privileges granted on the class by all Roles which the
    current User is a member of into the final privileges which will be
    enforced by the server.
    The privilege calculation is done locally using cached data, and inherently
    may be stale. It is possible that this method may indicate that an
    operation is permitted but the server will still reject it if permission is
    revoked before the changes have been integrated on the server.
    Non-synchronized and fully-synchronized Realms always have permission to
    perform all operations.
     - parameter cls: An Object subclass to get the privileges for.
     - returns: The privileges which the current user has for the given class.
    */
    public func getPrivileges<T: Object>(_ cls: T.Type) -> ClassPrivileges {
        return ClassPrivileges(rawValue: RLMGetComputedPermissions(rlmRealm, cls.className()))
    }
    /**
    Returns the computed privileges which the current user has for the named class.
    This combines all privileges granted on the class by all Roles which the
    current User is a member of into the final privileges which will be
    enforced by the server.
    The privilege calculation is done locally using cached data, and inherently
    may be stale. It is possible that this method may indicate that an
    operation is permitted but the server will still reject it if permission is
    revoked before the changes have been integrated on the server.
    Non-synchronized and fully-synchronized Realms always have permission to
    perform all operations.
     - parameter className: The name of an Object subclass to get the privileges for.
     - returns: The privileges which the current user has for the named class.
    */
    public func getPrivileges(forClassNamed className: String) -> ClassPrivileges {
        return ClassPrivileges(rawValue: RLMGetComputedPermissions(rlmRealm, className))
    }
    /**
    Returns the class-wide permissions for the given class.
     - parameter cls: An Object subclass to get the permissions for.
     - returns: The class-wide permissions for the given class.
     - requires: This must only be called on a Realm using query-based sync.
    */
    public func permissions<T: Object>(forType cls: T.Type) -> List<Permission> {
        return permissions(forClassNamed: cls._realmObjectName() ?? cls.className())
    }
    /**
    Returns the class-wide permissions for the named class.
     - parameter cls: The name of an Object subclass to get the permissions for.
     - returns: The class-wide permissions for the named class.
     - requires: className must name a class in this Realm's schema.
     - requires: This must only be called on a Realm using query-based sync.
    */
    public func permissions(forClassNamed className: String) -> List<Permission> {
        let classPermission = object(ofType: ClassPermission.self, forPrimaryKey: className)!
        return classPermission.permissions
    }
    /**
    Returns the Realm-wide permissions.
     - requires: This must only be called on a Realm using query-based sync.
    */
    public var permissions: List<Permission> {
        return object(ofType: RealmPermission.self, forPrimaryKey: 0)!.permissions
    }
    // MARK: Sync - Subscriptions
    /**
    Returns this list of the query-based sync subscriptions made for this Realm.
    This list includes all subscriptions which are currently in the states
    `.pending`, `.created`, and `.error`. Newly created subscriptions which are
    still in the `.creating` state are not included, and calling this
    immediately after calling `Results.subscribe()` will typically not include
    that subscription. Similarly, because unsubscription happens asynchronously,
    this may continue to include subscriptions after
    `SyncSubscription.unsubscribe()` is called on them.
     - requires: This must only be called on a Realm using query-based sync.
    */
    public func subscriptions() -> Results<SyncSubscription> {
        return Results(rlmRealm.subscriptions() as! RLMResults<AnyObject>)
    }
    /**
    Returns the named query-based sync subscription, if it exists.
    Subscriptions are created asynchronously, so calling this immediately after
    calling Results.subscribe(named:)` will typically return `nil`. Only
    subscriptions which are currently in the states `.pending`, `.created`,
    and `.error` can be retrieved with this method.
     - requires: This must only be called on a Realm using query-based sync.
    */
    public func subscription(named: String) -> SyncSubscription? {
        return rlmRealm.subscription(withName: named).map(SyncSubscription.init)
    }
}
extension List where Element == Permission {
    /**
    Returns the Permission object for the named Role in this List, creating it if needed.
    This function should be used in preference to manually querying the List for
    the applicable Permission as it ensures that there is exactly one Permission
    for the given Role, merging duplicates and inserting new ones as needed.
     - warning: This can only be called on a managed List<Permission>.
     - warning: The managing Realm must be in a write transaction.
     - parameter roleName: The name of the Role to obtain the Permission for.
     - returns: A Permission object contained in this List for the named Role.
    */
    public func findOrCreate(forRoleNamed roleName: String) -> Permission {
        precondition(realm != nil, "Cannot be called on an unmanaged object")
        return RLMPermissionForRole(_rlmArray, realm!.create(PermissionRole.self, value: [roleName], update: .modified)) as! Permission
    }
    /**
    Returns the Permission object for the named Role in this List, creating it if needed.
    This function should be used in preference to manually querying the List for
    the applicable Permission as it ensures that there is exactly one Permission
    for the given Role, merging duplicates and inserting new ones as needed.
     - warning: This can only be called on a managed List<Permission>.
     - warning: The managing Realm must be in a write transaction.
     - parameter roleName: The name of the Role to obtain the Permission for.
     - returns: A Permission object contained in this List for the named Role.
    */
    public func findOrCreate(forRole role: PermissionRole) -> Permission {
        precondition(realm != nil, "Cannot be called on an unmanaged object")
        return RLMPermissionForRole(_rlmArray, role) as! Permission
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2016 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
/**
 `LinkingObjects` is an auto-updating container type. It represents zero or more objects that are linked to its owning
 model object through a property relationship.
 `LinkingObjects` can be queried with the same predicates as `List<Element>` and `Results<Element>`.
 `LinkingObjects` always reflects the current state of the Realm on the current thread, including during write
 transactions on the current thread. The one exception to this is when using `for...in` enumeration, which will always
 enumerate over the linking objects that were present when the enumeration is begun, even if some of them are deleted or
 modified to no longer link to the target object during the enumeration.
 `LinkingObjects` can only be used as a property on `Object` models. Properties of this type must be declared as `let`
 and cannot be `dynamic`.
 */
public struct LinkingObjects<Element: Object> {
    /// The type of the objects represented by the linking objects.
    public typealias ElementType = Element
    // MARK: Properties
    /// The Realm which manages the linking objects, or `nil` if the linking objects are unmanaged.
    public var realm: Realm? { return rlmResults.isAttached ? Realm(rlmResults.realm) : nil }
    /// Indicates if the linking objects are no longer valid.
    ///
    /// The linking objects become invalid if `invalidate()` is called on the containing `realm` instance.
    ///
    /// An invalidated linking objects can be accessed, but will always be empty.
    public var isInvalidated: Bool { return rlmResults.isInvalidated }
    /// The number of linking objects.
    public var count: Int { return Int(rlmResults.count) }
    // MARK: Initializers
    /**
     Creates an instance of a `LinkingObjects`. This initializer should only be called when declaring a property on a
     Realm model.
     - parameter type:         The type of the object owning the property the linking objects should refer to.
     - parameter propertyName: The property name of the property the linking objects should refer to.
     */
    public init(fromType _: Element.Type, property propertyName: String) {
        self.propertyName = propertyName
    }
    /// A human-readable description of the objects represented by the linking objects.
    public var description: String {
        if realm == nil {
            var this = self
            return withUnsafePointer(to: &this) {
                return "LinkingObjects<\(Element.className())> <\($0)> (\n\n)"
            }
        }
        return RLMDescriptionWithMaxDepth("LinkingObjects", rlmResults, RLMDescriptionMaxDepth)
    }
    // MARK: Index Retrieval
    /**
     Returns the index of an object in the linking objects, or `nil` if the object is not present.
     - parameter object: The object whose index is being queried.
     */
    public func index(of object: Element) -> Int? {
        return notFoundToNil(index: rlmResults.index(of: object.unsafeCastToRLMObject()))
    }
    /**
     Returns the index of the first object matching the given predicate, or `nil` if no objects match.
     - parameter predicate: The predicate with which to filter the objects.
     */
    public func index(matching predicate: NSPredicate) -> Int? {
        return notFoundToNil(index: rlmResults.indexOfObject(with: predicate))
    }
    // MARK: Object Retrieval
    /**
     Returns the object at the given `index`.
     - parameter index: The index.
     */
    public subscript(index: Int) -> Element {
        throwForNegativeIndex(index)
        return unsafeBitCast(rlmResults[UInt(index)], to: Element.self)
    }
    /// Returns the first object in the linking objects, or `nil` if the linking objects are empty.
    public var first: Element? { return unsafeBitCast(rlmResults.firstObject(), to: Optional<Element>.self) }
    /// Returns the last object in the linking objects, or `nil` if the linking objects are empty.
    public var last: Element? { return unsafeBitCast(rlmResults.lastObject(), to: Optional<Element>.self) }
    // MARK: KVC
    /**
     Returns an `Array` containing the results of invoking `valueForKey(_:)` with `key` on each of the linking objects.
     - parameter key: The name of the property whose values are desired.
     */
    public func value(forKey key: String) -> Any? {
        return value(forKeyPath: key)
    }
    /**
     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` with `keyPath` on each of the linking
     objects.
     - parameter keyPath: The key path to the property whose values are desired.
     */
    public func value(forKeyPath keyPath: String) -> Any? {
        return rlmResults.value(forKeyPath: keyPath)
    }
    /**
     Invokes `setValue(_:forKey:)` on each of the linking objects using the specified `value` and `key`.
     - warning: This method may only be called during a write transaction.
     - parameter value: The value to set the property to.
     - parameter key:   The name of the property whose value should be set on each object.
     */
    public func setValue(_ value: Any?, forKey key: String) {
        return rlmResults.setValue(value, forKeyPath: key)
    }
    // MARK: Filtering
    /**
     Returns a `Results` containing all objects matching the given predicate in the linking objects.
     - parameter predicate: The predicate with which to filter the objects.
     */
    public func filter(_ predicate: NSPredicate) -> Results<Element> {
        return Results(rlmResults.objects(with: predicate))
    }
    // MARK: Sorting
    /**
     Returns a `Results` containing all the linking objects, but sorted.
     Objects are sorted based on the values of the given key path. For example, to sort a collection of `Student`s from
     youngest to oldest based on their `age` property, you might call
     `students.sorted(byKeyPath: "age", ascending: true)`.
     - warning: Collections may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                floating point, integer, and string types.
     - parameter keyPath:  The key path to sort by.
     - parameter ascending: The direction to sort in.
     */
    public func sorted(byKeyPath keyPath: String, ascending: Bool = true) -> Results<Element> {
        return sorted(by: [SortDescriptor(keyPath: keyPath, ascending: ascending)])
    }
    /**
     Returns a `Results` containing all the linking objects, but sorted.
     - warning: Collections may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                floating point, integer, and string types.
     - see: `sorted(byKeyPath:ascending:)`
     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
     */
    public func sorted<S: Sequence>(by sortDescriptors: S) -> Results<Element>
        where S.Iterator.Element == SortDescriptor {
            return Results(rlmResults.sortedResults(using: sortDescriptors.map { $0.rlmSortDescriptorValue }))
    }
    // MARK: Aggregate Operations
    /**
     Returns the minimum (lowest) value of the given property among all the linking objects, or `nil` if the linking
     objects are empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    public func min<T: MinMaxType>(ofProperty property: String) -> T? {
        return rlmResults.min(ofProperty: property).map(dynamicBridgeCast)
    }
    /**
     Returns the maximum (highest) value of the given property among all the linking objects, or `nil` if the linking
     objects are empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    public func max<T: MinMaxType>(ofProperty property: String) -> T? {
        return rlmResults.max(ofProperty: property).map(dynamicBridgeCast)
    }
    /**
     Returns the sum of the values of a given property over all the linking objects.
     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose values should be summed.
     */
    public func sum<T: AddableType>(ofProperty property: String) -> T {
        return dynamicBridgeCast(fromObjectiveC: rlmResults.sum(ofProperty: property))
    }
    /**
     Returns the average value of a given property over all the linking objects, or `nil` if the linking objects are
     empty.
     - warning: Only the name of a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose average value should be calculated.
     */
    public func average<T: AddableType>(ofProperty property: String) -> T? {
        return rlmResults.average(ofProperty: property).map(dynamicBridgeCast)
    }
    // MARK: Notifications
    /**
     Registers a block to be called each time the collection changes.
     The block will be asynchronously called with the initial results, and then called again after each write
     transaction which changes either any of the objects in the collection, or which objects are in the collection.
     The `change` parameter that is passed to the block reports, in the form of indices within the collection, which of
     the objects were added, removed, or modified during each write transaction. See the `RealmCollectionChange`
     documentation for more information on the change information supplied and an example of how to use it to update a
     `UITableView`.
     At the time when the block is called, the collection will be fully evaluated and up-to-date, and as long as you do
     not perform a write transaction on the same thread or explicitly call `realm.refresh()`, accessing it will never
     perform blocking work.
     If no queue is given, notifications are delivered via the standard run loop, and so can't be delivered while the
     run loop is blocked by other activity. If a queue is given, notifications are delivered to that queue instead. When
     notifications can't be delivered instantly, multiple notifications may be coalesced into a single notification.
     This can include the notification with the initial collection.
     For example, the following code performs a write transaction immediately after adding the notification block, so
     there is no opportunity for the initial notification to be delivered first. As a result, the initial notification
     will reflect the state of the Realm after the write transaction.
     ```swift
     let results = realm.objects(Dog.self)
     print("dogs.count: \(dogs?.count)") // => 0
     let token = dogs.observe { changes in
         switch changes {
         case .initial(let dogs):
             // Will print "dogs.count: 1"
             print("dogs.count: \(dogs.count)")
             break
         case .update:
             // Will not be hit in this example
             break
         case .error:
             break
         }
     }
     try! realm.write {
         let dog = Dog()
         dog.name = "Rex"
         person.dogs.append(dog)
     }
     // end of run loop execution context
     ```
     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
     updates, call `invalidate()` on the token.
     - warning: This method cannot be called during a write transaction, or when the containing Realm is read-only.
     - parameter queue: The serial dispatch queue to receive notification on. If
                        `nil`, notifications are delivered to the current thread.
     - parameter block: The block to be called whenever a change occurs.
     - returns: A token which must be held for as long as you want updates to be delivered.
     */
    public func observe(on queue: DispatchQueue? = nil,
                        _ block: @escaping (RealmCollectionChange<LinkingObjects>) -> Void) -> NotificationToken {
        return rlmResults.addNotificationBlock(wrapObserveBlock(block), queue: queue)
    }
    // MARK: Frozen Objects
    /// Returns if this collection is frozen.
    public var isFrozen: Bool { return self.rlmResults.isFrozen }
    /**
     Returns a frozen (immutable) snapshot of this collection.
     The frozen copy is an immutable collection which contains the same data as this collection
     currently contains, but will not update when writes are made to the containing Realm. Unlike
     live collections, frozen collections can be accessed from any thread.
     - warning: This method cannot be called during a write transaction, or when the containing
     Realm is read-only.
     - warning: Holding onto a frozen collection for an extended period while performing write
     transaction on the Realm may result in the Realm file growing to large sizes. See
     `Realm.Configuration.maximumNumberOfActiveVersions` for more information.
     */
    public func freeze() -> LinkingObjects {
        return LinkingObjects(propertyName: propertyName, handle: handle?.freeze())
    }
    // MARK: Implementation
    private init(propertyName: String, handle: RLMLinkingObjectsHandle?) {
        self.propertyName = propertyName
        self.handle = handle
    }
    internal init(objc: RLMResults<AnyObject>) {
        self.propertyName = ""
        self.handle = RLMLinkingObjectsHandle(linkingObjects: objc)
    }
    internal var rlmResults: RLMResults<AnyObject> {
        return handle?.results ?? RLMResults<AnyObject>.emptyDetached()
    }
    internal var propertyName: String
    internal var handle: RLMLinkingObjectsHandle?
}
extension LinkingObjects: RealmCollection {
    // MARK: Sequence Support
    /// Returns an iterator that yields successive elements in the linking objects.
    public func makeIterator() -> RLMIterator<Element> {
        return RLMIterator(collection: rlmResults)
    }
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _asNSFastEnumerator() -> Any {
        return rlmResults
    }
    // MARK: Collection Support
    /// The position of the first element in a non-empty collection.
    /// Identical to endIndex in an empty collection.
    public var startIndex: Int { return 0 }
    /// The collection's "past the end" position.
    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
    /// zero or more applications of successor().
    public var endIndex: Int { return count }
    public func index(after: Int) -> Int {
      return after + 1
    }
    public func index(before: Int) -> Int {
      return before - 1
    }
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _observe(_ queue: DispatchQueue?,
                         _ block: @escaping (RealmCollectionChange<AnyRealmCollection<Element>>) -> Void)
        -> NotificationToken {
            return rlmResults.addNotificationBlock(wrapObserveBlock(block), queue: queue)
    }
}
// MARK: AssistedObjectiveCBridgeable
extension LinkingObjects: AssistedObjectiveCBridgeable {
    internal static func bridging(from objectiveCValue: Any, with metadata: Any?) -> LinkingObjects {
        guard let object = objectiveCValue as? RLMResults<Element> else { preconditionFailure() }
        return LinkingObjects<Element>(objc: object as! RLMResults<AnyObject>)
    }
    internal var bridged: (objectiveCValue: Any, metadata: Any?) {
        return (objectiveCValue: handle!.results, metadata: nil)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2015 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
/**
 A `SortDescriptor` stores a key path and a sort order for use with `sorted(sortDescriptors:)`. It is similar to
 `NSSortDescriptor`, but supports only the subset of functionality which can be efficiently run by Realm's query engine.
 */
public struct SortDescriptor {
    // MARK: Properties
    /// The key path which the sort descriptor orders results by.
    public let keyPath: String
    /// Whether this descriptor sorts in ascending or descending order.
    public let ascending: Bool
    /// Converts the receiver to an `RLMSortDescriptor`.
    internal var rlmSortDescriptorValue: RLMSortDescriptor {
        return RLMSortDescriptor(keyPath: keyPath, ascending: ascending)
    }
    // MARK: Initializers
    /**
     Creates a sort descriptor with the given key path and sort order values.
     - parameter keyPath:   The key path which the sort descriptor orders results by.
     - parameter ascending: Whether the descriptor sorts in ascending or descending order.
     */
    public init(keyPath: String, ascending: Bool = true) {
        self.keyPath = keyPath
        self.ascending = ascending
    }
    // MARK: Functions
    /// Returns a copy of the sort descriptor with the sort order reversed.
    public func reversed() -> SortDescriptor {
        return SortDescriptor(keyPath: keyPath, ascending: !ascending)
    }
}
// MARK: CustomStringConvertible
extension SortDescriptor: CustomStringConvertible {
    /// A human-readable description of the sort descriptor.
    public var description: String {
        let direction = ascending ? "ascending" : "descending"
        return "SortDescriptor(keyPath: \(keyPath), direction: \(direction))"
    }
}
// MARK: Equatable
extension SortDescriptor: Equatable {
    /// Returns whether the two sort descriptors are equal.
    public static func == (lhs: SortDescriptor, rhs: SortDescriptor) -> Bool {
        return lhs.keyPath == rhs.keyPath &&
            lhs.ascending == rhs.ascending
    }
}
// MARK: StringLiteralConvertible
extension SortDescriptor: ExpressibleByStringLiteral {
    public typealias UnicodeScalarLiteralType = StringLiteralType
    public typealias ExtendedGraphemeClusterLiteralType = StringLiteralType
    /**
     Creates a `SortDescriptor` out of a string literal.
     - parameter stringLiteral: Property name literal.
     */
    public init(stringLiteral value: StringLiteralType) {
        self.init(keyPath: value)
    }
}
let swiftLanguageVersion = "5.3"
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2016 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Realm
/**
 Objects of types which conform to `ThreadConfined` can be managed by a Realm, which will make
 them bound to a thread-specific `Realm` instance. Managed objects must be explicitly exported
 and imported to be passed between threads.
 Managed instances of objects conforming to this protocol can be converted to a thread-safe
 reference for transport between threads by passing to the `ThreadSafeReference(to:)` constructor.
 Note that only types defined by Realm can meaningfully conform to this protocol, and defining new
 classes which attempt to conform to it will not make them work with `ThreadSafeReference`.
 */
public protocol ThreadConfined {
    // Must also conform to `AssistedObjectiveCBridgeable`
    /**
     The Realm which manages the object, or `nil` if the object is unmanaged.
     Unmanaged objects are not confined to a thread and cannot be passed to methods expecting a
     `ThreadConfined` object.
     */
    var realm: Realm? { get }
    /// Indicates if the object can no longer be accessed because it is now invalid.
    var isInvalidated: Bool { get }
    /**
    Indicates if the object is frozen.
    Frozen objects are not confined to their source thread. Forming a `ThreadSafeReference` to a
    frozen object is allowed, but is unlikely to be useful.
    */
    var isFrozen: Bool { get }
    /**
     Returns a frozen snapshot of this object.
     Unlike normal Realm live objects, the frozen copy can be read from any thread, and the values
     read will never update to reflect new writes to the Realm. Frozen collections can be queried
     like any other Realm collection. Frozen objects cannot be mutated, and cannot be observed for
     change notifications.
     Unmanaged Realm objects cannot be frozen.
     - warning: Holding onto a frozen object for an extended period while performing write
     transaction on the Realm may result in the Realm file growing to large sizes. See
     `Realm.Configuration.maximumNumberOfActiveVersions` for more information.
    */
    func freeze() -> Self
}
/**
 An object intended to be passed between threads containing a thread-safe reference to its
 thread-confined object.
 To resolve a thread-safe reference on a target Realm on a different thread, pass to
 `Realm.resolve(_:)`.
 - warning: A `ThreadSafeReference` object must be resolved at most once.
            Failing to resolve a `ThreadSafeReference` will result in the source version of the
            Realm being pinned until the reference is deallocated.
 - note: Prefer short-lived `ThreadSafeReference`s as the data for the version of the source Realm
         will be retained until all references have been resolved or deallocated.
 - see: `ThreadConfined`
 - see: `Realm.resolve(_:)`
 */
public struct ThreadSafeReference<Confined: ThreadConfined> {
    private let swiftMetadata: Any?
    /**
     Indicates if the reference can no longer be resolved because an attempt to resolve it has
     already occurred. References can only be resolved once.
     */
    public var isInvalidated: Bool { return objectiveCReference.isInvalidated }
    private let objectiveCReference: RLMThreadSafeReference<RLMThreadConfined>
    /**
     Create a thread-safe reference to the thread-confined object.
     - parameter threadConfined: The thread-confined object to create a thread-safe reference to.
     - note: You may continue to use and access the thread-confined object after passing it to this
             constructor.
     */
    public init(to threadConfined: Confined) {
        let bridged = (threadConfined as! AssistedObjectiveCBridgeable).bridged
        swiftMetadata = bridged.metadata
        objectiveCReference = RLMThreadSafeReference(threadConfined: bridged.objectiveCValue as! RLMThreadConfined)
    }
    internal func resolve(in realm: Realm) -> Confined? {
        guard let objectiveCValue = realm.rlmRealm.__resolve(objectiveCReference) else { return nil }
        return ((Confined.self as! AssistedObjectiveCBridgeable.Type).bridging(from: objectiveCValue, with: swiftMetadata) as! Confined)
    }
}
extension Realm {
    // MARK: Thread Safe Reference
    /**
     Returns the same object as the one referenced when the `ThreadSafeReference` was first
     created, but resolved for the current Realm for this thread. Returns `nil` if this object was
     deleted after the reference was created.
     - parameter reference: The thread-safe reference to the thread-confined object to resolve in
                            this Realm.
     - warning: A `ThreadSafeReference` object must be resolved at most once.
                Failing to resolve a `ThreadSafeReference` will result in the source version of the
                Realm being pinned until the reference is deallocated.
                An exception will be thrown if a reference is resolved more than once.
     - warning: Cannot call within a write transaction.
     - note: Will refresh this Realm if the source Realm was at a later version than this one.
     - see: `ThreadSafeReference(to:)`
     */
    public func resolve<Confined>(_ reference: ThreadSafeReference<Confined>) -> Confined? {
        return reference.resolve(in: self)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2015 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Realm
/**
 `ObjectiveCSupport` is a class providing methods for Swift/Objective-C interoperability.
 With `ObjectiveCSupport` you can either retrieve the internal ObjC representations of the Realm objects,
 or wrap ObjC Realm objects with their Swift equivalents.
 Use this to provide public APIs that support both platforms.
 :nodoc:
 **/
public struct ObjectiveCSupport {
    /// Convert a `Results` to a `RLMResults`.
    public static func convert<T>(object: Results<T>) -> RLMResults<AnyObject> {
        return object.rlmResults
    }
    /// Convert a `RLMResults` to a `Results`.
    public static func convert(object: RLMResults<AnyObject>) -> Results<Object> {
        return Results(object)
    }
    /// Convert a `List` to a `RLMArray`.
    public static func convert<T>(object: List<T>) -> RLMArray<AnyObject> {
        return object._rlmArray
    }
    /// Convert a `RLMArray` to a `List`.
    public static func convert(object: RLMArray<AnyObject>) -> List<Object> {
        return List(objc: object)
    }
    /// Convert a `LinkingObjects` to a `RLMResults`.
    public static func convert<T>(object: LinkingObjects<T>) -> RLMResults<AnyObject> {
        return object.rlmResults
    }
    /// Convert a `RLMLinkingObjects` to a `Results`.
    public static func convert(object: RLMLinkingObjects<RLMObject>) -> Results<Object> {
        return Results(object)
    }
    /// Convert a `Realm` to a `RLMRealm`.
    public static func convert(object: Realm) -> RLMRealm {
        return object.rlmRealm
    }
    /// Convert a `RLMRealm` to a `Realm`.
    public static func convert(object: RLMRealm) -> Realm {
        return Realm(object)
    }
    /// Convert a `Migration` to a `RLMMigration`.
    public static func convert(object: Migration) -> RLMMigration {
        return object.rlmMigration
    }
    /// Convert a `RLMMigration` to a `Migration`.
    public static func convert(object: RLMMigration) -> Migration {
        return Migration(object)
    }
    /// Convert a `ObjectSchema` to a `RLMObjectSchema`.
    public static func convert(object: ObjectSchema) -> RLMObjectSchema {
        return object.rlmObjectSchema
    }
    /// Convert a `RLMObjectSchema` to a `ObjectSchema`.
    public static func convert(object: RLMObjectSchema) -> ObjectSchema {
        return ObjectSchema(object)
    }
    /// Convert a `Property` to a `RLMProperty`.
    public static func convert(object: Property) -> RLMProperty {
        return object.rlmProperty
    }
    /// Convert a `RLMProperty` to a `Property`.
    public static func convert(object: RLMProperty) -> Property {
        return Property(object)
    }
    /// Convert a `Realm.Configuration` to a `RLMRealmConfiguration`.
    public static func convert(object: Realm.Configuration) -> RLMRealmConfiguration {
        return object.rlmConfiguration
    }
    /// Convert a `RLMRealmConfiguration` to a `Realm.Configuration`.
    public static func convert(object: RLMRealmConfiguration) -> Realm.Configuration {
        return .fromRLMRealmConfiguration(object)
    }
    /// Convert a `Schema` to a `RLMSchema`.
    public static func convert(object: Schema) -> RLMSchema {
        return object.rlmSchema
    }
    /// Convert a `RLMSchema` to a `Schema`.
    public static func convert(object: RLMSchema) -> Schema {
        return Schema(object)
    }
    /// Convert a `SortDescriptor` to a `RLMSortDescriptor`.
    public static func convert(object: SortDescriptor) -> RLMSortDescriptor {
        return object.rlmSortDescriptorValue
    }
    /// Convert a `RLMSortDescriptor` to a `SortDescriptor`.
    public static func convert(object: RLMSortDescriptor) -> SortDescriptor {
        return SortDescriptor(keyPath: object.keyPath, ascending: object.ascending)
    }
    /// Convert a `RLMShouldCompactOnLaunchBlock` to a Realm Swift compact block.
    public static func convert(object: @escaping RLMShouldCompactOnLaunchBlock) -> (Int, Int) -> Bool {
        return { totalBytes, usedBytes in
            return object(UInt(totalBytes), UInt(usedBytes))
        }
    }
    /// Convert a Realm Swift compact block to a `RLMShouldCompactOnLaunchBlock`.
    public static func convert(object: @escaping (Int, Int) -> Bool) -> RLMShouldCompactOnLaunchBlock {
        return { totalBytes, usedBytes in
            return object(Int(totalBytes), Int(usedBytes))
        }
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
// MARK: MinMaxType
/**
 Types of properties which can be used with the minimum and maximum value APIs.
 - see: `min(ofProperty:)`, `max(ofProperty:)`
 */
public protocol MinMaxType {}
extension NSNumber: MinMaxType {}
extension Double: MinMaxType {}
extension Float: MinMaxType {}
extension Int: MinMaxType {}
extension Int8: MinMaxType {}
extension Int16: MinMaxType {}
extension Int32: MinMaxType {}
extension Int64: MinMaxType {}
extension Date: MinMaxType {}
extension NSDate: MinMaxType {}
// MARK: AddableType
/**
 Types of properties which can be used with the sum and average value APIs.
 - see: `sum(ofProperty:)`, `average(ofProperty:)`
 */
public protocol AddableType {
    /// :nodoc:
    init()
}
extension NSNumber: AddableType {}
extension Double: AddableType {}
extension Float: AddableType {}
extension Int: AddableType {}
extension Int8: AddableType {}
extension Int16: AddableType {}
extension Int32: AddableType {}
extension Int64: AddableType {}
/**
 `Results` is an auto-updating container type in Realm returned from object queries.
 `Results` can be queried with the same predicates as `List<Element>`, and you can
 chain queries to further filter query results.
 `Results` always reflect the current state of the Realm on the current thread, including during write transactions on
 the current thread. The one exception to this is when using `for...in` enumeration, which will always enumerate over
 the objects which matched the query when the enumeration is begun, even if some of them are deleted or modified to be
 excluded by the filter during the enumeration.
 `Results` are lazily evaluated the first time they are accessed; they only run queries when the result of the query is
 requested. This means that chaining several temporary `Results` to sort and filter your data does not perform any
 unnecessary work processing the intermediate state.
 Once the results have been evaluated or a notification block has been added, the results are eagerly kept up-to-date,
 with the work done to keep them up-to-date done on a background thread whenever possible.
 Results instances cannot be directly instantiated.
 */
public struct Results<Element: RealmCollectionValue>: Equatable {
    internal let rlmResults: RLMResults<AnyObject>
    /// A human-readable description of the objects represented by the results.
    public var description: String {
        return RLMDescriptionWithMaxDepth("Results", rlmResults, RLMDescriptionMaxDepth)
    }
    /// The type of the objects described by the results.
    public typealias ElementType = Element
    // MARK: Properties
    /// The Realm which manages this results. Note that this property will never return `nil`.
    public var realm: Realm? { return Realm(rlmResults.realm) }
    /**
     Indicates if the results are no longer valid.
     The results becomes invalid if `invalidate()` is called on the containing `realm`. An invalidated results can be
     accessed, but will always be empty.
     */
    public var isInvalidated: Bool { return rlmResults.isInvalidated }
    /// The number of objects in the results.
    public var count: Int { return Int(rlmResults.count) }
    // MARK: Initializers
    internal init(_ rlmResults: RLMResults<AnyObject>) {
        self.rlmResults = rlmResults
    }
    internal init(objc rlmResults: RLMResults<AnyObject>) {
        self.rlmResults = rlmResults
    }
    // MARK: Index Retrieval
    /**
     Returns the index of the given object in the results, or `nil` if the object is not present.
     */
    public func index(of object: Element) -> Int? {
        return notFoundToNil(index: rlmResults.index(of: object as AnyObject))
    }
    /**
     Returns the index of the first object matching the predicate, or `nil` if no objects match.
     - parameter predicate: The predicate with which to filter the objects.
     */
    public func index(matching predicate: NSPredicate) -> Int? {
        return notFoundToNil(index: rlmResults.indexOfObject(with: predicate))
    }
    // MARK: Object Retrieval
    /**
     Returns the object at the given `index`.
     - parameter index: The index.
     */
    public subscript(position: Int) -> Element {
        throwForNegativeIndex(position)
        return dynamicBridgeCast(fromObjectiveC: rlmResults.object(at: UInt(position)))
    }
    /// Returns the first object in the results, or `nil` if the results are empty.
    public var first: Element? { return rlmResults.firstObject().map(dynamicBridgeCast) }
    /// Returns the last object in the results, or `nil` if the results are empty.
    public var last: Element? { return rlmResults.lastObject().map(dynamicBridgeCast) }
    // MARK: KVC
    /**
     Returns an `Array` containing the results of invoking `valueForKey(_:)` with `key` on each of the results.
     - parameter key: The name of the property whose values are desired.
     */
    public func value(forKey key: String) -> Any? {
        return value(forKeyPath: key)
    }
    /**
     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` with `keyPath` on each of the results.
     - parameter keyPath: The key path to the property whose values are desired.
     */
    public func value(forKeyPath keyPath: String) -> Any? {
        return rlmResults.value(forKeyPath: keyPath)
    }
    /**
     Invokes `setValue(_:forKey:)` on each of the objects represented by the results using the specified `value` and
     `key`.
     - warning: This method may only be called during a write transaction.
     - parameter value: The object value.
     - parameter key:   The name of the property whose value should be set on each object.
     */
    public func setValue(_ value: Any?, forKey key: String) {
        return rlmResults.setValue(value, forKeyPath: key)
    }
    // MARK: Filtering
    /**
     Returns a `Results` containing all objects matching the given predicate in the collection.
     - parameter predicate: The predicate with which to filter the objects.
     */
    public func filter(_ predicate: NSPredicate) -> Results<Element> {
        return Results<Element>(rlmResults.objects(with: predicate))
    }
    // MARK: Sorting
    /**
     Returns a `Results` containing the objects represented by the results, but sorted.
     Objects are sorted based on the values of the given key path. For example, to sort a collection of `Student`s from
     youngest to oldest based on their `age` property, you might call
     `students.sorted(byKeyPath: "age", ascending: true)`.
     - warning: Collections may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                floating point, integer, and string types.
     - parameter keyPath:   The key path to sort by.
     - parameter ascending: The direction to sort in.
     */
    public func sorted(byKeyPath keyPath: String, ascending: Bool = true) -> Results<Element> {
        return sorted(by: [SortDescriptor(keyPath: keyPath, ascending: ascending)])
    }
    /**
     Returns a `Results` containing the objects represented by the results, but sorted.
     - warning: Collections may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                floating point, integer, and string types.
     - see: `sorted(byKeyPath:ascending:)`
     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
     */
    public func sorted<S: Sequence>(by sortDescriptors: S) -> Results<Element>
        where S.Iterator.Element == SortDescriptor {
            return Results<Element>(rlmResults.sortedResults(using: sortDescriptors.map { $0.rlmSortDescriptorValue }))
    }
    /**
     Returns a `Results` containing distinct objects based on the specified key paths
     - parameter keyPaths:  The key paths used produce distinct results
     */
    public func distinct<S: Sequence>(by keyPaths: S) -> Results<Element>
        where S.Iterator.Element == String {
            return Results<Element>(rlmResults.distinctResults(usingKeyPaths: Array(keyPaths)))
    }
    // MARK: Aggregate Operations
    /**
     Returns the minimum (lowest) value of the given property among all the results, or `nil` if the results are empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    public func min<T: MinMaxType>(ofProperty property: String) -> T? {
        return rlmResults.min(ofProperty: property).map(dynamicBridgeCast)
    }
    /**
     Returns the maximum (highest) value of the given property among all the results, or `nil` if the results are empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    public func max<T: MinMaxType>(ofProperty property: String) -> T? {
        return rlmResults.max(ofProperty: property).map(dynamicBridgeCast)
    }
    /**
     Returns the sum of the values of a given property over all the results.
     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose values should be summed.
     */
    public func sum<T: AddableType>(ofProperty property: String) -> T {
        return dynamicBridgeCast(fromObjectiveC: rlmResults.sum(ofProperty: property))
    }
    /**
     Returns the average value of a given property over all the results, or `nil` if the results are empty.
     - warning: Only the name of a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose average value should be calculated.
     */
    public func average<T: AddableType>(ofProperty property: String) -> T? {
        return rlmResults.average(ofProperty: property).map(dynamicBridgeCast)
    }
    // MARK: Notifications
    /**
     Registers a block to be called each time the collection changes.
     The block will be asynchronously called with the initial results, and then called again after each write
     transaction which changes either any of the objects in the collection, or which objects are in the collection.
     The `change` parameter that is passed to the block reports, in the form of indices within the collection, which of
     the objects were added, removed, or modified during each write transaction. See the `RealmCollectionChange`
     documentation for more information on the change information supplied and an example of how to use it to update a
     `UITableView`.
     At the time when the block is called, the collection will be fully evaluated and up-to-date, and as long as you do
     not perform a write transaction on the same thread or explicitly call `realm.refresh()`, accessing it will never
     perform blocking work.
     If no queue is given, notifications are delivered via the standard run loop, and so can't be delivered while the
     run loop is blocked by other activity. If a queue is given, notifications are delivered to that queue instead. When
     notifications can't be delivered instantly, multiple notifications may be coalesced into a single notification.
     This can include the notification with the initial collection.
     For example, the following code performs a write transaction immediately after adding the notification block, so
     there is no opportunity for the initial notification to be delivered first. As a result, the initial notification
     will reflect the state of the Realm after the write transaction.
     ```swift
     let dogs = realm.objects(Dog.self)
     print("dogs.count: \(dogs?.count)") // => 0
     let token = dogs.observe { changes in
         switch changes {
         case .initial(let dogs):
             // Will print "dogs.count: 1"
             print("dogs.count: \(dogs.count)")
             break
         case .update:
             // Will not be hit in this example
             break
         case .error:
             break
         }
     }
     try! realm.write {
         let dog = Dog()
         dog.name = "Rex"
         person.dogs.append(dog)
     }
     // end of run loop execution context
     ```
     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
     updates, call `invalidate()` on the token.
     - warning: This method cannot be called during a write transaction, or when the containing Realm is read-only.
     - parameter queue: The serial dispatch queue to receive notification on. If
                        `nil`, notifications are delivered to the current thread.
     - parameter block: The block to be called whenever a change occurs.
     - returns: A token which must be held for as long as you want updates to be delivered.
     */
    public func observe(on queue: DispatchQueue? = nil,
                        _ block: @escaping (RealmCollectionChange<Results>) -> Void) -> NotificationToken {
        return rlmResults.addNotificationBlock(wrapObserveBlock(block), queue: queue)
    }
    // MARK: Frozen Objects
    public var isFrozen: Bool {
        return rlmResults.isFrozen
    }
    public func freeze() -> Results {
        return Results(rlmResults.freeze())
    }
}
extension Results: RealmCollection {
    // MARK: Sequence Support
    /// Returns a `RLMIterator` that yields successive elements in the results.
    public func makeIterator() -> RLMIterator<Element> {
        return RLMIterator(collection: rlmResults)
    }
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _asNSFastEnumerator() -> Any {
        return rlmResults
    }
    // MARK: Collection Support
    /// The position of the first element in a non-empty collection.
    /// Identical to endIndex in an empty collection.
    public var startIndex: Int { return 0 }
    /// The collection's "past the end" position.
    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
    /// zero or more applications of successor().
    public var endIndex: Int { return count }
    public func index(after i: Int) -> Int { return i + 1 }
    public func index(before i: Int) -> Int { return i - 1 }
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _observe(_ queue: DispatchQueue?,
                         _ block: @escaping (RealmCollectionChange<AnyRealmCollection<Element>>) -> Void)
        -> NotificationToken {
            return rlmResults.addNotificationBlock(wrapObserveBlock(block), queue: queue)
    }
}
// MARK: AssistedObjectiveCBridgeable
extension Results: AssistedObjectiveCBridgeable {
    internal static func bridging(from objectiveCValue: Any, with metadata: Any?) -> Results {
        return Results(objectiveCValue as! RLMResults)
    }
    internal var bridged: (objectiveCValue: Any, metadata: Any?) {
        return (objectiveCValue: rlmResults, metadata: nil)
    }
}
// MARK: - Codable
extension Results: Encodable where Element: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        for value in self {
            try container.encode(value)
        }
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
import Realm.Private
/// :nodoc:
/// Internal class. Do not use directly.
public class ListBase: RLMListBase {
    // Printable requires a description property defined in Swift (and not obj-c),
    // and it has to be defined as override, which can't be done in a
    // generic class.
    /// Returns a human-readable description of the objects contained in the List.
    @objc public override var description: String {
        return descriptionWithMaxDepth(RLMDescriptionMaxDepth)
    }
    @objc private func descriptionWithMaxDepth(_ depth: UInt) -> String {
        return RLMDescriptionWithMaxDepth("List", _rlmArray, depth)
    }
    /// Returns the number of objects in this List.
    public var count: Int { return Int(_rlmArray.count) }
}
/**
 `List` is the container type in Realm used to define to-many relationships.
 Like Swift's `Array`, `List` is a generic type that is parameterized on the type it stores. This can be either an `Object`
 subclass or one of the following types: `Bool`, `Int`, `Int8`, `Int16`, `Int32`, `Int64`, `Float`, `Double`, `String`, `Data`,
 and `Date` (and their optional versions)
 Unlike Swift's native collections, `List`s are reference types, and are only immutable if the Realm that manages them
 is opened as read-only.
 Lists can be filtered and sorted with the same predicates as `Results<Element>`.
 Properties of `List` type defined on `Object` subclasses must be declared as `let` and cannot be `dynamic`.
 */
public final class List<Element: RealmCollectionValue>: ListBase {
    // MARK: Properties
    /// The Realm which manages the list, or `nil` if the list is unmanaged.
    public var realm: Realm? {
        return _rlmArray.realm.map { Realm($0) }
    }
    /// Indicates if the list can no longer be accessed.
    public var isInvalidated: Bool { return _rlmArray.isInvalidated }
    // MARK: Initializers
    /// Creates a `List` that holds Realm model objects of type `Element`.
    public override init() {
        super.init()
    }
    internal init(objc rlmArray: RLMArray<AnyObject>) {
        super.init(array: rlmArray)
    }
    // MARK: Index Retrieval
    /**
     Returns the index of an object in the list, or `nil` if the object is not present.
     - parameter object: An object to find.
     */
    public func index(of object: Element) -> Int? {
        return notFoundToNil(index: _rlmArray.index(of: dynamicBridgeCast(fromSwift: object) as AnyObject))
    }
    /**
     Returns the index of the first object in the list matching the predicate, or `nil` if no objects match.
     - parameter predicate: The predicate with which to filter the objects.
    */
    public func index(matching predicate: NSPredicate) -> Int? {
        return notFoundToNil(index: _rlmArray.indexOfObject(with: predicate))
    }
    // MARK: Object Retrieval
    /**
     Returns the object at the given index (get), or replaces the object at the given index (set).
     - warning: You can only set an object during a write transaction.
     - parameter index: The index of the object to retrieve or replace.
     */
    public subscript(position: Int) -> Element {
        get {
            throwForNegativeIndex(position)
            return dynamicBridgeCast(fromObjectiveC: _rlmArray.object(at: UInt(position)))
        }
        set {
            throwForNegativeIndex(position)
            _rlmArray.replaceObject(at: UInt(position), with: dynamicBridgeCast(fromSwift: newValue) as AnyObject)
        }
    }
    /// Returns the first object in the list, or `nil` if the list is empty.
    public var first: Element? { return _rlmArray.firstObject().map(dynamicBridgeCast) }
    /// Returns the last object in the list, or `nil` if the list is empty.
    public var last: Element? { return _rlmArray.lastObject().map(dynamicBridgeCast) }
    // MARK: KVC
    /**
     Returns an `Array` containing the results of invoking `valueForKey(_:)` using `key` on each of the collection's
     objects.
     */
    @nonobjc public func value(forKey key: String) -> [AnyObject] {
        return _rlmArray.value(forKeyPath: key)! as! [AnyObject]
    }
    /**
     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` using `keyPath` on each of the
     collection's objects.
     - parameter keyPath: The key path to the property whose values are desired.
     */
    @nonobjc public func value(forKeyPath keyPath: String) -> [AnyObject] {
        return _rlmArray.value(forKeyPath: keyPath) as! [AnyObject]
    }
    /**
     Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified `value` and `key`.
     - warning: This method can only be called during a write transaction.
     - parameter value: The object value.
     - parameter key:   The name of the property whose value should be set on each object.
    */
    public override func setValue(_ value: Any?, forKey key: String) {
        return _rlmArray.setValue(value, forKeyPath: key)
    }
    // MARK: Filtering
    /**
     Returns a `Results` containing all objects matching the given predicate in the list.
     - parameter predicate: The predicate with which to filter the objects.
     */
    public func filter(_ predicate: NSPredicate) -> Results<Element> {
        return Results<Element>(_rlmArray.objects(with: predicate))
    }
    // MARK: Sorting
    /**
     Returns a `Results` containing the objects in the list, but sorted.
     Objects are sorted based on the values of the given key path. For example, to sort a list of `Student`s from
     youngest to oldest based on their `age` property, you might call
     `students.sorted(byKeyPath: "age", ascending: true)`.
     - warning: Lists may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                floating point, integer, and string types.
     - parameter keyPath:  The key path to sort by.
     - parameter ascending: The direction to sort in.
     */
    public func sorted(byKeyPath keyPath: String, ascending: Bool = true) -> Results<Element> {
        return sorted(by: [SortDescriptor(keyPath: keyPath, ascending: ascending)])
    }
    /**
     Returns a `Results` containing the objects in the list, but sorted.
     - warning: Lists may only be sorted by properties of boolean, `Date`, `NSDate`, single and double-precision
                floating point, integer, and string types.
     - see: `sorted(byKeyPath:ascending:)`
    */
    public func sorted<S: Sequence>(by sortDescriptors: S) -> Results<Element>
        where S.Iterator.Element == SortDescriptor {
            return Results<Element>(_rlmArray.sortedResults(using: sortDescriptors.map { $0.rlmSortDescriptorValue }))
    }
    // MARK: Aggregate Operations
    /**
     Returns the minimum (lowest) value of the given property among all the objects in the list, or `nil` if the list is
     empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose minimum value is desired.
     */
    public func min<T: MinMaxType>(ofProperty property: String) -> T? {
        return _rlmArray.min(ofProperty: property).map(dynamicBridgeCast)
    }
    /**
     Returns the maximum (highest) value of the given property among all the objects in the list, or `nil` if the list
     is empty.
     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
     - parameter property: The name of a property whose maximum value is desired.
     */
    public func max<T: MinMaxType>(ofProperty property: String) -> T? {
        return _rlmArray.max(ofProperty: property).map(dynamicBridgeCast)
    }
    /**
     Returns the sum of the values of a given property over all the objects in the list.
     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose values should be summed.
     */
    public func sum<T: AddableType>(ofProperty property: String) -> T {
        return dynamicBridgeCast(fromObjectiveC: _rlmArray.sum(ofProperty: property))
    }
    /**
     Returns the average value of a given property over all the objects in the list, or `nil` if the list is empty.
     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
     - parameter property: The name of a property whose average value should be calculated.
     */
    public func average(ofProperty property: String) -> Double? {
        return _rlmArray.average(ofProperty: property).map(dynamicBridgeCast)
    }
    // MARK: Mutation
    /**
     Appends the given object to the end of the list.
     If the object is managed by a different Realm than the receiver, a copy is made and added to the Realm managing
     the receiver.
     - warning: This method may only be called during a write transaction.
     - parameter object: An object.
     */
    public func append(_ object: Element) {
        _rlmArray.add(dynamicBridgeCast(fromSwift: object) as AnyObject)
    }
    /**
     Appends the objects in the given sequence to the end of the list.
     - warning: This method may only be called during a write transaction.
    */
    public func append<S: Sequence>(objectsIn objects: S) where S.Iterator.Element == Element {
        for obj in objects {
            _rlmArray.add(dynamicBridgeCast(fromSwift: obj) as AnyObject)
        }
    }
    /**
     Inserts an object at the given index.
     - warning: This method may only be called during a write transaction.
     - warning: This method will throw an exception if called with an invalid index.
     - parameter object: An object.
     - parameter index:  The index at which to insert the object.
     */
    public func insert(_ object: Element, at index: Int) {
        throwForNegativeIndex(index)
        _rlmArray.insert(dynamicBridgeCast(fromSwift: object) as AnyObject, at: UInt(index))
    }
    /**
     Removes an object at the given index. The object is not removed from the Realm that manages it.
     - warning: This method may only be called during a write transaction.
     - warning: This method will throw an exception if called with an invalid index.
     - parameter index: The index at which to remove the object.
     */
    public func remove(at index: Int) {
        throwForNegativeIndex(index)
        _rlmArray.removeObject(at: UInt(index))
    }
    /**
     Removes all objects from the list. The objects are not removed from the Realm that manages them.
     - warning: This method may only be called during a write transaction.
     */
    public func removeAll() {
        _rlmArray.removeAllObjects()
    }
    /**
     Replaces an object at the given index with a new object.
     - warning: This method may only be called during a write transaction.
     - warning: This method will throw an exception if called with an invalid index.
     - parameter index:  The index of the object to be replaced.
     - parameter object: An object.
     */
    public func replace(index: Int, object: Element) {
        throwForNegativeIndex(index)
        _rlmArray.replaceObject(at: UInt(index), with: dynamicBridgeCast(fromSwift: object) as AnyObject)
    }
    /**
     Moves the object at the given source index to the given destination index.
     - warning: This method may only be called during a write transaction.
     - warning: This method will throw an exception if called with invalid indices.
     - parameter from:  The index of the object to be moved.
     - parameter to:    index to which the object at `from` should be moved.
     */
    public func move(from: Int, to: Int) {
        throwForNegativeIndex(from)
        throwForNegativeIndex(to)
        _rlmArray.moveObject(at: UInt(from), to: UInt(to))
    }
    /**
     Exchanges the objects in the list at given indices.
     - warning: This method may only be called during a write transaction.
     - warning: This method will throw an exception if called with invalid indices.
     - parameter index1: The index of the object which should replace the object at index `index2`.
     - parameter index2: The index of the object which should replace the object at index `index1`.
     */
    public func swapAt(_ index1: Int, _ index2: Int) {
        throwForNegativeIndex(index1, parameterName: "index1")
        throwForNegativeIndex(index2, parameterName: "index2")
        _rlmArray.exchangeObject(at: UInt(index1), withObjectAt: UInt(index2))
    }
    // MARK: Notifications
    /**
     Registers a block to be called each time the collection changes.
     The block will be asynchronously called with the initial results, and then called again after each write
     transaction which changes either any of the objects in the collection, or which objects are in the collection.
     The `change` parameter that is passed to the block reports, in the form of indices within the collection, which of
     the objects were added, removed, or modified during each write transaction. See the `RealmCollectionChange`
     documentation for more information on the change information supplied and an example of how to use it to update a
     `UITableView`.
     At the time when the block is called, the collection will be fully evaluated and up-to-date, and as long as you do
     not perform a write transaction on the same thread or explicitly call `realm.refresh()`, accessing it will never
     perform blocking work.
     If no queue is given, notifications are delivered via the standard run loop, and so can't be delivered while the
     run loop is blocked by other activity. If a queue is given, notifications are delivered to that queue instead. When
     notifications can't be delivered instantly, multiple notifications may be coalesced into a single notification.
     This can include the notification with the initial collection.
     For example, the following code performs a write transaction immediately after adding the notification block, so
     there is no opportunity for the initial notification to be delivered first. As a result, the initial notification
     will reflect the state of the Realm after the write transaction.
     ```swift
     let results = realm.objects(Dog.self)
     print("dogs.count: \(dogs?.count)") // => 0
     let token = dogs.observe { changes in
         switch changes {
         case .initial(let dogs):
             // Will print "dogs.count: 1"
             print("dogs.count: \(dogs.count)")
             break
         case .update:
             // Will not be hit in this example
             break
         case .error:
             break
         }
     }
     try! realm.write {
         let dog = Dog()
         dog.name = "Rex"
         person.dogs.append(dog)
     }
     // end of run loop execution context
     ```
     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
     updates, call `invalidate()` on the token.
     - warning: This method cannot be called during a write transaction, or when the containing Realm is read-only.
     - parameter queue: The serial dispatch queue to receive notification on. If
                        `nil`, notifications are delivered to the current thread.
     - parameter block: The block to be called whenever a change occurs.
     - returns: A token which must be held for as long as you want updates to be delivered.
     */
    public func observe(on queue: DispatchQueue? = nil,
                        _ block: @escaping (RealmCollectionChange<List>) -> Void) -> NotificationToken {
        return _rlmArray.addNotificationBlock(wrapObserveBlock(block), queue: queue)
    }
    // MARK: Frozen Objects
    public var isFrozen: Bool {
        return _rlmArray.isFrozen
    }
    public func freeze() -> List {
        return List(objc: _rlmArray.freeze())
    }
    // swiftlint:disable:next identifier_name
    @objc class func _unmanagedArray() -> RLMArray<AnyObject> {
        return Element._rlmArray()
    }
}
extension List where Element: MinMaxType {
    /**
     Returns the minimum (lowest) value in the list, or `nil` if the list is empty.
     */
    public func min() -> Element? {
        return _rlmArray.min(ofProperty: "self").map(dynamicBridgeCast)
    }
    /**
     Returns the maximum (highest) value in the list, or `nil` if the list is empty.
     */
    public func max() -> Element? {
        return _rlmArray.max(ofProperty: "self").map(dynamicBridgeCast)
    }
}
extension List where Element: AddableType {
    /**
     Returns the sum of the values in the list.
     */
    public func sum() -> Element {
        return sum(ofProperty: "self")
    }
    /**
     Returns the average of the values in the list, or `nil` if the list is empty.
     */
    public func average() -> Double? {
        return average(ofProperty: "self")
    }
}
extension List: RealmCollection {
    /// The type of the objects stored within the list.
    public typealias ElementType = Element
    // MARK: Sequence Support
    /// Returns a `RLMIterator` that yields successive elements in the `List`.
    public func makeIterator() -> RLMIterator<Element> {
        return RLMIterator(collection: _rlmArray)
    }
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _asNSFastEnumerator() -> Any {
        return _rlmArray
    }
    /**
     Replace the given `subRange` of elements with `newElements`.
     - parameter subrange:    The range of elements to be replaced.
     - parameter newElements: The new elements to be inserted into the List.
     */
    public func replaceSubrange<C: Collection, R>(_ subrange: R, with newElements: C)
        where C.Iterator.Element == Element, R: RangeExpression, List<Element>.Index == R.Bound {
            let subrange = subrange.relative(to: self)
            for _ in subrange.lowerBound..<subrange.upperBound {
                remove(at: subrange.lowerBound)
            }
            for x in newElements.reversed() {
                insert(x, at: subrange.lowerBound)
            }
    }
    /// The position of the first element in a non-empty collection.
    /// Identical to endIndex in an empty collection.
    public var startIndex: Int { return 0 }
    /// The collection's "past the end" position.
    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
    /// zero or more applications of successor().
    public var endIndex: Int { return count }
    public func index(after i: Int) -> Int { return i + 1 }
    public func index(before i: Int) -> Int { return i - 1 }
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _observe(_ queue: DispatchQueue?,
                         _ block: @escaping (RealmCollectionChange<AnyRealmCollection<Element>>) -> Void)
        -> NotificationToken {
            return _rlmArray.addNotificationBlock(wrapObserveBlock(block), queue: queue)
    }
}
// MARK: - MutableCollection conformance, range replaceable collection emulation
extension List: MutableCollection {
    public typealias SubSequence = Slice<List>
    /**
     Returns the objects at the given range (get), or replaces the objects at the
     given range with new objects (set).
     - warning: Objects may only be set during a write transaction.
     - parameter index: The index of the object to retrieve or replace.
     */
    public subscript(bounds: Range<Int>) -> SubSequence {
        get {
            return SubSequence(base: self, bounds: bounds)
        }
        set {
            replaceSubrange(bounds.lowerBound..<bounds.upperBound, with: newValue)
        }
    }
    /**
     Removes the specified number of objects from the beginning of the list. The
     objects are not removed from the Realm that manages them.
     - warning: This method may only be called during a write transaction.
     */
    public func removeFirst(_ number: Int = 1) {
        throwForNegativeIndex(number)
        let count = Int(_rlmArray.count)
        guard number <= count else {
            throwRealmException("It is not possible to remove more objects (\(number)) from a list"
                + " than it already contains (\(count)).")
        }
        for _ in 0..<number {
            _rlmArray.removeObject(at: 0)
        }
    }
    /**
     Removes the specified number of objects from the end of the list. The objects
     are not removed from the Realm that manages them.
     - warning: This method may only be called during a write transaction.
     */
    public func removeLast(_ number: Int = 1) {
        throwForNegativeIndex(number)
        let count = Int(_rlmArray.count)
        guard number <= count else {
            throwRealmException("It is not possible to remove more objects (\(number)) from a list"
                + " than it already contains (\(count)).")
        }
        for _ in 0..<number {
            _rlmArray.removeLastObject()
        }
    }
    /**
     Inserts the items in the given collection into the list at the given position.
     - warning: This method may only be called during a write transaction.
     */
    public func insert<C: Collection>(contentsOf newElements: C, at i: Int) where C.Iterator.Element == Element {
        var currentIndex = i
        for item in newElements {
            insert(item, at: currentIndex)
            currentIndex += 1
        }
    }
    /**
     Removes objects from the list at the given range.
     - warning: This method may only be called during a write transaction.
     */
    public func removeSubrange<R>(_ boundsExpression: R) where R: RangeExpression, List<Element>.Index == R.Bound {
        let bounds = boundsExpression.relative(to: self)
        for _ in bounds {
            remove(at: bounds.lowerBound)
        }
    }
    /// :nodoc:
    public func remove(atOffsets offsets: IndexSet) {
        for offset in offsets.reversed() {
            remove(at: offset)
        }
    }
    /// :nodoc:
    public func move(fromOffsets offsets: IndexSet, toOffset destination: Int) {
        var tmp = [Element]()
        for offset in offsets {
            tmp.append(self[offset])
        }
        insert(contentsOf: tmp, at: destination)
        for offset in offsets.reversed() {
            var o = offset
            if o >= destination {
                o += tmp.count
            }
            remove(at: o)
        }
    }
}
// MARK: - Codable
extension List: Decodable where Element: Decodable {
    public convenience init(from decoder: Decoder) throws {
        self.init()
        var container = try decoder.unkeyedContainer()
        while !container.isAtEnd {
            append(try container.decode(Element.self))
        }
    }
}
extension List: Encodable where Element: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        for value in self {
            try container.encode(value)
        }
    }
}
// MARK: - AssistedObjectiveCBridgeable
extension List: AssistedObjectiveCBridgeable {
    internal static func bridging(from objectiveCValue: Any, with metadata: Any?) -> List {
        guard let objectiveCValue = objectiveCValue as? RLMArray<AnyObject> else { preconditionFailure() }
        return List(objc: objectiveCValue)
    }
    internal var bridged: (objectiveCValue: Any, metadata: Any?) {
        return (objectiveCValue: _rlmArray, metadata: nil)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2015 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
#if BUILDING_REALM_SWIFT_TESTS
import RealmSwift
#endif
// MARK: Internal Helpers
// Swift 3.1 provides fixits for some of our uses of unsafeBitCast
// to use unsafeDowncast instead, but the bitcast is required.
internal func noWarnUnsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U {
    return unsafeBitCast(x, to: type)
}
/// Given a list of `Any`-typed varargs, unwrap any optionals and
/// replace them with the underlying value or NSNull.
internal func unwrapOptionals(in varargs: [Any]) -> [Any] {
    return varargs.map { arg in
        if let someArg = arg as Any? {
            return someArg
        }
        return NSNull()
    }
}
internal func notFoundToNil(index: UInt) -> Int? {
    if index == UInt(NSNotFound) {
        return nil
    }
    return Int(index)
}
internal func throwRealmException(_ message: String, userInfo: [AnyHashable: Any]? = nil) -> Never {
    NSException(name: NSExceptionName(rawValue: RLMExceptionName), reason: message, userInfo: userInfo).raise()
    fatalError() // unreachable
}
internal func throwForNegativeIndex(_ int: Int, parameterName: String = "index") {
    if int < 0 {
        throwRealmException("Cannot pass a negative value for '\(parameterName)'.")
    }
}
internal func gsub(pattern: String, template: String, string: String, error: NSErrorPointer = nil) -> String? {
    let regex = try? NSRegularExpression(pattern: pattern, options: [])
    return regex?.stringByReplacingMatches(in: string, options: [],
                                           range: NSRange(location: 0, length: string.utf16.count),
                                           withTemplate: template)
}
internal func cast<U, V>(_ value: U, to: V.Type) -> V {
    if let v = value as? V {
        return v
    }
    return unsafeBitCast(value, to: to)
}
extension Object {
    // Must *only* be used to call Realm Objective-C APIs that are exposed on `RLMObject`
    // but actually operate on `RLMObjectBase`. Do not expose cast value to user.
    internal func unsafeCastToRLMObject() -> RLMObject {
        return unsafeBitCast(self, to: RLMObject.self)
    }
}
// MARK: CustomObjectiveCBridgeable
/// :nodoc:
public func dynamicBridgeCast<T>(fromObjectiveC x: Any) -> T {
    if T.self == DynamicObject.self {
        return unsafeBitCast(x as AnyObject, to: T.self)
    } else if let bridgeableType = T.self as? CustomObjectiveCBridgeable.Type {
        return bridgeableType.bridging(objCValue: x) as! T
    } else if let bridgeableType = T.self as? RealmEnum.Type {
        return bridgeableType._rlmFromRawValue(x) as! T
    } else {
        return x as! T
    }
}
/// :nodoc:
public func dynamicBridgeCast<T>(fromSwift x: T) -> Any {
    if let x = x as? CustomObjectiveCBridgeable {
        return x.objCValue
    } else if let bridgeableType = T.self as? RealmEnum.Type {
        return bridgeableType._rlmToRawValue(x)
    } else {
        return x
    }
}
// Used for conversion from Objective-C types to Swift types
internal protocol CustomObjectiveCBridgeable {
    static func bridging(objCValue: Any) -> Self
    var objCValue: Any { get }
}
// FIXME: needed with swift 3.2
// Double isn't though?
extension Float: CustomObjectiveCBridgeable {
    internal static func bridging(objCValue: Any) -> Float {
        return (objCValue as! NSNumber).floatValue
    }
    internal var objCValue: Any {
        return NSNumber(value: self)
    }
}
extension Int8: CustomObjectiveCBridgeable {
    internal static func bridging(objCValue: Any) -> Int8 {
        return (objCValue as! NSNumber).int8Value
    }
    internal var objCValue: Any {
        return NSNumber(value: self)
    }
}
extension Int16: CustomObjectiveCBridgeable {
    internal static func bridging(objCValue: Any) -> Int16 {
        return (objCValue as! NSNumber).int16Value
    }
    internal var objCValue: Any {
        return NSNumber(value: self)
    }
}
extension Int32: CustomObjectiveCBridgeable {
    internal static func bridging(objCValue: Any) -> Int32 {
        return (objCValue as! NSNumber).int32Value
    }
    internal var objCValue: Any {
        return NSNumber(value: self)
    }
}
extension Int64: CustomObjectiveCBridgeable {
    internal static func bridging(objCValue: Any) -> Int64 {
        return (objCValue as! NSNumber).int64Value
    }
    internal var objCValue: Any {
        return NSNumber(value: self)
    }
}
extension Optional: CustomObjectiveCBridgeable {
    internal static func bridging(objCValue: Any) -> Optional {
        if objCValue is NSNull {
            return nil
        } else {
            return .some(dynamicBridgeCast(fromObjectiveC: objCValue))
        }
    }
    internal var objCValue: Any {
        if let value = self {
            return dynamicBridgeCast(fromSwift: value)
        } else {
            return NSNull()
        }
    }
}
// MARK: AssistedObjectiveCBridgeable
internal protocol AssistedObjectiveCBridgeable {
    static func bridging(from objectiveCValue: Any, with metadata: Any?) -> Self
    var bridged: (objectiveCValue: Any, metadata: Any?) { get }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
import Realm.Private
/**
 This class represents Realm model object schemas.
 When using Realm, `ObjectSchema` instances allow performing migrations and introspecting the database's schema.
 Object schemas map to tables in the core database.
 */
public struct ObjectSchema: CustomStringConvertible {
    // MARK: Properties
    internal let rlmObjectSchema: RLMObjectSchema
    /**
     An array of `Property` instances representing the managed properties of a class described by the schema.
     - see: `Property`
     */
    public var properties: [Property] {
        return rlmObjectSchema.properties.map { Property($0) }
    }
    /// The name of the class the schema describes.
    public var className: String { return rlmObjectSchema.className }
    /// The object class the schema describes.
    public var objectClass: AnyClass { return rlmObjectSchema.objectClass }
    /// The property which serves as the primary key for the class the schema describes, if any.
    public var primaryKeyProperty: Property? {
        if let rlmProperty = rlmObjectSchema.primaryKeyProperty {
            return Property(rlmProperty)
        }
        return nil
    }
    /// A human-readable description of the properties contained in the object schema.
    public var description: String { return rlmObjectSchema.description }
    // MARK: Initializers
    internal init(_ rlmObjectSchema: RLMObjectSchema) {
        self.rlmObjectSchema = rlmObjectSchema
    }
    // MARK: Property Retrieval
    /// Returns the property with the given name, if it exists.
    public subscript(propertyName: String) -> Property? {
        if let rlmProperty = rlmObjectSchema[propertyName] {
            return Property(rlmProperty)
        }
        return nil
    }
}
// MARK: Equatable
extension ObjectSchema: Equatable {
    /// Returns whether the two object schemas are equal.
    public static func == (lhs: ObjectSchema, rhs: ObjectSchema) -> Bool {
        return lhs.rlmObjectSchema.isEqual(to: rhs.rlmObjectSchema)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2015 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Realm
/**
 :nodoc:
 **/
public extension ObjectiveCSupport {
    /// Convert a `SyncCredentials` to a `RLMSyncCredentials`.
    static func convert(object: SyncCredentials) -> RLMSyncCredentials {
        return RLMSyncCredentials(object)
    }
    /// Convert a `RLMSyncCredentials` to a `SyncCredentials`.
    static func convert(object: RLMSyncCredentials) -> SyncCredentials {
        return SyncCredentials(object)
    }
    /// Convert a `SyncConfiguration` to a `RLMSyncConfiguration`.
    static func convert(object: SyncConfiguration) -> RLMSyncConfiguration {
        return object.asConfig()
    }
    /// Convert a `RLMSyncConfiguration` to a `SyncConfiguration`.
    static func convert(object: RLMSyncConfiguration) -> SyncConfiguration {
        return SyncConfiguration(config: object)
    }
    /// Convert a `RLMSyncSubscription` to a `SyncSubscription`.
    static func convert(object: RLMSyncSubscription) -> SyncSubscription {
        return SyncSubscription(object)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
/**
 `Schema` instances represent collections of model object schemas managed by a Realm.
 When using Realm, `Schema` instances allow performing migrations and introspecting the database's schema.
 Schemas map to collections of tables in the core database.
 */
public struct Schema: CustomStringConvertible {
    // MARK: Properties
    internal let rlmSchema: RLMSchema
    /**
     An array of `ObjectSchema`s for all object types in the Realm.
     This property is intended to be used during migrations for dynamic introspection.
     */
    public var objectSchema: [ObjectSchema] {
        return rlmSchema.objectSchema.map(ObjectSchema.init)
    }
    /// A human-readable description of the object schemas contained within.
    public var description: String { return rlmSchema.description }
    // MARK: Initializers
    internal init(_ rlmSchema: RLMSchema) {
        self.rlmSchema = rlmSchema
    }
    // MARK: ObjectSchema Retrieval
    /// Looks up and returns an `ObjectSchema` for the given class name in the Realm, if it exists.
    public subscript(className: String) -> ObjectSchema? {
        if let rlmObjectSchema = rlmSchema.schema(forClassName: className) {
            return ObjectSchema(rlmObjectSchema)
        }
        return nil
    }
}
// MARK: Equatable
extension Schema: Equatable {
    /// Returns whether the two schemas are equal.
    public static func == (lhs: Schema, rhs: Schema) -> Bool {
        return lhs.rlmSchema.isEqual(to: rhs.rlmSchema)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
#if canImport(Combine)
import Combine
import Realm.Private
// MARK: - Identifiable
/// A protocol which defines a default identity for Realm Objects
///
/// Declaraing your Object subclass as conforming to this protocol will supply
/// a default implemention for `Identifiable`'s `id` which works for Realm
/// Objects:
///
///     // Automatically conforms to `Identifiable`
///     class MyObjectType: Object, ObjectKeyIdentifiable {
///         // ...
///     }
///
/// You can also manually conform to `Identifiable` if you wish, but note that
/// using the object's memory address does *not* work for managed objects.
public protocol ObjectKeyIdentifiable: Identifiable, Object {
    /// The stable identity of the entity associated with `self`.
    var id: UInt64 { get }
}
/// :nodoc:
@available(*, deprecated, renamed: "ObjectKeyIdentifiable")
public typealias ObjectKeyIdentifable = ObjectKeyIdentifiable
extension ObjectKeyIdentifiable {
    /// A stable identifier for this object. For managed Realm objects, this
    /// value will be the same for all object instances which refer to the same
    /// object (i.e. for which `Object.isSameObject(as:)` returns true).
    public var id: UInt64 {
        RLMObjectBaseGetCombineId(self)
    }
}
// MARK: - Combine
/// A type which can be passed to `valuePublisher()` or `changesetPublisher()`.
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
public protocol RealmSubscribable {
    // swiftlint:disable identifier_name
    /// :nodoc:
    func _observe<S>(on queue: DispatchQueue?, _ subscriber: S)
        -> NotificationToken where S: Subscriber, S.Input == Self, S.Failure == Error
    /// :nodoc:
    func _observe<S>(_ subscriber: S)
        -> NotificationToken where S: Subscriber, S.Input == Void, S.Failure == Never
    // swiftlint:enable identifier_name
}
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension Publisher {
    /// Freezes all Realm objects and collections emitted by the upstream publisher
    ///
    /// Freezing a Realm object makes it no longer live-update when writes are
    /// made to the Realm and makes it safe to pass freely between threads
    /// without using `.threadSafeReference()`.
    ///
    /// ```
    /// // Get a publisher for a Results
    /// let cancellable = myResults.publisher
    ///    // Convert to frozen Results
    ///    .freeze()
    ///    // Unlike live objects, frozen objects can be sent to a concurrent queue
    ///    .receive(on: DispatchQueue.global())
    ///    .sink { frozenResults in
    ///        // Do something with the frozen Results
    ///    }
    /// ```
    ///
    /// - returns: A publisher that publishes frozen copies of the objects which the upstream publisher publishes.
    public func freeze<T>() -> Combine.Publishers.Map<Self, T> where Output: ThreadConfined, T == Output {
        return map { $0.freeze() }
    }
    /// Freezes all Realm object changesets emitted by the upstream publisher.
    ///
    /// Freezing a Realm object changeset makes the included object reference
    /// no longer live-update when writes are made to the Realm and makes it
    /// safe to pass freely between threads without using
    /// `.threadSafeReference()`. It also guarantees that the frozen object
    /// contained in the changset will always match the property changes, which
    /// is not always the case when using thread-safe references.
    ///
    /// ```
    /// // Get a changeset publisher for an object
    /// let cancellable = changesetPublisher(object)
    ///    // Convert to frozen changesets
    ///    .freeze()
    ///    // Unlike live objects, frozen objects can be sent to a concurrent queue
    ///    .receive(on: DispatchQueue.global())
    ///    .sink { changeset in
    ///        // Do something with the frozen changeset
    ///    }
    /// ```
    ///
    /// - returns: A publisher that publishes frozen copies of the changesets
    ///            which the upstream publisher publishes.
    public func freeze<T: Object>() -> Combine.Publishers.Map<Self, ObjectChange<T>> where Output == ObjectChange<T> {
        return map {
            if case .change(let object, let properties) = $0 {
                return .change(object.freeze(), properties)
            }
            return $0
        }
    }
    /// Freezes all Realm collection changesets from the upstream publisher.
    ///
    /// Freezing a Realm collection changeset makes the included collection
    /// reference no longer live-update when writes are made to the Realm and
    /// makes it safe to pass freely between threads without using
    /// `.threadSafeReference()`. It also guarantees that the frozen collection
    /// contained in the changset will always match the change information,
    /// which is not always the case when using thread-safe references.
    ///
    /// ```
    /// // Get a changeset publisher for a collection
    /// let cancellable = myList.changesetPublisher
    ///    // Convert to frozen changesets
    ///    .freeze()
    ///    // Unlike live objects, frozen objects can be sent to a concurrent queue
    ///    .receive(on: DispatchQueue.global())
    ///    .sink { changeset in
    ///        // Do something with the frozen changeset
    ///    }
    /// ```
    ///
    /// - returns: A publisher that publishes frozen copies of the changesets
    ///            which the upstream publisher publishes.
    public func freeze<T: RealmCollection>()
        -> Combine.Publishers.Map<Self, RealmCollectionChange<T>> where Output == RealmCollectionChange<T> {
            return map {
                switch $0 {
                case .initial(let collection):
                    return .initial(collection.freeze())
                case .update(let collection, deletions: let deletions, insertions: let insertions, modifications: let modifications):
                    return .update(collection.freeze(), deletions: deletions, insertions: insertions, modifications: modifications)
                case .error(let error):
                    return .error(error)
                }
            }
    }
}
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension Publisher where Output: ThreadConfined {
    /// Enables passing thread-confined objects to a different dispatch queue.
    ///
    /// Each call to `receive(on:)` on a publisher which emits Realm
    /// thread-confined objects must be proceeded by a call to
    /// `.threadSafeReference()`.The returned publisher handles the required
    /// logic to pass the thread-confined object to the new queue. Only serial
    /// dispatch queues are supported and using other schedulers will result in
    /// a fatal error.
    ///
    /// For example, to subscribe on a background thread, do some work there,
    /// then pass the object to the main thread you can do:
    ///
    ///     let cancellable = publisher(myObject)
    ///         .subscribe(on: DispatchQueue(label: "background queue")
    ///         .print()
    ///         .threadSafeReference()
    ///         .receive(on: DispatchQueue.main)
    ///         .sink { object in
    ///             // Do things with the object on the main thread
    ///         }
    ///
    /// Calling this function on a publisher which emits frozen or unmanaged
    /// objects is unneccesary but is allowed.
    ///
    /// - returns: A publisher that supports `receive(on:)` for thread-confined objects.
    public func threadSafeReference() -> Publishers.MakeThreadSafe<Self> {
        Publishers.MakeThreadSafe(self)
    }
}
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension Publisher {
    /// Enables passing object changesets to a different dispatch queue.
    ///
    /// Each call to `receive(on:)` on a publisher which emits Realm
    /// thread-confined objects must be proceeded by a call to
    /// `.threadSafeReference()`. The returned publisher handles the required
    /// logic to pass the thread-confined object to the new queue. Only serial
    /// dispatch queues are supported and using other schedulers will result in
    /// a fatal error.
    ///
    /// For example, to subscribe on a background thread, do some work there,
    /// then pass the object changeset to the main thread you can do:
    ///
    ///     let cancellable = changesetPublisher(myObject)
    ///         .subscribe(on: DispatchQueue(label: "background queue")
    ///         .print()
    ///         .threadSafeReference()
    ///         .receive(on: DispatchQueue.main)
    ///         .sink { objectChange in
    ///             // Do things with the object on the main thread
    ///         }
    ///
    /// - returns: A publisher that supports `receive(on:)` for thread-confined objects.
    public func threadSafeReference<T: Object>()
        -> Publishers.MakeThreadSafeObjectChangeset<Self, T> where Output == ObjectChange<T> {
            Publishers.MakeThreadSafeObjectChangeset(self)
    }
    /// Enables passing Realm collection changesets to a different dispatch queue.
    ///
    /// Each call to `receive(on:)` on a publisher which emits Realm
    /// thread-confined objects must be proceeded by a call to
    /// `.threadSafeReference()`. The returned publisher handles the required
    /// logic to pass the thread-confined object to the new queue. Only serial
    /// dispatch queues are supported and using other schedulers will result in
    /// a fatal error.
    ///
    /// For example, to subscribe on a background thread, do some work there,
    /// then pass the collection changeset to the main thread you can do:
    ///
    ///     let cancellable = myCollection.changesetPublisher
    ///         .subscribe(on: DispatchQueue(label: "background queue")
    ///         .print()
    ///         .threadSafeReference()
    ///         .receive(on: DispatchQueue.main)
    ///         .sink { collectionChange in
    ///             // Do things with the collection on the main thread
    ///         }
    ///
    /// - returns: A publisher that supports `receive(on:)` for thread-confined objects.
    public func threadSafeReference<T: RealmCollection>()
        -> Publishers.MakeThreadSafeCollectionChangeset<Self, T> where Output == RealmCollectionChange<T> {
            Publishers.MakeThreadSafeCollectionChangeset(self)
    }
}
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension RealmCollection where Self: RealmSubscribable {
    /// A publisher that emits Void each time the collection changes.
    ///
    /// Despite the name, this actually emits *after* the collection has changed.
    public var objectWillChange: Publishers.WillChange<Self> {
        Publishers.WillChange(self)
    }
    /// :nodoc:
    @available(*, deprecated, renamed: "collectionPublisher")
    public var publisher: Publishers.Value<Self> {
        Publishers.Value(self)
    }
    /// A publisher that emits the collection each time the collection changes.
    public var collectionPublisher: Publishers.Value<Self> {
        Publishers.Value(self)
    }
    /// A publisher that emits a collection changeset each time the collection changes.
    public var changesetPublisher: Publishers.CollectionChangeset<Self> {
        Publishers.CollectionChangeset(self)
    }
}
/// Creates a publisher that emits the object each time the object changes.
///
/// - precondition: The object must be a managed object which has not been invalidated.
/// - parameter object: A managed object to observe.
/// - returns: A publisher that emits the object each time it changes.
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
public func valuePublisher<T: Object>(_ object: T) -> Publishers.Value<T> {
    Publishers.Value<T>(object)
}
/// Creates a publisher that emits the collection each time the collection changes.
///
/// - precondition: The collection must be a managed collection which has not been invalidated.
/// - parameter object: A managed collection to observe.
/// - returns: A publisher that emits the collection each time it changes.
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
public func valuePublisher<T: RealmCollection>(_ collection: T) -> Publishers.Value<T> {
    Publishers.Value<T>(collection)
}
/// Creates a publisher that emits an object changeset each time the object changes.
///
/// - precondition: The object must be a managed object which has not been invalidated.
/// - parameter object: A managed object to observe.
/// - returns: A publisher that emits an object changeset each time the object changes.
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
public func changesetPublisher<T: Object>(_ object: T) -> Publishers.ObjectChangeset<T> {
    Publishers.ObjectChangeset<T>(object)
}
/// Creates a publisher that emits a collection changeset each time the collection changes.
///
/// - precondition: The collection must be a managed collection which has not been invalidated.
/// - parameter object: A managed collection to observe.
/// - returns: A publisher that emits a collection changeset each time the collection changes.
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
public func changesetPublisher<T: RealmCollection>(_ collection: T) -> Publishers.CollectionChangeset<T> {
    Publishers.CollectionChangeset<T>(collection)
}
// MARK: - Realm
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension Realm {
    /// A publisher that emits Void each time the object changes.
    ///
    /// Despite the name, this actually emits *after* the collection has changed.
    public var objectWillChange: Publishers.RealmWillChange {
        return Publishers.RealmWillChange(self)
    }
}
// MARK: - Object
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension Object: Combine.ObservableObject {
    /// A publisher that emits Void each time the object changes.
    ///
    /// Despite the name, this actually emits *after* the collection has changed.
    public var objectWillChange: Publishers.WillChange<Object> {
        return Publishers.WillChange(self)
    }
}
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension Object: RealmSubscribable {
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _observe<S: Subscriber>(on queue: DispatchQueue?, _ subscriber: S)
        -> NotificationToken where S.Input: Object, S.Failure == Error {
            return observe(on: queue) { (change: ObjectChange<S.Input>) in
                switch change {
                case .change(let object, _):
                    _ = subscriber.receive(object)
                case .deleted:
                    subscriber.receive(completion: .finished)
                case .error(let error):
                    subscriber.receive(completion: .failure(error))
                }
            }
    }
    /// :nodoc:
    public func _observe<S: Subscriber>(_ subscriber: S) -> NotificationToken where S.Input == Void, S.Failure == Never {
        return observe { _ in _ = subscriber.receive() }
    }
}
// MARK: - List
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension List: ObservableObject, RealmSubscribable {
    /// A publisher that emits Void each time the collection changes.
    ///
    /// Despite the name, this actually emits *after* the collection has changed.
    public var objectWillChange: Publishers.WillChange<List> {
        Publishers.WillChange(self)
    }
}
// MARK: - LinkingObjects
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension LinkingObjects: RealmSubscribable {
    /// A publisher that emits Void each time the collection changes.
    ///
    /// Despite the name, this actually emits *after* the collection has changed.
    public var objectWillChange: Publishers.WillChange<LinkingObjects> {
        Publishers.WillChange(self)
    }
}
// MARK: - Results
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension Results: RealmSubscribable {
    /// A publisher that emits Void each time the collection changes.
    ///
    /// Despite the name, this actually emits *after* the collection has changed.
    public var objectWillChange: Publishers.WillChange<Results> {
        Publishers.WillChange(self)
    }
}
// MARK: RealmCollection
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension RealmCollection {
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    public func _observe<S>(on queue: DispatchQueue? = nil, _ subscriber: S)
        -> NotificationToken where S: Subscriber, S.Input == Self, S.Failure == Error {
            // FIXME: we could skip some pointless work in converting the changeset to the Swift type here
            return observe(on: queue) { change in
                switch change {
                case .initial(let collection):
                    _ = subscriber.receive(collection)
                case .update(let collection, deletions: _, insertions: _, modifications: _):
                    _ = subscriber.receive(collection)
                case .error(let error):
                    subscriber.receive(completion: .failure(error))
                }
            }
    }
    /// :nodoc:
    public func _observe<S: Subscriber>(_ subscriber: S) -> NotificationToken where S.Input == Void, S.Failure == Never {
        return observe(on: nil) { _ in _ = subscriber.receive() }
    }
}
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
extension AnyRealmCollection: RealmSubscribable {
}
// MARK: Subscriptions
/// A subscription which wraps a Realm notification.
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
public struct ObservationSubscription: Subscription {
    private var token: NotificationToken
    internal init(token: NotificationToken) {
        self.token = token
    }
    /// A unique identifier for identifying publisher streams.
    public var combineIdentifier: CombineIdentifier {
        return CombineIdentifier(token)
    }
    /// This function is not implemented.
    ///
    /// Realm publishers do not support backpressure and so this function does nothing.
    public func request(_ demand: Subscribers.Demand) {
    }
    /// Stop emitting values on this subscription.
    public func cancel() {
        token.invalidate()
    }
}
// MARK: Publishers
/// Combine publishers for Realm types.
///
/// You normally should not create any of these types directly, and should
/// instead use the extension methods which create them.
@available(OSX 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, OSXApplicationExtension 10.15, tvOS 13.0, *)
public enum Publishers {
    static private func realm<S: Scheduler>(_ config: RLMRealmConfiguration, _ scheduler: S) -> Realm? {
        try? Realm(RLMRealm(configuration: config, queue: scheduler as? DispatchQueue))
    }
    /// A publisher which emits Void each time the Realm is refreshed.
    ///
    /// Despite the name, this actually emits *after* the Realm is refreshed.
    public struct RealmWillChange: Publisher {
        /// This publisher cannot fail.
        public typealias Failure = Never
        /// This publisher emits Void.
        public typealias Output = Void
        private let realm: Realm
        internal init(_ realm: Realm) {
            self.realm = realm
        }
        /// :nodoc:
        public func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Never, Output == S.Input {
            let token = self.realm.observe { _, _ in
                _ = subscriber.receive()
            }
            subscriber.receive(subscription: ObservationSubscription(token: token))
        }
    }
    /// A publisher which emits Void each time the object is mutated.
    ///
    /// Despite the name, this actually emits *after* the collection has changed.
    public struct WillChange<Collection: RealmSubscribable>: Publisher where Collection: ThreadConfined {
        /// This publisher cannot fail.
        public typealias Failure = Never
        /// This publisher emits Void.
        public typealias Output = Void
        private let object: Collection
        internal init(_ object: Collection) {
            self.object = object
        }
        /// :nodoc:
        public func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Never, Output == S.Input {
            subscriber.receive(subscription: ObservationSubscription(token: self.object._observe(subscriber)))
        }
    }
    /// A publisher which emits an object or collection each time that object is mutated.
    public struct Value<Subscribable: RealmSubscribable>: Publisher where Subscribable: ThreadConfined {
        /// This publisher can only fail due to resource exhaustion when
        /// creating the worker thread used for change notifications.
        public typealias Failure = Error
        /// This publisher emits the object or collection which it is publishing.
        public typealias Output = Subscribable
        private let object: Subscribable
        private let queue: DispatchQueue?
        internal init(_ object: Subscribable, queue: DispatchQueue? = nil) {
            precondition(object.realm != nil, "Only managed objects can be published")
            self.object = object
            self.queue = queue
        }
        /// :nodoc:
        public func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Failure, Output == S.Input {
            subscriber.receive(subscription: ObservationSubscription(token: self.object._observe(on: queue, subscriber)))
        }
        /// Specifies the scheduler on which to perform subscribe, cancel, and request operations.
        ///
        /// For Realm Publishers, this determines which queue the underlying
        /// change notifications are sent to. If `receive(on:)` is not used
        /// subsequently, it also will determine which queue elements received
        /// from the publisher are evaluated on. Currently only serial dispatch
        /// queues are supported, and the `options:` parameter is not
        /// supported.
        ///
        /// - parameter scheduler: The serial dispatch queue to perform the subscription on.
        /// - returns: A publisher which subscribes on the given scheduler.
        public func subscribe<S: Scheduler>(on scheduler: S) -> Value<Subscribable> {
            guard let queue = scheduler as? DispatchQueue else {
                fatalError("Cannot subscribe on scheduler \(scheduler): only serial dispatch queues are currently implemented.")
            }
            return Value(object, queue: queue)
        }
        /// Specifies the scheduler on which to perform downstream operations.
        ///
        /// This differs from `subscribe(on:)` in how it is integrated with the
        /// autorefresh cycle. When using `subscribe(on:)`, the subscription is
        /// performed on the target scheduler and the publisher will emit the
        /// collection during the refresh. When using `receive(on:)`, the
        /// collection is then converted to a `ThreadSafeReference` and
        /// delivered to the target scheduler with no integration into the
        /// autorefresh cycle, meaning it may arrive some time after the
        /// refresh occurs.
        ///
        /// When in doubt, you probably want `subscribe(on:)`.
        ///
        /// - parameter scheduler: The serial dispatch queue to receive values on.
        /// - returns: A publisher which delivers values to the given scheduler.
        public func receive<S: Scheduler>(on scheduler: S) -> Publishers.Handover<Self, S> {
            return Publishers.Handover(self, scheduler, self.object.realm!)
        }
    }
    /// A helper publisher used to support `receive(on:)` on Realm publishers.
    public struct Handover<Upstream: Publisher, S: Scheduler>: Publisher where Upstream.Output: ThreadConfined {
        /// :nodoc:
        public typealias Failure = Upstream.Failure
        /// :nodoc:
        public typealias Output = Upstream.Output
        private let config: RLMRealmConfiguration
        private let upstream: Upstream
        private let scheduler: S
        internal init(_ upstream: Upstream, _ scheduler: S, _ realm: Realm) {
            self.config = realm.rlmRealm.configuration
            self.upstream = upstream
            self.scheduler = scheduler
        }
        /// :nodoc:
        public func receive<Sub>(subscriber: Sub) where Sub: Subscriber, Sub.Failure == Failure, Output == Sub.Input {
            let scheduler = self.scheduler
            let config = self.config
            self.upstream
                .map { ThreadSafeReference(to: $0) }
                .receive(on: scheduler)
                .compactMap { realm(config, scheduler)?.resolve($0) }
                .receive(subscriber: subscriber)
        }
    }
    /// A publisher which makes `receive(on:)` work for streams of thread-confined objects
    ///
    /// Create using .threadSafeReference()
    public struct MakeThreadSafe<Upstream: Publisher>: Publisher where Upstream.Output: ThreadConfined {
        /// :nodoc:
        public typealias Failure = Upstream.Failure
        /// :nodoc:
        public typealias Output = Upstream.Output
        private let upstream: Upstream
        internal init(_ upstream: Upstream) {
            self.upstream = upstream
        }
        /// :nodoc:
        public func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Failure, Output == S.Input {
            self.upstream.receive(subscriber: subscriber)
        }
        /// Specifies the scheduler on which to receive elements from the publisher.
        ///
        /// This publisher converts each value emitted by the upstream
        /// publisher to a `ThreadSafeReference`, passes it to the target
        /// scheduler, and then converts back to the original type.
        ///
        /// - parameter scheduler: The serial dispatch queue to receive values on.
        /// - returns: A publisher which delivers values to the given scheduler.
        public func receive<S: Scheduler>(on scheduler: S) -> DeferredHandover<Upstream, S> {
            DeferredHandover(self.upstream, scheduler)
        }
    }
    /// A publisher which delivers thread-confined values to a serial dispatch queue.
    ///
    /// Create using `.threadSafeReference().receive(on: queue)` on a publisher
    /// that emits thread-confined objects.
    public struct DeferredHandover<Upstream: Publisher, S: Scheduler>: Publisher where Upstream.Output: ThreadConfined {
        /// :nodoc:
        public typealias Failure = Upstream.Failure
        /// :nodoc:
        public typealias Output = Upstream.Output
        private let upstream: Upstream
        private let scheduler: S
        internal init(_ upstream: Upstream, _ scheduler: S) {
            self.upstream = upstream
            self.scheduler = scheduler
        }
        private enum Handover {
            case object(_ object: Output)
            case tsr(_ tsr: ThreadSafeReference<Output>, config: RLMRealmConfiguration)
        }
        /// :nodoc:
        public func receive<Sub>(subscriber: Sub) where Sub: Subscriber, Sub.Failure == Failure, Output == Sub.Input {
            let scheduler = self.scheduler
            self.upstream
                .map { (obj: Output) -> Handover in
                    guard let realm = obj.realm, !realm.isFrozen else { return .object(obj) }
                    return .tsr(ThreadSafeReference(to: obj), config: realm.rlmRealm.configuration)
            }
            .receive(on: scheduler)
            .compactMap { (handover: Handover) -> Output? in
                switch handover {
                case .object(let obj):
                    return obj
                case .tsr(let tsr, let config):
                    return realm(config, scheduler)?.resolve(tsr)
                }
            }
            .receive(subscriber: subscriber)
        }
    }
    /// A publisher which emits ObjectChange<T> each time the observed object is modified
    ///
    /// `receive(on:)` and `subscribe(on:)` can be called directly on this
    /// publisher, and calling `.threadSafeReference()` is only required if
    /// there is an intermediate transform. If `subscribe(on:)` is used, it
    /// should always be the first operation in the pipeline.
    ///
    /// Create this publisher using the `objectChangeset()` function.
    public struct ObjectChangeset<T: Object>: Publisher {
        /// This publisher emits a ObjectChange<T> indicating which object and
        /// which properties of that object have changed each time a Realm is
        /// refreshed after a write transaction which modifies the observed
        /// object.
        public typealias Output = ObjectChange<T>
        /// This publisher reports error via the `.error` case of ObjectChange.
        public typealias Failure = Never
        private let object: T
        private let queue: DispatchQueue?
        internal init(_ object: T, queue: DispatchQueue? = nil) {
            precondition(object.realm != nil, "Only managed objects can be published")
            precondition(!object.isInvalidated, "Object is invalidated or deleted")
            self.object = object
            self.queue = queue
        }
        /// :nodoc:
        public func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Never, Output == S.Input {
            let token = self.object.observe(on: self.queue) { change in
                switch change {
                case .change(let o, let properties):
                    _ = subscriber.receive(.change(o as! T, properties))
                case .error(let error):
                    _ = subscriber.receive(.error(error))
                case .deleted:
                    subscriber.receive(completion: .finished)
                }
            }
            subscriber.receive(subscription: ObservationSubscription(token: token))
        }
        /// Specifies the scheduler on which to perform subscribe, cancel, and request operations.
        ///
        /// For Realm Publishers, this determines which queue the underlying
        /// change notifications are sent to. If `receive(on:)` is not used
        /// subsequently, it also will determine which queue elements received
        /// from the publisher are evaluated on. Currently only serial dispatch
        /// queues are supported, and the `options:` parameter is not
        /// supported.
        ///
        /// - parameter scheduler: The serial dispatch queue to perform the subscription on.
        /// - returns: A publisher which subscribes on the given scheduler.
        public func subscribe<S: Scheduler>(on scheduler: S) -> ObjectChangeset<T> {
            guard let queue = scheduler as? DispatchQueue else {
                fatalError("Cannot subscribe on scheduler \(scheduler): only serial dispatch queues are currently implemented.")
            }
            return ObjectChangeset(object, queue: queue)
        }
        /// Specifies the scheduler on which to perform downstream operations.
        ///
        /// This differs from `subscribe(on:)` in how it is integrated with the
        /// autorefresh cycle. When using `subscribe(on:)`, the subscription is
        /// performed on the target scheduler and the publisher will emit the
        /// collection during the refresh. When using `receive(on:)`, the
        /// collection is then converted to a `ThreadSafeReference` and
        /// delivered to the target scheduler with no integration into the
        /// autorefresh cycle, meaning it may arrive some time after the
        /// refresh occurs.
        ///
        /// When in doubt, you probably want `subscribe(on:)`
        ///
        /// - parameter scheduler: The serial dispatch queue to receive values on.
        /// - returns: A publisher which delivers values to the given scheduler.
        public func receive<S: Scheduler>(on scheduler: S) -> DeferredHandoverObjectChangeset<Self, T, S> {
            DeferredHandoverObjectChangeset(self, scheduler)
        }
    }
    /// A helper publisher created by calling `.threadSafeReference()` on a publisher which emits thread-confined values.
    public struct MakeThreadSafeObjectChangeset<Upstream: Publisher, T: Object>: Publisher where Upstream.Output == ObjectChange<T> {
        /// :nodoc:
        public typealias Failure = Upstream.Failure
        /// :nodoc:
        public typealias Output = Upstream.Output
        private let upstream: Upstream
        internal init(_ upstream: Upstream) {
            self.upstream = upstream
        }
        /// :nodoc:
        public func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Failure, Output == S.Input {
            self.upstream.receive(subscriber: subscriber)
        }
        /// Specifies the scheduler to deliver object changesets to.
        ///
        /// This differs from `subscribe(on:)` in how it is integrated with the
        /// autorefresh cycle. When using `subscribe(on:)`, the subscription is
        /// performed on the target scheduler and the publisher will emit the
        /// collection during the refresh. When using `receive(on:)`, the
        /// collection is then converted to a `ThreadSafeReference` and
        /// delivered to the target scheduler with no integration into the
        /// autorefresh cycle, meaning it may arrive some time after the
        /// refresh occurs.
        ///
        /// When in doubt, you probably want `subscribe(on:)`.
        ///
        /// - parameter scheduler: The serial dispatch queue to receive values on.
        /// - returns: A publisher which delivers values to the given scheduler.
        public func receive<S: Scheduler>(on scheduler: S) -> DeferredHandoverObjectChangeset<Upstream, T, S> {
            DeferredHandoverObjectChangeset(self.upstream, scheduler)
        }
    }
    /// A publisher which delivers thread-confined object changesets to a serial dispatch queue.
    ///
    /// Create using `.threadSafeReference().receive(on: queue)` on a publisher
    /// that emits `ObjectChange`.
    public struct DeferredHandoverObjectChangeset<Upstream: Publisher, T: Object, S: Scheduler>: Publisher where Upstream.Output == ObjectChange<T> {
        /// :nodoc:
        public typealias Failure = Upstream.Failure
        /// :nodoc:
        public typealias Output = Upstream.Output
        private let upstream: Upstream
        private let scheduler: S
        internal init(_ upstream: Upstream, _ scheduler: S) {
            self.upstream = upstream
            self.scheduler = scheduler
        }
        private enum Handover {
            case passthrough(_ change: ObjectChange<T>)
            case tsr(_ tsr: ThreadSafeReference<T>, _ properties: [PropertyChange], config: RLMRealmConfiguration)
        }
        /// :nodoc:
        public func receive<Sub>(subscriber: Sub) where Sub: Subscriber, Sub.Failure == Failure, Output == Sub.Input {
            let scheduler = self.scheduler
            self.upstream
                .map { (change: Output) -> Handover in
                    guard case .change(let obj, let properties) = change else { return .passthrough(change) }
                    guard let realm = obj.realm, !realm.isFrozen else { return .passthrough(change) }
                    return .tsr(ThreadSafeReference(to: obj), properties, config: realm.rlmRealm.configuration)
                }
                .receive(on: scheduler)
                .compactMap { (handover: Handover) -> Output? in
                    switch handover {
                    case .passthrough(let change):
                        return change
                    case .tsr(let tsr, let properties, let config):
                        if let resolved = realm(config, scheduler)?.resolve(tsr) {
                            return .change(resolved, properties)
                        }
                        return nil
                    }
                }
                .receive(subscriber: subscriber)
        }
    }
    /// A publisher which emits RealmCollectionChange<T> each time the observed object is modified
    ///
    /// `receive(on:)` and `subscribe(on:)` can be called directly on this
    /// publisher, and calling `.threadSafeReference()` is only required if
    /// there is an intermediate transform. If `subscribe(on:)` is used, it
    /// should always be the first operation in the pipeline.
    ///
    /// Create this publisher using the `changesetPublisher` property on RealmCollection..
    public struct CollectionChangeset<Collection: RealmCollection>: Publisher {
        public typealias Output = RealmCollectionChange<Collection>
        /// This publisher reports error via the `.error` case of RealmCollectionChange..
        public typealias Failure = Never
        private let collection: Collection
        private let queue: DispatchQueue?
        internal init(_ collection: Collection, queue: DispatchQueue? = nil) {
            precondition(collection.realm != nil, "Only managed collections can be published")
            self.collection = collection
            self.queue = queue
        }
        /// :nodoc:
        public func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Never, Output == S.Input {
            let token = self.collection.observe(on: self.queue) { change in
                _ = subscriber.receive(change)
            }
            subscriber.receive(subscription: ObservationSubscription(token: token))
        }
        /// Specifies the scheduler on which to perform subscribe, cancel, and request operations.
        ///
        /// For Realm Publishers, this determines which queue the underlying
        /// change notifications are sent to. If `receive(on:)` is not used
        /// subsequently, it also will determine which queue elements received
        /// from the publisher are evaluated on. Currently only serial dispatch
        /// queues are supported, and the `options:` parameter is not
        /// supported.
        ///
        /// - parameter scheduler: The serial dispatch queue to perform the subscription on.
        /// - returns: A publisher which subscribes on the given scheduler.
        public func subscribe<S: Scheduler>(on scheduler: S) -> CollectionChangeset<Collection> {
            guard let queue = scheduler as? DispatchQueue else {
                fatalError("Cannot subscribe on scheduler \(scheduler): only serial dispatch queues are currently implemented.")
            }
            return CollectionChangeset(collection, queue: queue)
        }
        /// Specifies the scheduler on which to perform downstream operations.
        ///
        /// This differs from `subscribe(on:)` in how it is integrated with the
        /// autorefresh cycle. When using `subscribe(on:)`, the subscription is
        /// performed on the target scheduler and the publisher will emit the
        /// collection during the refresh. When using `receive(on:)`, the
        /// collection is then converted to a `ThreadSafeReference` and
        /// delivered to the target scheduler with no integration into the
        /// autorefresh cycle, meaning it may arrive some time after the
        /// refresh occurs.
        ///
        /// When in doubt, you probably want `subscribe(on:)`
        ///
        /// - parameter scheduler: The serial dispatch queue to receive values on.
        /// - returns: A publisher which delivers values to the given scheduler.
        public func receive<S: Scheduler>(on scheduler: S) -> DeferredHandoverCollectionChangeset<Self, Collection, S> {
            DeferredHandoverCollectionChangeset(self, scheduler)
        }
    }
    /// A helper publisher created by calling `.threadSafeReference()` on a
    /// publisher which emits `RealmCollectionChange`.
    public struct MakeThreadSafeCollectionChangeset<Upstream: Publisher, T: RealmCollection>: Publisher where Upstream.Output == RealmCollectionChange<T> {
        /// :nodoc:
        public typealias Failure = Upstream.Failure
        /// :nodoc:
        public typealias Output = Upstream.Output
        private let upstream: Upstream
        internal init(_ upstream: Upstream) {
            self.upstream = upstream
        }
        /// :nodoc:
        public func receive<S>(subscriber: S) where S: Subscriber, S.Failure == Failure, Output == S.Input {
            self.upstream.receive(subscriber: subscriber)
        }
        /// Specifies the scheduler on which to receive elements from the publisher.
        ///
        /// This publisher converts each value emitted by the upstream
        /// publisher to a `ThreadSafeReference`, passes it to the target
        /// scheduler, and then converts back to the original type.
        ///
        /// - parameter scheduler: The serial dispatch queue to receive values on.
        /// - returns: A publisher which delivers values to the given scheduler.
        public func receive<S: Scheduler>(on scheduler: S) -> DeferredHandoverCollectionChangeset<Upstream, T, S> {
            DeferredHandoverCollectionChangeset(self.upstream, scheduler)
        }
    }
    /// A publisher which delivers thread-confined collection changesets to a
    /// serial dispatch queue.
    ///
    /// Create using `.threadSafeReference().receive(on: queue)` on a publisher
    /// that emits `RealmCollectionChange`.
    public struct DeferredHandoverCollectionChangeset<Upstream: Publisher, T: RealmCollection, S: Scheduler>: Publisher where Upstream.Output == RealmCollectionChange<T> {
        /// :nodoc:
        public typealias Failure = Upstream.Failure
        /// :nodoc:
        public typealias Output = Upstream.Output
        private let upstream: Upstream
        private let scheduler: S
        internal init(_ upstream: Upstream, _ scheduler: S) {
            self.upstream = upstream
            self.scheduler = scheduler
        }
        private enum Handover {
            case passthrough(_ change: RealmCollectionChange<T>)
            case initial(_ tsr: ThreadSafeReference<T>, config: RLMRealmConfiguration)
            case update(_ tsr: ThreadSafeReference<T>, deletions: [Int], insertions: [Int], modifications: [Int], config: RLMRealmConfiguration)
        }
        /// :nodoc:
        public func receive<Sub>(subscriber: Sub) where Sub: Subscriber, Sub.Failure == Failure, Output == Sub.Input {
            let scheduler = self.scheduler
            self.upstream
                .map { (change: Output) -> Handover in
                    switch change {
                    case .initial(let collection):
                        guard let realm = collection.realm, !realm.isFrozen else { return .passthrough(change) }
                        return .initial(ThreadSafeReference(to: collection), config: realm.rlmRealm.configuration)
                    case .update(let collection, deletions: let deletions, insertions: let insertions, modifications: let modifications):
                        guard let realm = collection.realm, !realm.isFrozen else { return .passthrough(change) }
                        return .update(ThreadSafeReference(to: collection), deletions: deletions, insertions: insertions, modifications: modifications, config: realm.rlmRealm.configuration)
                    case .error:
                        return .passthrough(change)
                    }
                }
                .receive(on: scheduler)
                .compactMap { (handover: Handover) -> Output? in
                    switch handover {
                    case .passthrough(let change):
                        return change
                    case .initial(let tsr, config: let config):
                        if let resolved = realm(config, scheduler)?.resolve(tsr) {
                            return .initial(resolved)
                        }
                        return nil
                    case .update(let tsr, deletions: let deletions, insertions: let insertions, modifications: let modifications, config: let config):
                        if let resolved = realm(config, scheduler)?.resolve(tsr) {
                            return .update(resolved, deletions: deletions, insertions: insertions, modifications: modifications)
                        }
                        return nil
                    }
                }
                .receive(subscriber: subscriber)
        }
    }
}
#endif // canImport(Combine)
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
import Realm.Private
/**
 The type of a migration block used to migrate a Realm.
 - parameter migration:  A `Migration` object used to perform the migration. The migration object allows you to
                         enumerate and alter any existing objects which require migration.
 - parameter oldSchemaVersion: The schema version of the Realm being migrated.
 */
public typealias MigrationBlock = (_ migration: Migration, _ oldSchemaVersion: UInt64) -> Void
/// An object class used during migrations.
public typealias MigrationObject = DynamicObject
/**
 A block type which provides both the old and new versions of an object in the Realm. Object
 properties can only be accessed using subscripting.
 - parameter oldObject: The object from the original Realm (read-only).
 - parameter newObject: The object from the migrated Realm (read-write).
 */
public typealias MigrationObjectEnumerateBlock = (_ oldObject: MigrationObject?, _ newObject: MigrationObject?) -> Void
/**
 Returns the schema version for a Realm at a given local URL.
 - parameter fileURL:       Local URL to a Realm file.
 - parameter encryptionKey: 64-byte key used to encrypt the file, or `nil` if it is unencrypted.
 - throws: An `NSError` that describes the problem.
 */
public func schemaVersionAtURL(_ fileURL: URL, encryptionKey: Data? = nil) throws -> UInt64 {
    var error: NSError?
    let version = RLMRealm.__schemaVersion(at: fileURL, encryptionKey: encryptionKey, error: &error)
    guard version != RLMNotVersioned else {
        throw error!
    }
    return version
}
extension Realm {
    /**
     Performs the given Realm configuration's migration block on a Realm at the given path.
     This method is called automatically when opening a Realm for the first time and does not need to be called
     explicitly. You can choose to call this method to control exactly when and how migrations are performed.
     - parameter configuration: The Realm configuration used to open and migrate the Realm.
     */
    public static func performMigration(for configuration: Realm.Configuration = Realm.Configuration.defaultConfiguration) throws {
        try RLMRealm.performMigration(for: configuration.rlmConfiguration)
    }
}
/**
 `Migration` instances encapsulate information intended to facilitate a schema migration.
 A `Migration` instance is passed into a user-defined `MigrationBlock` block when updating the version of a Realm. This
 instance provides access to the old and new database schemas, the objects in the Realm, and provides functionality for
 modifying the Realm during the migration.
 */
public struct Migration {
    // MARK: Properties
    /// The old schema, describing the Realm before applying a migration.
    public var oldSchema: Schema { return Schema(rlmMigration.oldSchema) }
    /// The new schema, describing the Realm after applying a migration.
    public var newSchema: Schema { return Schema(rlmMigration.newSchema) }
    internal var rlmMigration: RLMMigration
    // MARK: Altering Objects During a Migration
    /**
     Enumerates all the objects of a given type in this Realm, providing both the old and new versions of each object.
     Properties on an object can be accessed using subscripting.
     - parameter objectClassName: The name of the `Object` class to enumerate.
     - parameter block:           The block providing both the old and new versions of an object in this Realm.
     */
    public func enumerateObjects(ofType typeName: String, _ block: MigrationObjectEnumerateBlock) {
        rlmMigration.enumerateObjects(typeName) { oldObject, newObject in
            block(unsafeBitCast(oldObject, to: MigrationObject.self),
                  unsafeBitCast(newObject, to: MigrationObject.self))
        }
    }
    /**
     Creates and returns an `Object` of type `className` in the Realm being migrated.
     The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or
     dictionary returned from the methods in `NSJSONSerialization`, or an `Array` containing one element for each
     managed property. An exception will be thrown if any required properties are not present and those properties were
     not defined with default values.
     When passing in an `Array` as the `value` argument, all properties must be present, valid and in the same order as
     the properties defined in the model.
     - parameter className: The name of the `Object` class to create.
     - parameter value:     The value used to populate the created object.
     - returns: The newly created object.
     */
    @discardableResult
    public func create(_ typeName: String, value: Any = [:]) -> MigrationObject {
        return unsafeBitCast(rlmMigration.createObject(typeName, withValue: value), to: MigrationObject.self)
    }
    /**
     Deletes an object from a Realm during a migration.
     It is permitted to call this method from within the block passed to `enumerate(_:block:)`.
     - parameter object: An object to be deleted from the Realm being migrated.
     */
    public func delete(_ object: MigrationObject) {
        rlmMigration.delete(object.unsafeCastToRLMObject())
    }
    /**
     Deletes the data for the class with the given name.
     All objects of the given class will be deleted. If the `Object` subclass no longer exists in your program, any
     remaining metadata for the class will be removed from the Realm file.
     - parameter objectClassName: The name of the `Object` class to delete.
     - returns: A Boolean value indicating whether there was any data to delete.
     */
    @discardableResult
    public func deleteData(forType typeName: String) -> Bool {
        return rlmMigration.deleteData(forClassName: typeName)
    }
    /**
     Renames a property of the given class from `oldName` to `newName`.
     - parameter className:  The name of the class whose property should be renamed. This class must be present
                             in both the old and new Realm schemas.
     - parameter oldName:    The old name for the property to be renamed. There must not be a property with this name in
                             the class as defined by the new Realm schema.
     - parameter newName:    The new name for the property to be renamed. There must not be a property with this name in
                             the class as defined by the old Realm schema.
     */
    public func renameProperty(onType typeName: String, from oldName: String, to newName: String) {
        rlmMigration.renameProperty(forClass: typeName, oldName: oldName, newName: newName)
    }
    internal init(_ rlmMigration: RLMMigration) {
        self.rlmMigration = rlmMigration
    }
}
// MARK: Private Helpers
internal func accessorMigrationBlock(_ migrationBlock: @escaping MigrationBlock) -> RLMMigrationBlock {
    return { migration, oldVersion in
        // set all accessor classes to MigrationObject
        for objectSchema in migration.oldSchema.objectSchema {
            objectSchema.accessorClass = MigrationObject.self
            // isSwiftClass is always `false` for object schema generated
            // from the table, but we need to pretend it's from a swift class
            // (even if it isn't) for the accessors to be initialized correctly.
            objectSchema.isSwiftClass = true
        }
        for objectSchema in migration.newSchema.objectSchema {
            objectSchema.accessorClass = MigrationObject.self
        }
        // run migration
        migrationBlock(Migration(migration), oldVersion)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2014 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Foundation
import Realm
import Realm.Private
/**
 `Object` is a class used to define Realm model objects.
 In Realm you define your model classes by subclassing `Object` and adding properties to be managed.
 You then instantiate and use your custom subclasses instead of using the `Object` class directly.
 ```swift
 class Dog: Object {
     @objc dynamic var name: String = ""
     @objc dynamic var adopted: Bool = false
     let siblings = List<Dog>()
 }
 ```
 ### Supported property types
 - `String`, `NSString`
 - `Int`
 - `Int8`, `Int16`, `Int32`, `Int64`
 - `Float`
 - `Double`
 - `Bool`
 - `Date`, `NSDate`
 - `Data`, `NSData`
 - `@objc enum` which has been delcared as conforming to `RealmEnum`.
 - `RealmOptional<Value>` for optional numeric properties
 - `Object` subclasses, to model many-to-one relationships
 - `List<Element>`, to model many-to-many relationships
 `String`, `NSString`, `Date`, `NSDate`, `Data`, `NSData` and `Object` subclass properties can be declared as optional.
 `Int`, `Int8`, `Int16`, `Int32`, `Int64`, `Float`, `Double`, `Bool`,  enum, and `List` properties cannot.
 To store an optional number, use `RealmOptional<Int>`, `RealmOptional<Float>`, `RealmOptional<Double>`, or
 `RealmOptional<Bool>` instead, which wraps an optional numeric value. Lists cannot be optional at all.
 All property types except for `List` and `RealmOptional` *must* be declared as `@objc dynamic var`. `List` and
 `RealmOptional` properties must be declared as non-dynamic `let` properties. Swift `lazy` properties are not allowed.
 Note that none of the restrictions listed above apply to properties that are configured to be ignored by Realm.
 ### Querying
 You can retrieve all objects of a given type from a Realm by calling the `objects(_:)` instance method.
 ### Relationships
 See our [Cocoa guide](http://realm.io/docs/cocoa) for more details.
 */
@objc(RealmSwiftObject)
open class Object: RLMObjectBase, RealmCollectionValue {
    /// :nodoc:
    public static func _rlmArray() -> RLMArray<AnyObject> {
        return RLMArray(objectClassName: className())
    }
    // MARK: Initializers
    /**
     Creates an unmanaged instance of a Realm object.
     Call `add(_:)` on a `Realm` instance to add an unmanaged object into that Realm.
     - see: `Realm().add(_:)`
     */
    public override required init() {
        super.init()
    }
    /**
     Creates an unmanaged instance of a Realm object.
     The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or
     dictionary returned from the methods in `NSJSONSerialization`, or an `Array` containing one element for each
     managed property. An exception will be thrown if any required properties are not present and those properties were
     not defined with default values.
     When passing in an `Array` as the `value` argument, all properties must be present, valid and in the same order as
     the properties defined in the model.
     Call `add(_:)` on a `Realm` instance to add an unmanaged object into that Realm.
     - parameter value:  The value used to populate the object.
     */
    public convenience init(value: Any) {
        self.init()
        RLMInitializeWithValue(self, value, .partialPrivateShared())
    }
    // MARK: Properties
    /// The Realm which manages the object, or `nil` if the object is unmanaged.
    public var realm: Realm? {
        if let rlmReam = RLMObjectBaseRealm(self) {
            return Realm(rlmReam)
        }
        return nil
    }
    /// The object schema which lists the managed properties for the object.
    public var objectSchema: ObjectSchema {
        return ObjectSchema(RLMObjectBaseObjectSchema(self)!)
    }
    /// Indicates if the object can no longer be accessed because it is now invalid.
    ///
    /// An object can no longer be accessed if the object has been deleted from the Realm that manages it, or if
    /// `invalidate()` is called on that Realm. This property is key-value observable.
    @objc dynamic open override var isInvalidated: Bool { return super.isInvalidated }
    /// A human-readable description of the object.
    open override var description: String { return super.description }
    /**
     WARNING: This is an internal helper method not intended for public use.
     It is not considered part of the public API.
     :nodoc:
     */
    public override final class func _getProperties(withInstance instance: Any) -> [RLMProperty] {
        return ObjectUtil.getSwiftProperties(instance as! RLMObjectBase)
    }
    // MARK: Object Customization
    /**
     Override this method to specify the name of a property to be used as the primary key.
     Only properties of types `String` and `Int` can be designated as the primary key. Primary key properties enforce
     uniqueness for each value whenever the property is set, which incurs minor overhead. Indexes are created
     automatically for primary key properties.
     - returns: The name of the property designated as the primary key, or `nil` if the model has no primary key.
     */
    @objc open class func primaryKey() -> String? { return nil }
    /**
     Override this method to specify the names of properties to ignore. These properties will not be managed by
     the Realm that manages the object.
     - returns: An array of property names to ignore.
     */
    @objc open class func ignoredProperties() -> [String] { return [] }
    /**
     Returns an array of property names for properties which should be indexed.
     Only string, integer, boolean, `Date`, and `NSDate` properties are supported.
     - returns: An array of property names.
     */
    @objc open class func indexedProperties() -> [String] { return [] }
    // MARK: Key-Value Coding & Subscripting
    /// Returns or sets the value of the property with the given name.
    @objc open subscript(key: String) -> Any? {
        get {
            if realm == nil {
                return value(forKey: key)
            }
            return dynamicGet(key: key)
        }
        set(value) {
            if realm == nil {
                setValue(value, forKey: key)
            } else {
                RLMDynamicValidatedSet(self, key, value)
            }
        }
    }
    private func dynamicGet(key: String) -> Any? {
        let objectSchema = RLMObjectBaseObjectSchema(self)!
        guard let prop = objectSchema[key] else {
            throwRealmException("Invalid property name '\(key) for class \(objectSchema.className)")
        }
        if let accessor = prop.swiftAccessor {
            return accessor.get(Unmanaged.passUnretained(self).toOpaque() + ivar_getOffset(prop.swiftIvar!))
        }
        if let ivar = prop.swiftIvar, prop.array {
            return object_getIvar(self, ivar)
        }
        return RLMDynamicGet(self, prop)
    }
    // MARK: Notifications
    /**
     Registers a block to be called each time the object changes.
     The block will be asynchronously called after each write transaction which
     deletes the object or modifies any of the managed properties of the object,
     including self-assignments that set a property to its existing value.
     For write transactions performed on different threads or in different
     processes, the block will be called when the managing Realm is
     (auto)refreshed to a version including the changes, while for local write
     transactions it will be called at some point in the future after the write
     transaction is committed.
     If no queue is given, notifications are delivered via the standard run
     loop, and so can't be delivered while the run loop is blocked by other
     activity. If a queue is given, notifications are delivered to that queue
     instead. When notifications can't be delivered instantly, multiple
     notifications may be coalesced into a single notification.
     Unlike with `List` and `Results`, there is no "initial" callback made after
     you add a new notification block.
     Only objects which are managed by a Realm can be observed in this way. You
     must retain the returned token for as long as you want updates to be sent
     to the block. To stop receiving updates, call `invalidate()` on the token.
     It is safe to capture a strong reference to the observed object within the
     callback block. There is no retain cycle due to that the callback is
     retained by the returned token and not by the object itself.
     - warning: This method cannot be called during a write transaction, or when
                the containing Realm is read-only.
     - parameter queue: The serial dispatch queue to receive notification on. If
                        `nil`, notifications are delivered to the current thread.
     - parameter block: The block to call with information about changes to the object.
     - returns: A token which must be held for as long as you want updates to be delivered.
     */
    public func observe<T: Object>(on queue: DispatchQueue? = nil,
                                   _ block: @escaping (ObjectChange<T>) -> Void) -> NotificationToken {
        precondition(self as? T != nil)
        return RLMObjectBaseAddNotificationBlock(self, queue) { object, names, oldValues, newValues, error in
            if let error = error {
                block(.error(error as NSError))
                return
            }
            guard let names = names, let newValues = newValues else {
                block(.deleted)
                return
            }
            block(.change(object as! T, (0..<newValues.count).map { i in
                PropertyChange(name: names[i], oldValue: oldValues?[i], newValue: newValues[i])
            }))
        }
    }
    // MARK: Dynamic list
    /**
     Returns a list of `DynamicObject`s for a given property name.
     - warning:  This method is useful only in specialized circumstances, for example, when building
     components that integrate with Realm. If you are simply building an app on Realm, it is
     recommended to use instance variables or cast the values returned from key-value coding.
     - parameter propertyName: The name of the property.
     - returns: A list of `DynamicObject`s.
     :nodoc:
     */
    public func dynamicList(_ propertyName: String) -> List<DynamicObject> {
        return noWarnUnsafeBitCast(dynamicGet(key: propertyName) as! RLMListBase,
                                   to: List<DynamicObject>.self)
    }
    // MARK: Comparison
    /**
     Returns whether two Realm objects are the same.
     Objects are considered the same if and only if they are both managed by the same
     Realm and point to the same underlying object in the database.
     - note: Equality comparison is implemented by `isEqual(_:)`. If the object type
             is defined with a primary key, `isEqual(_:)` behaves identically to this
             method. If the object type is not defined with a primary key,
             `isEqual(_:)` uses the `NSObject` behavior of comparing object identity.
             This method can be used to compare two objects for database equality
             whether or not their object type defines a primary key.
     - parameter object: The object to compare the receiver to.
     */
    public func isSameObject(as object: Object?) -> Bool {
        return RLMObjectBaseAreEqual(self, object)
    }
}
extension Object: ThreadConfined {
    /**
     Indicates if this object is frozen.
     - see: `Object.freeze()`
     */
    public var isFrozen: Bool { return realm?.isFrozen ?? false }
    /**
     Returns a frozen (immutable) snapshot of this object.
     The frozen copy is an immutable object which contains the same data as this
     object currently contains, but will not update when writes are made to the
     containing Realm. Unlike live objects, frozen objects can be accessed from any
     thread.
     - warning: Holding onto a frozen object for an extended period while performing write
     transaction on the Realm may result in the Realm file growing to large sizes. See
     `Realm.Configuration.maximumNumberOfActiveVersions` for more information.
     - warning: This method can only be called on a managed object.
     */
    public func freeze() -> Self {
        return realm!.freeze(self)
    }
}
/**
 Information about a specific property which changed in an `Object` change notification.
 */
public struct PropertyChange {
    /**
     The name of the property which changed.
    */
    public let name: String
    /**
     Value of the property before the change occurred. This is not supplied if
     the change happened on the same thread as the notification and for `List`
     properties.
     For object properties this will give the object which was previously
     linked to, but that object will have its new values and not the values it
     had before the changes. This means that `previousValue` may be a deleted
     object, and you will need to check `isInvalidated` before accessing any
     of its properties.
    */
    public let oldValue: Any?
    /**
     The value of the property after the change occurred. This is not supplied
     for `List` properties and will always be nil.
    */
    public let newValue: Any?
}
/**
 Information about the changes made to an object which is passed to `Object`'s
 notification blocks.
 */
public enum ObjectChange<T: Object> {
    /**
     If an error occurs, notification blocks are called one time with a `.error`
     result and an `NSError` containing details about the error. Currently the
     only errors which can occur are when opening the Realm on a background
     worker thread to calculate the change set. The callback will never be
     called again after `.error` is delivered.
     */
    case error(_ error: NSError)
    /**
     One or more of the properties of the object have been changed.
     */
    case change(_: T, _: [PropertyChange])
    /// The object has been deleted from the Realm.
    case deleted
}
/// Object interface which allows untyped getters and setters for Objects.
/// :nodoc:
public final class DynamicObject: Object {
    public override subscript(key: String) -> Any? {
        get {
            let value = RLMDynamicGetByName(self, key)
            if let array = value as? RLMArray<AnyObject> {
                return List<DynamicObject>(objc: array)
            }
            return value
        }
        set(value) {
            RLMDynamicValidatedSet(self, key, value)
        }
    }
    /// :nodoc:
    public override func dynamicList(_ propertyName: String) -> List<DynamicObject> {
        return self[propertyName] as! List<DynamicObject>
    }
    /// :nodoc:
    public override func value(forUndefinedKey key: String) -> Any? {
        return self[key]
    }
    /// :nodoc:
    public override func setValue(_ value: Any?, forUndefinedKey key: String) {
        self[key] = value
    }
    /// :nodoc:
    public override class func shouldIncludeInDefaultSchema() -> Bool {
        return false
    }
}
/**
 An enum type which can be stored on a Realm Object.
 Only `@objc` enums backed by an Int can be stored on a Realm object, and the
 enum type must explicitly conform to this protocol. For example:
 ```
 @objc enum class MyEnum: Int, RealmEnum {
    case first = 1
    case second = 2
    case third = 7
 }
 class MyModel: Object {
    @objc dynamic enumProperty = MyEnum.first
    let optionalEnumProperty = RealmOptional<MyEnum>()
 }
 ```
 */
public protocol RealmEnum: RealmOptionalType, _ManagedPropertyType {
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    static func _rlmToRawValue(_ value: Any) -> Any
    /// :nodoc:
    // swiftlint:disable:next identifier_name
    static func _rlmFromRawValue(_ value: Any) -> Any
}
// MARK: - Implementation
/// :nodoc:
public extension RealmEnum where Self: RawRepresentable, Self.RawValue: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    static func _rlmToRawValue(_ value: Any) -> Any {
        return (value as! Self).rawValue
    }
    // swiftlint:disable:next identifier_name
    static func _rlmFromRawValue(_ value: Any) -> Any {
        return Self.init(rawValue: value as! RawValue)!
    }
    // swiftlint:disable:next identifier_name
    static func _rlmProperty(_ prop: RLMProperty) {
        RawValue._rlmProperty(prop)
    }
}
// A type which can be a managed property on a Realm object
/// :nodoc:
public protocol _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    func _rlmProperty(_ prop: RLMProperty)
    // swiftlint:disable:next identifier_name
    static func _rlmProperty(_ prop: RLMProperty)
    // swiftlint:disable:next identifier_name
    static func _rlmRequireObjc() -> Bool
}
/// :nodoc:
extension _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public func _rlmProperty(_ prop: RLMProperty) { }
    // swiftlint:disable:next identifier_name
    public static func _rlmRequireObjc() -> Bool { return true }
}
/// :nodoc:
extension Int: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .int
    }
}
/// :nodoc:
extension Int8: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .int
    }
}
/// :nodoc:
extension Int16: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .int
    }
}
/// :nodoc:
extension Int32: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .int
    }
}
/// :nodoc:
extension Int64: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .int
    }
}
/// :nodoc:
extension Float: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .float
    }
}
/// :nodoc:
extension Double: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .double
    }
}
/// :nodoc:
extension Bool: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .bool
    }
}
/// :nodoc:
extension String: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .string
    }
}
/// :nodoc:
extension NSString: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .string
    }
}
/// :nodoc:
extension Data: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .data
    }
}
/// :nodoc:
extension NSData: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .data
    }
}
/// :nodoc:
extension Date: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .date
    }
}
/// :nodoc:
extension NSDate: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.type = .date
    }
}
/// :nodoc:
extension Object: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        if !prop.optional && !prop.array {
            throwRealmException("Object property '\(prop.name)' must be marked as optional.")
        }
        if prop.optional && prop.array {
            throwRealmException("List<\(className())> property '\(prop.name)' must not be marked as optional.")
        }
        prop.type = .object
        prop.objectClassName = className()
    }
}
/// :nodoc:
extension List: _ManagedPropertyType where Element: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.array = true
        Element._rlmProperty(prop)
    }
    // swiftlint:disable:next identifier_name
    public static func _rlmRequireObjc() -> Bool { return false }
}
/// :nodoc:
class LinkingObjectsAccessor<Element: Object>: RLMManagedPropertyAccessor {
    @objc override class func initializeObject(_ ptr: UnsafeMutableRawPointer,
                                               parent: RLMObjectBase, property: RLMProperty) {
        ptr.assumingMemoryBound(to: LinkingObjects.self).pointee.handle = RLMLinkingObjectsHandle(object: parent, property: property)
    }
    @objc override class func get(_ ptr: UnsafeMutableRawPointer) -> Any {
        return ptr.assumingMemoryBound(to: LinkingObjects<Element>.self).pointee
    }
}
/// :nodoc:
extension LinkingObjects: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.array = true
        prop.type = .linkingObjects
        prop.objectClassName = Element.className()
        prop.swiftAccessor = LinkingObjectsAccessor<Element>.self
    }
    // swiftlint:disable:next identifier_name
    public func _rlmProperty(_ prop: RLMProperty) {
        prop.linkOriginPropertyName = self.propertyName
    }
    // swiftlint:disable:next identifier_name
    public static func _rlmRequireObjc() -> Bool { return false }
}
/// :nodoc:
extension Optional: _ManagedPropertyType where Wrapped: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.optional = true
        Wrapped._rlmProperty(prop)
    }
}
/// :nodoc:
extension RealmOptional: _ManagedPropertyType where Value: _ManagedPropertyType {
    // swiftlint:disable:next identifier_name
    public static func _rlmProperty(_ prop: RLMProperty) {
        prop.optional = true
        Value._rlmProperty(prop)
    }
    // swiftlint:disable:next identifier_name
    public static func _rlmRequireObjc() -> Bool { return false }
}
/// :nodoc:
internal class ObjectUtil {
    private static let runOnce: Void = {
        RLMSwiftAsFastEnumeration = { (obj: Any) -> Any? in
            // Intermediate cast to AnyObject due to https://bugs.swift.org/browse/SR-8651
            if let collection = obj as AnyObject as? _RealmCollectionEnumerator {
                return collection._asNSFastEnumerator()
            }
            return nil
        }
    }()
    private class func swiftVersion() -> NSString {
#if SWIFT_PACKAGE
        return "5.1"
#else
        return swiftLanguageVersion as NSString
#endif
    }
    // If the property is a storage property for a lazy Swift property, return
    // the base property name (e.g. `foo.storage` becomes `foo`). Otherwise, nil.
    private static func baseName(forLazySwiftProperty name: String) -> String? {
        // A Swift lazy var shows up as two separate children on the reflection tree:
        // one named 'x', and another that is optional and is named 'x.storage'. Note
        // that '.' is illegal in either a Swift or Objective-C property name.
        if let storageRange = name.range(of: ".storage", options: [.anchored, .backwards]) {
            return String(name[..<storageRange.lowerBound])
        }
        // Xcode 11 changed the name of the storage property to "$__lazy_storage_$_propName"
        if let storageRange = name.range(of: "$__lazy_storage_$_", options: [.anchored]) {
            return String(name[storageRange.upperBound...])
        }
        return nil
    }
    // Reflect an object, returning only children representing managed Realm properties.
    private static func getNonIgnoredMirrorChildren(for object: Any) -> [Mirror.Child] {
        let ignoredPropNames: Set<String>
        if let realmObject = object as? Object {
            ignoredPropNames = Set(type(of: realmObject).ignoredProperties())
        } else {
            ignoredPropNames = Set()
        }
        return Mirror(reflecting: object).children.filter { (prop: Mirror.Child) -> Bool in
            guard let label = prop.label else {
                return false
            }
            if ignoredPropNames.contains(label) {
                return false
            }
            if let lazyBaseName = baseName(forLazySwiftProperty: label) {
                if ignoredPropNames.contains(lazyBaseName) {
                    return false
                }
                // Managed lazy property; not currently supported.
                // FIXME: revisit this once Swift gets property behaviors/property macros.
                throwRealmException("Lazy managed property '\(lazyBaseName)' is not allowed on a Realm Swift object"
                    + " class. Either add the property to the ignored properties list or make it non-lazy.")
            }
            return true
        }
    }
    internal class func getSwiftProperties(_ object: RLMObjectBase) -> [RLMProperty] {
        _ = ObjectUtil.runOnce
        let cls = type(of: object)
        var indexedProperties: Set<String>!
        let columnNames = cls._realmColumnNames()
        if let realmObject = object as? Object {
            indexedProperties = Set(type(of: realmObject).indexedProperties())
        } else {
            indexedProperties = Set()
        }
        return getNonIgnoredMirrorChildren(for: object).compactMap { prop in
            guard let label = prop.label else { return nil }
            var rawValue = prop.value
            if let value = rawValue as? RealmEnum {
                rawValue = type(of: value)._rlmToRawValue(value)
            }
            guard let value = rawValue as? _ManagedPropertyType else {
                if class_getProperty(cls, label) != nil {
                    throwRealmException("Property \(cls).\(label) is declared as \(type(of: prop.value)), which is not a supported managed Object property type. If it is not supposed to be a managed property, either add it to `ignoredProperties()` or do not declare it as `@objc dynamic`. See https://realm.io/docs/swift/latest/api/Classes/Object.html for more information.")
                }
                if prop.value as? RealmOptionalProtocol != nil {
                    throwRealmException("Property \(cls).\(label) has unsupported RealmOptional type \(type(of: prop.value)). Extending RealmOptionalType with custom types is not currently supported. ")
                }
                return nil
            }
            RLMValidateSwiftPropertyName(label)
            let valueType = type(of: value)
            let property = RLMProperty()
            property.name = label
            property.indexed = indexedProperties.contains(label)
            property.columnName = columnNames?[label]
            valueType._rlmProperty(property)
            value._rlmProperty(property)
            if let objcProp = class_getProperty(cls, label) {
                var count: UInt32 = 0
                let attrs = property_copyAttributeList(objcProp, &count)!
                defer {
                    free(attrs)
                }
                var computed = true
                for i in 0..<Int(count) {
                    let attr = attrs[i]
                    switch attr.name[0] {
                    case Int8(UInt8(ascii: "R")): // Read only
                        return nil
                    case Int8(UInt8(ascii: "V")): // Ivar name
                        computed = false
                    case Int8(UInt8(ascii: "G")): // Getter name
                        property.getterName = String(cString: attr.value)
                    case Int8(UInt8(ascii: "S")): // Setter name
                        property.setterName = String(cString: attr.value)
                    default:
                        break
                    }
                }
                // If there's no ivar name and no ivar with the same name as
                // the property then this is a computed property and we should
                // implicitly ignore it
                if computed && class_getInstanceVariable(cls, label) == nil {
                    return nil
                }
            } else if valueType._rlmRequireObjc() {
                // Implicitly ignore non-@objc dynamic properties
                return nil
            } else {
                property.swiftIvar = class_getInstanceVariable(cls, label)
            }
            property.updateAccessors()
            return property
        }
    }
}
// MARK: AssistedObjectiveCBridgeable
// FIXME: Remove when `as! Self` can be written
private func forceCastToInferred<T, V>(_ x: T) -> V {
    return x as! V
}
extension Object: AssistedObjectiveCBridgeable {
    internal static func bridging(from objectiveCValue: Any, with metadata: Any?) -> Self {
        return forceCastToInferred(objectiveCValue)
    }
    internal var bridged: (objectiveCValue: Any, metadata: Any?) {
        return (objectiveCValue: unsafeCastToRLMObject(), metadata: nil)
    }
}
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2015 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import Realm
/// A protocol describing types that can parameterize a `RealmOptional`.
public protocol RealmOptionalType {
}
public extension RealmOptionalType {
    /// :nodoc:
    static func className() -> String {
        return ""
    }
}
extension Int: RealmOptionalType {}
extension Int8: RealmOptionalType {}
extension Int16: RealmOptionalType {}
extension Int32: RealmOptionalType {}
extension Int64: RealmOptionalType {}
extension Float: RealmOptionalType {}
extension Double: RealmOptionalType {}
extension Bool: RealmOptionalType {}
/**
 A `RealmOptional` instance represents an optional value for types that can't be
 directly declared as `@objc` in Swift, such as `Int`, `Float`, `Double`, and `Bool`.
 To change the underlying value stored by a `RealmOptional` instance, mutate the instance's `value` property.
 */
public final class RealmOptional<Value: RealmOptionalType>: RLMOptionalBase {
    /// The value the optional represents.
    public var value: Value? {
        get {
            return RLMGetOptional(self).map(dynamicBridgeCast)
        }
        set {
            RLMSetOptional(self, newValue.map(dynamicBridgeCast))
        }
    }
    /**
     Creates a `RealmOptional` instance encapsulating the given default value.
     - parameter value: The value to store in the optional, or `nil` if not specified.
     */
    public init(_ value: Value? = nil) {
        super.init()
        self.value = value
    }
}
extension RealmOptional: Codable where Value: Codable {
    public convenience init(from decoder: Decoder) throws {
        self.init()
        // `try decoder.singleValueContainer().decode(Value?.self)` incorrectly
        // rejects null values: https://bugs.swift.org/browse/SR-7404
        let container = try decoder.singleValueContainer()
        self.value = container.decodeNil() ? nil : try container.decode(Value.self)
    }
    public func encode(to encoder: Encoder) throws {
        try self.value.encode(to: encoder)
    }
}
internal protocol RealmOptionalProtocol { }
extension RealmOptional: RealmOptionalProtocol { }
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  Helper.swift
//  HandyJSON
//
//  Created by zhouzhuo on 07/01/2017.
//
struct ReflectionHelper {
    static func mutableStorage<T>(instance: inout T) -> UnsafeMutableRawPointer {
        return UnsafeMutableRawPointer(mutating: storage(instance: &instance))
    }
    static func storage<T>(instance: inout T) -> UnsafeRawPointer {
        if type(of: instance) is AnyClass {
            let opaquePointer = Unmanaged.passUnretained(instance as AnyObject).toOpaque()
            return UnsafeRawPointer(opaquePointer)
        } else {
            return withUnsafePointer(to: &instance) { pointer in
                return UnsafeRawPointer(pointer)
            }
        }
    }
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  Created by zhouzhuo on 07/01/2017.
//
struct _class_rw_t {
    var flags: Int32
    var version: Int32
    var ro: UInt
    // other fields we don't care
    // reference: include/swift/Remote/MetadataReader.h/readObjcRODataPtr
    func class_ro_t() -> UnsafePointer<_class_ro_t>? {
        var addr: UInt = self.ro
        if (self.ro & UInt(1)) != 0 {
            if let ptr = UnsafePointer<UInt>(bitPattern: self.ro ^ 1) {
                addr = ptr.pointee
            }
        }
        return UnsafePointer<_class_ro_t>(bitPattern: addr)
    }
}
struct _class_ro_t {
    var flags: Int32
    var instanceStart: Int32
    var instanceSize: Int32
    // other fields we don't care
}
// MARK: MetadataType
protocol MetadataType : PointerType {
    static var kind: Metadata.Kind? { get }
}
extension MetadataType {
    var kind: Metadata.Kind {
        return Metadata.Kind(flag: UnsafePointer<Int>(pointer).pointee)
    }
    init?(anyType: Any.Type) {
        self.init(pointer: unsafeBitCast(anyType, to: UnsafePointer<Int>.self))
        if let kind = type(of: self).kind, kind != self.kind {
            return nil
        }
    }
}
// MARK: Metadata
struct Metadata : MetadataType {
    var pointer: UnsafePointer<Int>
    init(type: Any.Type) {
        self.init(pointer: unsafeBitCast(type, to: UnsafePointer<Int>.self))
    }
}
struct _Metadata {}
var is64BitPlatform: Bool {
    return MemoryLayout<Int>.size == MemoryLayout<Int64>.size
}
// MARK: Metadata + Kind
// include/swift/ABI/MetadataKind.def
let MetadataKindIsNonHeap = 0x200
let MetadataKindIsRuntimePrivate = 0x100
let MetadataKindIsNonType = 0x400
extension Metadata {
    static let kind: Kind? = nil
    enum Kind {
        case `struct`
        case `enum`
        case optional
        case opaque
        case foreignClass
        case tuple
        case function
        case existential
        case metatype
        case objCClassWrapper
        case existentialMetatype
        case heapLocalVariable
        case heapGenericLocalVariable
        case errorObject
        case `class` // The kind only valid for non-class metadata
        init(flag: Int) {
            switch flag {
            case (0 | MetadataKindIsNonHeap): self = .struct
            case (1 | MetadataKindIsNonHeap): self = .enum
            case (2 | MetadataKindIsNonHeap): self = .optional
            case (3 | MetadataKindIsNonHeap): self = .foreignClass
            case (0 | MetadataKindIsRuntimePrivate | MetadataKindIsNonHeap): self = .opaque
            case (1 | MetadataKindIsRuntimePrivate | MetadataKindIsNonHeap): self = .tuple
            case (2 | MetadataKindIsRuntimePrivate | MetadataKindIsNonHeap): self = .function
            case (3 | MetadataKindIsRuntimePrivate | MetadataKindIsNonHeap): self = .existential
            case (4 | MetadataKindIsRuntimePrivate | MetadataKindIsNonHeap): self = .metatype
            case (5 | MetadataKindIsRuntimePrivate | MetadataKindIsNonHeap): self = .objCClassWrapper
            case (6 | MetadataKindIsRuntimePrivate | MetadataKindIsNonHeap): self = .existentialMetatype
            case (0 | MetadataKindIsNonType): self = .heapLocalVariable
            case (0 | MetadataKindIsNonType | MetadataKindIsRuntimePrivate): self = .heapGenericLocalVariable
            case (1 | MetadataKindIsNonType | MetadataKindIsRuntimePrivate): self = .errorObject
            default: self = .class
            }
        }
    }
}
// MARK: Metadata + Class
extension Metadata {
    struct Class : ContextDescriptorType {
        static let kind: Kind? = .class
        var pointer: UnsafePointer<_Metadata._Class>
        var isSwiftClass: Bool {
            get {
                // see include/swift/Runtime/Config.h macro SWIFT_CLASS_IS_SWIFT_MASK
                // it can be 1 or 2 depending on environment
                let lowbit = self.pointer.pointee.rodataPointer & 3
                return lowbit != 0
            }
        }
        var contextDescriptorOffsetLocation: Int {
            return is64BitPlatform ? 8 : 11
        }
        var superclass: Class? {
            guard let superclass = pointer.pointee.superclass else {
                return nil
            }
            // If the superclass doesn't conform to handyjson/handyjsonenum protocol,
            // we should ignore the properties inside
            if !(superclass is HandyJSON.Type) && !(superclass is HandyJSONEnum.Type) {
                return nil
            }
            // ignore objc-runtime layer
            guard let metaclass = Metadata.Class(anyType: superclass) else {
                return nil
            }
            return metaclass
        }
        var vTableSize: Int {
            // memory size after ivar destroyer
            return Int(pointer.pointee.classObjectSize - pointer.pointee.classObjectAddressPoint) - (contextDescriptorOffsetLocation + 2) * MemoryLayout<Int>.size
        }
        // reference: https://github.com/apple/swift/blob/master/docs/ABI/TypeMetadata.rst#generic-argument-vector
        var genericArgumentVector: UnsafeRawPointer? {
            let pointer = UnsafePointer<Int>(self.pointer)
            var superVTableSize = 0
            if let _superclass = self.superclass {
                superVTableSize = _superclass.vTableSize / MemoryLayout<Int>.size
            }
            let base = pointer.advanced(by: contextDescriptorOffsetLocation + 2 + superVTableSize)
            if base.pointee == 0 {
                return nil
            }
            return UnsafeRawPointer(base)
        }
        func _propertyDescriptionsAndStartPoint() -> ([Property.Description], Int32?)? {
            let instanceStart = pointer.pointee.class_rw_t()?.pointee.class_ro_t()?.pointee.instanceStart
            var result: [Property.Description] = []
            if let fieldOffsets = self.fieldOffsets, let fieldRecords = self.reflectionFieldDescriptor?.fieldRecords {
                class NameAndType {
                    var name: String?
                    var type: Any.Type?
                }
                
                for i in 0..<self.numberOfFields {
                    let name = fieldRecords[i].fieldName
                    if let cMangledTypeName = fieldRecords[i].mangledTypeName,
                        let fieldType = _getTypeByMangledNameInContext(cMangledTypeName, getMangledTypeNameSize(cMangledTypeName), genericContext: self.contextDescriptorPointer, genericArguments: self.genericArgumentVector) {
                        result.append(Property.Description(key: name, type: fieldType, offset: fieldOffsets[i]))
                    }
                }
            }
            if let superclass = superclass,
                String(describing: unsafeBitCast(superclass.pointer, to: Any.Type.self)) != "SwiftObject",  // ignore the root swift object
                let superclassProperties = superclass._propertyDescriptionsAndStartPoint(),
                superclassProperties.0.count > 0 {
                return (superclassProperties.0 + result, superclassProperties.1)
            }
            return (result, instanceStart)
        }
        func propertyDescriptions() -> [Property.Description]? {
            let propsAndStp = _propertyDescriptionsAndStartPoint()
            if let firstInstanceStart = propsAndStp?.1,
                let firstProperty = propsAndStp?.0.first?.offset {
                    return propsAndStp?.0.map({ (propertyDesc) -> Property.Description in
                        let offset = propertyDesc.offset - firstProperty + Int(firstInstanceStart)
                        return Property.Description(key: propertyDesc.key, type: propertyDesc.type, offset: offset)
                    })
            } else {
                return propsAndStp?.0
            }
        }
    }
}
extension _Metadata {
    struct _Class {
        var kind: Int
        var superclass: Any.Type?
        var reserveword1: Int
        var reserveword2: Int
        var rodataPointer: UInt
        var classFlags: UInt32
        var instanceAddressPoint: UInt32
        var instanceSize: UInt32
        var instanceAlignmentMask: UInt16
        var runtimeReservedField: UInt16
        var classObjectSize: UInt32
        var classObjectAddressPoint: UInt32
        var nominalTypeDescriptor: Int
        var ivarDestroyer: Int
        // other fields we don't care
        func class_rw_t() -> UnsafePointer<_class_rw_t>? {
            if MemoryLayout<Int>.size == MemoryLayout<Int64>.size {
                let fast_data_mask: UInt64 = 0x00007ffffffffff8
                let databits_t: UInt64 = UInt64(self.rodataPointer)
                return UnsafePointer<_class_rw_t>(bitPattern: UInt(databits_t & fast_data_mask))
            } else {
                return UnsafePointer<_class_rw_t>(bitPattern: self.rodataPointer & 0xfffffffc)
            }
        }
    }
}
// MARK: Metadata + Struct
extension Metadata {
    struct Struct : ContextDescriptorType {
        static let kind: Kind? = .struct
        var pointer: UnsafePointer<_Metadata._Struct>
        var contextDescriptorOffsetLocation: Int {
            return 1
        }
        var genericArgumentOffsetLocation: Int {
            return 2
        }
        var genericArgumentVector: UnsafeRawPointer? {
            let pointer = UnsafePointer<Int>(self.pointer)
            let base = pointer.advanced(by: genericArgumentOffsetLocation)
            if base.pointee == 0 {
                return nil
            }
            return UnsafeRawPointer(base)
        }
        func propertyDescriptions() -> [Property.Description]? {
            guard let fieldOffsets = self.fieldOffsets, let fieldRecords = self.reflectionFieldDescriptor?.fieldRecords else {
                return []
            }
            var result: [Property.Description] = []
            class NameAndType {
                var name: String?
                var type: Any.Type?
            }
            for i in 0..<self.numberOfFields {
                let name = fieldRecords[i].fieldName
                if let cMangledTypeName = fieldRecords[i].mangledTypeName,
                    let fieldType = _getTypeByMangledNameInContext(cMangledTypeName, getMangledTypeNameSize(cMangledTypeName), genericContext: self.contextDescriptorPointer, genericArguments: self.genericArgumentVector) {
                    result.append(Property.Description(key: name, type: fieldType, offset: fieldOffsets[i]))
                }
            }
            return result
        }
    }
}
extension _Metadata {
    struct _Struct {
        var kind: Int
        var contextDescriptorOffset: Int
        var parent: Metadata?
    }
}
// MARK: Metadata + ObjcClassWrapper
extension Metadata {
    struct ObjcClassWrapper: ContextDescriptorType {
        static let kind: Kind? = .objCClassWrapper
        var pointer: UnsafePointer<_Metadata._ObjcClassWrapper>
        var contextDescriptorOffsetLocation: Int {
            return is64BitPlatform ? 8 : 11
        }
        var targetType: Any.Type? {
            get {
                return pointer.pointee.targetType
            }
        }
    }
}
extension _Metadata {
    struct _ObjcClassWrapper {
        var kind: Int
        var targetType: Any.Type?
    }
}
//
//  CustomDateFormatTransform.swift
//  ObjectMapper
//
//  Created by Dan McCracken on 3/8/15.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
open class CustomDateFormatTransform: DateFormatterTransform {
    public init(formatString: String) {
		let formatter = DateFormatter()
		formatter.locale = Locale(identifier: "en_US_POSIX")
		formatter.dateFormat = formatString
		super.init(dateFormatter: formatter)
    }
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  Created by zhouzhuo on 07/01/2017.
//
/// An instance property
struct Property {
    let key: String
    let value: Any
    /// An instance property description
    struct Description {
        public let key: String
        public let type: Any.Type
        public let offset: Int
        public func write(_ value: Any, to storage: UnsafeMutableRawPointer) {
            return extensions(of: type).write(value, to: storage.advanced(by: offset))
        }
    }
}
/// Retrieve properties for `instance`
func getProperties(forInstance instance: Any) -> [Property]? {
    if let props = getProperties(forType: type(of: instance)) {
        var copy = extensions(of: instance)
        let storage = copy.storage()
        return props.map {
            nextProperty(description: $0, storage: storage)
        }
    }
    return nil
}
private func nextProperty(description: Property.Description, storage: UnsafeRawPointer) -> Property {
    return Property(
        key: description.key,
        value: extensions(of: description.type).value(from: storage.advanced(by: description.offset))
    )
}
/// Retrieve property descriptions for `type`
func getProperties(forType type: Any.Type) -> [Property.Description]? {
    if let structDescriptor = Metadata.Struct(anyType: type) {
        return structDescriptor.propertyDescriptions()
    } else if let classDescriptor = Metadata.Class(anyType: type) {
        return classDescriptor.propertyDescriptions()
    } else if let objcClassDescriptor = Metadata.ObjcClassWrapper(anyType: type),
        let targetType = objcClassDescriptor.targetType {
        return getProperties(forType: targetType)
    }
    return nil
}
//
//  HexColorTransform.swift
//  ObjectMapper
//
//  Created by Vitaliy Kuzmenko on 10/10/16.
//  Copyright © 2016 hearst. All rights reserved.
//
#if os(iOS) || os(tvOS) || os(watchOS)
import UIKit
#else
import Cocoa
#endif
open class HexColorTransform: TransformType {
	#if os(iOS) || os(tvOS) || os(watchOS)
	public typealias Object = UIColor
	#else
	public typealias Object = NSColor
	#endif
	public typealias JSON = String
	var prefix: Bool = false
	var alpha: Bool = false
	public init(prefixToJSON: Bool = false, alphaToJSON: Bool = false) {
		alpha = alphaToJSON
		prefix = prefixToJSON
	}
	open func transformFromJSON(_ value: Any?) -> Object? {
		if let rgba = value as? String {
			if rgba.hasPrefix("#") {
				let index = rgba.index(rgba.startIndex, offsetBy: 1)
				let hex = String(rgba[index...])
				return getColor(hex: hex)
			} else {
				return getColor(hex: rgba)
			}
		}
		return nil
	}
	open func transformToJSON(_ value: Object?) -> JSON? {
		if let value = value {
			return hexString(color: value)
		}
		return nil
	}
	fileprivate func hexString(color: Object) -> String {
		let comps = color.cgColor.components!
		let r = Int(comps[0] * 255)
		let g = Int(comps[1] * 255)
		let b = Int(comps[2] * 255)
		let a = Int(comps[3] * 255)
		var hexString: String = ""
		if prefix {
			hexString = "#"
		}
		hexString += String(format: "%02X%02X%02X", r, g, b)
		if alpha {
			hexString += String(format: "%02X", a)
		}
		return hexString
	}
	fileprivate func getColor(hex: String) -> Object? {
		var red: CGFloat   = 0.0
		var green: CGFloat = 0.0
		var blue: CGFloat  = 0.0
		var alpha: CGFloat = 1.0
		let scanner = Scanner(string: hex)
		var hexValue: CUnsignedLongLong = 0
		if scanner.scanHexInt64(&hexValue) {
			switch (hex.count) {
			case 3:
				red   = CGFloat((hexValue & 0xF00) >> 8)       / 15.0
				green = CGFloat((hexValue & 0x0F0) >> 4)       / 15.0
				blue  = CGFloat(hexValue & 0x00F)              / 15.0
			case 4:
				red   = CGFloat((hexValue & 0xF000) >> 12)     / 15.0
				green = CGFloat((hexValue & 0x0F00) >> 8)      / 15.0
				blue  = CGFloat((hexValue & 0x00F0) >> 4)      / 15.0
				alpha = CGFloat(hexValue & 0x000F)             / 15.0
			case 6:
				red   = CGFloat((hexValue & 0xFF0000) >> 16)   / 255.0
				green = CGFloat((hexValue & 0x00FF00) >> 8)    / 255.0
				blue  = CGFloat(hexValue & 0x0000FF)           / 255.0
			case 8:
				red   = CGFloat((hexValue & 0xFF000000) >> 24) / 255.0
				green = CGFloat((hexValue & 0x00FF0000) >> 16) / 255.0
				blue  = CGFloat((hexValue & 0x0000FF00) >> 8)  / 255.0
				alpha = CGFloat(hexValue & 0x000000FF)         / 255.0
			default:
				// Invalid RGB string, number of characters after '#' should be either 3, 4, 6 or 8
				return nil
			}
		} else {
			// "Scan hex error
			return nil
		}
		#if os(iOS) || os(tvOS) || os(watchOS)
			return UIColor(red: red, green: green, blue: blue, alpha: alpha)
		#else
			return NSColor(calibratedRed: red, green: green, blue: blue, alpha: alpha)
		#endif
	}
}
//
//  Transformable.swift
//  HandyJSON
//
//  Created by zhouzhuo on 15/07/2017.
//  Copyright © 2017 aliyun. All rights reserved.
//
import Foundation
public protocol _Transformable: _Measurable {}
extension _Transformable {
    static func transform(from object: Any) -> Self? {
        if let typedObject = object as? Self {
            return typedObject
        }
        switch self {
        case let type as _ExtendCustomBasicType.Type:
            return type._transform(from: object) as? Self
        case let type as _BuiltInBridgeType.Type:
            return type._transform(from: object) as? Self
        case let type as _BuiltInBasicType.Type:
            return type._transform(from: object) as? Self
        case let type as _RawEnumProtocol.Type:
            return type._transform(from: object) as? Self
        case let type as _ExtendCustomModelType.Type:
            return type._transform(from: object) as? Self
        default:
            return nil
        }
    }
    func plainValue() -> Any? {
        switch self {
        case let rawValue as _ExtendCustomBasicType:
            return rawValue._plainValue()
        case let rawValue as _BuiltInBridgeType:
            return rawValue._plainValue()
        case let rawValue as _BuiltInBasicType:
            return rawValue._plainValue()
        case let rawValue as _RawEnumProtocol:
            return rawValue._plainValue()
        case let rawValue as _ExtendCustomModelType:
            return rawValue._plainValue()
        default:
            return nil
        }
    }
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  Created by zhouzhuo on 07/01/2017.
//
protocol PointerType : Equatable {
    associatedtype Pointee
    var pointer: UnsafePointer<Pointee> { get set }
}
extension PointerType {
    init<T>(pointer: UnsafePointer<T>) {
        func cast<T, U>(_ value: T) -> U {
            return unsafeBitCast(value, to: U.self)
        }
        self = cast(UnsafePointer<Pointee>(pointer))
    }
}
func == <T: PointerType>(lhs: T, rhs: T) -> Bool {
    return lhs.pointer == rhs.pointer
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  Logger.swift
//  HandyJSON
//
//  Created by zhouzhuo on 08/01/2017.
//
struct InternalLogger {
    static func logError(_ items: Any..., separator: String = " ", terminator: String = "\n") {
        if HandyJSONConfiguration.debugMode.rawValue <= DebugMode.error.rawValue {
            print(items, separator: separator, terminator: terminator)
        }
    }
    static func logDebug(_ items: Any..., separator: String = " ", terminator: String = "\n") {
        if HandyJSONConfiguration.debugMode.rawValue <= DebugMode.debug.rawValue {
            print(items, separator: separator, terminator: terminator)
        }
    }
    static func logVerbose(_ items: Any..., separator: String = " ", terminator: String = "\n") {
        if HandyJSONConfiguration.debugMode.rawValue <= DebugMode.verbose.rawValue {
            print(items, separator: separator, terminator: terminator)
        }
    }
}
//
//  MangledName.swift
//  HandyJSON
//
//  Created by chantu on 2019/2/2.
//  Copyright © 2019 aliyun. All rights reserved.
//
import Foundation
 // mangled name might contain 0 but it is not the end, do not just use strlen
func getMangledTypeNameSize(_ mangledName: UnsafePointer<UInt8>) -> Int {
    // TODO: should find the actually size 
    return 256
}
//
//  ExtendCustomType.swift
//  HandyJSON
//
//  Created by zhouzhuo on 16/07/2017.
//  Copyright © 2017 aliyun. All rights reserved.
//
import Foundation
public protocol _ExtendCustomModelType: _Transformable {
    init()
    mutating func willStartMapping()
    mutating func mapping(mapper: HelpingMapper)
    mutating func didFinishMapping()
}
extension _ExtendCustomModelType {
    public mutating func willStartMapping() {}
    public mutating func mapping(mapper: HelpingMapper) {}
    public mutating func didFinishMapping() {}
}
fileprivate func convertKeyIfNeeded(dict: [String: Any]) -> [String: Any] {
    if HandyJSONConfiguration.deserializeOptions.contains(.caseInsensitive) {
        var newDict = [String: Any]()
        dict.forEach({ (kvPair) in
            let (key, value) = kvPair
            newDict[key.lowercased()] = value
        })
        return newDict
    }
    return dict
}
fileprivate func getRawValueFrom(dict: [String: Any], property: PropertyInfo, mapper: HelpingMapper) -> Any? {
    let address = Int(bitPattern: property.address)
    if let mappingHandler = mapper.getMappingHandler(key: address) {
        if let mappingPaths = mappingHandler.mappingPaths, mappingPaths.count > 0 {
            for mappingPath in mappingPaths {
                if let _value = dict.findValueBy(path: mappingPath) {
                    return _value
                }
            }
            return nil
        }
    }
    if HandyJSONConfiguration.deserializeOptions.contains(.caseInsensitive) {
        return dict[property.key.lowercased()]
    }
    return dict[property.key]
}
fileprivate func convertValue(rawValue: Any, property: PropertyInfo, mapper: HelpingMapper) -> Any? {
    if rawValue is NSNull { return nil }
    if let mappingHandler = mapper.getMappingHandler(key: Int(bitPattern: property.address)), let transformer = mappingHandler.assignmentClosure {
        return transformer(rawValue)
    }
    if let transformableType = property.type as? _Transformable.Type {
        return transformableType.transform(from: rawValue)
    } else {
        return extensions(of: property.type).takeValue(from: rawValue)
    }
}
fileprivate func assignProperty(convertedValue: Any, instance: _ExtendCustomModelType, property: PropertyInfo) {
    if property.bridged {
        (instance as! NSObject).setValue(convertedValue, forKey: property.key)
    } else {
        extensions(of: property.type).write(convertedValue, to: property.address)
    }
}
fileprivate func readAllChildrenFrom(mirror: Mirror) -> [(String, Any)] {
    var children = [(label: String?, value: Any)]()
    let mirrorChildrenCollection = AnyRandomAccessCollection(mirror.children)!
    children += mirrorChildrenCollection
    var currentMirror = mirror
    while let superclassChildren = currentMirror.superclassMirror?.children {
        let randomCollection = AnyRandomAccessCollection(superclassChildren)!
        children += randomCollection
        currentMirror = currentMirror.superclassMirror!
    }
    var result = [(String, Any)]()
    children.forEach { (child) in
        if let _label = child.label {
            result.append((_label, child.value))
        }
    }
    return result
}
fileprivate func merge(children: [(String, Any)], propertyInfos: [PropertyInfo]) -> [String: (Any, PropertyInfo?)] {
    var infoDict = [String: PropertyInfo]()
    propertyInfos.forEach { (info) in
        infoDict[info.key] = info
    }
    var result = [String: (Any, PropertyInfo?)]()
    children.forEach { (child) in
        result[child.0] = (child.1, infoDict[child.0])
    }
    return result
}
// this's a workaround before https://bugs.swift.org/browse/SR-5223 fixed
extension NSObject {
    static func createInstance() -> NSObject {
        return self.init()
    }
}
extension _ExtendCustomModelType {
    static func _transform(from object: Any) -> Self? {
        if let dict = object as? [String: Any] {
            // nested object, transform recursively
            return self._transform(dict: dict) as? Self
        }
        return nil
    }
    static func _transform(dict: [String: Any]) -> _ExtendCustomModelType? {
        var instance: Self
        if let _nsType = Self.self as? NSObject.Type {
            instance = _nsType.createInstance() as! Self
        } else {
            instance = Self.init()
        }
        instance.willStartMapping()
        _transform(dict: dict, to: &instance)
        instance.didFinishMapping()
        return instance
    }
    static func _transform(dict: [String: Any], to instance: inout Self) {
        guard let properties = getProperties(forType: Self.self) else {
            InternalLogger.logDebug("Failed when try to get properties from type: \(type(of: Self.self))")
            return
        }
        // do user-specified mapping first
        let mapper = HelpingMapper()
        instance.mapping(mapper: mapper)
        // get head addr
        let rawPointer = instance.headPointer()
        InternalLogger.logVerbose("instance start at: ", Int(bitPattern: rawPointer))
        // process dictionary
        let _dict = convertKeyIfNeeded(dict: dict)
        let instanceIsNsObject = instance.isNSObjectType()
        let bridgedPropertyList = instance.getBridgedPropertyList()
        for property in properties {
            let isBridgedProperty = instanceIsNsObject && bridgedPropertyList.contains(property.key)
            let propAddr = rawPointer.advanced(by: property.offset)
            InternalLogger.logVerbose(property.key, "address at: ", Int(bitPattern: propAddr))
            if mapper.propertyExcluded(key: Int(bitPattern: propAddr)) {
                InternalLogger.logDebug("Exclude property: \(property.key)")
                continue
            }
            let propertyDetail = PropertyInfo(key: property.key, type: property.type, address: propAddr, bridged: isBridgedProperty)
            InternalLogger.logVerbose("field: ", property.key, "  offset: ", property.offset, "  isBridgeProperty: ", isBridgedProperty)
            if let rawValue = getRawValueFrom(dict: _dict, property: propertyDetail, mapper: mapper) {
                if let convertedValue = convertValue(rawValue: rawValue, property: propertyDetail, mapper: mapper) {
                    assignProperty(convertedValue: convertedValue, instance: instance, property: propertyDetail)
                    continue
                }
            }
            InternalLogger.logDebug("Property: \(property.key) hasn't been written in")
        }
    }
}
extension _ExtendCustomModelType {
    func _plainValue() -> Any? {
        return Self._serializeAny(object: self)
    }
    static func _serializeAny(object: _Transformable) -> Any? {
        let mirror = Mirror(reflecting: object)
        guard let displayStyle = mirror.displayStyle else {
            return object.plainValue()
        }
        // after filtered by protocols above, now we expect the type is pure struct/class
        switch displayStyle {
        case .class, .struct:
            let mapper = HelpingMapper()
            // do user-specified mapping first
            if !(object is _ExtendCustomModelType) {
                InternalLogger.logDebug("This model of type: \(type(of: object)) is not mappable but is class/struct type")
                return object
            }
            let children = readAllChildrenFrom(mirror: mirror)
            guard let properties = getProperties(forType: type(of: object)) else {
                InternalLogger.logError("Can not get properties info for type: \(type(of: object))")
                return nil
            }
            var mutableObject = object as! _ExtendCustomModelType
            let instanceIsNsObject = mutableObject.isNSObjectType()
            let head = mutableObject.headPointer()
            let bridgedProperty = mutableObject.getBridgedPropertyList()
            let propertyInfos = properties.map({ (desc) -> PropertyInfo in
                return PropertyInfo(key: desc.key, type: desc.type, address: head.advanced(by: desc.offset),
                                        bridged: instanceIsNsObject && bridgedProperty.contains(desc.key))
            })
            mutableObject.mapping(mapper: mapper)
            let requiredInfo = merge(children: children, propertyInfos: propertyInfos)
            return _serializeModelObject(instance: mutableObject, properties: requiredInfo, mapper: mapper) as Any
        default:
            return object.plainValue()
        }
    }
    static func _serializeModelObject(instance: _ExtendCustomModelType, properties: [String: (Any, PropertyInfo?)], mapper: HelpingMapper) -> [String: Any] {
        var dict = [String: Any]()
        for (key, property) in properties {
            var realKey = key
            var realValue = property.0
            if let info = property.1 {
                if info.bridged, let _value = (instance as! NSObject).value(forKey: key) {
                    realValue = _value
                }
                if mapper.propertyExcluded(key: Int(bitPattern: info.address)) {
                    continue
                }
                if let mappingHandler = mapper.getMappingHandler(key: Int(bitPattern: info.address)) {
                    // if specific key is set, replace the label
                    if let mappingPaths = mappingHandler.mappingPaths, mappingPaths.count > 0 {
                        // take the first path, last segment if more than one
                        realKey = mappingPaths[0].segments.last!
                    }
                    if let transformer = mappingHandler.takeValueClosure {
                        if let _transformedValue = transformer(realValue) {
                            dict[realKey] = _transformedValue
                        }
                        continue
                    }
                }
            }
            if let typedValue = realValue as? _Transformable {
                if let result = self._serializeAny(object: typedValue) {
                    dict[realKey] = result
                    continue
                }
            }
            InternalLogger.logDebug("The value for key: \(key) is not transformable type")
        }
        return dict
    }
}
//
//  Measuable.swift
//  HandyJSON
//
//  Created by zhouzhuo on 15/07/2017.
//  Copyright © 2017 aliyun. All rights reserved.
//
import Foundation
typealias Byte = Int8
public protocol _Measurable {}
extension _Measurable {
    // locate the head of a struct type object in memory
    mutating func headPointerOfStruct() -> UnsafeMutablePointer<Byte> {
        return withUnsafeMutablePointer(to: &self) {
            return UnsafeMutableRawPointer($0).bindMemory(to: Byte.self, capacity: MemoryLayout<Self>.stride)
        }
    }
    // locating the head of a class type object in memory
    mutating func headPointerOfClass() -> UnsafeMutablePointer<Byte> {
        let opaquePointer = Unmanaged.passUnretained(self as AnyObject).toOpaque()
        let mutableTypedPointer = opaquePointer.bindMemory(to: Byte.self, capacity: MemoryLayout<Self>.stride)
        return UnsafeMutablePointer<Byte>(mutableTypedPointer)
    }
    // locating the head of an object
    mutating func headPointer() -> UnsafeMutablePointer<Byte> {
        if Self.self is AnyClass {
            return self.headPointerOfClass()
        } else {
            return self.headPointerOfStruct()
        }
    }
    func isNSObjectType() -> Bool {
        return (type(of: self) as? NSObject.Type) != nil
    }
    func getBridgedPropertyList() -> Set<String> {
        if let anyClass = type(of: self) as? AnyClass {
            return _getBridgedPropertyList(anyClass: anyClass)
        }
        return []
    }
    func _getBridgedPropertyList(anyClass: AnyClass) -> Set<String> {
        if !(anyClass is HandyJSON.Type) {
            return []
        }
        var propertyList = Set<String>()
        if let superClass = class_getSuperclass(anyClass), superClass != NSObject.self {
            propertyList = propertyList.union(_getBridgedPropertyList(anyClass: superClass))
        }
        let count = UnsafeMutablePointer<UInt32>.allocate(capacity: 1)
        if let props = class_copyPropertyList(anyClass, count) {
            for i in 0 ..< count.pointee {
                let name = String(cString: property_getName(props.advanced(by: Int(i)).pointee))
                propertyList.insert(name)
            }
            free(props)
        }
        #if swift(>=4.1)
        count.deallocate()
        #else
        count.deallocate(capacity: 1)
        #endif
        return propertyList
    }
    // memory size occupy by self object
    static func size() -> Int {
        return MemoryLayout<Self>.size
    }
    // align
    static func align() -> Int {
        return MemoryLayout<Self>.alignment
    }
    // Returns the offset to the next integer that is greater than
    // or equal to Value and is a multiple of Align. Align must be
    // non-zero.
    static func offsetToAlignment(value: Int, align: Int) -> Int {
        let m = value % align
        return m == 0 ? 0 : (align - m)
    }
}
//
//  ISO8601DateTransform.swift
//  ObjectMapper
//
//  Created by Jean-Pierre Mouilleseaux on 21 Nov 2014.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
open class ISO8601DateTransform: DateFormatterTransform {
	public init() {
		let formatter = DateFormatter()
		formatter.locale = Locale(identifier: "en_US_POSIX")
		formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZZZZZ"
		super.init(dateFormatter: formatter)
	}
}
//
//  Export.swift
//  HandyJSON
//
//  Created by zhouzhuo on 16/07/2017.
//  Copyright © 2017 aliyun. All rights reserved.
//
import Foundation
public protocol HandyJSONCustomTransformable: _ExtendCustomBasicType {}
public protocol HandyJSON: _ExtendCustomModelType {}
public protocol HandyJSONEnum: _RawEnumProtocol {}
//
//  URLTransform.swift
//  ObjectMapper
//
//  Created by Tristan Himmelman on 2014-10-27.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
open class URLTransform: TransformType {
	public typealias Object = URL
	public typealias JSON = String
	private let shouldEncodeURLString: Bool
	/**
	Initializes the URLTransform with an option to encode URL strings before converting them to an NSURL
	- parameter shouldEncodeUrlString: when true (the default) the string is encoded before passing
	to `NSURL(string:)`
	- returns: an initialized transformer
	*/
	public init(shouldEncodeURLString: Bool = true) {
		self.shouldEncodeURLString = shouldEncodeURLString
	}
	open func transformFromJSON(_ value: Any?) -> URL? {
		guard let URLString = value as? String else { return nil }
		if !shouldEncodeURLString {
			return URL(string: URLString)
		}
		guard let escapedURLString = URLString.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) else {
			return nil
		}
		return URL(string: escapedURLString)
	}
	open func transformToJSON(_ value: URL?) -> String? {
		if let URL = value {
			return URL.absoluteString
		}
		return nil
	}
}
//
//  TransformOf.swift
//  ObjectMapper
//
//  Created by Tristan Himmelman on 8/22/16.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
open class NSDecimalNumberTransform: TransformType {
    public typealias Object = NSDecimalNumber
    public typealias JSON = String
    public init() {}
    open func transformFromJSON(_ value: Any?) -> NSDecimalNumber? {
        if let string = value as? String {
            return NSDecimalNumber(string: string)
        }
        if let double = value as? Double {
            return NSDecimalNumber(value: double)
        }
        return nil
    }
    open func transformToJSON(_ value: NSDecimalNumber?) -> String? {
        guard let value = value else { return nil }
        return value.description
    }
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  Created by zhouzhuo on 07/01/2017.
//
protocol ContextDescriptorType : MetadataType {
    var contextDescriptorOffsetLocation: Int { get }
}
extension ContextDescriptorType {
    var contextDescriptor: ContextDescriptorProtocol? {
        let pointer = UnsafePointer<Int>(self.pointer)
        let base = pointer.advanced(by: contextDescriptorOffsetLocation)
        if base.pointee == 0 {
            // swift class created dynamically in objc-runtime didn't have valid contextDescriptor
            return nil
        }
        if self.kind == .class {
            return ContextDescriptor<_ClassContextDescriptor>(pointer: relativePointer(base: base, offset: base.pointee - Int(bitPattern: base)))
        } else {
            return ContextDescriptor<_StructContextDescriptor>(pointer: relativePointer(base: base, offset: base.pointee - Int(bitPattern: base)))
        }
    }
    var contextDescriptorPointer: UnsafeRawPointer? {
        let pointer = UnsafePointer<Int>(self.pointer)
        let base = pointer.advanced(by: contextDescriptorOffsetLocation)
        if base.pointee == 0 {
            return nil
        }
        return UnsafeRawPointer(bitPattern: base.pointee)
    }
//    var genericArgumentVector: UnsafeRawPointer? {
//        let pointer = UnsafePointer<Int>(self.pointer)
//        let base = pointer.advanced(by: 19)
//        if base.pointee == 0 {
//            return nil
//        }
//        return UnsafeRawPointer(base)
//    }
    var mangledName: String {
        let pointer = UnsafePointer<Int>(self.pointer)
        let base = pointer.advanced(by: contextDescriptorOffsetLocation)
        let mangledNameAddress = base.pointee + 2 * 4 // 2 properties in front
        if let offset = contextDescriptor?.mangledName,
            let cString = UnsafePointer<UInt8>(bitPattern: mangledNameAddress + offset) {
            return String(cString: cString)
        }
        return ""
    }
    var numberOfFields: Int {
        return contextDescriptor?.numberOfFields ?? 0
    }
    var fieldOffsets: [Int]? {
        guard let contextDescriptor = self.contextDescriptor else {
            return nil
        }
        let vectorOffset = contextDescriptor.fieldOffsetVector
        guard vectorOffset != 0 else {
            return nil
        }
        if self.kind == .class {
            return (0..<contextDescriptor.numberOfFields).map {
                return UnsafePointer<Int>(pointer)[vectorOffset + $0]
            }
        } else {
            return (0..<contextDescriptor.numberOfFields).map {
                return Int(UnsafePointer<Int32>(pointer)[vectorOffset * (is64BitPlatform ? 2 : 1) + $0])
            }
        }
    }
    var reflectionFieldDescriptor: FieldDescriptor? {
        guard let contextDescriptor = self.contextDescriptor else {
            return nil
        }
        let pointer = UnsafePointer<Int>(self.pointer)
        let base = pointer.advanced(by: contextDescriptorOffsetLocation)
        let offset = contextDescriptor.reflectionFieldDescriptor
        let address = base.pointee + 4 * 4 // (4 properties in front) * (sizeof Int32)
        guard let fieldDescriptorPtr = UnsafePointer<_FieldDescriptor>(bitPattern: address + offset) else {
            return nil
        }
        return FieldDescriptor(pointer: fieldDescriptorPtr)
    }
}
protocol ContextDescriptorProtocol {
    var mangledName: Int { get }
    var numberOfFields: Int { get }
    var fieldOffsetVector: Int { get }
    var reflectionFieldDescriptor: Int { get }
}
struct ContextDescriptor<T: _ContextDescriptorProtocol>: ContextDescriptorProtocol, PointerType {
    var pointer: UnsafePointer<T>
    var mangledName: Int {
        return Int(pointer.pointee.mangledNameOffset)
    }
    var numberOfFields: Int {
        return Int(pointer.pointee.numberOfFields)
    }
    var fieldOffsetVector: Int {
        return Int(pointer.pointee.fieldOffsetVector)
    }
    var fieldTypesAccessor: Int {
        return Int(pointer.pointee.fieldTypesAccessor)
    }
    var reflectionFieldDescriptor: Int {
        return Int(pointer.pointee.reflectionFieldDescriptor)
    }
}
protocol _ContextDescriptorProtocol {
    var mangledNameOffset: Int32 { get }
    var numberOfFields: Int32 { get }
    var fieldOffsetVector: Int32 { get }
    var fieldTypesAccessor: Int32 { get }
    var reflectionFieldDescriptor: Int32 { get }
}
struct _StructContextDescriptor: _ContextDescriptorProtocol {
    var flags: Int32
    var parent: Int32
    var mangledNameOffset: Int32
    var fieldTypesAccessor: Int32
    var reflectionFieldDescriptor: Int32
    var numberOfFields: Int32
    var fieldOffsetVector: Int32
}
struct _ClassContextDescriptor: _ContextDescriptorProtocol {
    var flags: Int32
    var parent: Int32
    var mangledNameOffset: Int32
    var fieldTypesAccessor: Int32
    var reflectionFieldDescriptor: Int32
    var superClsRef: Int32
    var metadataNegativeSizeInWords: Int32
    var metadataPositiveSizeInWords: Int32
    var numImmediateMembers: Int32
    var numberOfFields: Int32
    var fieldOffsetVector: Int32
}
//
//  EnumTransform.swift
//  ObjectMapper
//
//  Created by Kaan Dedeoglu on 3/20/15.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
open class EnumTransform<T: RawRepresentable>: TransformType {
	public typealias Object = T
	public typealias JSON = T.RawValue
	public init() {}
	open func transformFromJSON(_ value: Any?) -> T? {
		if let raw = value as? T.RawValue {
			return T(rawValue: raw)
		}
		return nil
	}
	open func transformToJSON(_ value: T?) -> T.RawValue? {
		if let obj = value {
			return obj.rawValue
		}
		return nil
	}
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  CBridge.swift
//  HandyJSON
//
//  Created by chantu on 2018/7/15.
//  Copyright © 2018 aliyun. All rights reserved.
//
import Foundation
@_silgen_name("swift_getTypeByMangledNameInContext")
public func _getTypeByMangledNameInContext(
    _ name: UnsafePointer<UInt8>,
    _ nameLength: Int,
    genericContext: UnsafeRawPointer?,
    genericArguments: UnsafeRawPointer?)
    -> Any.Type?
@_silgen_name("swift_getTypeContextDescriptor")
public func _swift_getTypeContextDescriptor(_ metadata: UnsafeRawPointer?) -> UnsafeRawPointer?
//
//  FieldDescriptor.swift
//  HandyJSON
//
//  Created by chantu on 2019/1/31.
//  Copyright © 2019 aliyun. All rights reserved.
//
import Foundation
enum FieldDescriptorKind : UInt16 {
    // Swift nominal types.
    case Struct = 0
    case Class
    case Enum
    // Fixed-size multi-payload enums have a special descriptor format that
    // encodes spare bits.
    //
    // FIXME: Actually implement this. For now, a descriptor with this kind
    // just means we also have a builtin descriptor from which we get the
    // size and alignment.
    case MultiPayloadEnum
    // A Swift opaque protocol. There are no fields, just a record for the
    // type itself.
    case `Protocol`
    // A Swift class-bound protocol.
    case ClassProtocol
    // An Objective-C protocol, which may be imported or defined in Swift.
    case ObjCProtocol
    // An Objective-C class, which may be imported or defined in Swift.
    // In the former case, field type metadata is not emitted, and
    // must be obtained from the Objective-C runtime.
    case ObjCClass
}
struct FieldDescriptor: PointerType {
    var pointer: UnsafePointer<_FieldDescriptor>
    var fieldRecordSize: Int {
        return Int(pointer.pointee.fieldRecordSize)
    }
    var numFields: Int {
        return Int(pointer.pointee.numFields)
    }
    var fieldRecords: [FieldRecord] {
        return (0..<numFields).map({ (i) -> FieldRecord in
            return FieldRecord(pointer: UnsafePointer<_FieldRecord>(pointer + 1) + i)
        })
    }
}
struct _FieldDescriptor {
    var mangledTypeNameOffset: Int32
    var superClassOffset: Int32
    var fieldDescriptorKind: FieldDescriptorKind
    var fieldRecordSize: Int16
    var numFields: Int32
}
struct FieldRecord: PointerType {
    var pointer: UnsafePointer<_FieldRecord>
    var fieldRecordFlags: Int {
        return Int(pointer.pointee.fieldRecordFlags)
    }
    var mangledTypeName: UnsafePointer<UInt8>? {
        let address = Int(bitPattern: pointer) + 1 * 4
        let offset = Int(pointer.pointee.mangledTypeNameOffset)
        let cString = UnsafePointer<UInt8>(bitPattern: address + offset)
        return cString
    }
    var fieldName: String {
        let address = Int(bitPattern: pointer) + 2 * 4
        let offset = Int(pointer.pointee.fieldNameOffset)
        if let cString = UnsafePointer<UInt8>(bitPattern: address + offset) {
            return String(cString: cString)
        }
        return ""
    }
}
struct _FieldRecord {
    var fieldRecordFlags: Int32
    var mangledTypeNameOffset: Int32
    var fieldNameOffset: Int32
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//  Created by zhouzhuo on 7/7/16.
//
import Foundation
protocol _BuiltInBasicType: _Transformable {
    static func _transform(from object: Any) -> Self?
    func _plainValue() -> Any?
}
// Suppport integer type
protocol IntegerPropertyProtocol: FixedWidthInteger, _BuiltInBasicType {
    init?(_ text: String, radix: Int)
    init(_ number: NSNumber)
}
extension IntegerPropertyProtocol {
    static func _transform(from object: Any) -> Self? {
        switch object {
        case let str as String:
            return Self(str, radix: 10)
        case let num as NSNumber:
            return Self(num)
        default:
            return nil
        }
    }
    
    func _plainValue() -> Any? {
        return self
    }
}
extension Int: IntegerPropertyProtocol {}
extension UInt: IntegerPropertyProtocol {}
extension Int8: IntegerPropertyProtocol {}
extension Int16: IntegerPropertyProtocol {}
extension Int32: IntegerPropertyProtocol {}
extension Int64: IntegerPropertyProtocol {}
extension UInt8: IntegerPropertyProtocol {}
extension UInt16: IntegerPropertyProtocol {}
extension UInt32: IntegerPropertyProtocol {}
extension UInt64: IntegerPropertyProtocol {}
extension Bool: _BuiltInBasicType {
    static func _transform(from object: Any) -> Bool? {
        switch object {
        case let str as NSString:
            let lowerCase = str.lowercased
            if ["0", "false"].contains(lowerCase) {
                return false
            }
            if ["1", "true"].contains(lowerCase) {
                return true
            }
            return nil
        case let num as NSNumber:
            return num.boolValue
        default:
            return nil
        }
    }
    func _plainValue() -> Any? {
        return self
    }
}
// Support float type
protocol FloatPropertyProtocol: _BuiltInBasicType, LosslessStringConvertible {
    init(_ number: NSNumber)
}
extension FloatPropertyProtocol {
    static func _transform(from object: Any) -> Self? {
        switch object {
        case let str as String:
            return Self(str)
        case let num as NSNumber:
            return Self(num)
        default:
            return nil
        }
    }
    func _plainValue() -> Any? {
        return self
    }
}
extension Float: FloatPropertyProtocol {}
extension Double: FloatPropertyProtocol {}
fileprivate let formatter: NumberFormatter = {
    let formatter = NumberFormatter()
    formatter.usesGroupingSeparator = false
    formatter.numberStyle = .decimal
    formatter.maximumFractionDigits = 16
    return formatter
}()
extension String: _BuiltInBasicType {
    static func _transform(from object: Any) -> String? {
        switch object {
        case let str as String:
            return str
        case let num as NSNumber:
            // Boolean Type Inside
            if NSStringFromClass(type(of: num)) == "__NSCFBoolean" {
                if num.boolValue {
                    return "true"
                } else {
                    return "false"
                }
            }
            return formatter.string(from: num)
        case _ as NSNull:
            return nil
        default:
            return "\(object)"
        }
    }
    func _plainValue() -> Any? {
        return self
    }
}
// MARK: Optional Support
extension Optional: _BuiltInBasicType {
    static func _transform(from object: Any) -> Optional? {
        if let value = (Wrapped.self as? _Transformable.Type)?.transform(from: object) as? Wrapped {
            return Optional(value)
        } else if let value = object as? Wrapped {
            return Optional(value)
        }
        return nil
    }
    func _getWrappedValue() -> Any? {
        return self.map( { (wrapped) -> Any in
            return wrapped as Any
        })
    }
    func _plainValue() -> Any? {
        if let value = _getWrappedValue() {
            if let transformable = value as? _Transformable {
                return transformable.plainValue()
            } else {
                return value
            }
        }
        return nil
    }
}
// MARK: Collection Support : Array & Set
extension Collection {
    static func _collectionTransform(from object: Any) -> [Iterator.Element]? {
        guard let arr = object as? [Any] else {
            InternalLogger.logDebug("Expect object to be an array but it's not")
            return nil
        }
        typealias Element = Iterator.Element
        var result: [Element] = [Element]()
        arr.forEach { (each) in
            if let element = (Element.self as? _Transformable.Type)?.transform(from: each) as? Element {
                result.append(element)
            } else if let element = each as? Element {
                result.append(element)
            }
        }
        return result
    }
    func _collectionPlainValue() -> Any? {
        typealias Element = Iterator.Element
        var result: [Any] = [Any]()
        self.forEach { (each) in
            if let transformable = each as? _Transformable, let transValue = transformable.plainValue() {
                result.append(transValue)
            } else {
                InternalLogger.logError("value: \(each) isn't transformable type!")
            }
        }
        return result
    }
}
extension Array: _BuiltInBasicType {
    static func _transform(from object: Any) -> [Element]? {
        return self._collectionTransform(from: object)
    }
    func _plainValue() -> Any? {
        return self._collectionPlainValue()
    }
}
extension Set: _BuiltInBasicType {
    static func _transform(from object: Any) -> Set<Element>? {
        if let arr = self._collectionTransform(from: object) {
            return Set(arr)
        }
        return nil
    }
    func _plainValue() -> Any? {
        return self._collectionPlainValue()
    }
}
// MARK: Dictionary Support
extension Dictionary: _BuiltInBasicType {
    static func _transform(from object: Any) -> [Key: Value]? {
        guard let dict = object as? [String: Any] else {
            InternalLogger.logDebug("Expect object to be an NSDictionary but it's not")
            return nil
        }
        var result = [Key: Value]()
        for (key, value) in dict {
            if let sKey = key as? Key {
                if let nValue = (Value.self as? _Transformable.Type)?.transform(from: value) as? Value {
                    result[sKey] = nValue
                } else if let nValue = value as? Value {
                    result[sKey] = nValue
                }
            }
        }
        return result
    }
    func _plainValue() -> Any? {
        var result = [String: Any]()
        for (key, value) in self {
            if let key = key as? String {
                if let transformable = value as? _Transformable {
                    if let transValue = transformable.plainValue() {
                        result[key] = transValue
                    }
                }
            }
        }
        return result
    }
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  OtherExtension.swift
//  HandyJSON
//
//  Created by zhouzhuo on 08/01/2017.
//
protocol UTF8Initializable {
    init?(validatingUTF8: UnsafePointer<CChar>)
}
extension String : UTF8Initializable {}
extension Array where Element : UTF8Initializable {
    init(utf8Strings: UnsafePointer<CChar>) {
        var strings = [Element]()
        var pointer = utf8Strings
        while let string = Element(validatingUTF8: pointer) {
            strings.append(string)
            while pointer.pointee != 0 {
                pointer.advance()
            }
            pointer.advance()
            guard pointer.pointee != 0 else {
                break
            }
        }
        self = strings
    }
}
extension Strideable {
    mutating func advance() {
        self = advanced(by: 1)
    }
}
extension UnsafePointer {
    init<T>(_ pointer: UnsafePointer<T>) {
        self = UnsafeRawPointer(pointer).assumingMemoryBound(to: Pointee.self)
    }
}
func relativePointer<T, U, V>(base: UnsafePointer<T>, offset: U) -> UnsafePointer<V> where U : FixedWidthInteger {
    return UnsafeRawPointer(base).advanced(by: Int(integer: offset)).assumingMemoryBound(to: V.self)
}
extension Int {
    fileprivate init<T : FixedWidthInteger>(integer: T) {
        switch integer {
        case let value as Int: self = value
        case let value as Int32: self = Int(value)
        case let value as Int16: self = Int(value)
        case let value as Int8: self = Int(value)
        default: self = 0
        }
    }
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//  Created by zhouzhuo on 7/7/16.
//
import Foundation
public extension HandyJSON {
    /// Finds the internal dictionary in `dict` as the `designatedPath` specified, and converts it to a Model
    /// `designatedPath` is a string like `result.data.orderInfo`, which each element split by `.` represents key of each layer
    static func deserialize(from dict: NSDictionary?, designatedPath: String? = nil) -> Self? {
        return deserialize(from: dict as? [String: Any], designatedPath: designatedPath)
    }
    /// Finds the internal dictionary in `dict` as the `designatedPath` specified, and converts it to a Model
    /// `designatedPath` is a string like `result.data.orderInfo`, which each element split by `.` represents key of each layer
    static func deserialize(from dict: [String: Any]?, designatedPath: String? = nil) -> Self? {
        return JSONDeserializer<Self>.deserializeFrom(dict: dict, designatedPath: designatedPath)
    }
    /// Finds the internal JSON field in `json` as the `designatedPath` specified, and converts it to a Model
    /// `designatedPath` is a string like `result.data.orderInfo`, which each element split by `.` represents key of each layer
    static func deserialize(from json: String?, designatedPath: String? = nil) -> Self? {
        return JSONDeserializer<Self>.deserializeFrom(json: json, designatedPath: designatedPath)
    }
}
public extension Array where Element: HandyJSON {
    /// if the JSON field finded by `designatedPath` in `json` is representing a array, such as `[{...}, {...}, {...}]`,
    /// this method converts it to a Models array
    static func deserialize(from json: String?, designatedPath: String? = nil) -> [Element?]? {
        return JSONDeserializer<Element>.deserializeModelArrayFrom(json: json, designatedPath: designatedPath)
    }
    /// deserialize model array from NSArray
    static func deserialize(from array: NSArray?) -> [Element?]? {
        return JSONDeserializer<Element>.deserializeModelArrayFrom(array: array)
    }
    /// deserialize model array from array
    static func deserialize(from array: [Any]?) -> [Element?]? {
        return JSONDeserializer<Element>.deserializeModelArrayFrom(array: array)
    }
}
public class JSONDeserializer<T: HandyJSON> {
    /// Finds the internal dictionary in `dict` as the `designatedPath` specified, and map it to a Model
    /// `designatedPath` is a string like `result.data.orderInfo`, which each element split by `.` represents key of each layer, or nil
    public static func deserializeFrom(dict: NSDictionary?, designatedPath: String? = nil) -> T? {
        return deserializeFrom(dict: dict as? [String: Any], designatedPath: designatedPath)
    }
    /// Finds the internal dictionary in `dict` as the `designatedPath` specified, and map it to a Model
    /// `designatedPath` is a string like `result.data.orderInfo`, which each element split by `.` represents key of each layer, or nil
    public static func deserializeFrom(dict: [String: Any]?, designatedPath: String? = nil) -> T? {
        var targetDict = dict
        if let path = designatedPath {
            targetDict = getInnerObject(inside: targetDict, by: path) as? [String: Any]
        }
        if let _dict = targetDict {
            return T._transform(dict: _dict) as? T
        }
        return nil
    }
    /// Finds the internal JSON field in `json` as the `designatedPath` specified, and converts it to Model
    /// `designatedPath` is a string like `result.data.orderInfo`, which each element split by `.` represents key of each layer, or nil
    public static func deserializeFrom(json: String?, designatedPath: String? = nil) -> T? {
        guard let _json = json else {
            return nil
        }
        do {
            let jsonObject = try JSONSerialization.jsonObject(with: _json.data(using: String.Encoding.utf8)!, options: .allowFragments)
            if let jsonDict = jsonObject as? NSDictionary {
                return self.deserializeFrom(dict: jsonDict, designatedPath: designatedPath)
            }
        } catch let error {
            InternalLogger.logError(error)
        }
        return nil
    }
    /// Finds the internal dictionary in `dict` as the `designatedPath` specified, and use it to reassign an exist model
    /// `designatedPath` is a string like `result.data.orderInfo`, which each element split by `.` represents key of each layer, or nil
    public static func update(object: inout T, from dict: [String: Any]?, designatedPath: String? = nil) {
        var targetDict = dict
        if let path = designatedPath {
            targetDict = getInnerObject(inside: targetDict, by: path) as? [String: Any]
        }
        if let _dict = targetDict {
            T._transform(dict: _dict, to: &object)
        }
    }
    /// Finds the internal JSON field in `json` as the `designatedPath` specified, and use it to reassign an exist model
    /// `designatedPath` is a string like `result.data.orderInfo`, which each element split by `.` represents key of each layer, or nil
    public static func update(object: inout T, from json: String?, designatedPath: String? = nil) {
        guard let _json = json else {
            return
        }
        do {
            let jsonObject = try JSONSerialization.jsonObject(with: _json.data(using: String.Encoding.utf8)!, options: .allowFragments)
            if let jsonDict = jsonObject as? [String: Any] {
                update(object: &object, from: jsonDict, designatedPath: designatedPath)
            }
        } catch let error {
            InternalLogger.logError(error)
        }
    }
    /// if the JSON field found by `designatedPath` in `json` is representing a array, such as `[{...}, {...}, {...}]`,
    /// this method converts it to a Models array
    public static func deserializeModelArrayFrom(json: String?, designatedPath: String? = nil) -> [T?]? {
        guard let _json = json else {
            return nil
        }
        do {
            let jsonObject = try JSONSerialization.jsonObject(with: _json.data(using: String.Encoding.utf8)!, options: .allowFragments)
            if let jsonArray = getInnerObject(inside: jsonObject, by: designatedPath) as? [Any] {
                return jsonArray.map({ (item) -> T? in
                    return self.deserializeFrom(dict: item as? [String: Any])
                })
            }
        } catch let error {
            InternalLogger.logError(error)
        }
        return nil
    }
    /// mapping raw array to Models array
    public static func deserializeModelArrayFrom(array: NSArray?) -> [T?]? {
        return deserializeModelArrayFrom(array: array as? [Any])
    }
    /// mapping raw array to Models array
    public static func deserializeModelArrayFrom(array: [Any]?) -> [T?]? {
        guard let _arr = array else {
            return nil
        }
        return _arr.map({ (item) -> T? in
            return self.deserializeFrom(dict: item as? NSDictionary)
        })
    }
}
fileprivate func getInnerObject(inside object: Any?, by designatedPath: String?) -> Any? {
    var result: Any? = object
    var abort = false
    if let paths = designatedPath?.components(separatedBy: "."), paths.count > 0 {
        var next = object as? [String: Any]
        paths.forEach({ (seg) in
            if seg.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) == "" || abort {
                return
            }
            if let _next = next?[seg] {
                result = _next
                next = _next as? [String: Any]
            } else {
                abort = true
            }
        })
    }
    return abort ? nil : result
}
//
//  DataTransform.swift
//  ObjectMapper
//
//  Created by Yagrushkin, Evgeny on 8/30/16.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
open class DataTransform: TransformType {
	public typealias Object = Data
	public typealias JSON = String
	public init() {}
	open func transformFromJSON(_ value: Any?) -> Data? {
		guard let string = value as? String else{
			return nil
		}
		return Data(base64Encoded: string)
	}
	open func transformToJSON(_ value: Data?) -> String? {
		guard let data = value else{
			return nil
		}
		return data.base64EncodedString()
	}
}
//
//  BuiltInBridgeType.swift
//  HandyJSON
//
//  Created by zhouzhuo on 15/07/2017.
//  Copyright © 2017 aliyun. All rights reserved.
//
import Foundation
protocol _BuiltInBridgeType: _Transformable {
    static func _transform(from object: Any) -> _BuiltInBridgeType?
    func _plainValue() -> Any?
}
extension NSString: _BuiltInBridgeType {
    static func _transform(from object: Any) -> _BuiltInBridgeType? {
        if let str = String.transform(from: object) {
            return NSString(string: str)
        }
        return nil
    }
    func _plainValue() -> Any? {
        return self
    }
}
extension NSNumber: _BuiltInBridgeType {
    static func _transform(from object: Any) -> _BuiltInBridgeType? {
        switch object {
        case let num as NSNumber:
            return num
        case let str as NSString:
            let lowercase = str.lowercased
            if lowercase == "true" {
                return NSNumber(booleanLiteral: true)
            } else if lowercase == "false" {
                return NSNumber(booleanLiteral: false)
            } else {
                // normal number
                let formatter = NumberFormatter()
                formatter.numberStyle = .decimal
                return formatter.number(from: str as String)
            }
        default:
            return nil
        }
    }
    func _plainValue() -> Any? {
        return self
    }
}
extension NSArray: _BuiltInBridgeType {
    
    static func _transform(from object: Any) -> _BuiltInBridgeType? {
        return object as? NSArray
    }
    func _plainValue() -> Any? {
        return (self as? Array<Any>)?.plainValue()
    }
}
extension NSDictionary: _BuiltInBridgeType {
    
    static func _transform(from object: Any) -> _BuiltInBridgeType? {
        return object as? NSDictionary
    }
    func _plainValue() -> Any? {
        return (self as? Dictionary<String, Any>)?.plainValue()
    }
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//  Created by zhouzhuo on 9/20/16.
//
import Foundation
public typealias CustomMappingKeyValueTuple = (Int, MappingPropertyHandler)
struct MappingPath {
    var segments: [String]
    static func buildFrom(rawPath: String) -> MappingPath {
        let regex = try! NSRegularExpression(pattern: "(?<![\\\\])\\.")
        let nsString = rawPath as NSString
        let results = regex.matches(in: rawPath, range: NSRange(location: 0, length: nsString.length))
        var splitPoints = results.map { $0.range.location }
        var curPos = 0
        var pathArr = [String]()
        splitPoints.append(nsString.length)
        splitPoints.forEach({ (point) in
            let start = rawPath.index(rawPath.startIndex, offsetBy: curPos)
            let end = rawPath.index(rawPath.startIndex, offsetBy: point)
            let subPath = String(rawPath[start ..< end]).replacingOccurrences(of: "\\.", with: ".")
            if !subPath.isEmpty {
                pathArr.append(subPath)
            }
            curPos = point + 1
        })
        return MappingPath(segments: pathArr)
    }
}
extension Dictionary where Key == String, Value: Any {
    func findValueBy(path: MappingPath) -> Any? {
        var currentDict: [String: Any]? = self
        var lastValue: Any?
        path.segments.forEach { (segment) in
            lastValue = currentDict?[segment]
            currentDict = currentDict?[segment] as? [String: Any]
        }
        return lastValue
    }
}
public class MappingPropertyHandler {
    var mappingPaths: [MappingPath]?
    var assignmentClosure: ((Any?) -> (Any?))?
    var takeValueClosure: ((Any?) -> (Any?))?
    
    public init(rawPaths: [String]?, assignmentClosure: ((Any?) -> (Any?))?, takeValueClosure: ((Any?) -> (Any?))?) {
        let mappingPaths = rawPaths?.map({ (rawPath) -> MappingPath in
            if HandyJSONConfiguration.deserializeOptions.contains(.caseInsensitive) {
                return MappingPath.buildFrom(rawPath: rawPath.lowercased())
            }
            return MappingPath.buildFrom(rawPath: rawPath)
        }).filter({ (mappingPath) -> Bool in
            return mappingPath.segments.count > 0
        })
        if let count = mappingPaths?.count, count > 0 {
            self.mappingPaths = mappingPaths
        }
        self.assignmentClosure = assignmentClosure
        self.takeValueClosure = takeValueClosure
    }
}
public class HelpingMapper {
    
    private var mappingHandlers = [Int: MappingPropertyHandler]()
    private var excludeProperties = [Int]()
    
    internal func getMappingHandler(key: Int) -> MappingPropertyHandler? {
        return self.mappingHandlers[key]
    }
    
    internal func propertyExcluded(key: Int) -> Bool {
        return self.excludeProperties.contains(key)
    }
    
    public func specify<T>(property: inout T, name: String) {
        self.specify(property: &property, name: name, converter: nil)
    }
    
    public func specify<T>(property: inout T, converter: @escaping (String) -> T) {
        self.specify(property: &property, name: nil, converter: converter)
    }
    
    public func specify<T>(property: inout T, name: String?, converter: ((String) -> T)?) {
        let pointer = withUnsafePointer(to: &property, { return $0 })
        let key = Int(bitPattern: pointer)
        let names = (name == nil ? nil : [name!])
        
        if let _converter = converter {
            let assignmentClosure = { (jsonValue: Any?) -> Any? in
                if let _value = jsonValue{
                    if let object = _value as? NSObject {
                        if let str = String.transform(from: object){
                            return _converter(str)
                        }
                    }
                }
                return nil
            }
            self.mappingHandlers[key] = MappingPropertyHandler(rawPaths: names, assignmentClosure: assignmentClosure, takeValueClosure: nil)
        } else {
            self.mappingHandlers[key] = MappingPropertyHandler(rawPaths: names, assignmentClosure: nil, takeValueClosure: nil)
        }
    }
    
    public func exclude<T>(property: inout T) {
        self._exclude(property: &property)
    }
    
    fileprivate func addCustomMapping(key: Int, mappingInfo: MappingPropertyHandler) {
        self.mappingHandlers[key] = mappingInfo
    }
    
    fileprivate func _exclude<T>(property: inout T) {
        let pointer = withUnsafePointer(to: &property, { return $0 })
        self.excludeProperties.append(Int(bitPattern: pointer))
    }
}
infix operator <-- : LogicalConjunctionPrecedence
public func <-- <T>(property: inout T, name: String) -> CustomMappingKeyValueTuple {
    return property <-- [name]
}
public func <-- <T>(property: inout T, names: [String]) -> CustomMappingKeyValueTuple {
    let pointer = withUnsafePointer(to: &property, { return $0 })
    let key = Int(bitPattern: pointer)
    return (key, MappingPropertyHandler(rawPaths: names, assignmentClosure: nil, takeValueClosure: nil))
}
// MARK: non-optional properties
public func <-- <Transform: TransformType>(property: inout Transform.Object, transformer: Transform) -> CustomMappingKeyValueTuple {
    return property <-- (nil, transformer)
}
public func <-- <Transform: TransformType>(property: inout Transform.Object, transformer: (String?, Transform?)) -> CustomMappingKeyValueTuple {
    let names = (transformer.0 == nil ? [] : [transformer.0!])
    return property <-- (names, transformer.1)
}
public func <-- <Transform: TransformType>(property: inout Transform.Object, transformer: ([String], Transform?)) -> CustomMappingKeyValueTuple {
    let pointer = withUnsafePointer(to: &property, { return $0 })
    let key = Int(bitPattern: pointer)
    let assignmentClosure = { (jsonValue: Any?) -> Transform.Object? in
        return transformer.1?.transformFromJSON(jsonValue)
    }
    let takeValueClosure = { (objectValue: Any?) -> Any? in
        if let _value = objectValue as? Transform.Object {
            return transformer.1?.transformToJSON(_value) as Any
        }
        return nil
    }
    return (key, MappingPropertyHandler(rawPaths: transformer.0, assignmentClosure: assignmentClosure, takeValueClosure: takeValueClosure))
}
// MARK: optional properties
public func <-- <Transform: TransformType>(property: inout Transform.Object?, transformer: Transform) -> CustomMappingKeyValueTuple {
    return property <-- (nil, transformer)
}
public func <-- <Transform: TransformType>(property: inout Transform.Object?, transformer: (String?, Transform?)) -> CustomMappingKeyValueTuple {
    let names = (transformer.0 == nil ? [] : [transformer.0!])
    return property <-- (names, transformer.1)
}
public func <-- <Transform: TransformType>(property: inout Transform.Object?, transformer: ([String], Transform?)) -> CustomMappingKeyValueTuple {
    let pointer = withUnsafePointer(to: &property, { return $0 })
    let key = Int(bitPattern: pointer)
    let assignmentClosure = { (jsonValue: Any?) -> Any? in
        return transformer.1?.transformFromJSON(jsonValue)
    }
    let takeValueClosure = { (objectValue: Any?) -> Any? in
        if let _value = objectValue as? Transform.Object {
            return transformer.1?.transformToJSON(_value) as Any
        }
        return nil
    }
    return (key, MappingPropertyHandler(rawPaths: transformer.0, assignmentClosure: assignmentClosure, takeValueClosure: takeValueClosure))
}
infix operator <<< : AssignmentPrecedence
public func <<< (mapper: HelpingMapper, mapping: CustomMappingKeyValueTuple) {
    mapper.addCustomMapping(key: mapping.0, mappingInfo: mapping.1)
}
public func <<< (mapper: HelpingMapper, mappings: [CustomMappingKeyValueTuple]) {
    mappings.forEach { (mapping) in
        mapper.addCustomMapping(key: mapping.0, mappingInfo: mapping.1)
    }
}
infix operator >>> : AssignmentPrecedence
public func >>> <T> (mapper: HelpingMapper, property: inout T) {
    mapper._exclude(property: &property)
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  AnyExtension.swift
//  HandyJSON
//
//  Created by zhouzhuo on 08/01/2017.
//
protocol AnyExtensions {}
extension AnyExtensions {
    public static func isValueTypeOrSubtype(_ value: Any) -> Bool {
        return value is Self
    }
    public static func value(from storage: UnsafeRawPointer) -> Any {
        return storage.assumingMemoryBound(to: self).pointee
    }
    public static func write(_ value: Any, to storage: UnsafeMutableRawPointer) {
        guard let this = value as? Self else {
            return
        }
        storage.assumingMemoryBound(to: self).pointee = this
    }
    public static func takeValue(from anyValue: Any) -> Self? {
        return anyValue as? Self
    }
}
func extensions(of type: Any.Type) -> AnyExtensions.Type {
    struct Extensions : AnyExtensions {}
    var extensions: AnyExtensions.Type = Extensions.self
    withUnsafePointer(to: &extensions) { pointer in
        UnsafeMutableRawPointer(mutating: pointer).assumingMemoryBound(to: Any.Type.self).pointee = type
    }
    return extensions
}
func extensions(of value: Any) -> AnyExtensions {
    struct Extensions : AnyExtensions {}
    var extensions: AnyExtensions = Extensions()
    withUnsafePointer(to: &extensions) { pointer in
        UnsafeMutableRawPointer(mutating: pointer).assumingMemoryBound(to: Any.self).pointee = value
    }
    return extensions
}
/// Tests if `value` is `type` or a subclass of `type`
func value(_ value: Any, is type: Any.Type) -> Bool {
    return extensions(of: type).isValueTypeOrSubtype(value)
}
/// Tests equality of any two existential types
func == (lhs: Any.Type, rhs: Any.Type) -> Bool {
    return Metadata(type: lhs) == Metadata(type: rhs)
}
// MARK: AnyExtension + Storage
extension AnyExtensions {
    mutating func storage() -> UnsafeRawPointer {
        if type(of: self) is AnyClass {
            let opaquePointer = Unmanaged.passUnretained(self as AnyObject).toOpaque()
            return UnsafeRawPointer(opaquePointer)
        } else {
            return withUnsafePointer(to: &self) { pointer in
                return UnsafeRawPointer(pointer)
            }
        }
    }
}
//
//  EnumType.swift
//  HandyJSON
//
//  Created by zhouzhuo on 16/07/2017.
//  Copyright © 2017 aliyun. All rights reserved.
//
import Foundation
public protocol _RawEnumProtocol: _Transformable {
    static func _transform(from object: Any) -> Self?
    func _plainValue() -> Any?
}
extension RawRepresentable where Self: _RawEnumProtocol {
    public static func _transform(from object: Any) -> Self? {
        if let transformableType = RawValue.self as? _Transformable.Type {
            if let typedValue = transformableType.transform(from: object) {
                return Self(rawValue: typedValue as! RawValue)
            }
        }
        return nil
    }
    public func _plainValue() -> Any? {
        return self.rawValue
    }
}
//
//  TransformType.swift
//  ObjectMapper
//
//  Created by Syo Ikeda on 2/4/15.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
public protocol TransformType {
	associatedtype Object
	associatedtype JSON
	func transformFromJSON(_ value: Any?) -> Object?
	func transformToJSON(_ value: Object?) -> JSON?
}
//
//  DateTransform.swift
//  ObjectMapper
//
//  Created by Tristan Himmelman on 2014-10-13.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
open class DateTransform: TransformType {
	public typealias Object = Date
	public typealias JSON = Double
	public init() {}
	open func transformFromJSON(_ value: Any?) -> Date? {
		if let timeInt = value as? Double {
			return Date(timeIntervalSince1970: TimeInterval(timeInt))
		}
		if let timeStr = value as? String {
			return Date(timeIntervalSince1970: TimeInterval(atof(timeStr)))
		}
		return nil
	}
	open func transformToJSON(_ value: Date?) -> Double? {
		if let date = value {
			return Double(date.timeIntervalSince1970)
		}
		return nil
	}
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  PropertyInfo.swift
//  HandyJSON
//
//  Created by zhouzhuo on 20/08/2017.
//
struct PropertyInfo {
    let key: String
    let type: Any.Type
    let address: UnsafeMutableRawPointer
    let bridged: Bool
}
//
//  DateFormatterTransform.swift
//  ObjectMapper
//
//  Created by Tristan Himmelman on 2015-03-09.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
open class DateFormatterTransform: TransformType {
	public typealias Object = Date
	public typealias JSON = String
	public let dateFormatter: DateFormatter
	public init(dateFormatter: DateFormatter) {
		self.dateFormatter = dateFormatter
	}
	open func transformFromJSON(_ value: Any?) -> Date? {
		if let dateString = value as? String {
			return dateFormatter.date(from: dateString)
		}
		return nil
	}
	open func transformToJSON(_ value: Date?) -> String? {
		if let date = value {
			return dateFormatter.string(from: date)
		}
		return nil
	}
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  JSONSerializer.swift
//  HandyJSON
//
//  Created by zhouzhuo on 9/30/16.
//
import Foundation
public extension HandyJSON {
    func toJSON() -> [String: Any]? {
        if let dict = Self._serializeAny(object: self) as? [String: Any] {
            return dict
        }
        return nil
    }
    func toJSONString(prettyPrint: Bool = false) -> String? {
        if let anyObject = self.toJSON() {
            if JSONSerialization.isValidJSONObject(anyObject) {
                do {
                    let jsonData: Data
                    if prettyPrint {
                        jsonData = try JSONSerialization.data(withJSONObject: anyObject, options: [.prettyPrinted])
                    } else {
                        jsonData = try JSONSerialization.data(withJSONObject: anyObject, options: [])
                    }
                    return String(data: jsonData, encoding: .utf8)
                } catch let error {
                    InternalLogger.logError(error)
                }
            } else {
                InternalLogger.logDebug("\(anyObject)) is not a valid JSON Object")
            }
        }
        return nil
    }
}
public extension Collection where Iterator.Element: HandyJSON {
    func toJSON() -> [[String: Any]?] {
        return self.map{ $0.toJSON() }
    }
    func toJSONString(prettyPrint: Bool = false) -> String? {
        let anyArray = self.toJSON()
        if JSONSerialization.isValidJSONObject(anyArray) {
            do {
                let jsonData: Data
                if prettyPrint {
                    jsonData = try JSONSerialization.data(withJSONObject: anyArray, options: [.prettyPrinted])
                } else {
                    jsonData = try JSONSerialization.data(withJSONObject: anyArray, options: [])
                }
                return String(data: jsonData, encoding: .utf8)
            } catch let error {
                InternalLogger.logError(error)
            }
        } else {
            InternalLogger.logDebug("\(self.toJSON()) is not a valid JSON Object")
        }
        return nil
    }
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  ExtendCustomBasicType.swift
//  HandyJSON
//
//  Created by zhouzhuo on 05/09/2017.
//
public protocol _ExtendCustomBasicType: _Transformable {
    static func _transform(from object: Any) -> Self?
    func _plainValue() -> Any?
}
//
//  TransformOf.swift
//  ObjectMapper
//
//  Created by Syo Ikeda on 1/23/15.
//
//  The MIT License (MIT)
//
//  Copyright (c) 2014-2016 Hearst
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
open class TransformOf<ObjectType, JSONType>: TransformType {
	public typealias Object = ObjectType
	public typealias JSON = JSONType
	private let fromJSON: (JSONType?) -> ObjectType?
	private let toJSON: (ObjectType?) -> JSONType?
	public init(fromJSON: @escaping(JSONType?) -> ObjectType?, toJSON: @escaping(ObjectType?) -> JSONType?) {
		self.fromJSON = fromJSON
		self.toJSON = toJSON
	}
	open func transformFromJSON(_ value: Any?) -> ObjectType? {
		return fromJSON(value as? JSONType)
	}
	open func transformToJSON(_ value: ObjectType?) -> JSONType? {
		return toJSON(value)
	}
}
/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
//  Configuration.swift
//  HandyJSON
//
//  Created by zhouzhuo on 08/01/2017.
//
public struct DeserializeOptions: OptionSet {
    public let rawValue: Int
    public static let caseInsensitive = DeserializeOptions(rawValue: 1 << 0)
    public static let defaultOptions: DeserializeOptions = []
    public init(rawValue: Int) {
        self.rawValue = rawValue
    }
}
public enum DebugMode: Int {
    case verbose = 0
    case debug = 1
    case error = 2
    case none = 3
}
public struct HandyJSONConfiguration {
    private static var _mode = DebugMode.error
    public static var debugMode: DebugMode {
        get {
            return _mode
        }
        set {
            _mode = newValue
        }
    }
    public static var deserializeOptions: DeserializeOptions = .defaultOptions
}
//
//  Storage.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/10/15.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Constants for some time intervals
struct TimeConstants {
    static let secondsInOneMinute = 60
    static let minutesInOneHour = 60
    static let hoursInOneDay = 24
    static let secondsInOneDay = 86_400
}
/// Represents the expiration strategy used in storage.
///
/// - never: The item never expires.
/// - seconds: The item expires after a time duration of given seconds from now.
/// - days: The item expires after a time duration of given days from now.
/// - date: The item expires after a given date.
public enum StorageExpiration {
    /// The item never expires.
    case never
    /// The item expires after a time duration of given seconds from now.
    case seconds(TimeInterval)
    /// The item expires after a time duration of given days from now.
    case days(Int)
    /// The item expires after a given date.
    case date(Date)
    /// Indicates the item is already expired. Use this to skip cache.
    case expired
    func estimatedExpirationSince(_ date: Date) -> Date {
        switch self {
        case .never: return .distantFuture
        case .seconds(let seconds):
            return date.addingTimeInterval(seconds)
        case .days(let days):
            let duration = TimeInterval(TimeConstants.secondsInOneDay) * TimeInterval(days)
            return date.addingTimeInterval(duration)
        case .date(let ref):
            return ref
        case .expired:
            return .distantPast
        }
    }
    
    var estimatedExpirationSinceNow: Date {
        return estimatedExpirationSince(Date())
    }
    
    var isExpired: Bool {
        return timeInterval <= 0
    }
    var timeInterval: TimeInterval {
        switch self {
        case .never: return .infinity
        case .seconds(let seconds): return seconds
        case .days(let days): return TimeInterval(TimeConstants.secondsInOneDay) * TimeInterval(days)
        case .date(let ref): return ref.timeIntervalSinceNow
        case .expired: return -(.infinity)
        }
    }
}
/// Represents the expiration extending strategy used in storage to after access.
///
/// - none: The item expires after the original time, without extending after access.
/// - cacheTime: The item expiration extends by the original cache time after each access.
/// - expirationTime: The item expiration extends by the provided time after each access.
public enum ExpirationExtending {
    /// The item expires after the original time, without extending after access.
    case none
    /// The item expiration extends by the original cache time after each access.
    case cacheTime
    /// The item expiration extends by the provided time after each access.
    case expirationTime(_ expiration: StorageExpiration)
}
/// Represents types which cost in memory can be calculated.
public protocol CacheCostCalculable {
    var cacheCost: Int { get }
}
/// Represents types which can be converted to and from data.
public protocol DataTransformable {
    func toData() throws -> Data
    static func fromData(_ data: Data) throws -> Self
    static var empty: Self { get }
}
//
//  ImageCache.swift
//  Kingfisher
//
//  Created by Wei Wang on 15/4/6.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(macOS)
import AppKit
#else
import UIKit
#endif
extension Notification.Name {
    /// This notification will be sent when the disk cache got cleaned either there are cached files expired or the
    /// total size exceeding the max allowed size. The manually invoking of `clearDiskCache` method will not trigger
    /// this notification.
    ///
    /// The `object` of this notification is the `ImageCache` object which sends the notification.
    /// A list of removed hashes (files) could be retrieved by accessing the array under
    /// `KingfisherDiskCacheCleanedHashKey` key in `userInfo` of the notification object you received.
    /// By checking the array, you could know the hash codes of files are removed.
    public static let KingfisherDidCleanDiskCache =
        Notification.Name("com.onevcat.Kingfisher.KingfisherDidCleanDiskCache")
}
/// Key for array of cleaned hashes in `userInfo` of `KingfisherDidCleanDiskCacheNotification`.
public let KingfisherDiskCacheCleanedHashKey = "com.onevcat.Kingfisher.cleanedHash"
/// Cache type of a cached image.
/// - none: The image is not cached yet when retrieving it.
/// - memory: The image is cached in memory.
/// - disk: The image is cached in disk.
public enum CacheType {
    /// The image is not cached yet when retrieving it.
    case none
    /// The image is cached in memory.
    case memory
    /// The image is cached in disk.
    case disk
    
    /// Whether the cache type represents the image is already cached or not.
    public var cached: Bool {
        switch self {
        case .memory, .disk: return true
        case .none: return false
        }
    }
}
/// Represents the caching operation result.
public struct CacheStoreResult {
    
    /// The cache result for memory cache. Caching an image to memory will never fail.
    public let memoryCacheResult: Result<(), Never>
    
    /// The cache result for disk cache. If an error happens during caching operation,
    /// you can get it from `.failure` case of this `diskCacheResult`.
    public let diskCacheResult: Result<(), KingfisherError>
}
extension KFCrossPlatformImage: CacheCostCalculable {
    /// Cost of an image
    public var cacheCost: Int { return kf.cost }
}
extension Data: DataTransformable {
    public func toData() throws -> Data {
        return self
    }
    public static func fromData(_ data: Data) throws -> Data {
        return data
    }
    public static let empty = Data()
}
/// Represents the getting image operation from the cache.
///
/// - disk: The image can be retrieved from disk cache.
/// - memory: The image can be retrieved memory cache.
/// - none: The image does not exist in the cache.
public enum ImageCacheResult {
    
    /// The image can be retrieved from disk cache.
    case disk(KFCrossPlatformImage)
    
    /// The image can be retrieved memory cache.
    case memory(KFCrossPlatformImage)
    
    /// The image does not exist in the cache.
    case none
    
    /// Extracts the image from cache result. It returns the associated `Image` value for
    /// `.disk` and `.memory` case. For `.none` case, `nil` is returned.
    public var image: KFCrossPlatformImage? {
        switch self {
        case .disk(let image): return image
        case .memory(let image): return image
        case .none: return nil
        }
    }
    
    /// Returns the corresponding `CacheType` value based on the result type of `self`.
    public var cacheType: CacheType {
        switch self {
        case .disk: return .disk
        case .memory: return .memory
        case .none: return .none
        }
    }
}
/// Represents a hybrid caching system which is composed by a `MemoryStorage.Backend` and a `DiskStorage.Backend`.
/// `ImageCache` is a high level abstract for storing an image as well as its data to disk memory and disk, and
/// retrieving them back.
///
/// While a default image cache object will be used if you prefer the extension methods of Kingfisher, you can create
/// your own cache object and configure its storages as your need. This class also provide an interface for you to set
/// the memory and disk storage config.
open class ImageCache {
    // MARK: Singleton
    /// The default `ImageCache` object. Kingfisher will use this cache for its related methods if there is no
    /// other cache specified. The `name` of this default cache is "default", and you should not use this name
    /// for any of your customize cache.
    public static let `default` = ImageCache(name: "default")
    // MARK: Public Properties
    /// The `MemoryStorage.Backend` object used in this cache. This storage holds loaded images in memory with a
    /// reasonable expire duration and a maximum memory usage. To modify the configuration of a storage, just set
    /// the storage `config` and its properties.
    public let memoryStorage: MemoryStorage.Backend<KFCrossPlatformImage>
    
    /// The `DiskStorage.Backend` object used in this cache. This storage stores loaded images in disk with a
    /// reasonable expire duration and a maximum disk usage. To modify the configuration of a storage, just set
    /// the storage `config` and its properties.
    public let diskStorage: DiskStorage.Backend<Data>
    
    private let ioQueue: DispatchQueue
    
    /// Closure that defines the disk cache path from a given path and cacheName.
    public typealias DiskCachePathClosure = (URL, String) -> URL
    // MARK: Initializers
    /// Creates an `ImageCache` from a customized `MemoryStorage` and `DiskStorage`.
    ///
    /// - Parameters:
    ///   - memoryStorage: The `MemoryStorage.Backend` object to use in the image cache.
    ///   - diskStorage: The `DiskStorage.Backend` object to use in the image cache.
    public init(
        memoryStorage: MemoryStorage.Backend<KFCrossPlatformImage>,
        diskStorage: DiskStorage.Backend<Data>)
    {
        self.memoryStorage = memoryStorage
        self.diskStorage = diskStorage
        let ioQueueName = "com.onevcat.Kingfisher.ImageCache.ioQueue.\(UUID().uuidString)"
        ioQueue = DispatchQueue(label: ioQueueName)
        let notifications: [(Notification.Name, Selector)]
        #if !os(macOS) && !os(watchOS)
        #if swift(>=4.2)
        notifications = [
            (UIApplication.didReceiveMemoryWarningNotification, #selector(clearMemoryCache)),
            (UIApplication.willTerminateNotification, #selector(cleanExpiredDiskCache)),
            (UIApplication.didEnterBackgroundNotification, #selector(backgroundCleanExpiredDiskCache))
        ]
        #else
        notifications = [
            (NSNotification.Name.UIApplicationDidReceiveMemoryWarning, #selector(clearMemoryCache)),
            (NSNotification.Name.UIApplicationWillTerminate, #selector(cleanExpiredDiskCache)),
            (NSNotification.Name.UIApplicationDidEnterBackground, #selector(backgroundCleanExpiredDiskCache))
        ]
        #endif
        #elseif os(macOS)
        notifications = [
            (NSApplication.willResignActiveNotification, #selector(cleanExpiredDiskCache)),
        ]
        #else
        notifications = []
        #endif
        notifications.forEach {
            NotificationCenter.default.addObserver(self, selector: $0.1, name: $0.0, object: nil)
        }
    }
    
    /// Creates an `ImageCache` with a given `name`. Both `MemoryStorage` and `DiskStorage` will be created
    /// with a default config based on the `name`.
    ///
    /// - Parameter name: The name of cache object. It is used to setup disk cache directories and IO queue.
    ///                   You should not use the same `name` for different caches, otherwise, the disk storage would
    ///                   be conflicting to each other. The `name` should not be an empty string.
    public convenience init(name: String) {
        try! self.init(name: name, cacheDirectoryURL: nil, diskCachePathClosure: nil)
    }
    /// Creates an `ImageCache` with a given `name`, cache directory `path`
    /// and a closure to modify the cache directory.
    ///
    /// - Parameters:
    ///   - name: The name of cache object. It is used to setup disk cache directories and IO queue.
    ///           You should not use the same `name` for different caches, otherwise, the disk storage would
    ///           be conflicting to each other.
    ///   - cacheDirectoryURL: Location of cache directory URL on disk. It will be internally pass to the
    ///                        initializer of `DiskStorage` as the disk cache directory. If `nil`, the cache
    ///                        directory under user domain mask will be used.
    ///   - diskCachePathClosure: Closure that takes in an optional initial path string and generates
    ///                           the final disk cache path. You could use it to fully customize your cache path.
    /// - Throws: An error that happens during image cache creating, such as unable to create a directory at the given
    ///           path.
    public convenience init(
        name: String,
        cacheDirectoryURL: URL?,
        diskCachePathClosure: DiskCachePathClosure? = nil) throws
    {
        if name.isEmpty {
            fatalError("[Kingfisher] You should specify a name for the cache. A cache with empty name is not permitted.")
        }
        let totalMemory = ProcessInfo.processInfo.physicalMemory
        let costLimit = totalMemory / 4
        let memoryStorage = MemoryStorage.Backend<KFCrossPlatformImage>(config:
            .init(totalCostLimit: (costLimit > Int.max) ? Int.max : Int(costLimit)))
        var diskConfig = DiskStorage.Config(
            name: name,
            sizeLimit: 0,
            directory: cacheDirectoryURL
        )
        if let closure = diskCachePathClosure {
            diskConfig.cachePathBlock = closure
        }
        let diskStorage = try DiskStorage.Backend<Data>(config: diskConfig)
        diskConfig.cachePathBlock = nil
        self.init(memoryStorage: memoryStorage, diskStorage: diskStorage)
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    // MARK: Storing Images
    open func store(_ image: KFCrossPlatformImage,
                    original: Data? = nil,
                    forKey key: String,
                    options: KingfisherParsedOptionsInfo,
                    toDisk: Bool = true,
                    completionHandler: ((CacheStoreResult) -> Void)? = nil)
    {
        let identifier = options.processor.identifier
        let callbackQueue = options.callbackQueue
        
        let computedKey = key.computedKey(with: identifier)
        // Memory storage should not throw.
        memoryStorage.storeNoThrow(value: image, forKey: computedKey, expiration: options.memoryCacheExpiration)
        
        guard toDisk else {
            if let completionHandler = completionHandler {
                let result = CacheStoreResult(memoryCacheResult: .success(()), diskCacheResult: .success(()))
                callbackQueue.execute { completionHandler(result) }
            }
            return
        }
        
        ioQueue.async {
            let serializer = options.cacheSerializer
            if let data = serializer.data(with: image, original: original) {
                self.syncStoreToDisk(
                    data,
                    forKey: key,
                    processorIdentifier: identifier,
                    callbackQueue: callbackQueue,
                    expiration: options.diskCacheExpiration,
                    completionHandler: completionHandler)
            } else {
                guard let completionHandler = completionHandler else { return }
                
                let diskError = KingfisherError.cacheError(
                    reason: .cannotSerializeImage(image: image, original: original, serializer: serializer))
                let result = CacheStoreResult(
                    memoryCacheResult: .success(()),
                    diskCacheResult: .failure(diskError))
                callbackQueue.execute { completionHandler(result) }
            }
        }
    }
    /// Stores an image to the cache.
    ///
    /// - Parameters:
    ///   - image: The image to be stored.
    ///   - original: The original data of the image. This value will be forwarded to the provided `serializer` for
    ///               further use. By default, Kingfisher uses a `DefaultCacheSerializer` to serialize the image to
    ///               data for caching in disk, it checks the image format based on `original` data to determine in
    ///               which image format should be used. For other types of `serializer`, it depends on their
    ///               implementation detail on how to use this original data.
    ///   - key: The key used for caching the image.
    ///   - identifier: The identifier of processor being used for caching. If you are using a processor for the
    ///                 image, pass the identifier of processor to this parameter.
    ///   - serializer: The `CacheSerializer`
    ///   - toDisk: Whether this image should be cached to disk or not. If `false`, the image is only cached in memory.
    ///             Otherwise, it is cached in both memory storage and disk storage. Default is `true`.
    ///   - callbackQueue: The callback queue on which `completionHandler` is invoked. Default is `.untouch`. For case
    ///                    that `toDisk` is `false`, a `.untouch` queue means `callbackQueue` will be invoked from the
    ///                    caller queue of this method. If `toDisk` is `true`, the `completionHandler` will be called
    ///                    from an internal file IO queue. To change this behavior, specify another `CallbackQueue`
    ///                    value.
    ///   - completionHandler: A closure which is invoked when the cache operation finishes.
    open func store(_ image: KFCrossPlatformImage,
                      original: Data? = nil,
                      forKey key: String,
                      processorIdentifier identifier: String = "",
                      cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,
                      toDisk: Bool = true,
                      callbackQueue: CallbackQueue = .untouch,
                      completionHandler: ((CacheStoreResult) -> Void)? = nil)
    {
        struct TempProcessor: ImageProcessor {
            let identifier: String
            func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
                return nil
            }
        }
        
        let options = KingfisherParsedOptionsInfo([
            .processor(TempProcessor(identifier: identifier)),
            .cacheSerializer(serializer),
            .callbackQueue(callbackQueue)
        ])
        store(image, original: original, forKey: key, options: options,
              toDisk: toDisk, completionHandler: completionHandler)
    }
    
    open func storeToDisk(
        _ data: Data,
        forKey key: String,
        processorIdentifier identifier: String = "",
        expiration: StorageExpiration? = nil,
        callbackQueue: CallbackQueue = .untouch,
        completionHandler: ((CacheStoreResult) -> Void)? = nil)
    {
        ioQueue.async {
            self.syncStoreToDisk(
                data,
                forKey: key,
                processorIdentifier: identifier,
                callbackQueue: callbackQueue,
                expiration: expiration,
                completionHandler: completionHandler)
        }
    }
    
    private func syncStoreToDisk(
        _ data: Data,
        forKey key: String,
        processorIdentifier identifier: String = "",
        callbackQueue: CallbackQueue = .untouch,
        expiration: StorageExpiration? = nil,
        completionHandler: ((CacheStoreResult) -> Void)? = nil)
    {
        let computedKey = key.computedKey(with: identifier)
        let result: CacheStoreResult
        do {
            try self.diskStorage.store(value: data, forKey: computedKey, expiration: expiration)
            result = CacheStoreResult(memoryCacheResult: .success(()), diskCacheResult: .success(()))
        } catch {
            let diskError: KingfisherError
            if let error = error as? KingfisherError {
                diskError = error
            } else {
                diskError = .cacheError(reason: .cannotConvertToData(object: data, error: error))
            }
            
            result = CacheStoreResult(
                memoryCacheResult: .success(()),
                diskCacheResult: .failure(diskError)
            )
        }
        if let completionHandler = completionHandler {
            callbackQueue.execute { completionHandler(result) }
        }
    }
    // MARK: Removing Images
    /// Removes the image for the given key from the cache.
    ///
    /// - Parameters:
    ///   - key: The key used for caching the image.
    ///   - identifier: The identifier of processor being used for caching. If you are using a processor for the
    ///                 image, pass the identifier of processor to this parameter.
    ///   - fromMemory: Whether this image should be removed from memory storage or not.
    ///                 If `false`, the image won't be removed from the memory storage. Default is `true`.
    ///   - fromDisk: Whether this image should be removed from disk storage or not.
    ///               If `false`, the image won't be removed from the disk storage. Default is `true`.
    ///   - callbackQueue: The callback queue on which `completionHandler` is invoked. Default is `.untouch`.
    ///   - completionHandler: A closure which is invoked when the cache removing operation finishes.
    open func removeImage(forKey key: String,
                          processorIdentifier identifier: String = "",
                          fromMemory: Bool = true,
                          fromDisk: Bool = true,
                          callbackQueue: CallbackQueue = .untouch,
                          completionHandler: (() -> Void)? = nil)
    {
        let computedKey = key.computedKey(with: identifier)
        if fromMemory {
            try? memoryStorage.remove(forKey: computedKey)
        }
        
        if fromDisk {
            ioQueue.async{
                try? self.diskStorage.remove(forKey: computedKey)
                if let completionHandler = completionHandler {
                    callbackQueue.execute { completionHandler() }
                }
            }
        } else {
            if let completionHandler = completionHandler {
                callbackQueue.execute { completionHandler() }
            }
        }
    }
    func retrieveImage(forKey key: String,
                       options: KingfisherParsedOptionsInfo,
                       callbackQueue: CallbackQueue = .mainCurrentOrAsync,
                       completionHandler: ((Result<ImageCacheResult, KingfisherError>) -> Void)?)
    {
        // No completion handler. No need to start working and early return.
        guard let completionHandler = completionHandler else { return }
        // Try to check the image from memory cache first.
        if let image = retrieveImageInMemoryCache(forKey: key, options: options) {
            let image = options.imageModifier?.modify(image) ?? image
            callbackQueue.execute { completionHandler(.success(.memory(image))) }
        } else if options.fromMemoryCacheOrRefresh {
            callbackQueue.execute { completionHandler(.success(.none)) }
        } else {
            // Begin to disk search.
            self.retrieveImageInDiskCache(forKey: key, options: options, callbackQueue: callbackQueue) {
                result in
                switch result {
                case .success(let image):
                    guard let image = image else {
                        // No image found in disk storage.
                        callbackQueue.execute { completionHandler(.success(.none)) }
                        return
                    }
                    let finalImage = options.imageModifier?.modify(image) ?? image
                    // Cache the disk image to memory.
                    // We are passing `false` to `toDisk`, the memory cache does not change
                    // callback queue, we can call `completionHandler` without another dispatch.
                    var cacheOptions = options
                    cacheOptions.callbackQueue = .untouch
                    self.store(
                        finalImage,
                        forKey: key,
                        options: cacheOptions,
                        toDisk: false)
                    {
                        _ in
                        callbackQueue.execute { completionHandler(.success(.disk(finalImage))) }
                    }
                case .failure(let error):
                    callbackQueue.execute { completionHandler(.failure(error)) }
                }
            }
        }
    }
    // MARK: Getting Images
    /// Gets an image for a given key from the cache, either from memory storage or disk storage.
    ///
    /// - Parameters:
    ///   - key: The key used for caching the image.
    ///   - options: The `KingfisherOptionsInfo` options setting used for retrieving the image.
    ///   - callbackQueue: The callback queue on which `completionHandler` is invoked. Default is `.mainCurrentOrAsync`.
    ///   - completionHandler: A closure which is invoked when the image getting operation finishes. If the
    ///                        image retrieving operation finishes without problem, an `ImageCacheResult` value
    ///                        will be sent to this closure as result. Otherwise, a `KingfisherError` result
    ///                        with detail failing reason will be sent.
    open func retrieveImage(forKey key: String,
                               options: KingfisherOptionsInfo? = nil,
                        callbackQueue: CallbackQueue = .mainCurrentOrAsync,
                     completionHandler: ((Result<ImageCacheResult, KingfisherError>) -> Void)?)
    {
        retrieveImage(
            forKey: key,
            options: KingfisherParsedOptionsInfo(options),
            callbackQueue: callbackQueue,
            completionHandler: completionHandler)
    }
    func retrieveImageInMemoryCache(
        forKey key: String,
        options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage?
    {
        let computedKey = key.computedKey(with: options.processor.identifier)
        return memoryStorage.value(forKey: computedKey, extendingExpiration: options.memoryCacheAccessExtendingExpiration)
    }
    /// Gets an image for a given key from the memory storage.
    ///
    /// - Parameters:
    ///   - key: The key used for caching the image.
    ///   - options: The `KingfisherOptionsInfo` options setting used for retrieving the image.
    /// - Returns: The image stored in memory cache, if exists and valid. Otherwise, if the image does not exist or
    ///            has already expired, `nil` is returned.
    open func retrieveImageInMemoryCache(
        forKey key: String,
        options: KingfisherOptionsInfo? = nil) -> KFCrossPlatformImage?
    {
        return retrieveImageInMemoryCache(forKey: key, options: KingfisherParsedOptionsInfo(options))
    }
    func retrieveImageInDiskCache(
        forKey key: String,
        options: KingfisherParsedOptionsInfo,
        callbackQueue: CallbackQueue = .untouch,
        completionHandler: @escaping (Result<KFCrossPlatformImage?, KingfisherError>) -> Void)
    {
        let computedKey = key.computedKey(with: options.processor.identifier)
        let loadingQueue: CallbackQueue = options.loadDiskFileSynchronously ? .untouch : .dispatch(ioQueue)
        loadingQueue.execute {
            do {
                var image: KFCrossPlatformImage? = nil
                if let data = try self.diskStorage.value(forKey: computedKey, extendingExpiration: options.diskCacheAccessExtendingExpiration) {
                    image = options.cacheSerializer.image(with: data, options: options)
                }
                callbackQueue.execute { completionHandler(.success(image)) }
            } catch {
                if let error = error as? KingfisherError {
                    callbackQueue.execute { completionHandler(.failure(error)) }
                } else {
                    assertionFailure("The internal thrown error should be a `KingfisherError`.")
                }
            }
        }
    }
    
    /// Gets an image for a given key from the disk storage.
    ///
    /// - Parameters:
    ///   - key: The key used for caching the image.
    ///   - options: The `KingfisherOptionsInfo` options setting used for retrieving the image.
    ///   - callbackQueue: The callback queue on which `completionHandler` is invoked. Default is `.untouch`.
    ///   - completionHandler: A closure which is invoked when the operation finishes.
    open func retrieveImageInDiskCache(
        forKey key: String,
        options: KingfisherOptionsInfo? = nil,
        callbackQueue: CallbackQueue = .untouch,
        completionHandler: @escaping (Result<KFCrossPlatformImage?, KingfisherError>) -> Void)
    {
        retrieveImageInDiskCache(
            forKey: key,
            options: KingfisherParsedOptionsInfo(options),
            callbackQueue: callbackQueue,
            completionHandler: completionHandler)
    }
    // MARK: Cleaning
    /// Clears the memory & disk storage of this cache. This is an async operation.
    ///
    /// - Parameter handler: A closure which is invoked when the cache clearing operation finishes.
    ///                      This `handler` will be called from the main queue.
    public func clearCache(completion handler: (() -> Void)? = nil) {
        clearMemoryCache()
        clearDiskCache(completion: handler)
    }
    
    /// Clears the memory storage of this cache.
    @objc public func clearMemoryCache() {
        try? memoryStorage.removeAll()
    }
    
    /// Clears the disk storage of this cache. This is an async operation.
    ///
    /// - Parameter handler: A closure which is invoked when the cache clearing operation finishes.
    ///                      This `handler` will be called from the main queue.
    open func clearDiskCache(completion handler: (() -> Void)? = nil) {
        ioQueue.async {
            do {
                try self.diskStorage.removeAll()
            } catch _ { }
            if let handler = handler {
                DispatchQueue.main.async { handler() }
            }
        }
    }
    
    /// Clears the expired images from memory & disk storage. This is an async operation.
    open func cleanExpiredCache(completion handler: (() -> Void)? = nil) {
        cleanExpiredMemoryCache()
        cleanExpiredDiskCache(completion: handler)
    }
    /// Clears the expired images from disk storage.
    open func cleanExpiredMemoryCache() {
        memoryStorage.removeExpired()
    }
    
    /// Clears the expired images from disk storage. This is an async operation.
    @objc func cleanExpiredDiskCache() {
        cleanExpiredDiskCache(completion: nil)
    }
    /// Clears the expired images from disk storage. This is an async operation.
    ///
    /// - Parameter handler: A closure which is invoked when the cache clearing operation finishes.
    ///                      This `handler` will be called from the main queue.
    open func cleanExpiredDiskCache(completion handler: (() -> Void)? = nil) {
        ioQueue.async {
            do {
                var removed: [URL] = []
                let removedExpired = try self.diskStorage.removeExpiredValues()
                removed.append(contentsOf: removedExpired)
                let removedSizeExceeded = try self.diskStorage.removeSizeExceededValues()
                removed.append(contentsOf: removedSizeExceeded)
                if !removed.isEmpty {
                    DispatchQueue.main.async {
                        let cleanedHashes = removed.map { $0.lastPathComponent }
                        NotificationCenter.default.post(
                            name: .KingfisherDidCleanDiskCache,
                            object: self,
                            userInfo: [KingfisherDiskCacheCleanedHashKey: cleanedHashes])
                    }
                }
                if let handler = handler {
                    DispatchQueue.main.async { handler() }
                }
            } catch {}
        }
    }
#if !os(macOS) && !os(watchOS)
    /// Clears the expired images from disk storage when app is in background. This is an async operation.
    /// In most cases, you should not call this method explicitly.
    /// It will be called automatically when `UIApplicationDidEnterBackgroundNotification` received.
    @objc public func backgroundCleanExpiredDiskCache() {
        // if 'sharedApplication()' is unavailable, then return
        guard let sharedApplication = KingfisherWrapper<UIApplication>.shared else { return }
        func endBackgroundTask(_ task: inout UIBackgroundTaskIdentifier) {
            sharedApplication.endBackgroundTask(task)
            #if swift(>=4.2)
            task = UIBackgroundTaskIdentifier.invalid
            #else
            task = UIBackgroundTaskInvalid
            #endif
        }
        
        var backgroundTask: UIBackgroundTaskIdentifier!
        backgroundTask = sharedApplication.beginBackgroundTask {
            endBackgroundTask(&backgroundTask!)
        }
        
        cleanExpiredDiskCache {
            endBackgroundTask(&backgroundTask!)
        }
    }
#endif
    // MARK: Image Cache State
    /// Returns the cache type for a given `key` and `identifier` combination.
    /// This method is used for checking whether an image is cached in current cache.
    /// It also provides information on which kind of cache can it be found in the return value.
    ///
    /// - Parameters:
    ///   - key: The key used for caching the image.
    ///   - identifier: Processor identifier which used for this image. Default is the `identifier` of
    ///                 `DefaultImageProcessor.default`.
    /// - Returns: A `CacheType` instance which indicates the cache status.
    ///            `.none` means the image is not in cache or it is already expired.
    open func imageCachedType(
        forKey key: String,
        processorIdentifier identifier: String = DefaultImageProcessor.default.identifier) -> CacheType
    {
        let computedKey = key.computedKey(with: identifier)
        if memoryStorage.isCached(forKey: computedKey) { return .memory }
        if diskStorage.isCached(forKey: computedKey) { return .disk }
        return .none
    }
    
    /// Returns whether the file exists in cache for a given `key` and `identifier` combination.
    ///
    /// - Parameters:
    ///   - key: The key used for caching the image.
    ///   - identifier: Processor identifier which used for this image. Default is the `identifier` of
    ///                 `DefaultImageProcessor.default`.
    /// - Returns: A `Bool` which indicates whether a cache could match the given `key` and `identifier` combination.
    ///
    /// - Note:
    /// The return value does not contain information about from which kind of storage the cache matches.
    /// To get the information about cache type according `CacheType`,
    /// use `imageCachedType(forKey:processorIdentifier:)` instead.
    public func isCached(
        forKey key: String,
        processorIdentifier identifier: String = DefaultImageProcessor.default.identifier) -> Bool
    {
        return imageCachedType(forKey: key, processorIdentifier: identifier).cached
    }
    
    /// Gets the hash used as cache file name for the key.
    ///
    /// - Parameters:
    ///   - key: The key used for caching the image.
    ///   - identifier: Processor identifier which used for this image. Default is the `identifier` of
    ///                 `DefaultImageProcessor.default`.
    /// - Returns: The hash which is used as the cache file name.
    ///
    /// - Note:
    /// By default, for a given combination of `key` and `identifier`, `ImageCache` will use the value
    /// returned by this method as the cache file name. You can use this value to check and match cache file
    /// if you need.
    open func hash(
        forKey key: String,
        processorIdentifier identifier: String = DefaultImageProcessor.default.identifier) -> String
    {
        let computedKey = key.computedKey(with: identifier)
        return diskStorage.cacheFileName(forKey: computedKey)
    }
    
    /// Calculates the size taken by the disk storage.
    /// It is the total file size of all cached files in the `diskStorage` on disk in bytes.
    ///
    /// - Parameter handler: Called with the size calculating finishes. This closure is invoked from the main queue.
    open func calculateDiskStorageSize(completion handler: @escaping ((Result<UInt, KingfisherError>) -> Void)) {
        ioQueue.async {
            do {
                let size = try self.diskStorage.totalSize()
                DispatchQueue.main.async { handler(.success(size)) }
            } catch {
                if let error = error as? KingfisherError {
                    DispatchQueue.main.async { handler(.failure(error)) }
                } else {
                    assertionFailure("The internal thrown error should be a `KingfisherError`.")
                }
                
            }
        }
    }
    
    /// Gets the cache path for the key.
    /// It is useful for projects with web view or anyone that needs access to the local file path.
    ///
    /// i.e. Replacing the `<img src='path_for_key'>` tag in your HTML.
    ///
    /// - Parameters:
    ///   - key: The key used for caching the image.
    ///   - identifier: Processor identifier which used for this image. Default is the `identifier` of
    ///                 `DefaultImageProcessor.default`.
    /// - Returns: The disk path of cached image under the given `key` and `identifier`.
    ///
    /// - Note:
    /// This method does not guarantee there is an image already cached in the returned path. It just gives your
    /// the path that the image should be, if it exists in disk storage.
    ///
    /// You could use `isCached(forKey:)` method to check whether the image is cached under that key in disk.
    open func cachePath(
        forKey key: String,
        processorIdentifier identifier: String = DefaultImageProcessor.default.identifier) -> String
    {
        let computedKey = key.computedKey(with: identifier)
        return diskStorage.cacheFileURL(forKey: computedKey).path
    }
}
extension Dictionary {
    func keysSortedByValue(_ isOrderedBefore: (Value, Value) -> Bool) -> [Key] {
        return Array(self).sorted{ isOrderedBefore($0.1, $1.1) }.map{ $0.0 }
    }
}
#if !os(macOS) && !os(watchOS)
// MARK: - For App Extensions
extension UIApplication: KingfisherCompatible { }
extension KingfisherWrapper where Base: UIApplication {
    public static var shared: UIApplication? {
        let selector = NSSelectorFromString("sharedApplication")
        guard Base.responds(to: selector) else { return nil }
        return Base.perform(selector).takeUnretainedValue() as? UIApplication
    }
}
#endif
extension String {
    func computedKey(with identifier: String) -> String {
        if identifier.isEmpty {
            return self
        } else {
            return appending("@\(identifier)")
        }
    }
}
extension ImageCache {
    /// Creates an `ImageCache` with a given `name`, cache directory `path`
    /// and a closure to modify the cache directory.
    ///
    /// - Parameters:
    ///   - name: The name of cache object. It is used to setup disk cache directories and IO queue.
    ///           You should not use the same `name` for different caches, otherwise, the disk storage would
    ///           be conflicting to each other.
    ///   - path: Location of cache URL on disk. It will be internally pass to the initializer of `DiskStorage` as the
    ///           disk cache directory.
    ///   - diskCachePathClosure: Closure that takes in an optional initial path string and generates
    ///                           the final disk cache path. You could use it to fully customize your cache path.
    /// - Throws: An error that happens during image cache creating, such as unable to create a directory at the given
    ///           path.
    @available(*, deprecated, message: "Use `init(name:cacheDirectoryURL:diskCachePathClosure:)` instead",
    renamed: "init(name:cacheDirectoryURL:diskCachePathClosure:)")
    public convenience init(
        name: String,
        path: String?,
        diskCachePathClosure: DiskCachePathClosure? = nil) throws
    {
        let directoryURL = path.flatMap { URL(string: $0) }
        try self.init(name: name, cacheDirectoryURL: directoryURL, diskCachePathClosure: diskCachePathClosure)
    }
}
//
//  MemoryStorage.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/10/15.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents a set of conception related to storage which stores a certain type of value in memory.
/// This is a namespace for the memory storage types. A `Backend` with a certain `Config` will be used to describe the
/// storage. See these composed types for more information.
public enum MemoryStorage {
    /// Represents a storage which stores a certain type of value in memory. It provides fast access,
    /// but limited storing size. The stored value type needs to conform to `CacheCostCalculable`,
    /// and its `cacheCost` will be used to determine the cost of size for the cache item.
    ///
    /// You can config a `MemoryStorage.Backend` in its initializer by passing a `MemoryStorage.Config` value.
    /// or modifying the `config` property after it being created. The backend of `MemoryStorage` has
    /// upper limitation on cost size in memory and item count. All items in the storage has an expiration
    /// date. When retrieved, if the target item is already expired, it will be recognized as it does not
    /// exist in the storage. The `MemoryStorage` also contains a scheduled self clean task, to evict expired
    /// items from memory.
    public class Backend<T: CacheCostCalculable> {
        let storage = NSCache<NSString, StorageObject<T>>()
        // Keys trackes the objects once inside the storage. For object removing triggered by user, the corresponding
        // key would be also removed. However, for the object removing triggered by cache rule/policy of system, the
        // key will be remained there until next `removeExpired` happens.
        //
        // Breaking the strict tracking could save additional locking behaviors.
        // See https://github.com/onevcat/Kingfisher/issues/1233
        var keys = Set<String>()
        private var cleanTimer: Timer? = nil
        private let lock = NSLock()
        /// The config used in this storage. It is a value you can set and
        /// use to config the storage in air.
        public var config: Config {
            didSet {
                storage.totalCostLimit = config.totalCostLimit
                storage.countLimit = config.countLimit
            }
        }
        /// Creates a `MemoryStorage` with a given `config`.
        ///
        /// - Parameter config: The config used to create the storage. It determines the max size limitation,
        ///                     default expiration setting and more.
        public init(config: Config) {
            self.config = config
            storage.totalCostLimit = config.totalCostLimit
            storage.countLimit = config.countLimit
            cleanTimer = .scheduledTimer(withTimeInterval: config.cleanInterval, repeats: true) { [weak self] _ in
                guard let self = self else { return }
                self.removeExpired()
            }
        }
        func removeExpired() {
            lock.lock()
            defer { lock.unlock() }
            for key in keys {
                let nsKey = key as NSString
                guard let object = storage.object(forKey: nsKey) else {
                    // This could happen if the object is moved by cache `totalCostLimit` or `countLimit` rule.
                    // We didn't remove the key yet until now, since we do not want to introduce additional lock.
                    // See https://github.com/onevcat/Kingfisher/issues/1233
                    keys.remove(key)
                    continue
                }
                if object.estimatedExpiration.isPast {
                    storage.removeObject(forKey: nsKey)
                    keys.remove(key)
                }
            }
        }
        // Storing in memory will not throw. It is just for meeting protocol requirement and
        // forwarding to no throwing method.
        func store(
            value: T,
            forKey key: String,
            expiration: StorageExpiration? = nil) throws
        {
            storeNoThrow(value: value, forKey: key, expiration: expiration)
        }
        // The no throw version for storing value in cache. Kingfisher knows the detail so it
        // could use this version to make syntax simpler internally.
        func storeNoThrow(
            value: T,
            forKey key: String,
            expiration: StorageExpiration? = nil)
        {
            lock.lock()
            defer { lock.unlock() }
            let expiration = expiration ?? config.expiration
            // The expiration indicates that already expired, no need to store.
            guard !expiration.isExpired else { return }
            
            let object = StorageObject(value, key: key, expiration: expiration)
            storage.setObject(object, forKey: key as NSString, cost: value.cacheCost)
            keys.insert(key)
        }
        
        /// Use this when you actually access the memory cached item.
        /// By default, this will extend the expired data for the accessed item.
        ///
        /// - Parameters:
        ///   - key: Cache Key
        ///   - extendingExpiration: expiration value to extend item expiration time:
        ///     * .none: The item expires after the original time, without extending after access.
        ///     * .cacheTime: The item expiration extends by the original cache time after each access.
        ///     * .expirationTime: The item expiration extends by the provided time after each access.
        /// - Returns: cached object or nil
        func value(forKey key: String, extendingExpiration: ExpirationExtending = .cacheTime) -> T? {
            guard let object = storage.object(forKey: key as NSString) else {
                return nil
            }
            if object.expired {
                return nil
            }
            object.extendExpiration(extendingExpiration)
            return object.value
        }
        func isCached(forKey key: String) -> Bool {
            guard let _ = value(forKey: key, extendingExpiration: .none) else {
                return false
            }
            return true
        }
        func remove(forKey key: String) throws {
            lock.lock()
            defer { lock.unlock() }
            storage.removeObject(forKey: key as NSString)
            keys.remove(key)
        }
        func removeAll() throws {
            lock.lock()
            defer { lock.unlock() }
            storage.removeAllObjects()
            keys.removeAll()
        }
    }
}
extension MemoryStorage {
    /// Represents the config used in a `MemoryStorage`.
    public struct Config {
        /// Total cost limit of the storage in bytes.
        public var totalCostLimit: Int
        /// The item count limit of the memory storage.
        public var countLimit: Int = .max
        /// The `StorageExpiration` used in this memory storage. Default is `.seconds(300)`,
        /// means that the memory cache would expire in 5 minutes.
        public var expiration: StorageExpiration = .seconds(300)
        /// The time interval between the storage do clean work for swiping expired items.
        public let cleanInterval: TimeInterval
        /// Creates a config from a given `totalCostLimit` value.
        ///
        /// - Parameters:
        ///   - totalCostLimit: Total cost limit of the storage in bytes.
        ///   - cleanInterval: The time interval between the storage do clean work for swiping expired items.
        ///                    Default is 120, means the auto eviction happens once per two minutes.
        ///
        /// - Note:
        /// Other members of `MemoryStorage.Config` will use their default values when created.
        public init(totalCostLimit: Int, cleanInterval: TimeInterval = 120) {
            self.totalCostLimit = totalCostLimit
            self.cleanInterval = cleanInterval
        }
    }
}
extension MemoryStorage {
    class StorageObject<T> {
        let value: T
        let expiration: StorageExpiration
        let key: String
        
        private(set) var estimatedExpiration: Date
        
        init(_ value: T, key: String, expiration: StorageExpiration) {
            self.value = value
            self.key = key
            self.expiration = expiration
            
            self.estimatedExpiration = expiration.estimatedExpirationSinceNow
        }
        func extendExpiration(_ extendingExpiration: ExpirationExtending = .cacheTime) {
            switch extendingExpiration {
            case .none:
                return
            case .cacheTime:
                self.estimatedExpiration = expiration.estimatedExpirationSinceNow
            case .expirationTime(let expirationTime):
                self.estimatedExpiration = expirationTime.estimatedExpirationSinceNow
            }
        }
        
        var expired: Bool {
            return estimatedExpiration.isPast
        }
    }
}
//
//  DiskStorage.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/10/15.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents a set of conception related to storage which stores a certain type of value in disk.
/// This is a namespace for the disk storage types. A `Backend` with a certain `Config` will be used to describe the
/// storage. See these composed types for more information.
public enum DiskStorage {
    /// Represents a storage back-end for the `DiskStorage`. The value is serialized to data
    /// and stored as file in the file system under a specified location.
    ///
    /// You can config a `DiskStorage.Backend` in its initializer by passing a `DiskStorage.Config` value.
    /// or modifying the `config` property after it being created. `DiskStorage` will use file's attributes to keep
    /// track of a file for its expiration or size limitation.
    public class Backend<T: DataTransformable> {
        /// The config used for this disk storage.
        public var config: Config
        // The final storage URL on disk, with `name` and `cachePathBlock` considered.
        public let directoryURL: URL
        let metaChangingQueue: DispatchQueue
        var maybeCached : Set<String>?
        let maybeCachedCheckingQueue = DispatchQueue(label: "com.onevcat.Kingfisher.maybeCachedCheckingQueue")
        /// Creates a disk storage with the given `DiskStorage.Config`.
        ///
        /// - Parameter config: The config used for this disk storage.
        /// - Throws: An error if the folder for storage cannot be got or created.
        public init(config: Config) throws {
            self.config = config
            let url: URL
            if let directory = config.directory {
                url = directory
            } else {
                url = try config.fileManager.url(
                    for: .cachesDirectory,
                    in: .userDomainMask,
                    appropriateFor: nil,
                    create: true)
            }
            let cacheName = "com.onevcat.Kingfisher.ImageCache.\(config.name)"
            directoryURL = config.cachePathBlock(url, cacheName)
            metaChangingQueue = DispatchQueue(label: cacheName)
            try prepareDirectory()
            maybeCachedCheckingQueue.async {
                do {
                    self.maybeCached = Set()
                    try config.fileManager.contentsOfDirectory(atPath: self.directoryURL.path).forEach { fileName in
                        self.maybeCached?.insert(fileName)
                    }
                } catch {
                    // Just disable the functionality if we fail to initialize it properly. This will just revert to
                    // the behavior which is to check file existence on disk directly.
                    self.maybeCached = nil
                }
            }
        }
        // Creates the storage folder.
        func prepareDirectory() throws {
            let fileManager = config.fileManager
            let path = directoryURL.path
            guard !fileManager.fileExists(atPath: path) else { return }
            do {
                try fileManager.createDirectory(
                    atPath: path,
                    withIntermediateDirectories: true,
                    attributes: nil)
            } catch {
                throw KingfisherError.cacheError(reason: .cannotCreateDirectory(path: path, error: error))
            }
        }
        func store(
            value: T,
            forKey key: String,
            expiration: StorageExpiration? = nil) throws
        {
            let expiration = expiration ?? config.expiration
            // The expiration indicates that already expired, no need to store.
            guard !expiration.isExpired else { return }
            
            let data: Data
            do {
                data = try value.toData()
            } catch {
                throw KingfisherError.cacheError(reason: .cannotConvertToData(object: value, error: error))
            }
            let fileURL = cacheFileURL(forKey: key)
            do {
                try data.write(to: fileURL)
            } catch {
                throw KingfisherError.cacheError(
                    reason: .cannotCreateCacheFile(fileURL: fileURL, key: key, data: data, error: error)
                )
            }
            let now = Date()
            let attributes: [FileAttributeKey : Any] = [
                // The last access date.
                .creationDate: now.fileAttributeDate,
                // The estimated expiration date.
                .modificationDate: expiration.estimatedExpirationSinceNow.fileAttributeDate
            ]
            do {
                try config.fileManager.setAttributes(attributes, ofItemAtPath: fileURL.path)
            } catch {
                try? config.fileManager.removeItem(at: fileURL)
                throw KingfisherError.cacheError(
                    reason: .cannotSetCacheFileAttribute(
                        filePath: fileURL.path,
                        attributes: attributes,
                        error: error
                    )
                )
            }
            maybeCachedCheckingQueue.async {
                self.maybeCached?.insert(fileURL.lastPathComponent)
            }
        }
        func value(forKey key: String, extendingExpiration: ExpirationExtending = .cacheTime) throws -> T? {
            return try value(forKey: key, referenceDate: Date(), actuallyLoad: true, extendingExpiration: extendingExpiration)
        }
        func value(
            forKey key: String,
            referenceDate: Date,
            actuallyLoad: Bool,
            extendingExpiration: ExpirationExtending) throws -> T?
        {
            let fileManager = config.fileManager
            let fileURL = cacheFileURL(forKey: key)
            let filePath = fileURL.path
            let fileMaybeCached = maybeCachedCheckingQueue.sync {
                return maybeCached?.contains(fileURL.lastPathComponent) ?? true
            }
            guard fileMaybeCached else {
                return nil
            }
            guard fileManager.fileExists(atPath: filePath) else {
                return nil
            }
            let meta: FileMeta
            do {
                let resourceKeys: Set<URLResourceKey> = [.contentModificationDateKey, .creationDateKey]
                meta = try FileMeta(fileURL: fileURL, resourceKeys: resourceKeys)
            } catch {
                throw KingfisherError.cacheError(
                    reason: .invalidURLResource(error: error, key: key, url: fileURL))
            }
            if meta.expired(referenceDate: referenceDate) {
                return nil
            }
            if !actuallyLoad { return T.empty }
            do {
                let data = try Data(contentsOf: fileURL)
                let obj = try T.fromData(data)
                metaChangingQueue.async {
                    meta.extendExpiration(with: fileManager, extendingExpiration: extendingExpiration)
                }
                return obj
            } catch {
                throw KingfisherError.cacheError(reason: .cannotLoadDataFromDisk(url: fileURL, error: error))
            }
        }
        func isCached(forKey key: String) -> Bool {
            return isCached(forKey: key, referenceDate: Date())
        }
        func isCached(forKey key: String, referenceDate: Date) -> Bool {
            do {
                let result = try value(
                    forKey: key,
                    referenceDate: referenceDate,
                    actuallyLoad: false,
                    extendingExpiration: .none
                )
                return result != nil
            } catch {
                return false
            }
        }
        func remove(forKey key: String) throws {
            let fileURL = cacheFileURL(forKey: key)
            try removeFile(at: fileURL)
        }
        func removeFile(at url: URL) throws {
            try config.fileManager.removeItem(at: url)
        }
        func removeAll() throws {
            try removeAll(skipCreatingDirectory: false)
        }
        func removeAll(skipCreatingDirectory: Bool) throws {
            try config.fileManager.removeItem(at: directoryURL)
            if !skipCreatingDirectory {
                try prepareDirectory()
            }
        }
        /// The URL of the cached file with a given computed `key`.
        ///
        /// - Note:
        /// This method does not guarantee there is an image already cached in the returned URL. It just gives your
        /// the URL that the image should be if it exists in disk storage, with the give key.
        ///
        /// - Parameter key: The final computed key used when caching the image. Please note that usually this is not
        /// the `cacheKey` of an image `Source`. It is the computed key with processor identifier considered.
        public func cacheFileURL(forKey key: String) -> URL {
            let fileName = cacheFileName(forKey: key)
            return directoryURL.appendingPathComponent(fileName, isDirectory: false)
        }
        func cacheFileName(forKey key: String) -> String {
            if config.usesHashedFileName {
                let hashedKey = key.kf.md5
                if let ext = config.pathExtension {
                    return "\(hashedKey).\(ext)"
                }
                return hashedKey
            } else {
                if let ext = config.pathExtension {
                    return "\(key).\(ext)"
                }
                return key
            }
        }
        func allFileURLs(for propertyKeys: [URLResourceKey]) throws -> [URL] {
            let fileManager = config.fileManager
            guard let directoryEnumerator = fileManager.enumerator(
                at: directoryURL, includingPropertiesForKeys: propertyKeys, options: .skipsHiddenFiles) else
            {
                throw KingfisherError.cacheError(reason: .fileEnumeratorCreationFailed(url: directoryURL))
            }
            guard let urls = directoryEnumerator.allObjects as? [URL] else {
                throw KingfisherError.cacheError(reason: .invalidFileEnumeratorContent(url: directoryURL))
            }
            return urls
        }
        func removeExpiredValues(referenceDate: Date = Date()) throws -> [URL] {
            let propertyKeys: [URLResourceKey] = [
                .isDirectoryKey,
                .contentModificationDateKey
            ]
            let urls = try allFileURLs(for: propertyKeys)
            let keys = Set(propertyKeys)
            let expiredFiles = urls.filter { fileURL in
                do {
                    let meta = try FileMeta(fileURL: fileURL, resourceKeys: keys)
                    if meta.isDirectory {
                        return false
                    }
                    return meta.expired(referenceDate: referenceDate)
                } catch {
                    return true
                }
            }
            try expiredFiles.forEach { url in
                try removeFile(at: url)
            }
            return expiredFiles
        }
        func removeSizeExceededValues() throws -> [URL] {
            if config.sizeLimit == 0 { return [] } // Back compatible. 0 means no limit.
            var size = try totalSize()
            if size < config.sizeLimit { return [] }
            let propertyKeys: [URLResourceKey] = [
                .isDirectoryKey,
                .creationDateKey,
                .fileSizeKey
            ]
            let keys = Set(propertyKeys)
            let urls = try allFileURLs(for: propertyKeys)
            var pendings: [FileMeta] = urls.compactMap { fileURL in
                guard let meta = try? FileMeta(fileURL: fileURL, resourceKeys: keys) else {
                    return nil
                }
                return meta
            }
            // Sort by last access date. Most recent file first.
            pendings.sort(by: FileMeta.lastAccessDate)
            var removed: [URL] = []
            let target = config.sizeLimit / 2
            while size > target, let meta = pendings.popLast() {
                size -= UInt(meta.fileSize)
                try removeFile(at: meta.url)
                removed.append(meta.url)
            }
            return removed
        }
        /// Get the total file size of the folder in bytes.
        func totalSize() throws -> UInt {
            let propertyKeys: [URLResourceKey] = [.fileSizeKey]
            let urls = try allFileURLs(for: propertyKeys)
            let keys = Set(propertyKeys)
            let totalSize: UInt = urls.reduce(0) { size, fileURL in
                do {
                    let meta = try FileMeta(fileURL: fileURL, resourceKeys: keys)
                    return size + UInt(meta.fileSize)
                } catch {
                    return size
                }
            }
            return totalSize
        }
    }
}
extension DiskStorage {
    /// Represents the config used in a `DiskStorage`.
    public struct Config {
        /// The file size limit on disk of the storage in bytes. 0 means no limit.
        public var sizeLimit: UInt
        /// The `StorageExpiration` used in this disk storage. Default is `.days(7)`,
        /// means that the disk cache would expire in one week.
        public var expiration: StorageExpiration = .days(7)
        /// The preferred extension of cache item. It will be appended to the file name as its extension.
        /// Default is `nil`, means that the cache file does not contain a file extension.
        public var pathExtension: String? = nil
        /// Default is `true`, means that the cache file name will be hashed before storing.
        public var usesHashedFileName = true
        let name: String
        let fileManager: FileManager
        let directory: URL?
        var cachePathBlock: ((_ directory: URL, _ cacheName: String) -> URL)! = {
            (directory, cacheName) in
            return directory.appendingPathComponent(cacheName, isDirectory: true)
        }
        /// Creates a config value based on given parameters.
        ///
        /// - Parameters:
        ///   - name: The name of cache. It is used as a part of storage folder. It is used to identify the disk
        ///           storage. Two storages with the same `name` would share the same folder in disk, and it should
        ///           be prevented.
        ///   - sizeLimit: The size limit in bytes for all existing files in the disk storage.
        ///   - fileManager: The `FileManager` used to manipulate files on disk. Default is `FileManager.default`.
        ///   - directory: The URL where the disk storage should live. The storage will use this as the root folder,
        ///                and append a path which is constructed by input `name`. Default is `nil`, indicates that
        ///                the cache directory under user domain mask will be used.
        public init(
            name: String,
            sizeLimit: UInt,
            fileManager: FileManager = .default,
            directory: URL? = nil)
        {
            self.name = name
            self.fileManager = fileManager
            self.directory = directory
            self.sizeLimit = sizeLimit
        }
    }
}
extension DiskStorage {
    struct FileMeta {
    
        let url: URL
        
        let lastAccessDate: Date?
        let estimatedExpirationDate: Date?
        let isDirectory: Bool
        let fileSize: Int
        
        static func lastAccessDate(lhs: FileMeta, rhs: FileMeta) -> Bool {
            return lhs.lastAccessDate ?? .distantPast > rhs.lastAccessDate ?? .distantPast
        }
        
        init(fileURL: URL, resourceKeys: Set<URLResourceKey>) throws {
            let meta = try fileURL.resourceValues(forKeys: resourceKeys)
            self.init(
                fileURL: fileURL,
                lastAccessDate: meta.creationDate,
                estimatedExpirationDate: meta.contentModificationDate,
                isDirectory: meta.isDirectory ?? false,
                fileSize: meta.fileSize ?? 0)
        }
        
        init(
            fileURL: URL,
            lastAccessDate: Date?,
            estimatedExpirationDate: Date?,
            isDirectory: Bool,
            fileSize: Int)
        {
            self.url = fileURL
            self.lastAccessDate = lastAccessDate
            self.estimatedExpirationDate = estimatedExpirationDate
            self.isDirectory = isDirectory
            self.fileSize = fileSize
        }
        func expired(referenceDate: Date) -> Bool {
            return estimatedExpirationDate?.isPast(referenceDate: referenceDate) ?? true
        }
        
        func extendExpiration(with fileManager: FileManager, extendingExpiration: ExpirationExtending) {
            guard let lastAccessDate = lastAccessDate,
                  let lastEstimatedExpiration = estimatedExpirationDate else
            {
                return
            }
            let attributes: [FileAttributeKey : Any]
            switch extendingExpiration {
            case .none:
                // not extending expiration time here
                return
            case .cacheTime:
                let originalExpiration: StorageExpiration =
                    .seconds(lastEstimatedExpiration.timeIntervalSince(lastAccessDate))
                attributes = [
                    .creationDate: Date().fileAttributeDate,
                    .modificationDate: originalExpiration.estimatedExpirationSinceNow.fileAttributeDate
                ]
            case .expirationTime(let expirationTime):
                attributes = [
                    .creationDate: Date().fileAttributeDate,
                    .modificationDate: expirationTime.estimatedExpirationSinceNow.fileAttributeDate
                ]
            }
            try? fileManager.setAttributes(attributes, ofItemAtPath: url.path)
        }
    }
}
//
//  CacheSerializer.swift
//  Kingfisher
//
//  Created by Wei Wang on 2016/09/02.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
import CoreGraphics
/// An `CacheSerializer` is used to convert some data to an image object after
/// retrieving it from disk storage, and vice versa, to convert an image to data object
/// for storing to the disk storage.
public protocol CacheSerializer {
    
    /// Gets the serialized data from a provided image
    /// and optional original data for caching to disk.
    ///
    /// - Parameters:
    ///   - image: The image needed to be serialized.
    ///   - original: The original data which is just downloaded.
    ///               If the image is retrieved from cache instead of
    ///               downloaded, it will be `nil`.
    /// - Returns: The data object for storing to disk, or `nil` when no valid
    ///            data could be serialized.
    func data(with image: KFCrossPlatformImage, original: Data?) -> Data?
    /// Gets an image from provided serialized data.
    ///
    /// - Parameters:
    ///   - data: The data from which an image should be deserialized.
    ///   - options: The parsed options for deserialization.
    /// - Returns: An image deserialized or `nil` when no valid image
    ///            could be deserialized.
    func image(with data: Data, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage?
    
    /// Gets an image deserialized from provided data.
    ///
    /// - Parameters:
    ///   - data: The data from which an image should be deserialized.
    ///   - options: Options for deserialization.
    /// - Returns: An image deserialized or `nil` when no valid image
    ///            could be deserialized.
    /// - Note:
    /// This method is deprecated. Please implement the version with
    /// `KingfisherParsedOptionsInfo` as parameter instead.
    @available(*, deprecated,
    message: "Deprecated. Implement the method with same name but with `KingfisherParsedOptionsInfo` instead.")
    func image(with data: Data, options: KingfisherOptionsInfo?) -> KFCrossPlatformImage?
}
extension CacheSerializer {
    public func image(with data: Data, options: KingfisherOptionsInfo?) -> KFCrossPlatformImage? {
        return image(with: data, options: KingfisherParsedOptionsInfo(options))
    }
}
/// Represents a basic and default `CacheSerializer` used in Kingfisher disk cache system.
/// It could serialize and deserialize images in PNG, JPEG and GIF format. For
/// image other than these formats, a normalized `pngRepresentation` will be used.
public struct DefaultCacheSerializer: CacheSerializer {
    
    /// The default general cache serializer used across Kingfisher's cache.
    public static let `default` = DefaultCacheSerializer()
    /// The compression quality when converting image to a lossy format data. Default is 1.0.
    public var compressionQuality: CGFloat = 1.0
    /// Whether the original data should be preferred when serializing the image.
    /// If `true`, the input original data will be checked first and used unless the data is `nil`.
    /// In that case, the serialization will fall back to creating data from image.
    public var preferCacheOriginalData: Bool = false
    /// Creates a cache serializer that serialize and deserialize images in PNG, JPEG and GIF format.
    ///
    /// - Note:
    /// Use `DefaultCacheSerializer.default` unless you need to specify your own properties.
    ///
    public init() { }
    /// - Parameters:
    ///   - image: The image needed to be serialized.
    ///   - original: The original data which is just downloaded.
    ///               If the image is retrieved from cache instead of
    ///               downloaded, it will be `nil`.
    /// - Returns: The data object for storing to disk, or `nil` when no valid
    ///            data could be serialized.
    ///
    /// - Note:
    /// Only when `original` contains valid PNG, JPEG and GIF format data, the `image` will be
    /// converted to the corresponding data type. Otherwise, if the `original` is provided but it is not
    /// If `original` is `nil`, the input `image` will be encoded as PNG data.
    public func data(with image: KFCrossPlatformImage, original: Data?) -> Data? {
        if preferCacheOriginalData {
            return original ??
                image.kf.data(
                    format: original?.kf.imageFormat ?? .unknown,
                    compressionQuality: compressionQuality
                )
        } else {
            return image.kf.data(
                format: original?.kf.imageFormat ?? .unknown,
                compressionQuality: compressionQuality
            )
        }
    }
    
    /// Gets an image deserialized from provided data.
    ///
    /// - Parameters:
    ///   - data: The data from which an image should be deserialized.
    ///   - options: Options for deserialization.
    /// - Returns: An image deserialized or `nil` when no valid image
    ///            could be deserialized.
    public func image(with data: Data, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        return KingfisherWrapper.image(data: data, options: options.imageCreatingOptions)
    }
}
//
//  RequestModifier.swift
//  Kingfisher
//
//  Created by Junyu Kuang on 5/28/17.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
import CoreGraphics
/// `FormatIndicatedCacheSerializer` lets you indicate an image format for serialized caches.
///
/// It could serialize and deserialize PNG, JPEG and GIF images. For
/// image other than these formats, a normalized `pngRepresentation` will be used.
///
/// Example:
/// ````
/// let profileImageSize = CGSize(width: 44, height: 44)
///
/// // A round corner image.
/// let imageProcessor = RoundCornerImageProcessor(
///     cornerRadius: profileImageSize.width / 2, targetSize: profileImageSize)
///
/// let optionsInfo: KingfisherOptionsInfo = [
///     .cacheSerializer(FormatIndicatedCacheSerializer.png), 
///     .processor(imageProcessor)]
///
/// A URL pointing to a JPEG image.
/// let url = URL(string: "https://example.com/image.jpg")!
///
/// // Image will be always cached as PNG format to preserve alpha channel for round rectangle.
/// // So when you load it from cache again later, it will be still round cornered.
/// // Otherwise, the corner part would be filled by white color (since JPEG does not contain an alpha channel).
/// imageView.kf.setImage(with: url, options: optionsInfo)
/// ````
public struct FormatIndicatedCacheSerializer: CacheSerializer {
    
    /// A `FormatIndicatedCacheSerializer` which converts image from and to PNG format. If the image cannot be
    /// represented by PNG format, it will fallback to its real format which is determined by `original` data.
    public static let png = FormatIndicatedCacheSerializer(imageFormat: .PNG, jpegCompressionQuality: nil)
    
    /// A `FormatIndicatedCacheSerializer` which converts image from and to JPEG format. If the image cannot be
    /// represented by JPEG format, it will fallback to its real format which is determined by `original` data.
    /// The compression quality is 1.0 when using this serializer. If you need to set a customized compression quality,
    /// use `jpeg(compressionQuality:)`.
    public static let jpeg = FormatIndicatedCacheSerializer(imageFormat: .JPEG, jpegCompressionQuality: 1.0)
    /// A `FormatIndicatedCacheSerializer` which converts image from and to JPEG format with a settable compression
    /// quality. If the image cannot be represented by JPEG format, it will fallback to its real format which is
    /// determined by `original` data.
    /// - Parameter compressionQuality: The compression quality when converting image to JPEG data.
    public static func jpeg(compressionQuality: CGFloat) -> FormatIndicatedCacheSerializer {
        return FormatIndicatedCacheSerializer(imageFormat: .JPEG, jpegCompressionQuality: compressionQuality)
    }
    
    /// A `FormatIndicatedCacheSerializer` which converts image from and to GIF format. If the image cannot be
    /// represented by GIF format, it will fallback to its real format which is determined by `original` data.
    public static let gif = FormatIndicatedCacheSerializer(imageFormat: .GIF, jpegCompressionQuality: nil)
    
    /// The indicated image format.
    private let imageFormat: ImageFormat
    /// The compression quality used for loss image format (like JPEG).
    private let jpegCompressionQuality: CGFloat?
    
    /// Creates data which represents the given `image` under a format.
    public func data(with image: KFCrossPlatformImage, original: Data?) -> Data? {
        
        func imageData(withFormat imageFormat: ImageFormat) -> Data? {
            return autoreleasepool { () -> Data? in
                switch imageFormat {
                case .PNG: return image.kf.pngRepresentation()
                case .JPEG: return image.kf.jpegRepresentation(compressionQuality: jpegCompressionQuality ?? 1.0)
                case .GIF: return image.kf.gifRepresentation()
                case .unknown: return nil
                }
            }
        }
        
        // generate data with indicated image format
        if let data = imageData(withFormat: imageFormat) {
            return data
        }
        
        let originalFormat = original?.kf.imageFormat ?? .unknown
        
        // generate data with original image's format
        if originalFormat != imageFormat, let data = imageData(withFormat: originalFormat) {
            return data
        }
        
        return original ?? image.kf.normalized.kf.pngRepresentation()
    }
    
    /// Same implementation as `DefaultCacheSerializer`.
    public func image(with data: Data, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        return KingfisherWrapper.image(data: data, options: options.imageCreatingOptions)
    }
}
//
//  Kingfisher.swift
//  Kingfisher
//
//  Created by Wei Wang on 16/9/14.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
import ImageIO
#if os(macOS)
import AppKit
public typealias KFCrossPlatformImage = NSImage
public typealias KFCrossPlatformView = NSView
public typealias KFCrossPlatformColor = NSColor
public typealias KFCrossPlatformImageView = NSImageView
public typealias KFCrossPlatformButton = NSButton
#else
import UIKit
public typealias KFCrossPlatformImage = UIImage
public typealias KFCrossPlatformColor = UIColor
#if !os(watchOS)
public typealias KFCrossPlatformImageView = UIImageView
public typealias KFCrossPlatformView = UIView
public typealias KFCrossPlatformButton = UIButton
#else
import WatchKit
#endif
#endif
/// Wrapper for Kingfisher compatible types. This type provides an extension point for
/// connivence methods in Kingfisher.
public struct KingfisherWrapper<Base> {
    public let base: Base
    public init(_ base: Base) {
        self.base = base
    }
}
/// Represents an object type that is compatible with Kingfisher. You can use `kf` property to get a
/// value in the namespace of Kingfisher.
public protocol KingfisherCompatible: AnyObject { }
/// Represents a value type that is compatible with Kingfisher. You can use `kf` property to get a
/// value in the namespace of Kingfisher.
public protocol KingfisherCompatibleValue {}
extension KingfisherCompatible {
    /// Gets a namespace holder for Kingfisher compatible types.
    public var kf: KingfisherWrapper<Self> {
        get { return KingfisherWrapper(self) }
        set { }
    }
}
extension KingfisherCompatibleValue {
    /// Gets a namespace holder for Kingfisher compatible types.
    public var kf: KingfisherWrapper<Self> {
        get { return KingfisherWrapper(self) }
        set { }
    }
}
extension KFCrossPlatformImage: KingfisherCompatible { }
#if !os(watchOS)
extension KFCrossPlatformImageView: KingfisherCompatible { }
extension KFCrossPlatformButton: KingfisherCompatible { }
extension NSTextAttachment: KingfisherCompatible { }
#else
extension WKInterfaceImage: KingfisherCompatible { }
#endif
//
//  KingfisherError.swift
//  Kingfisher
//
//  Created by onevcat on 2018/09/26.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
extension Never {}
/// Represents all the errors which can happen in Kingfisher framework.
/// Kingfisher related methods always throw a `KingfisherError` or invoke the callback with `KingfisherError`
/// as its error type. To handle errors from Kingfisher, you switch over the error to get a reason catalog,
/// then switch over the reason to know error detail.
public enum KingfisherError: Error {
    // MARK: Error Reason Types
    /// Represents the error reason during networking request phase.
    ///
    /// - emptyRequest: The request is empty. Code 1001.
    /// - invalidURL: The URL of request is invalid. Code 1002.
    /// - taskCancelled: The downloading task is cancelled by user. Code 1003.
    public enum RequestErrorReason {
        
        /// The request is empty. Code 1001.
        case emptyRequest
        
        /// The URL of request is invalid. Code 1002.
        /// - request: The request is tend to be sent but its URL is invalid.
        case invalidURL(request: URLRequest)
        
        /// The downloading task is cancelled by user. Code 1003.
        /// - task: The session data task which is cancelled.
        /// - token: The cancel token which is used for cancelling the task.
        case taskCancelled(task: SessionDataTask, token: SessionDataTask.CancelToken)
    }
    
    /// Represents the error reason during networking response phase.
    ///
    /// - invalidURLResponse: The response is not a valid URL response. Code 2001.
    /// - invalidHTTPStatusCode: The response contains an invalid HTTP status code. Code 2002.
    /// - URLSessionError: An error happens in the system URL session. Code 2003.
    /// - dataModifyingFailed: Data modifying fails on returning a valid data. Code 2004.
    /// - noURLResponse: The task is done but no URL response found. Code 2005.
    public enum ResponseErrorReason {
        
        /// The response is not a valid URL response. Code 2001.
        /// - response: The received invalid URL response.
        ///             The response is expected to be an HTTP response, but it is not.
        case invalidURLResponse(response: URLResponse)
        
        /// The response contains an invalid HTTP status code. Code 2002.
        /// - Note:
        ///   By default, status code 200..<400 is recognized as valid. You can override
        ///   this behavior by conforming to the `ImageDownloaderDelegate`.
        /// - response: The received response.
        case invalidHTTPStatusCode(response: HTTPURLResponse)
        
        /// An error happens in the system URL session. Code 2003.
        /// - error: The underlying URLSession error object.
        case URLSessionError(error: Error)
        
        /// Data modifying fails on returning a valid data. Code 2004.
        /// - task: The failed task.
        case dataModifyingFailed(task: SessionDataTask)
        
        /// The task is done but no URL response found. Code 2005.
        /// - task: The failed task.
        case noURLResponse(task: SessionDataTask)
    }
    
    /// Represents the error reason during Kingfisher caching system.
    ///
    /// - fileEnumeratorCreationFailed: Cannot create a file enumerator for a certain disk URL. Code 3001.
    /// - invalidFileEnumeratorContent: Cannot get correct file contents from a file enumerator. Code 3002.
    /// - invalidURLResource: The file at target URL exists, but its URL resource is unavailable. Code 3003.
    /// - cannotLoadDataFromDisk: The file at target URL exists, but the data cannot be loaded from it. Code 3004.
    /// - cannotCreateDirectory: Cannot create a folder at a given path. Code 3005.
    /// - imageNotExisting: The requested image does not exist in cache. Code 3006.
    /// - cannotConvertToData: Cannot convert an object to data for storing. Code 3007.
    /// - cannotSerializeImage: Cannot serialize an image to data for storing. Code 3008.
    /// - cannotCreateCacheFile: Cannot create the cache file at a certain fileURL under a key. Code 3009.
    /// - cannotSetCacheFileAttribute: Cannot set file attributes to a cached file. Code 3010.
    public enum CacheErrorReason {
        
        /// Cannot create a file enumerator for a certain disk URL. Code 3001.
        /// - url: The target disk URL from which the file enumerator should be created.
        case fileEnumeratorCreationFailed(url: URL)
        
        /// Cannot get correct file contents from a file enumerator. Code 3002.
        /// - url: The target disk URL from which the content of a file enumerator should be got.
        case invalidFileEnumeratorContent(url: URL)
        
        /// The file at target URL exists, but its URL resource is unavailable. Code 3003.
        /// - error: The underlying error thrown by file manager.
        /// - key: The key used to getting the resource from cache.
        /// - url: The disk URL where the target cached file exists.
        case invalidURLResource(error: Error, key: String, url: URL)
        
        /// The file at target URL exists, but the data cannot be loaded from it. Code 3004.
        /// - url: The disk URL where the target cached file exists.
        /// - error: The underlying error which describes why this error happens.
        case cannotLoadDataFromDisk(url: URL, error: Error)
        
        /// Cannot create a folder at a given path. Code 3005.
        /// - path: The disk path where the directory creating operation fails.
        /// - error: The underlying error which describes why this error happens.
        case cannotCreateDirectory(path: String, error: Error)
        
        /// The requested image does not exist in cache. Code 3006.
        /// - key: Key of the requested image in cache.
        case imageNotExisting(key: String)
        
        /// Cannot convert an object to data for storing. Code 3007.
        /// - object: The object which needs be convert to data.
        case cannotConvertToData(object: Any, error: Error)
        
        /// Cannot serialize an image to data for storing. Code 3008.
        /// - image: The input image needs to be serialized to cache.
        /// - original: The original image data, if exists.
        /// - serializer: The `CacheSerializer` used for the image serializing.
        case cannotSerializeImage(image: KFCrossPlatformImage?, original: Data?, serializer: CacheSerializer)
        /// Cannot create the cache file at a certain fileURL under a key. Code 3009.
        /// - fileURL: The url where the cache file should be created.
        /// - key: The cache key used for the cache. When caching a file through `KingfisherManager` and Kingfisher's
        ///        extension method, it is the resolved cache key based on your input `Source` and the image processors.
        /// - data: The data to be cached.
        /// - error: The underlying error originally thrown by Foundation when writing the `data` to the disk file at
        ///          `fileURL`.
        case cannotCreateCacheFile(fileURL: URL, key: String, data: Data, error: Error)
        /// Cannot set file attributes to a cached file. Code 3010.
        /// - filePath: The path of target cache file.
        /// - attributes: The file attribute to be set to the target file.
        /// - error: The underlying error originally thrown by Foundation when setting the `attributes` to the disk
        ///          file at `filePath`.
        case cannotSetCacheFileAttribute(filePath: String, attributes: [FileAttributeKey : Any], error: Error)
    }
    
    
    /// Represents the error reason during image processing phase.
    ///
    /// - processingFailed: Image processing fails. There is no valid output image from the processor. Code 4001.
    public enum ProcessorErrorReason {
        /// Image processing fails. There is no valid output image from the processor. Code 4001.
        /// - processor: The `ImageProcessor` used to process the image or its data in `item`.
        /// - item: The image or its data content.
        case processingFailed(processor: ImageProcessor, item: ImageProcessItem)
    }
    /// Represents the error reason during image setting in a view related class.
    ///
    /// - emptySource: The input resource is empty or `nil`. Code 5001.
    /// - notCurrentSourceTask: The source task is finished, but it is not the one expected now. Code 5002.
    /// - dataProviderError: An error happens during getting data from an `ImageDataProvider`. Code 5003.
    public enum ImageSettingErrorReason {
        
        /// The input resource is empty or `nil`. Code 5001.
        case emptySource
        
        /// The resource task is finished, but it is not the one expected now. This usually happens when you set another
        /// resource on the view without cancelling the current on-going one. The previous setting task will fail with
        /// this `.notCurrentSourceTask` error when a result got, regardless of it being successful or not for that task.
        /// The result of this original task is contained in the associated value.
        /// Code 5002.
        /// - result: The `RetrieveImageResult` if the source task is finished without problem. `nil` if an error
        ///           happens.
        /// - error: The `Error` if an issue happens during image setting task. `nil` if the task finishes without
        ///          problem.
        /// - source: The original source value of the task.
        case notCurrentSourceTask(result: RetrieveImageResult?, error: Error?, source: Source)
        /// An error happens during getting data from an `ImageDataProvider`. Code 5003.
        case dataProviderError(provider: ImageDataProvider, error: Error)
        /// No more alternative `Source` can be used in current loading process. It means that the
        /// `.alternativeSources` are used and Kingfisher tried to recovery from the original error, but still
        /// fails for all the given alternative sources. The associated value holds all the errors encountered during
        /// the load process, including the original source loading error and all the alternative sources errors.
        /// Code 5004.
        case alternativeSourcesExhausted([PropagationError])
    }
    // MARK: Member Cases
    
    /// Represents the error reason during networking request phase.
    case requestError(reason: RequestErrorReason)
    /// Represents the error reason during networking response phase.
    case responseError(reason: ResponseErrorReason)
    /// Represents the error reason during Kingfisher caching system.
    case cacheError(reason: CacheErrorReason)
    /// Represents the error reason during image processing phase.
    case processorError(reason: ProcessorErrorReason)
    /// Represents the error reason during image setting in a view related class.
    case imageSettingError(reason: ImageSettingErrorReason)
    // MARK: Helper Properties & Methods
    /// Helper property to check whether this error is a `RequestErrorReason.taskCancelled` or not.
    public var isTaskCancelled: Bool {
        if case .requestError(reason: .taskCancelled) = self {
            return true
        }
        return false
    }
    /// Helper method to check whether this error is a `ResponseErrorReason.invalidHTTPStatusCode` and the
    /// associated value is a given status code.
    ///
    /// - Parameter code: The given status code.
    /// - Returns: If `self` is a `ResponseErrorReason.invalidHTTPStatusCode` error
    ///            and its status code equals to `code`, `true` is returned. Otherwise, `false`.
    public func isInvalidResponseStatusCode(_ code: Int) -> Bool {
        if case .responseError(reason: .invalidHTTPStatusCode(let response)) = self {
            return response.statusCode == code
        }
        return false
    }
    public var isInvalidResponseStatusCode: Bool {
        if case .responseError(reason: .invalidHTTPStatusCode) = self {
            return true
        }
        return false
    }
    /// Helper property to check whether this error is a `ImageSettingErrorReason.notCurrentSourceTask` or not.
    /// When a new image setting task starts while the old one is still running, the new task identifier will be
    /// set and the old one is overwritten. A `.notCurrentSourceTask` error will be raised when the old task finishes
    /// to let you know the setting process finishes with a certain result, but the image view or button is not set.
    public var isNotCurrentTask: Bool {
        if case .imageSettingError(reason: .notCurrentSourceTask(_, _, _)) = self {
            return true
        }
        return false
    }
}
// MARK: - LocalizedError Conforming
extension KingfisherError: LocalizedError {
    
    /// A localized message describing what error occurred.
    public var errorDescription: String? {
        switch self {
        case .requestError(let reason): return reason.errorDescription
        case .responseError(let reason): return reason.errorDescription
        case .cacheError(let reason): return reason.errorDescription
        case .processorError(let reason): return reason.errorDescription
        case .imageSettingError(let reason): return reason.errorDescription
        }
    }
}
// MARK: - CustomNSError Conforming
extension KingfisherError: CustomNSError {
    /// The error domain of `KingfisherError`. All errors from Kingfisher is under this domain.
    public static let domain = "com.onevcat.Kingfisher.Error"
    /// The error code within the given domain.
    public var errorCode: Int {
        switch self {
        case .requestError(let reason): return reason.errorCode
        case .responseError(let reason): return reason.errorCode
        case .cacheError(let reason): return reason.errorCode
        case .processorError(let reason): return reason.errorCode
        case .imageSettingError(let reason): return reason.errorCode
        }
    }
}
extension KingfisherError.RequestErrorReason {
    var errorDescription: String? {
        switch self {
        case .emptyRequest:
            return "The request is empty or `nil`."
        case .invalidURL(let request):
            return "The request contains an invalid or empty URL. Request: \(request)."
        case .taskCancelled(let task, let token):
            return "The session task was cancelled. Task: \(task), cancel token: \(token)."
        }
    }
    
    var errorCode: Int {
        switch self {
        case .emptyRequest: return 1001
        case .invalidURL: return 1002
        case .taskCancelled: return 1003
        }
    }
}
extension KingfisherError.ResponseErrorReason {
    var errorDescription: String? {
        switch self {
        case .invalidURLResponse(let response):
            return "The URL response is invalid: \(response)"
        case .invalidHTTPStatusCode(let response):
            return "The HTTP status code in response is invalid. Code: \(response.statusCode), response: \(response)."
        case .URLSessionError(let error):
            return "A URL session error happened. The underlying error: \(error)"
        case .dataModifyingFailed(let task):
            return "The data modifying delegate returned `nil` for the downloaded data. Task: \(task)."
        case .noURLResponse(let task):
            return "No URL response received. Task: \(task),"
        }
    }
    
    var errorCode: Int {
        switch self {
        case .invalidURLResponse: return 2001
        case .invalidHTTPStatusCode: return 2002
        case .URLSessionError: return 2003
        case .dataModifyingFailed: return 2004
        case .noURLResponse: return 2005
        }
    }
}
extension KingfisherError.CacheErrorReason {
    var errorDescription: String? {
        switch self {
        case .fileEnumeratorCreationFailed(let url):
            return "Cannot create file enumerator for URL: \(url)."
        case .invalidFileEnumeratorContent(let url):
            return "Cannot get contents from the file enumerator at URL: \(url)."
        case .invalidURLResource(let error, let key, let url):
            return "Cannot get URL resource values or data for the given URL: \(url). " +
                   "Cache key: \(key). Underlying error: \(error)"
        case .cannotLoadDataFromDisk(let url, let error):
            return "Cannot load data from disk at URL: \(url). Underlying error: \(error)"
        case .cannotCreateDirectory(let path, let error):
            return "Cannot create directory at given path: Path: \(path). Underlying error: \(error)"
        case .imageNotExisting(let key):
            return "The image is not in cache, but you requires it should only be " +
                   "from cache by enabling the `.onlyFromCache` option. Key: \(key)."
        case .cannotConvertToData(let object, let error):
            return "Cannot convert the input object to a `Data` object when storing it to disk cache. " +
                   "Object: \(object). Underlying error: \(error)"
        case .cannotSerializeImage(let image, let originalData, let serializer):
            return "Cannot serialize an image due to the cache serializer returning `nil`. " +
                   "Image: \(String(describing:image)), original data: \(String(describing: originalData)), " +
                   "serializer: \(serializer)."
        case .cannotCreateCacheFile(let fileURL, let key, let data, let error):
            return "Cannot create cache file at url: \(fileURL), key: \(key), data length: \(data.count). " +
                   "Underlying foundation error: \(error)."
        case .cannotSetCacheFileAttribute(let filePath, let attributes, let error):
            return "Cannot set file attribute for the cache file at path: \(filePath), attributes: \(attributes)." +
                   "Underlying foundation error: \(error)."
        }
    }
    
    var errorCode: Int {
        switch self {
        case .fileEnumeratorCreationFailed: return 3001
        case .invalidFileEnumeratorContent: return 3002
        case .invalidURLResource: return 3003
        case .cannotLoadDataFromDisk: return 3004
        case .cannotCreateDirectory: return 3005
        case .imageNotExisting: return 3006
        case .cannotConvertToData: return 3007
        case .cannotSerializeImage: return 3008
        case .cannotCreateCacheFile: return 3009
        case .cannotSetCacheFileAttribute: return 3010
        }
    }
}
extension KingfisherError.ProcessorErrorReason {
    var errorDescription: String? {
        switch self {
        case .processingFailed(let processor, let item):
            return "Processing image failed. Processor: \(processor). Processing item: \(item)."
        }
    }
    
    var errorCode: Int {
        switch self {
        case .processingFailed: return 4001
        }
    }
}
extension KingfisherError.ImageSettingErrorReason {
    var errorDescription: String? {
        switch self {
        case .emptySource:
            return "The input resource is empty."
        case .notCurrentSourceTask(let result, let error, let resource):
            if let result = result {
                return "Retrieving resource succeeded, but this source is " +
                       "not the one currently expected. Result: \(result). Resource: \(resource)."
            } else if let error = error {
                return "Retrieving resource failed, and this resource is " +
                       "not the one currently expected. Error: \(error). Resource: \(resource)."
            } else {
                return nil
            }
        case .dataProviderError(let provider, let error):
            return "Image data provider fails to provide data. Provider: \(provider), error: \(error)"
        case .alternativeSourcesExhausted(let errors):
            return "Image setting from alternaive sources failed: \(errors)"
        }
    }
    
    var errorCode: Int {
        switch self {
        case .emptySource: return 5001
        case .notCurrentSourceTask: return 5002
        case .dataProviderError: return 5003
        case .alternativeSourcesExhausted: return 5004
        }
    }
}
//
//  Source.swift
//  Kingfisher
//
//  Created by onevcat on 2018/11/17.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents an image setting source for Kingfisher methods.
///
/// A `Source` value indicates the way how the target image can be retrieved and cached.
///
/// - network: The target image should be got from network remotely. The associated `Resource`
///            value defines detail information like image URL and cache key.
/// - provider: The target image should be provided in a data format. Normally, it can be an image
///             from local storage or in any other encoding format (like Base64).
public enum Source {
    /// Represents the source task identifier when setting an image to a view with extension methods.
    public enum Identifier {
        /// The underlying value type of source identifier.
        public typealias Value = UInt
        static var current: Value = 0
        static func next() -> Value {
            current += 1
            return current
        }
    }
    // MARK: Member Cases
    /// The target image should be got from network remotely. The associated `Resource`
    /// value defines detail information like image URL and cache key.
    case network(Resource)
    
    /// The target image should be provided in a data format. Normally, it can be an image
    /// from local storage or in any other encoding format (like Base64).
    case provider(ImageDataProvider)
    // MARK: Getting Properties
    /// The cache key defined for this source value.
    public var cacheKey: String {
        switch self {
        case .network(let resource): return resource.cacheKey
        case .provider(let provider): return provider.cacheKey
        }
    }
    /// The URL defined for this source value.
    ///
    /// For a `.network` source, it is the `downloadURL` of associated `Resource` instance.
    /// For a `.provider` value, it is always `nil`.
    public var url: URL? {
        switch self {
        case .network(let resource): return resource.downloadURL
        case .provider(let provider): return provider.contentURL
        }
    }
}
extension Source {
    var asResource: Resource? {
        guard case .network(let resource) = self else {
            return nil
        }
        return resource
    }
    var asProvider: ImageDataProvider? {
        guard case .provider(let provider) = self else {
            return nil
        }
        return provider
    }
}
//
//  Resource.swift
//  Kingfisher
//
//  Created by Wei Wang on 15/4/6.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents an image resource at a certain url and a given cache key.
/// Kingfisher will use a `Resource` to download a resource from network and cache it with the cache key when
/// using `Source.network` as its image setting source.
public protocol Resource {
    
    /// The key used in cache.
    var cacheKey: String { get }
    
    /// The target image URL.
    var downloadURL: URL { get }
}
extension Resource {
    /// Converts `self` to a valid `Source` based on its `downloadURL` scheme. A `.provider` with
    /// `LocalFileImageDataProvider` associated will be returned if the URL points to a local file. Otherwise,
    /// `.network` is returned.
    public func convertToSource() -> Source {
        return downloadURL.isFileURL ?
            .provider(LocalFileImageDataProvider(fileURL: downloadURL, cacheKey: cacheKey)) :
            .network(self)
    }
}
/// ImageResource is a simple combination of `downloadURL` and `cacheKey`.
/// When passed to image view set methods, Kingfisher will try to download the target
/// image from the `downloadURL`, and then store it with the `cacheKey` as the key in cache.
public struct ImageResource: Resource {
    // MARK: - Initializers
    /// Creates an image resource.
    ///
    /// - Parameters:
    ///   - downloadURL: The target image URL from where the image can be downloaded.
    ///   - cacheKey: The cache key. If `nil`, Kingfisher will use the `absoluteString` of `downloadURL` as the key.
    ///               Default is `nil`.
    public init(downloadURL: URL, cacheKey: String? = nil) {
        self.downloadURL = downloadURL
        self.cacheKey = cacheKey ?? downloadURL.absoluteString
    }
    // MARK: Protocol Conforming
    
    /// The key used in cache.
    public let cacheKey: String
    /// The target image URL.
    public let downloadURL: URL
}
/// URL conforms to `Resource` in Kingfisher.
/// The `absoluteString` of this URL is used as `cacheKey`. And the URL itself will be used as `downloadURL`.
/// If you need customize the url and/or cache key, use `ImageResource` instead.
extension URL: Resource {
    public var cacheKey: String { return absoluteString }
    public var downloadURL: URL { return self }
}
//
//  ImageDataProvider.swift
//  Kingfisher
//
//  Created by onevcat on 2018/11/13.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents a data provider to provide image data to Kingfisher when setting with
/// `Source.provider` source. Compared to `Source.network` member, it gives a chance
/// to load some image data in your own way, as long as you can provide the data
/// representation for the image.
public protocol ImageDataProvider {
    
    /// The key used in cache.
    var cacheKey: String { get }
    
    /// Provides the data which represents image. Kingfisher uses the data you pass in the
    /// handler to process images and caches it for later use.
    ///
    /// - Parameter handler: The handler you should call when you prepared your data.
    ///                      If the data is loaded successfully, call the handler with
    ///                      a `.success` with the data associated. Otherwise, call it
    ///                      with a `.failure` and pass the error.
    ///
    /// - Note:
    /// If the `handler` is called with a `.failure` with error, a `dataProviderError` of
    /// `ImageSettingErrorReason` will be finally thrown out to you as the `KingfisherError`
    /// from the framework.
    func data(handler: @escaping (Result<Data, Error>) -> Void)
    /// The content URL represents this provider, if exists.
    var contentURL: URL? { get }
}
public extension ImageDataProvider {
    var contentURL: URL? { return nil }
}
/// Represents an image data provider for loading from a local file URL on disk.
/// Uses this type for adding a disk image to Kingfisher. Compared to loading it
/// directly, you can get benefit of using Kingfisher's extension methods, as well
/// as applying `ImageProcessor`s and storing the image to `ImageCache` of Kingfisher.
public struct LocalFileImageDataProvider: ImageDataProvider {
    // MARK: Public Properties
    /// The file URL from which the image be loaded.
    public let fileURL: URL
    // MARK: Initializers
    /// Creates an image data provider by supplying the target local file URL.
    ///
    /// - Parameters:
    ///   - fileURL: The file URL from which the image be loaded.
    ///   - cacheKey: The key is used for caching the image data. By default,
    ///               the `absoluteString` of `fileURL` is used.
    public init(fileURL: URL, cacheKey: String? = nil) {
        self.fileURL = fileURL
        self.cacheKey = cacheKey ?? fileURL.absoluteString
    }
    // MARK: Protocol Conforming
    /// The key used in cache.
    public var cacheKey: String
    public func data(handler: (Result<Data, Error>) -> Void) {
        handler(Result(catching: { try Data(contentsOf: fileURL) }))
    }
    /// The URL of the local file on the disk.
    public var contentURL: URL? {
        return fileURL
    }
}
/// Represents an image data provider for loading image from a given Base64 encoded string.
public struct Base64ImageDataProvider: ImageDataProvider {
    // MARK: Public Properties
    /// The encoded Base64 string for the image.
    public let base64String: String
    // MARK: Initializers
    /// Creates an image data provider by supplying the Base64 encoded string.
    ///
    /// - Parameters:
    ///   - base64String: The Base64 encoded string for an image.
    ///   - cacheKey: The key is used for caching the image data. You need a different key for any different image.
    public init(base64String: String, cacheKey: String) {
        self.base64String = base64String
        self.cacheKey = cacheKey
    }
    // MARK: Protocol Conforming
    /// The key used in cache.
    public var cacheKey: String
    public func data(handler: (Result<Data, Error>) -> Void) {
        let data = Data(base64Encoded: base64String)!
        handler(.success(data))
    }
}
/// Represents an image data provider for a raw data object.
public struct RawImageDataProvider: ImageDataProvider {
    // MARK: Public Properties
    /// The raw data object to provide to Kingfisher image loader.
    public let data: Data
    // MARK: Initializers
    /// Creates an image data provider by the given raw `data` value and a `cacheKey` be used in Kingfisher cache.
    ///
    /// - Parameters:
    ///   - data: The raw data reprensents an image.
    ///   - cacheKey: The key is used for caching the image data. You need a different key for any different image.
    public init(data: Data, cacheKey: String) {
        self.data = data
        self.cacheKey = cacheKey
    }
    // MARK: Protocol Conforming
    
    /// The key used in cache.
    public var cacheKey: String
    public func data(handler: @escaping (Result<Data, Error>) -> Void) {
        handler(.success(data))
    }
}
//
//  AVAssetImageDataProvider.swift
//  Kingfisher
//
//  Created by onevcat on 2020/08/09.
//
//  Copyright (c) 2020 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if !os(watchOS)
import Foundation
import AVKit
#if canImport(MobileCoreServices)
import MobileCoreServices
#else
import CoreServices
#endif
/// A data provider to provide thumbnail data from a given AVKit asset.
public struct AVAssetImageDataProvider: ImageDataProvider {
    /// The possible error might be caused by the `AVAssetImageDataProvider`.
    /// - userCancelled: The data provider process is cancelled.
    /// - invalidImage: The retrieved image is invalid.
    public enum AVAssetImageDataProviderError: Error {
        case userCancelled
        case invalidImage(_ image: CGImage?)
    }
    /// The asset image generator bound to `self`.
    public let assetImageGenerator: AVAssetImageGenerator
    /// The time at which the image should be generate in the asset.
    public let time: CMTime
    private var internalKey: String {
        return (assetImageGenerator.asset as? AVURLAsset)?.url.absoluteString ?? UUID().uuidString
    }
    /// The cache key used by `self`.
    public var cacheKey: String {
        return "\(internalKey)_\(time.seconds)"
    }
    /// Creates an asset image data provider.
    /// - Parameters:
    ///   - assetImageGenerator: The asset image generator controls data providing behaviors.
    ///   - time: At which time in the asset the image should be generated.
    public init(assetImageGenerator: AVAssetImageGenerator, time: CMTime) {
        self.assetImageGenerator = assetImageGenerator
        self.time = time
    }
    /// Creates an asset image data provider.
    /// - Parameters:
    ///   - assetURL: The URL of asset for providing image data.
    ///   - time: At which time in the asset the image should be generated.
    ///
    /// This method uses `assetURL` to create an `AVAssetImageGenerator` object and calls
    /// the `init(assetImageGenerator:time:)` initializer.
    ///
    public init(assetURL: URL, time: CMTime) {
        let asset = AVAsset(url: assetURL)
        let generator = AVAssetImageGenerator(asset: asset)
        self.init(assetImageGenerator: generator, time: time)
    }
    /// Creates an asset image data provider.
    ///
    /// - Parameters:
    ///   - assetURL: The URL of asset for providing image data.
    ///   - seconds: At which time in seconds in the asset the image should be generated.
    ///
    /// This method uses `assetURL` to create an `AVAssetImageGenerator` object, uses `seconds` to create a `CMTime`,
    /// and calls the `init(assetImageGenerator:time:)` initializer.
    ///
    public init(assetURL: URL, seconds: TimeInterval) {
        let time = CMTime(seconds: seconds, preferredTimescale: 600)
        self.init(assetURL: assetURL, time: time)
    }
    public func data(handler: @escaping (Result<Data, Error>) -> Void) {
        assetImageGenerator.generateCGImagesAsynchronously(forTimes: [NSValue(time: time)]) {
            (requestedTime, image, imageTime, result, error) in
            if let error = error {
                handler(.failure(error))
                return
            }
            if result == .cancelled {
                handler(.failure(AVAssetImageDataProviderError.userCancelled))
                return
            }
            guard let cgImage = image, let data = cgImage.jpegData else {
                handler(.failure(AVAssetImageDataProviderError.invalidImage(image)))
                return
            }
            handler(.success(data))
        }
    }
}
extension CGImage {
    var jpegData: Data? {
        guard let mutableData = CFDataCreateMutable(nil, 0),
              let destination = CGImageDestinationCreateWithData(mutableData, kUTTypeJPEG, 1, nil)
        else {
            return nil
        }
        CGImageDestinationAddImage(destination, self, nil)
        guard CGImageDestinationFinalize(destination) else { return nil }
        return mutableData as Data
    }
}
#endif
//
//  KingfisherManager.swift
//  Kingfisher
//
//  Created by Wei Wang on 15/4/6.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// The downloading progress block type.
/// The parameter value is the `receivedSize` of current response.
/// The second parameter is the total expected data length from response's "Content-Length" header.
/// If the expected length is not available, this block will not be called.
public typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -> Void)
/// Represents the result of a Kingfisher retrieving image task.
public struct RetrieveImageResult {
    /// Gets the image object of this result.
    public let image: KFCrossPlatformImage
    /// Gets the cache source of the image. It indicates from which layer of cache this image is retrieved.
    /// If the image is just downloaded from network, `.none` will be returned.
    public let cacheType: CacheType
    /// The `Source` which this result is related to. This indicated where the `image` of `self` is referring.
    public let source: Source
    /// The original `Source` from which the retrieve task begins. It can be different from the `source` property.
    /// When an alternative source loading happened, the `source` will be the replacing loading target, while the
    /// `originalSource` will be kept as the initial `source` which issued the image loading process.
    public let originalSource: Source
}
/// A struct that stores some related information of an `KingfisherError`. It provides some context information for
/// a pure error so you can identify the error easier.
public struct PropagationError {
    /// The `Source` to which current `error` is bound.
    public let source: Source
    /// The actual error happens in framework.
    public let error: KingfisherError
}
/// The downloading task updated block type. The parameter `newTask` is the updated new task of image setting process.
/// It is a `nil` if the image loading does not require an image downloading process. If an image downloading is issued,
/// this value will contain the actual `DownloadTask` for you to keep and cancel it later if you need.
public typealias DownloadTaskUpdatedBlock = ((_ newTask: DownloadTask?) -> Void)
/// Main manager class of Kingfisher. It connects Kingfisher downloader and cache,
/// to provide a set of convenience methods to use Kingfisher for tasks.
/// You can use this class to retrieve an image via a specified URL from web or cache.
public class KingfisherManager {
    /// Represents a shared manager used across Kingfisher.
    /// Use this instance for getting or storing images with Kingfisher.
    public static let shared = KingfisherManager()
    // Mark: Public Properties
    /// The `ImageCache` used by this manager. It is `ImageCache.default` by default.
    /// If a cache is specified in `KingfisherManager.defaultOptions`, the value in `defaultOptions` will be
    /// used instead.
    public var cache: ImageCache
    
    /// The `ImageDownloader` used by this manager. It is `ImageDownloader.default` by default.
    /// If a downloader is specified in `KingfisherManager.defaultOptions`, the value in `defaultOptions` will be
    /// used instead.
    public var downloader: ImageDownloader
    
    /// Default options used by the manager. This option will be used in
    /// Kingfisher manager related methods, as well as all view extension methods.
    /// You can also passing other options for each image task by sending an `options` parameter
    /// to Kingfisher's APIs. The per image options will overwrite the default ones,
    /// if the option exists in both.
    public var defaultOptions = KingfisherOptionsInfo.empty
    
    // Use `defaultOptions` to overwrite the `downloader` and `cache`.
    private var currentDefaultOptions: KingfisherOptionsInfo {
        return [.downloader(downloader), .targetCache(cache)] + defaultOptions
    }
    private let processingQueue: CallbackQueue
    
    private convenience init() {
        self.init(downloader: .default, cache: .default)
    }
    /// Creates an image setting manager with specified downloader and cache.
    ///
    /// - Parameters:
    ///   - downloader: The image downloader used to download images.
    ///   - cache: The image cache which stores memory and disk images.
    public init(downloader: ImageDownloader, cache: ImageCache) {
        self.downloader = downloader
        self.cache = cache
        let processQueueName = "com.onevcat.Kingfisher.KingfisherManager.processQueue.\(UUID().uuidString)"
        processingQueue = .dispatch(DispatchQueue(label: processQueueName))
    }
    // MARK: - Getting Images
    /// Gets an image from a given resource.
    /// - Parameters:
    ///   - resource: The `Resource` object defines data information like key or URL.
    ///   - options: Options to use when creating the image.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called. `progressBlock` is always called in
    ///                    main queue.
    ///   - downloadTaskUpdated: Called when a new image downloading task is created for current image retrieving. This
    ///                          usually happens when an alternative source is used to replace the original (failed)
    ///                          task. You can update your reference of `DownloadTask` if you want to manually `cancel`
    ///                          the new task.
    ///   - completionHandler: Called when the image retrieved and set finished. This completion handler will be invoked
    ///                        from the `options.callbackQueue`. If not specified, the main queue will be used.
    /// - Returns: A task represents the image downloading. If there is a download task starts for `.network` resource,
    ///            the started `DownloadTask` is returned. Otherwise, `nil` is returned.
    ///
    /// - Note:
    ///    This method will first check whether the requested `resource` is already in cache or not. If cached,
    ///    it returns `nil` and invoke the `completionHandler` after the cached image retrieved. Otherwise, it
    ///    will download the `resource`, store it in cache, then call `completionHandler`.
    @discardableResult
    public func retrieveImage(
        with resource: Resource,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        downloadTaskUpdated: DownloadTaskUpdatedBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
    {
        return retrieveImage(
            with: resource.convertToSource(),
            options: options,
            progressBlock: progressBlock,
            downloadTaskUpdated: downloadTaskUpdated,
            completionHandler: completionHandler
        )
    }
    /// Gets an image from a given resource.
    ///
    /// - Parameters:
    ///   - source: The `Source` object defines data information from network or a data provider.
    ///   - options: Options to use when creating the image.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called. `progressBlock` is always called in
    ///                    main queue.
    ///   - downloadTaskUpdated: Called when a new image downloading task is created for current image retrieving. This
    ///                          usually happens when an alternative source is used to replace the original (failed)
    ///                          task. You can update your reference of `DownloadTask` if you want to manually `cancel`
    ///                          the new task.
    ///   - completionHandler: Called when the image retrieved and set finished. This completion handler will be invoked
    ///                        from the `options.callbackQueue`. If not specified, the main queue will be used.
    /// - Returns: A task represents the image downloading. If there is a download task starts for `.network` resource,
    ///            the started `DownloadTask` is returned. Otherwise, `nil` is returned.
    ///
    /// - Note:
    ///    This method will first check whether the requested `source` is already in cache or not. If cached,
    ///    it returns `nil` and invoke the `completionHandler` after the cached image retrieved. Otherwise, it
    ///    will try to load the `source`, store it in cache, then call `completionHandler`.
    ///
    public func retrieveImage(
        with source: Source,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        downloadTaskUpdated: DownloadTaskUpdatedBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
    {
        let options = currentDefaultOptions + (options ?? .empty)
        var info = KingfisherParsedOptionsInfo(options)
        if let block = progressBlock {
            info.onDataReceived = (info.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        return retrieveImage(
            with: source,
            options: info,
            downloadTaskUpdated: downloadTaskUpdated,
            completionHandler: completionHandler)
    }
    func retrieveImage(
        with source: Source,
        options: KingfisherParsedOptionsInfo,
        downloadTaskUpdated: DownloadTaskUpdatedBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
    {
        let retrievingContext = RetrievingContext(options: options, originalSource: source)
        var retryContext: RetryContext?
        func startNewRetrieveTask(
            with source: Source,
            downloadTaskUpdated: DownloadTaskUpdatedBlock?
        ) {
            let newTask = self.retrieveImage(with: source, context: retrievingContext) { result in
                handler(currentSource: source, result: result)
            }
            downloadTaskUpdated?(newTask)
        }
        func failCurrentSource(_ source: Source, with error: KingfisherError) {
            // Skip alternative sources if the user cancelled it.
            guard !error.isTaskCancelled else {
                completionHandler?(.failure(error))
                return
            }
            if let nextSource = retrievingContext.popAlternativeSource() {
                startNewRetrieveTask(with: nextSource, downloadTaskUpdated: downloadTaskUpdated)
            } else {
                // No other alternative source. Finish with error.
                if retrievingContext.propagationErrors.isEmpty {
                    completionHandler?(.failure(error))
                } else {
                    retrievingContext.appendError(error, to: source)
                    let finalError = KingfisherError.imageSettingError(
                        reason: .alternativeSourcesExhausted(retrievingContext.propagationErrors)
                    )
                    completionHandler?(.failure(finalError))
                }
            }
        }
        func handler(currentSource: Source, result: (Result<RetrieveImageResult, KingfisherError>)) -> Void {
            switch result {
            case .success:
                completionHandler?(result)
            case .failure(let error):
                if let retryStrategy = options.retryStrategy {
                    let context = retryContext?.increaseRetryCount() ?? RetryContext(source: source, error: error)
                    retryContext = context
                    retryStrategy.retry(context: context) { decision in
                        switch decision {
                        case .retry(let userInfo):
                            retryContext?.userInfo = userInfo
                            startNewRetrieveTask(with: source, downloadTaskUpdated: downloadTaskUpdated)
                        case .stop:
                            failCurrentSource(currentSource, with: error)
                        }
                    }
                } else {
                    // Skip alternative sources if the user cancelled it.
                    guard !error.isTaskCancelled else {
                        completionHandler?(.failure(error))
                        return
                    }
                    if let nextSource = retrievingContext.popAlternativeSource() {
                        retrievingContext.appendError(error, to: currentSource)
                        startNewRetrieveTask(with: nextSource, downloadTaskUpdated: downloadTaskUpdated)
                    } else {
                        // No other alternative source. Finish with error.
                        if retrievingContext.propagationErrors.isEmpty {
                            completionHandler?(.failure(error))
                        } else {
                            retrievingContext.appendError(error, to: currentSource)
                            let finalError = KingfisherError.imageSettingError(
                                reason: .alternativeSourcesExhausted(retrievingContext.propagationErrors)
                            )
                            completionHandler?(.failure(finalError))
                        }
                    }
                }
            }
        }
        return retrieveImage(
            with: source,
            context: retrievingContext)
        {
            result in
            handler(currentSource: source, result: result)
        }
    }
    
    private func retrieveImage(
        with source: Source,
        context: RetrievingContext,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
    {
        let options = context.options
        if options.forceRefresh {
            return loadAndCacheImage(
                source: source,
                context: context,
                completionHandler: completionHandler)?.value
            
        } else {
            let loadedFromCache = retrieveImageFromCache(
                source: source,
                context: context,
                completionHandler: completionHandler)
            
            if loadedFromCache {
                return nil
            }
            
            if options.onlyFromCache {
                let error = KingfisherError.cacheError(reason: .imageNotExisting(key: source.cacheKey))
                completionHandler?(.failure(error))
                return nil
            }
            
            return loadAndCacheImage(
                source: source,
                context: context,
                completionHandler: completionHandler)?.value
        }
    }
    func provideImage(
        provider: ImageDataProvider,
        options: KingfisherParsedOptionsInfo,
        completionHandler: ((Result<ImageLoadingResult, KingfisherError>) -> Void)?)
    {
        guard let  completionHandler = completionHandler else { return }
        provider.data { result in
            switch result {
            case .success(let data):
                (options.processingQueue ?? self.processingQueue).execute {
                    let processor = options.processor
                    let processingItem = ImageProcessItem.data(data)
                    guard let image = processor.process(item: processingItem, options: options) else {
                        options.callbackQueue.execute {
                            let error = KingfisherError.processorError(
                                reason: .processingFailed(processor: processor, item: processingItem))
                            completionHandler(.failure(error))
                        }
                        return
                    }
                    let finalImage = options.imageModifier?.modify(image) ?? image
                    options.callbackQueue.execute {
                        let result = ImageLoadingResult(image: finalImage, url: nil, originalData: data)
                        completionHandler(.success(result))
                    }
                }
            case .failure(let error):
                options.callbackQueue.execute {
                    let error = KingfisherError.imageSettingError(
                        reason: .dataProviderError(provider: provider, error: error))
                    completionHandler(.failure(error))
                }
            }
        }
    }
    private func cacheImage(
        source: Source,
        options: KingfisherParsedOptionsInfo,
        context: RetrievingContext,
        result: Result<ImageLoadingResult, KingfisherError>,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?
    )
    {
        switch result {
        case .success(let value):
            let needToCacheOriginalImage = options.cacheOriginalImage &&
                                           options.processor != DefaultImageProcessor.default
            let coordinator = CacheCallbackCoordinator(
                shouldWaitForCache: options.waitForCache, shouldCacheOriginal: needToCacheOriginalImage)
            // Add image to cache.
            let targetCache = options.targetCache ?? self.cache
            targetCache.store(
                value.image,
                original: value.originalData,
                forKey: source.cacheKey,
                options: options,
                toDisk: !options.cacheMemoryOnly)
            {
                _ in
                coordinator.apply(.cachingImage) {
                    let result = RetrieveImageResult(
                        image: value.image,
                        cacheType: .none,
                        source: source,
                        originalSource: context.originalSource
                    )
                    completionHandler?(.success(result))
                }
            }
            // Add original image to cache if necessary.
            if needToCacheOriginalImage {
                let originalCache = options.originalCache ?? targetCache
                originalCache.storeToDisk(
                    value.originalData,
                    forKey: source.cacheKey,
                    processorIdentifier: DefaultImageProcessor.default.identifier,
                    expiration: options.diskCacheExpiration)
                {
                    _ in
                    coordinator.apply(.cachingOriginalImage) {
                        let result = RetrieveImageResult(
                            image: value.image,
                            cacheType: .none,
                            source: source,
                            originalSource: context.originalSource
                        )
                        completionHandler?(.success(result))
                    }
                }
            }
            coordinator.apply(.cacheInitiated) {
                let result = RetrieveImageResult(
                    image: value.image,
                    cacheType: .none,
                    source: source,
                    originalSource: context.originalSource
                )
                completionHandler?(.success(result))
            }
        case .failure(let error):
            completionHandler?(.failure(error))
        }
    }
    @discardableResult
    func loadAndCacheImage(
        source: Source,
        context: RetrievingContext,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask.WrappedTask?
    {
        let options = context.options
        func _cacheImage(_ result: Result<ImageLoadingResult, KingfisherError>) {
            cacheImage(
                source: source,
                options: options,
                context: context,
                result: result,
                completionHandler: completionHandler
            )
        }
        switch source {
        case .network(let resource):
            let downloader = options.downloader ?? self.downloader
            let task = downloader.downloadImage(
                with: resource.downloadURL, options: options, completionHandler: _cacheImage
            )
            // The code below is neat, but it fails the Swift 5.2 compiler with a runtime crash when 
            // `BUILD_LIBRARY_FOR_DISTRIBUTION` is turned on. I believe it is a bug in the compiler. 
            // Let's fallback to a traditional style before it can be fixed in Swift.
            //
            // https://github.com/onevcat/Kingfisher/issues/1436
            //
            // return task.map(DownloadTask.WrappedTask.download)
            if let task = task {
                return .download(task)
            } else {
                return nil
            }
        case .provider(let provider):
            provideImage(provider: provider, options: options, completionHandler: _cacheImage)
            return .dataProviding
        }
    }
    
    /// Retrieves image from memory or disk cache.
    ///
    /// - Parameters:
    ///   - source: The target source from which to get image.
    ///   - key: The key to use when caching the image.
    ///   - url: Image request URL. This is not used when retrieving image from cache. It is just used for
    ///          `RetrieveImageResult` callback compatibility.
    ///   - options: Options on how to get the image from image cache.
    ///   - completionHandler: Called when the image retrieving finishes, either with succeeded
    ///                        `RetrieveImageResult` or an error.
    /// - Returns: `true` if the requested image or the original image before being processed is existing in cache.
    ///            Otherwise, this method returns `false`.
    ///
    /// - Note:
    ///    The image retrieving could happen in either memory cache or disk cache. The `.processor` option in
    ///    `options` will be considered when searching in the cache. If no processed image is found, Kingfisher
    ///    will try to check whether an original version of that image is existing or not. If there is already an
    ///    original, Kingfisher retrieves it from cache and processes it. Then, the processed image will be store
    ///    back to cache for later use.
    func retrieveImageFromCache(
        source: Source,
        context: RetrievingContext,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> Bool
    {
        let options = context.options
        // 1. Check whether the image was already in target cache. If so, just get it.
        let targetCache = options.targetCache ?? cache
        let key = source.cacheKey
        let targetImageCached = targetCache.imageCachedType(
            forKey: key, processorIdentifier: options.processor.identifier)
        
        let validCache = targetImageCached.cached &&
            (options.fromMemoryCacheOrRefresh == false || targetImageCached == .memory)
        if validCache {
            targetCache.retrieveImage(forKey: key, options: options) { result in
                guard let completionHandler = completionHandler else { return }
                options.callbackQueue.execute {
                    result.match(
                        onSuccess: { cacheResult in
                            let value: Result<RetrieveImageResult, KingfisherError>
                            if let image = cacheResult.image {
                                value = result.map {
                                    RetrieveImageResult(
                                        image: image,
                                        cacheType: $0.cacheType,
                                        source: source,
                                        originalSource: context.originalSource
                                    )
                                }
                            } else {
                                value = .failure(KingfisherError.cacheError(reason: .imageNotExisting(key: key)))
                            }
                            completionHandler(value)
                        },
                        onFailure: { _ in
                            completionHandler(.failure(KingfisherError.cacheError(reason: .imageNotExisting(key: key))))
                        }
                    )
                }
            }
            return true
        }
        // 2. Check whether the original image exists. If so, get it, process it, save to storage and return.
        let originalCache = options.originalCache ?? targetCache
        // No need to store the same file in the same cache again.
        if originalCache === targetCache && options.processor == DefaultImageProcessor.default {
            return false
        }
        // Check whether the unprocessed image existing or not.
        let originalImageCacheType = originalCache.imageCachedType(
            forKey: key, processorIdentifier: DefaultImageProcessor.default.identifier)
        let canAcceptDiskCache = !options.fromMemoryCacheOrRefresh
        
        let canUseOriginalImageCache =
            (canAcceptDiskCache && originalImageCacheType.cached) ||
            (!canAcceptDiskCache && originalImageCacheType == .memory)
        
        if canUseOriginalImageCache {
            // Now we are ready to get found the original image from cache. We need the unprocessed image, so remove
            // any processor from options first.
            var optionsWithoutProcessor = options
            optionsWithoutProcessor.processor = DefaultImageProcessor.default
            originalCache.retrieveImage(forKey: key, options: optionsWithoutProcessor) { result in
                result.match(
                    onSuccess: { cacheResult in
                        guard let image = cacheResult.image else {
                            assertionFailure("The image (under key: \(key) should be existing in the original cache.")
                            return
                        }
                        let processor = options.processor
                        (options.processingQueue ?? self.processingQueue).execute {
                            let item = ImageProcessItem.image(image)
                            guard let processedImage = processor.process(item: item, options: options) else {
                                let error = KingfisherError.processorError(
                                    reason: .processingFailed(processor: processor, item: item))
                                options.callbackQueue.execute { completionHandler?(.failure(error)) }
                                return
                            }
                            var cacheOptions = options
                            cacheOptions.callbackQueue = .untouch
                            let coordinator = CacheCallbackCoordinator(
                                shouldWaitForCache: options.waitForCache, shouldCacheOriginal: false)
                            targetCache.store(
                                processedImage,
                                forKey: key,
                                options: cacheOptions,
                                toDisk: !options.cacheMemoryOnly)
                            {
                                _ in
                                coordinator.apply(.cachingImage) {
                                    let value = RetrieveImageResult(
                                        image: processedImage,
                                        cacheType: .none,
                                        source: source,
                                        originalSource: context.originalSource
                                    )
                                    options.callbackQueue.execute { completionHandler?(.success(value)) }
                                }
                            }
                            coordinator.apply(.cacheInitiated) {
                                let value = RetrieveImageResult(
                                    image: processedImage,
                                    cacheType: .none,
                                    source: source,
                                    originalSource: context.originalSource
                                )
                                options.callbackQueue.execute { completionHandler?(.success(value)) }
                            }
                        }
                    },
                    onFailure: { _ in
                        // This should not happen actually, since we already confirmed `originalImageCached` is `true`.
                        // Just in case...
                        options.callbackQueue.execute {
                            completionHandler?(
                                .failure(KingfisherError.cacheError(reason: .imageNotExisting(key: key)))
                            )
                        }
                    }
                )
            }
            return true
        }
        return false
    }
}
class RetrievingContext {
    var options: KingfisherParsedOptionsInfo
    let originalSource: Source
    var propagationErrors: [PropagationError] = []
    init(options: KingfisherParsedOptionsInfo, originalSource: Source) {
        self.originalSource = originalSource
        self.options = options
    }
    func popAlternativeSource() -> Source? {
        guard var alternativeSources = options.alternativeSources, !alternativeSources.isEmpty else {
            return nil
        }
        let nextSource = alternativeSources.removeFirst()
        options.alternativeSources = alternativeSources
        return nextSource
    }
    @discardableResult
    func appendError(_ error: KingfisherError, to source: Source) -> [PropagationError] {
        let item = PropagationError(source: source, error: error)
        propagationErrors.append(item)
        return propagationErrors
    }
}
class CacheCallbackCoordinator {
    enum State {
        case idle
        case imageCached
        case originalImageCached
        case done
    }
    enum Action {
        case cacheInitiated
        case cachingImage
        case cachingOriginalImage
    }
    private let shouldWaitForCache: Bool
    private let shouldCacheOriginal: Bool
    private let stateQueue: DispatchQueue
    private var threadSafeState: State = .idle
    private (set) var state: State {
        set { stateQueue.sync { threadSafeState = newValue } }
        get { stateQueue.sync { threadSafeState } }
    }
    init(shouldWaitForCache: Bool, shouldCacheOriginal: Bool) {
        self.shouldWaitForCache = shouldWaitForCache
        self.shouldCacheOriginal = shouldCacheOriginal
        let stateQueueName = "com.onevcat.Kingfisher.CacheCallbackCoordinator.stateQueue.\(UUID().uuidString)"
        self.stateQueue = DispatchQueue(label: stateQueueName)
    }
    func apply(_ action: Action, trigger: () -> Void) {
        switch (state, action) {
        case (.done, _):
            break
        // From .idle
        case (.idle, .cacheInitiated):
            if !shouldWaitForCache {
                state = .done
                trigger()
            }
        case (.idle, .cachingImage):
            if shouldCacheOriginal {
                state = .imageCached
            } else {
                state = .done
                trigger()
            }
        case (.idle, .cachingOriginalImage):
            state = .originalImageCached
        // From .imageCached
        case (.imageCached, .cachingOriginalImage):
            state = .done
            trigger()
        // From .originalImageCached
        case (.originalImageCached, .cachingImage):
            state = .done
            trigger()
        default:
            assertionFailure("This case should not happen in CacheCallbackCoordinator: \(state) - \(action)")
        }
    }
}
//
//  Deprecated.swift
//  Kingfisher
//
//  Created by onevcat on 2018/09/28.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
#elseif canImport(UIKit)
import UIKit
#endif
// MARK: - Deprecated
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    @available(*, deprecated, message:
    "Will be removed soon. Pass parameters with `ImageCreatingOptions`, use `image(with:options:)` instead.")
    public static func image(
        data: Data,
        scale: CGFloat,
        preloadAllAnimationData: Bool,
        onlyFirstFrame: Bool) -> KFCrossPlatformImage?
    {
        let options = ImageCreatingOptions(
            scale: scale,
            duration: 0.0,
            preloadAll: preloadAllAnimationData,
            onlyFirstFrame: onlyFirstFrame)
        return KingfisherWrapper.image(data: data, options: options)
    }
    
    @available(*, deprecated, message:
    "Will be removed soon. Pass parameters with `ImageCreatingOptions`, use `animatedImage(with:options:)` instead.")
    public static func animated(
        with data: Data,
        scale: CGFloat = 1.0,
        duration: TimeInterval = 0.0,
        preloadAll: Bool,
        onlyFirstFrame: Bool = false) -> KFCrossPlatformImage?
    {
        let options = ImageCreatingOptions(
            scale: scale, duration: duration, preloadAll: preloadAll, onlyFirstFrame: onlyFirstFrame)
        return animatedImage(data: data, options: options)
    }
}
@available(*, deprecated, message: "Will be removed soon. Use `Result<RetrieveImageResult>` based callback instead")
public typealias CompletionHandler =
    ((_ image: KFCrossPlatformImage?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -> Void)
@available(*, deprecated, message: "Will be removed soon. Use `Result<ImageLoadingResult>` based callback instead")
public typealias ImageDownloaderCompletionHandler =
    ((_ image: KFCrossPlatformImage?, _ error: NSError?, _ url: URL?, _ originalData: Data?) -> Void)
// MARK: - Deprecated
@available(*, deprecated, message: "Will be removed soon. Use `DownloadTask` to cancel a task.")
extension RetrieveImageTask {
    @available(*, deprecated, message: "RetrieveImageTask.empty will be removed soon. Use `nil` to represent a no task.")
    public static let empty = RetrieveImageTask()
}
// MARK: - Deprecated
extension KingfisherManager {
    /// Get an image with resource.
    /// If `.empty` is used as `options`, Kingfisher will seek the image in memory and disk first.
    /// If not found, it will download the image at `resource.downloadURL` and cache it with `resource.cacheKey`.
    /// These default behaviors could be adjusted by passing different options. See `KingfisherOptions` for more.
    ///
    /// - Parameters:
    ///   - resource: Resource object contains information such as `cacheKey` and `downloadURL`.
    ///   - options: A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called every time downloaded data changed. This could be used as a progress UI.
    ///   - completionHandler: Called when the whole retrieving process finished.
    /// - Returns: A `RetrieveImageTask` task object. You can use this object to cancel the task.
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    @discardableResult
    public func retrieveImage(with resource: Resource,
                              options: KingfisherOptionsInfo?,
                              progressBlock: DownloadProgressBlock?,
                              completionHandler: CompletionHandler?) -> DownloadTask?
    {
        return retrieveImage(with: resource, options: options, progressBlock: progressBlock) {
            result in
            switch result {
            case .success(let value): completionHandler?(value.image, nil, value.cacheType, value.source.url)
            case .failure(let error): completionHandler?(nil, error as NSError, .none, resource.downloadURL)
            }
        }
    }
}
// MARK: - Deprecated
extension ImageDownloader {
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    @discardableResult
    open func downloadImage(with url: URL,
                            retrieveImageTask: RetrieveImageTask? = nil,
                            options: KingfisherOptionsInfo? = nil,
                            progressBlock: ImageDownloaderProgressBlock? = nil,
                            completionHandler: ImageDownloaderCompletionHandler?) -> DownloadTask?
    {
        return downloadImage(with: url, options: options, progressBlock: progressBlock) {
            result in
            switch result {
            case .success(let value): completionHandler?(value.image, nil, value.url, value.originalData)
            case .failure(let error): completionHandler?(nil, error as NSError, nil, nil)
            }
        }
    }
}
@available(*, deprecated, message: "RetrieveImageDownloadTask is removed. Use `DownloadTask` to cancel a task.")
public struct RetrieveImageDownloadTask {
}
@available(*, deprecated, message: "RetrieveImageTask is removed. Use `DownloadTask` to cancel a task.")
public final class RetrieveImageTask {
}
@available(*, deprecated, message: "Use `DownloadProgressBlock` instead.", renamed: "DownloadProgressBlock")
public typealias ImageDownloaderProgressBlock = DownloadProgressBlock
#if !os(watchOS)
// MARK: - Deprecated
extension KingfisherWrapper where Base: KFCrossPlatformImageView {
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    @discardableResult
    public func setImage(with resource: Resource?,
                         placeholder: Placeholder? = nil,
                         options: KingfisherOptionsInfo? = nil,
                         progressBlock: DownloadProgressBlock? = nil,
                         completionHandler: CompletionHandler?) -> DownloadTask?
    {
        return setImage(with: resource, placeholder: placeholder, options: options, progressBlock: progressBlock) {
            result in
            switch result {
            case .success(let value):
                completionHandler?(value.image, nil, value.cacheType, value.source.url)
            case .failure(let error):
                completionHandler?(nil, error as NSError, .none, nil)
            }
        }
    }
}
#endif
#if canImport(UIKit) && !os(watchOS)
// MARK: - Deprecated
extension KingfisherWrapper where Base: UIButton {
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    @discardableResult
    public func setImage(
        with resource: Resource?,
        for state: UIControl.State,
        placeholder: UIImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: CompletionHandler?) -> DownloadTask?
    {
        return setImage(
            with: resource,
            for: state,
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock)
        {
            result in
            switch result {
            case .success(let value):
                completionHandler?(value.image, nil, value.cacheType, value.source.url)
            case .failure(let error):
                completionHandler?(nil, error as NSError, .none, nil)
            }
        }
    }
    
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    @discardableResult
    public func setBackgroundImage(
        with resource: Resource?,
        for state: UIControl.State,
        placeholder: UIImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: CompletionHandler?) -> DownloadTask?
    {
        return setBackgroundImage(
            with: resource,
            for: state,
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock)
        {
            result in
            switch result {
            case .success(let value):
                completionHandler?(value.image, nil, value.cacheType, value.source.url)
            case .failure(let error):
                completionHandler?(nil, error as NSError, .none, nil)
            }
        }
    }
}
#endif
#if os(watchOS)
import WatchKit
// MARK: - Deprecated
extension KingfisherWrapper where Base: WKInterfaceImage {
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    @discardableResult
    public func setImage(_ resource: Resource?,
                         placeholder: KFCrossPlatformImage? = nil,
                         options: KingfisherOptionsInfo? = nil,
                         progressBlock: DownloadProgressBlock? = nil,
                         completionHandler: CompletionHandler?) -> DownloadTask?
    {
        return setImage(
            with: resource,
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock)
        {
            result in
            switch result {
            case .success(let value):
                completionHandler?(value.image, nil, value.cacheType, value.source.url)
            case .failure(let error):
                completionHandler?(nil, error as NSError, .none, nil)
            }
        }
    }
}
#endif
#if os(macOS)
// MARK: - Deprecated
extension KingfisherWrapper where Base: NSButton {
    @discardableResult
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    public func setImage(with resource: Resource?,
                         placeholder: KFCrossPlatformImage? = nil,
                         options: KingfisherOptionsInfo? = nil,
                         progressBlock: DownloadProgressBlock? = nil,
                         completionHandler: CompletionHandler?) -> DownloadTask?
    {
        return setImage(
            with: resource,
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock)
        {
            result in
            switch result {
            case .success(let value):
                completionHandler?(value.image, nil, value.cacheType, value.source.url)
            case .failure(let error):
                completionHandler?(nil, error as NSError, .none, nil)
            }
        }
    }
    
    @discardableResult
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    public func setAlternateImage(with resource: Resource?,
                                  placeholder: KFCrossPlatformImage? = nil,
                                  options: KingfisherOptionsInfo? = nil,
                                  progressBlock: DownloadProgressBlock? = nil,
                                  completionHandler: CompletionHandler?) -> DownloadTask?
    {
        return setAlternateImage(
            with: resource,
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock)
        {
            result in
            switch result {
            case .success(let value):
                completionHandler?(value.image, nil, value.cacheType, value.source.url)
            case .failure(let error):
                completionHandler?(nil, error as NSError, .none, nil)
            }
        }
    }
}
#endif
// MARK: - Deprecated
extension ImageCache {
    /// The largest cache cost of memory cache. The total cost is pixel count of
    /// all cached images in memory.
    /// Default is unlimited. Memory cache will be purged automatically when a
    /// memory warning notification is received.
    @available(*, deprecated, message: "Use `memoryStorage.config.totalCostLimit` instead.",
    renamed: "memoryStorage.config.totalCostLimit")
    open var maxMemoryCost: Int {
        get { return memoryStorage.config.totalCostLimit }
        set { memoryStorage.config.totalCostLimit = newValue }
    }
    /// The default DiskCachePathClosure
    @available(*, deprecated, message: "Not needed anymore.")
    public final class func defaultDiskCachePathClosure(path: String?, cacheName: String) -> String {
        let dstPath = path ?? NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true).first!
        return (dstPath as NSString).appendingPathComponent(cacheName)
    }
    /// The default file extension appended to cached files.
    @available(*, deprecated, message: "Use `diskStorage.config.pathExtension` instead.",
    renamed: "diskStorage.config.pathExtension")
    open var pathExtension: String? {
        get { return diskStorage.config.pathExtension }
        set { diskStorage.config.pathExtension = newValue }
    }
    
    ///The disk cache location.
    @available(*, deprecated, message: "Use `diskStorage.directoryURL.absoluteString` instead.",
    renamed: "diskStorage.directoryURL.absoluteString")
    public var diskCachePath: String {
        return diskStorage.directoryURL.absoluteString
    }
    
    /// The largest disk size can be taken for the cache. It is the total
    /// allocated size of cached files in bytes.
    /// Default is no limit.
    @available(*, deprecated, message: "Use `diskStorage.config.sizeLimit` instead.",
    renamed: "diskStorage.config.sizeLimit")
    open var maxDiskCacheSize: UInt {
        get { return UInt(diskStorage.config.sizeLimit) }
        set { diskStorage.config.sizeLimit = newValue }
    }
    
    @available(*, deprecated, message: "Use `diskStorage.cacheFileURL(forKey:).path` instead.",
    renamed: "diskStorage.cacheFileURL(forKey:)")
    open func cachePath(forComputedKey key: String) -> String {
        return diskStorage.cacheFileURL(forKey: key).path
    }
    
    /**
     Get an image for a key from disk.
     
     - parameter key:     Key for the image.
     - parameter options: Options of retrieving image. If you need to retrieve an image which was
     stored with a specified `ImageProcessor`, pass the processor in the option too.
     
     - returns: The image object if it is cached, or `nil` if there is no such key in the cache.
     */
    @available(*, deprecated,
    message: "Use `Result` based `retrieveImageInDiskCache(forKey:options:callbackQueue:completionHandler:)` instead.",
    renamed: "retrieveImageInDiskCache(forKey:options:callbackQueue:completionHandler:)")
    open func retrieveImageInDiskCache(forKey key: String, options: KingfisherOptionsInfo? = nil) -> KFCrossPlatformImage? {
        let options = KingfisherParsedOptionsInfo(options ?? .empty)
        let computedKey = key.computedKey(with: options.processor.identifier)
        do {
            if let data = try diskStorage.value(forKey: computedKey, extendingExpiration: options.diskCacheAccessExtendingExpiration) {
                return options.cacheSerializer.image(with: data, options: options)
            }
        } catch {}
        return nil
    }
    @available(*, deprecated,
    message: "Use `Result` based `retrieveImage(forKey:options:callbackQueue:completionHandler:)` instead.",
    renamed: "retrieveImage(forKey:options:callbackQueue:completionHandler:)")
    open func retrieveImage(forKey key: String,
                            options: KingfisherOptionsInfo?,
                            completionHandler: ((KFCrossPlatformImage?, CacheType) -> Void)?)
    {
        retrieveImage(
            forKey: key,
            options: options,
            callbackQueue: .dispatch((options ?? .empty).callbackDispatchQueue))
        {
            result in
            do {
                let value = try result.get()
                completionHandler?(value.image, value.cacheType)
            } catch {
                completionHandler?(nil, .none)
            }
        }
    }
    /// The longest time duration in second of the cache being stored in disk.
    /// Default is 1 week (60 * 60 * 24 * 7 seconds).
    /// Setting this to a negative value will make the disk cache never expiring.
    @available(*, deprecated, message: "Deprecated. Use `diskStorage.config.expiration` instead")
    open var maxCachePeriodInSecond: TimeInterval {
        get { return diskStorage.config.expiration.timeInterval }
        set { diskStorage.config.expiration = newValue < 0 ? .never : .seconds(newValue) }
    }
    @available(*, deprecated, message: "Use `Result` based callback instead.")
    open func store(_ image: KFCrossPlatformImage,
                    original: Data? = nil,
                    forKey key: String,
                    processorIdentifier identifier: String = "",
                    cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,
                    toDisk: Bool = true,
                    completionHandler: (() -> Void)?)
    {
        store(
            image,
            original: original,
            forKey: key,
            processorIdentifier: identifier,
            cacheSerializer: serializer,
            toDisk: toDisk)
        {
            _ in
            completionHandler?()
        }
    }
    @available(*, deprecated, message: "Use the `Result`-based `calculateDiskStorageSize` instead.")
    open func calculateDiskCacheSize(completion handler: @escaping ((_ size: UInt) -> Void)) {
        calculateDiskStorageSize { result in
            let size: UInt? = try? result.get()
            handler(size ?? 0)
        }
    }
}
// MARK: - Deprecated
extension Collection where Iterator.Element == KingfisherOptionsInfoItem {
    /// The queue of callbacks should happen from Kingfisher.
    @available(*, deprecated, message: "Use `callbackQueue` instead.", renamed: "callbackQueue")
    public var callbackDispatchQueue: DispatchQueue {
        return KingfisherParsedOptionsInfo(Array(self)).callbackQueue.queue
    }
}
/// Error domain of Kingfisher
@available(*, deprecated, message: "Use `KingfisherError.domain` instead.", renamed: "KingfisherError.domain")
public let KingfisherErrorDomain = "com.onevcat.Kingfisher.Error"
/// Key will be used in the `userInfo` of `.invalidStatusCode`
@available(*, unavailable,
message: "Use `.invalidHTTPStatusCode` or `isInvalidResponseStatusCode` of `KingfisherError` instead for the status code.")
public let KingfisherErrorStatusCodeKey = "statusCode"
// MARK: - Deprecated
extension Collection where Iterator.Element == KingfisherOptionsInfoItem {
    /// The target `ImageCache` which is used.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `targetCache` instead.")
    public var targetCache: ImageCache? {
        return KingfisherParsedOptionsInfo(Array(self)).targetCache
    }
    /// The original `ImageCache` which is used.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `originalCache` instead.")
    public var originalCache: ImageCache? {
        return KingfisherParsedOptionsInfo(Array(self)).originalCache
    }
    /// The `ImageDownloader` which is specified.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `downloader` instead.")
    public var downloader: ImageDownloader? {
        return KingfisherParsedOptionsInfo(Array(self)).downloader
    }
    /// Member for animation transition when using UIImageView.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `transition` instead.")
    public var transition: ImageTransition {
        return KingfisherParsedOptionsInfo(Array(self)).transition
    }
    /// A `Float` value set as the priority of image download task. The value for it should be
    /// between 0.0~1.0.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `downloadPriority` instead.")
    public var downloadPriority: Float {
        return KingfisherParsedOptionsInfo(Array(self)).downloadPriority
    }
    /// Whether an image will be always downloaded again or not.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `forceRefresh` instead.")
    public var forceRefresh: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).forceRefresh
    }
    /// Whether an image should be got only from memory cache or download.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `fromMemoryCacheOrRefresh` instead.")
    public var fromMemoryCacheOrRefresh: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).fromMemoryCacheOrRefresh
    }
    /// Whether the transition should always happen or not.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `forceTransition` instead.")
    public var forceTransition: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).forceTransition
    }
    /// Whether cache the image only in memory or not.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheMemoryOnly` instead.")
    public var cacheMemoryOnly: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).cacheMemoryOnly
    }
    /// Whether the caching operation will be waited or not.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `waitForCache` instead.")
    public var waitForCache: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).waitForCache
    }
    /// Whether only load the images from cache or not.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onlyFromCache` instead.")
    public var onlyFromCache: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).onlyFromCache
    }
    /// Whether the image should be decoded in background or not.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `backgroundDecode` instead.")
    public var backgroundDecode: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).backgroundDecode
    }
    /// Whether the image data should be all loaded at once if it is an animated image.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `preloadAllAnimationData` instead.")
    public var preloadAllAnimationData: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).preloadAllAnimationData
    }
    /// The `CallbackQueue` on which completion handler should be invoked.
    /// If not set in the options, `.mainCurrentOrAsync` will be used.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `callbackQueue` instead.")
    public var callbackQueue: CallbackQueue {
        return KingfisherParsedOptionsInfo(Array(self)).callbackQueue
    }
    /// The scale factor which should be used for the image.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `scaleFactor` instead.")
    public var scaleFactor: CGFloat {
        return KingfisherParsedOptionsInfo(Array(self)).scaleFactor
    }
    /// The `ImageDownloadRequestModifier` will be used before sending a download request.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `requestModifier` instead.")
    public var modifier: ImageDownloadRequestModifier? {
        return KingfisherParsedOptionsInfo(Array(self)).requestModifier
    }
    /// `ImageProcessor` for processing when the downloading finishes.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `processor` instead.")
    public var processor: ImageProcessor {
        return KingfisherParsedOptionsInfo(Array(self)).processor
    }
    /// `ImageModifier` for modifying right before the image is displayed.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `imageModifier` instead.")
    public var imageModifier: ImageModifier? {
        return KingfisherParsedOptionsInfo(Array(self)).imageModifier
    }
    /// `CacheSerializer` to convert image to data for storing in cache.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheSerializer` instead.")
    public var cacheSerializer: CacheSerializer {
        return KingfisherParsedOptionsInfo(Array(self)).cacheSerializer
    }
    /// Keep the existing image while setting another image to an image view.
    /// Or the placeholder will be used while downloading.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `keepCurrentImageWhileLoading` instead.")
    public var keepCurrentImageWhileLoading: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).keepCurrentImageWhileLoading
    }
    /// Whether the options contains `.onlyLoadFirstFrame`.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onlyLoadFirstFrame` instead.")
    public var onlyLoadFirstFrame: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).onlyLoadFirstFrame
    }
    /// Whether the options contains `.cacheOriginalImage`.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheOriginalImage` instead.")
    public var cacheOriginalImage: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).cacheOriginalImage
    }
    /// The image which should be used when download image request fails.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onFailureImage` instead.")
    public var onFailureImage: Optional<KFCrossPlatformImage?> {
        return KingfisherParsedOptionsInfo(Array(self)).onFailureImage
    }
    /// Whether the `ImagePrefetcher` should load images to memory in an aggressive way or not.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `alsoPrefetchToMemory` instead.")
    public var alsoPrefetchToMemory: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).alsoPrefetchToMemory
    }
    /// Whether the disk storage file loading should happen in a synchronous behavior or not.
    @available(*, deprecated,
    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `loadDiskFileSynchronously` instead.")
    public var loadDiskFileSynchronously: Bool {
        return KingfisherParsedOptionsInfo(Array(self)).loadDiskFileSynchronously
    }
}
/// The default modifier.
/// It does nothing and returns the image as is.
@available(*, deprecated, message: "Use `nil` in KingfisherOptionsInfo to indicate no modifier.")
public struct DefaultImageModifier: ImageModifier {
    /// A default `DefaultImageModifier` which can be used everywhere.
    public static let `default` = DefaultImageModifier()
    private init() {}
    /// Modifies an input `Image`. See `ImageModifier` protocol for more.
    public func modify(_ image: KFCrossPlatformImage) -> KFCrossPlatformImage { return image }
}
#if os(macOS)
@available(*, deprecated, message: "Use `KFCrossPlatformImage` instead.")
public typealias Image = KFCrossPlatformImage
@available(*, deprecated, message: "Use `KFCrossPlatformView` instead.")
public typealias View = KFCrossPlatformView
@available(*, deprecated, message: "Use `KFCrossPlatformColor` instead.")
public typealias Color = KFCrossPlatformColor
@available(*, deprecated, message: "Use `KFCrossPlatformImageView` instead.")
public typealias ImageView = KFCrossPlatformImageView
@available(*, deprecated, message: "Use `KFCrossPlatformButton` instead.")
public typealias Button = KFCrossPlatformButton
#else
@available(*, deprecated, message: "Use `KFCrossPlatformImage` instead.")
public typealias Image = KFCrossPlatformImage
@available(*, deprecated, message: "Use `KFCrossPlatformColor` instead.")
public typealias Color = KFCrossPlatformColor
    #if !os(watchOS)
    @available(*, deprecated, message: "Use `KFCrossPlatformImageView` instead.")
    public typealias ImageView = KFCrossPlatformImageView
    @available(*, deprecated, message: "Use `KFCrossPlatformView` instead.")
    public typealias View = KFCrossPlatformView
    @available(*, deprecated, message: "Use `KFCrossPlatformButton` instead.")
    public typealias Button = KFCrossPlatformButton
    #endif
#endif
//
//  KingfisherOptionsInfo.swift
//  Kingfisher
//
//  Created by Wei Wang on 15/4/23.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(macOS)
import AppKit
#else
import UIKit
#endif
    
/// KingfisherOptionsInfo is a typealias for [KingfisherOptionsInfoItem].
/// You can use the enum of option item with value to control some behaviors of Kingfisher.
public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]
extension Array where Element == KingfisherOptionsInfoItem {
    static let empty: KingfisherOptionsInfo = []
}
/// Represents the available option items could be used in `KingfisherOptionsInfo`.
public enum KingfisherOptionsInfoItem {
    
    /// Kingfisher will use the associated `ImageCache` object when handling related operations,
    /// including trying to retrieve the cached images and store the downloaded image to it.
    case targetCache(ImageCache)
    
    /// The `ImageCache` for storing and retrieving original images. If `originalCache` is
    /// contained in the options, it will be preferred for storing and retrieving original images.
    /// If there is no `.originalCache` in the options, `.targetCache` will be used to store original images.
    ///
    /// When using KingfisherManager to download and store an image, if `cacheOriginalImage` is
    /// applied in the option, the original image will be stored to this `originalCache`. At the
    /// same time, if a requested final image (with processor applied) cannot be found in `targetCache`,
    /// Kingfisher will try to search the original image to check whether it is already there. If found,
    /// it will be used and applied with the given processor. It is an optimization for not downloading
    /// the same image for multiple times.
    case originalCache(ImageCache)
    
    /// Kingfisher will use the associated `ImageDownloader` object to download the requested images.
    case downloader(ImageDownloader)
    /// Member for animation transition when using `UIImageView`. Kingfisher will use the `ImageTransition` of
    /// this enum to animate the image in if it is downloaded from web. The transition will not happen when the
    /// image is retrieved from either memory or disk cache by default. If you need to do the transition even when
    /// the image being retrieved from cache, set `.forceRefresh` as well.
    case transition(ImageTransition)
    
    /// Associated `Float` value will be set as the priority of image download task. The value for it should be
    /// between 0.0~1.0. If this option not set, the default value (`URLSessionTask.defaultPriority`) will be used.
    case downloadPriority(Float)
    
    /// If set, Kingfisher will ignore the cache and try to fire a download task for the resource.
    case forceRefresh
    /// If set, Kingfisher will try to retrieve the image from memory cache first. If the image is not in memory
    /// cache, then it will ignore the disk cache but download the image again from network. This is useful when
    /// you want to display a changeable image behind the same url at the same app session, while avoiding download
    /// it for multiple times.
    case fromMemoryCacheOrRefresh
    
    /// If set, setting the image to an image view will happen with transition even when retrieved from cache.
    /// See `.transition` option for more.
    case forceTransition
    
    /// If set, Kingfisher will only cache the value in memory but not in disk.
    case cacheMemoryOnly
    
    /// If set, Kingfisher will wait for caching operation to be completed before calling the completion block.
    case waitForCache
    
    /// If set, Kingfisher will only try to retrieve the image from cache, but not from network. If the image is
    /// not in cache, the image retrieving will fail with an error.
    case onlyFromCache
    
    /// Decode the image in background thread before using. It will decode the downloaded image data and do a off-screen
    /// rendering to extract pixel information in background. This can speed up display, but will cost more time to
    /// prepare the image for using.
    case backgroundDecode
    
    /// The associated value of this member will be used as the target queue of dispatch callbacks when
    /// retrieving images from cache. If not set, Kingfisher will use main queue for callbacks.
    @available(*, deprecated, message: "Use `.callbackQueue(CallbackQueue)` instead.")
    case callbackDispatchQueue(DispatchQueue?)
    /// The associated value will be used as the target queue of dispatch callbacks when retrieving images from
    /// cache. If not set, Kingfisher will use `.mainCurrentOrAsync` for callbacks.
    ///
    /// - Note:
    /// This option does not affect the callbacks for UI related extension methods. You will always get the
    /// callbacks called from main queue.
    case callbackQueue(CallbackQueue)
    
    /// The associated value will be used as the scale factor when converting retrieved data to an image.
    /// Specify the image scale, instead of your screen scale. You may need to set the correct scale when you dealing
    /// with 2x or 3x retina images. Otherwise, Kingfisher will convert the data to image object at `scale` 1.0.
    case scaleFactor(CGFloat)
    /// Whether all the animated image data should be preloaded. Default is `false`, which means only following frames
    /// will be loaded on need. If `true`, all the animated image data will be loaded and decoded into memory.
    ///
    /// This option is mainly used for back compatibility internally. You should not set it directly. Instead,
    /// you should choose the image view class to control the GIF data loading. There are two classes in Kingfisher
    /// support to display a GIF image. `AnimatedImageView` does not preload all data, it takes much less memory, but
    /// uses more CPU when display. While a normal image view (`UIImageView` or `NSImageView`) loads all data at once,
    /// which uses more memory but only decode image frames once.
    case preloadAllAnimationData
    
    /// The `ImageDownloadRequestModifier` contained will be used to change the request before it being sent.
    /// This is the last chance you can modify the image download request. You can modify the request for some
    /// customizing purpose, such as adding auth token to the header, do basic HTTP auth or something like url mapping.
    /// The original request will be sent without any modification by default.
    case requestModifier(ImageDownloadRequestModifier)
    
    /// The `ImageDownloadRedirectHandler` contained will be used to change the request before redirection.
    /// This is the possibility you can modify the image download request during redirect. You can modify the request for
    /// some customizing purpose, such as adding auth token to the header, do basic HTTP auth or something like url
    /// mapping.
    /// The original redirection request will be sent without any modification by default.
    case redirectHandler(ImageDownloadRedirectHandler)
    
    /// Processor for processing when the downloading finishes, a processor will convert the downloaded data to an image
    /// and/or apply some filter on it. If a cache is connected to the downloader (it happens when you are using
    /// KingfisherManager or any of the view extension methods), the converted image will also be sent to cache as well.
    /// If not set, the `DefaultImageProcessor.default` will be used.
    case processor(ImageProcessor)
    
    /// Supplies a `CacheSerializer` to convert some data to an image object for
    /// retrieving from disk cache or vice versa for storing to disk cache.
    /// If not set, the `DefaultCacheSerializer.default` will be used.
    case cacheSerializer(CacheSerializer)
    /// An `ImageModifier` is for modifying an image as needed right before it is used. If the image was fetched
    /// directly from the downloader, the modifier will run directly after the `ImageProcessor`. If the image is being
    /// fetched from a cache, the modifier will run after the `CacheSerializer`.
    ///
    /// Use `ImageModifier` when you need to set properties that do not persist when caching the image on a concrete
    /// type of `Image`, such as the `renderingMode` or the `alignmentInsets` of `UIImage`.
    case imageModifier(ImageModifier)
    
    /// Keep the existing image of image view while setting another image to it.
    /// By setting this option, the placeholder image parameter of image view extension method
    /// will be ignored and the current image will be kept while loading or downloading the new image.
    case keepCurrentImageWhileLoading
    
    /// If set, Kingfisher will only load the first frame from an animated image file as a single image.
    /// Loading an animated images may take too much memory. It will be useful when you want to display a
    /// static preview of the first frame from a animated image.
    ///
    /// This option will be ignored if the target image is not animated image data.
    case onlyLoadFirstFrame
    
    /// If set and an `ImageProcessor` is used, Kingfisher will try to cache both the final result and original
    /// image. Kingfisher will have a chance to use the original image when another processor is applied to the same
    /// resource, instead of downloading it again. You can use `.originalCache` to specify a cache or the original
    /// images if necessary.
    ///
    /// The original image will be only cached to disk storage.
    case cacheOriginalImage
    
    /// If set and a downloading error occurred Kingfisher will set provided image (or empty)
    /// in place of requested one. It's useful when you don't want to show placeholder
    /// during loading time but wants to use some default image when requests will be failed.
    case onFailureImage(KFCrossPlatformImage?)
    
    /// If set and used in `ImagePrefetcher`, the prefetching operation will load the images into memory storage
    /// aggressively. By default this is not contained in the options, that means if the requested image is already
    /// in disk cache, Kingfisher will not try to load it to memory.
    case alsoPrefetchToMemory
    
    /// If set, the disk storage loading will happen in the same calling queue. By default, disk storage file loading
    /// happens in its own queue with an asynchronous dispatch behavior. Although it provides better non-blocking disk
    /// loading performance, it also causes a flickering when you reload an image from disk, if the image view already
    /// has an image set.
    ///
    /// Set this options will stop that flickering by keeping all loading in the same queue (typically the UI queue
    /// if you are using Kingfisher's extension methods to set an image), with a tradeoff of loading performance.
    case loadDiskFileSynchronously
    
    /// The expiration setting for memory cache. By default, the underlying `MemoryStorage.Backend` uses the
    /// expiration in its config for all items. If set, the `MemoryStorage.Backend` will use this associated
    /// value to overwrite the config setting for this caching item.
    case memoryCacheExpiration(StorageExpiration)
    
    /// The expiration extending setting for memory cache. The item expiration time will be incremented by this
    /// value after access.
    /// By default, the underlying `MemoryStorage.Backend` uses the initial cache expiration as extending
    /// value: .cacheTime.
    ///
    /// To disable extending option at all add memoryCacheAccessExtendingExpiration(.none) to options.
    case memoryCacheAccessExtendingExpiration(ExpirationExtending)
    
    /// The expiration setting for disk cache. By default, the underlying `DiskStorage.Backend` uses the
    /// expiration in its config for all items. If set, the `DiskStorage.Backend` will use this associated
    /// value to overwrite the config setting for this caching item.
    case diskCacheExpiration(StorageExpiration)
    /// The expiration extending setting for disk cache. The item expiration time will be incremented by this value after access.
    /// By default, the underlying `DiskStorage.Backend` uses the initial cache expiration as extending value: .cacheTime.
    /// To disable extending option at all add diskCacheAccessExtendingExpiration(.none) to options.
    case diskCacheAccessExtendingExpiration(ExpirationExtending)
    
    /// Decides on which queue the image processing should happen. By default, Kingfisher uses a pre-defined serial
    /// queue to process images. Use this option to change this behavior. For example, specify a `.mainCurrentOrAsync`
    /// to let the image be processed in main queue to prevent a possible flickering (but with a possibility of
    /// blocking the UI, especially if the processor needs a lot of time to run).
    case processingQueue(CallbackQueue)
    
    /// Enable progressive image loading, Kingfisher will use the `ImageProgressive` of
    case progressiveJPEG(ImageProgressive)
    /// The alternative sources will be used when the original input `Source` fails. The `Source`s in the associated
    /// array will be used to start a new image loading task if the previous task fails due to an error. The image
    /// source loading process will stop as soon as a source is loaded successfully. If all `[Source]`s are used but
    /// the loading is still failing, an `imageSettingError` with `alternativeSourcesExhausted` as its reason will be
    /// thrown out.
    ///
    /// This option is useful if you want to implement a fallback solution for setting image.
    ///
    /// User cancellation will not trigger the alternative source loading.
    case alternativeSources([Source])
    /// Provide a retry strategy which will be used when something gets wrong during the image retrieving process from
    /// `KingfisherManager`. You can define a strategy by create a type conforming to the `RetryStrategy` protocol.
    ///
    /// - Note:
    ///
    /// All extension methods of Kingfisher (`kf` extensions on `UIImageView` or `UIButton`) retrieve images through
    /// `KingfisherManager`, so the retry strategy also applies when using them. However, this option does not apply
    /// when pass to an `ImageDownloader` or `ImageCache`.
    ///
    case retryStrategy(RetryStrategy)
}
// Improve performance by parsing the input `KingfisherOptionsInfo` (self) first.
// So we can prevent the iterating over the options array again and again.
/// The parsed options info used across Kingfisher methods. Each property in this type corresponds a case member
/// in `KingfisherOptionsInfoItem`. When a `KingfisherOptionsInfo` sent to Kingfisher related methods, it will be
/// parsed and converted to a `KingfisherParsedOptionsInfo` first, and pass through the internal methods.
public struct KingfisherParsedOptionsInfo {
    public var targetCache: ImageCache? = nil
    public var originalCache: ImageCache? = nil
    public var downloader: ImageDownloader? = nil
    public var transition: ImageTransition = .none
    public var downloadPriority: Float = URLSessionTask.defaultPriority
    public var forceRefresh = false
    public var fromMemoryCacheOrRefresh = false
    public var forceTransition = false
    public var cacheMemoryOnly = false
    public var waitForCache = false
    public var onlyFromCache = false
    public var backgroundDecode = false
    public var preloadAllAnimationData = false
    public var callbackQueue: CallbackQueue = .mainCurrentOrAsync
    public var scaleFactor: CGFloat = 1.0
    public var requestModifier: ImageDownloadRequestModifier? = nil
    public var redirectHandler: ImageDownloadRedirectHandler? = nil
    public var processor: ImageProcessor = DefaultImageProcessor.default
    public var imageModifier: ImageModifier? = nil
    public var cacheSerializer: CacheSerializer = DefaultCacheSerializer.default
    public var keepCurrentImageWhileLoading = false
    public var onlyLoadFirstFrame = false
    public var cacheOriginalImage = false
    public var onFailureImage: Optional<KFCrossPlatformImage?> = .none
    public var alsoPrefetchToMemory = false
    public var loadDiskFileSynchronously = false
    public var memoryCacheExpiration: StorageExpiration? = nil
    public var memoryCacheAccessExtendingExpiration: ExpirationExtending = .cacheTime
    public var diskCacheExpiration: StorageExpiration? = nil
    public var diskCacheAccessExtendingExpiration: ExpirationExtending = .cacheTime
    public var processingQueue: CallbackQueue? = nil
    public var progressiveJPEG: ImageProgressive? = nil
    public var alternativeSources: [Source]? = nil
    public var retryStrategy: RetryStrategy? = nil
    var onDataReceived: [DataReceivingSideEffect]? = nil
    
    public init(_ info: KingfisherOptionsInfo?) {
        guard let info = info else { return }
        for option in info {
            switch option {
            case .targetCache(let value): targetCache = value
            case .originalCache(let value): originalCache = value
            case .downloader(let value): downloader = value
            case .transition(let value): transition = value
            case .downloadPriority(let value): downloadPriority = value
            case .forceRefresh: forceRefresh = true
            case .fromMemoryCacheOrRefresh: fromMemoryCacheOrRefresh = true
            case .forceTransition: forceTransition = true
            case .cacheMemoryOnly: cacheMemoryOnly = true
            case .waitForCache: waitForCache = true
            case .onlyFromCache: onlyFromCache = true
            case .backgroundDecode: backgroundDecode = true
            case .preloadAllAnimationData: preloadAllAnimationData = true
            case .callbackQueue(let value): callbackQueue = value
            case .scaleFactor(let value): scaleFactor = value
            case .requestModifier(let value): requestModifier = value
            case .redirectHandler(let value): redirectHandler = value
            case .processor(let value): processor = value
            case .imageModifier(let value): imageModifier = value
            case .cacheSerializer(let value): cacheSerializer = value
            case .keepCurrentImageWhileLoading: keepCurrentImageWhileLoading = true
            case .onlyLoadFirstFrame: onlyLoadFirstFrame = true
            case .cacheOriginalImage: cacheOriginalImage = true
            case .onFailureImage(let value): onFailureImage = .some(value)
            case .alsoPrefetchToMemory: alsoPrefetchToMemory = true
            case .loadDiskFileSynchronously: loadDiskFileSynchronously = true
            case .callbackDispatchQueue(let value): callbackQueue = value.map { .dispatch($0) } ?? .mainCurrentOrAsync
            case .memoryCacheExpiration(let expiration): memoryCacheExpiration = expiration
            case .memoryCacheAccessExtendingExpiration(let expirationExtending): memoryCacheAccessExtendingExpiration = expirationExtending
            case .diskCacheExpiration(let expiration): diskCacheExpiration = expiration
            case .diskCacheAccessExtendingExpiration(let expirationExtending): diskCacheAccessExtendingExpiration = expirationExtending
            case .processingQueue(let queue): processingQueue = queue
            case .progressiveJPEG(let value): progressiveJPEG = value
            case .alternativeSources(let sources): alternativeSources = sources
            case .retryStrategy(let strategy): retryStrategy = strategy
            }
        }
        if originalCache == nil {
            originalCache = targetCache
        }
    }
}
extension KingfisherParsedOptionsInfo {
    var imageCreatingOptions: ImageCreatingOptions {
        return ImageCreatingOptions(
            scale: scaleFactor,
            duration: 0.0,
            preloadAll: preloadAllAnimationData,
            onlyFirstFrame: onlyLoadFirstFrame)
    }
}
protocol DataReceivingSideEffect: AnyObject {
    var onShouldApply: () -> Bool { get set }
    func onDataReceived(_ session: URLSession, task: SessionDataTask, data: Data)
}
class ImageLoadingProgressSideEffect: DataReceivingSideEffect {
    var onShouldApply: () -> Bool = { return true }
    
    let block: DownloadProgressBlock
    init(_ block: @escaping DownloadProgressBlock) {
        self.block = block
    }
    func onDataReceived(_ session: URLSession, task: SessionDataTask, data: Data) {
        DispatchQueue.main.async {
            guard self.onShouldApply() else { return }
            guard let expectedContentLength = task.task.response?.expectedContentLength,
                      expectedContentLength != -1 else
            {
                return
            }
            let dataLength = Int64(task.mutableData.count)
            self.block(dataLength, expectedContentLength)
        }
    }
}
//
//  ImageDownloaderDelegate.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/10/11.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Protocol of `ImageDownloader`. This protocol provides a set of methods which are related to image downloader
/// working stages and rules.
public protocol ImageDownloaderDelegate: AnyObject {
    /// Called when the `ImageDownloader` object will start downloading an image from a specified URL.
    ///
    /// - Parameters:
    ///   - downloader: The `ImageDownloader` object which is used for the downloading operation.
    ///   - url: URL of the starting request.
    ///   - request: The request object for the download process.
    ///
    func imageDownloader(_ downloader: ImageDownloader, willDownloadImageForURL url: URL, with request: URLRequest?)
    /// Called when the `ImageDownloader` completes a downloading request with success or failure.
    ///
    /// - Parameters:
    ///   - downloader: The `ImageDownloader` object which is used for the downloading operation.
    ///   - url: URL of the original request URL.
    ///   - response: The response object of the downloading process.
    ///   - error: The error in case of failure.
    ///
    func imageDownloader(
        _ downloader: ImageDownloader,
        didFinishDownloadingImageForURL url: URL,
        with response: URLResponse?,
        error: Error?)
    /// Called when the `ImageDownloader` object successfully downloaded image data from specified URL. This is
    /// your last chance to verify or modify the downloaded data before Kingfisher tries to perform addition
    /// processing on the image data.
    ///
    /// - Parameters:
    ///   - downloader: The `ImageDownloader` object which is used for the downloading operation.
    ///   - data: The original downloaded data.
    ///   - url: The URL of the original request URL.
    /// - Returns: The data from which Kingfisher should use to create an image. You need to provide valid data
    ///            which content is one of the supported image file format. Kingfisher will perform process on this
    ///            data and try to convert it to an image object.
    /// - Note:
    ///   This can be used to pre-process raw image data before creation of `Image` instance (i.e.
    ///   decrypting or verification). If `nil` returned, the processing is interrupted and a `KingfisherError` with
    ///   `ResponseErrorReason.dataModifyingFailed` will be raised. You could use this fact to stop the image
    ///   processing flow if you find the data is corrupted or malformed.
    func imageDownloader(_ downloader: ImageDownloader, didDownload data: Data, for url: URL) -> Data?
    /// Called when the `ImageDownloader` object successfully downloads and processes an image from specified URL.
    ///
    /// - Parameters:
    ///   - downloader: The `ImageDownloader` object which is used for the downloading operation.
    ///   - image: The downloaded and processed image.
    ///   - url: URL of the original request URL.
    ///   - response: The original response object of the downloading process.
    ///
    func imageDownloader(
        _ downloader: ImageDownloader,
        didDownload image: KFCrossPlatformImage,
        for url: URL,
        with response: URLResponse?)
    /// Checks if a received HTTP status code is valid or not.
    /// By default, a status code in range 200..<400 is considered as valid.
    /// If an invalid code is received, the downloader will raise an `KingfisherError` with
    /// `ResponseErrorReason.invalidHTTPStatusCode` as its reason.
    ///
    /// - Parameters:
    ///   - code: The received HTTP status code.
    ///   - downloader: The `ImageDownloader` object asks for validate status code.
    /// - Returns: Returns a value to indicate whether this HTTP status code is valid or not.
    /// - Note: If the default 200 to 400 valid code does not suit your need,
    ///         you can implement this method to change that behavior.
    func isValidStatusCode(_ code: Int, for downloader: ImageDownloader) -> Bool
}
// Default implementation for `ImageDownloaderDelegate`.
extension ImageDownloaderDelegate {
    public func imageDownloader(
        _ downloader: ImageDownloader,
        willDownloadImageForURL url: URL,
        with request: URLRequest?) {}
    public func imageDownloader(
        _ downloader: ImageDownloader,
        didFinishDownloadingImageForURL url: URL,
        with response: URLResponse?,
        error: Error?) {}
    public func imageDownloader(
        _ downloader: ImageDownloader,
        didDownload image: KFCrossPlatformImage,
        for url: URL,
        with response: URLResponse?) {}
    public func isValidStatusCode(_ code: Int, for downloader: ImageDownloader) -> Bool {
        return (200..<400).contains(code)
    }
    public func imageDownloader(_ downloader: ImageDownloader, didDownload data: Data, for url: URL) -> Data? {
        return data
    }
}
//
//  RequestModifier.swift
//  Kingfisher
//
//  Created by Wei Wang on 2016/09/05.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents and wraps a method for modifying request before an image download request starts.
public protocol ImageDownloadRequestModifier {
    /// A method will be called just before the `request` being sent.
    /// This is the last chance you can modify the image download request. You can modify the request for some
    /// customizing purpose, such as adding auth token to the header, do basic HTTP auth or something like url mapping.
    ///
    /// Usually, you pass an `ImageDownloadRequestModifier` as the associated value of
    /// `KingfisherOptionsInfoItem.requestModifier` and use it as the `options` parameter in related methods.
    ///
    /// If you do nothing with the input `request` and return it as is, a downloading process will start with it.
    ///
    /// - Parameter request: The input request contains necessary information like `url`. This request is generated
    ///                      according to your resource url as a GET request.
    /// - Returns: A modified version of request, which you wish to use for downloading an image. If `nil` returned,
    ///            a `KingfisherError.requestError` with `.emptyRequest` as its reason will occur.
    ///
    func modified(for request: URLRequest) -> URLRequest?
}
/// A wrapper for creating an `ImageDownloadRequestModifier` easier.
/// This type conforms to `ImageDownloadRequestModifier` and wraps an image modify block.
public struct AnyModifier: ImageDownloadRequestModifier {
    
    let block: (URLRequest) -> URLRequest?
    /// For `ImageDownloadRequestModifier` conformation.
    public func modified(for request: URLRequest) -> URLRequest? {
        return block(request)
    }
    
    /// Creates a value of `ImageDownloadRequestModifier` which runs `modify` block.
    ///
    /// - Parameter modify: The request modifying block runs when a request modifying task comes.
    ///                     The return `URLRequest?` value of this block will be used as the image download request.
    ///                     If `nil` returned, a `KingfisherError.requestError` with `.emptyRequest` as its
    ///                     reason will occur.
    public init(modify: @escaping (URLRequest) -> URLRequest?) {
        block = modify
    }
}
//
//  ImageDataProcessor.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/10/11.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
private let sharedProcessingQueue: CallbackQueue =
    .dispatch(DispatchQueue(label: "com.onevcat.Kingfisher.ImageDownloader.Process"))
// Handles image processing work on an own process queue.
class ImageDataProcessor {
    let data: Data
    let callbacks: [SessionDataTask.TaskCallback]
    let queue: CallbackQueue
    // Note: We have an optimization choice there, to reduce queue dispatch by checking callback
    // queue settings in each option...
    let onImageProcessed = Delegate<(Result<KFCrossPlatformImage, KingfisherError>, SessionDataTask.TaskCallback), Void>()
    init(data: Data, callbacks: [SessionDataTask.TaskCallback], processingQueue: CallbackQueue?) {
        self.data = data
        self.callbacks = callbacks
        self.queue = processingQueue ?? sharedProcessingQueue
    }
    func process() {
        queue.execute(doProcess)
    }
    private func doProcess() {
        var processedImages = [String: KFCrossPlatformImage]()
        for callback in callbacks {
            let processor = callback.options.processor
            var image = processedImages[processor.identifier]
            if image == nil {
                image = processor.process(item: .data(data), options: callback.options)
                processedImages[processor.identifier] = image
            }
            let result: Result<KFCrossPlatformImage, KingfisherError>
            if let image = image {
                var finalImage = image
                if let imageModifier = callback.options.imageModifier {
                    finalImage = imageModifier.modify(image)
                }
                if callback.options.backgroundDecode {
                    finalImage = finalImage.kf.decoded
                }
                result = .success(finalImage)
            } else {
                let error = KingfisherError.processorError(
                    reason: .processingFailed(processor: processor, item: .data(data)))
                result = .failure(error)
            }
            onImageProcessed.call((result, callback))
        }
    }
}
//
//  SessionDataTask.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/11/1.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents a session data task in `ImageDownloader`. It consists of an underlying `URLSessionDataTask` and
/// an array of `TaskCallback`. Multiple `TaskCallback`s could be added for a single downloading data task.
public class SessionDataTask {
    /// Represents the type of token which used for cancelling a task.
    public typealias CancelToken = Int
    struct TaskCallback {
        let onCompleted: Delegate<Result<ImageLoadingResult, KingfisherError>, Void>?
        let options: KingfisherParsedOptionsInfo
    }
    /// Downloaded raw data of current task.
    public private(set) var mutableData: Data
    /// The underlying download task. It is only for debugging purpose when you encountered an error. You should not
    /// modify the content of this task or start it yourself.
    public let task: URLSessionDataTask
    private var callbacksStore = [CancelToken: TaskCallback]()
    var callbacks: [SessionDataTask.TaskCallback] {
        lock.lock()
        defer { lock.unlock() }
        return Array(callbacksStore.values)
    }
    private var currentToken = 0
    private let lock = NSLock()
    let onTaskDone = Delegate<(Result<(Data, URLResponse?), KingfisherError>, [TaskCallback]), Void>()
    let onCallbackCancelled = Delegate<(CancelToken, TaskCallback), Void>()
    var started = false
    var containsCallbacks: Bool {
        // We should be able to use `task.state != .running` to check it.
        // However, in some rare cases, cancelling the task does not change
        // task state to `.cancelling` immediately, but still in `.running`.
        // So we need to check callbacks count to for sure that it is safe to remove the
        // task in delegate.
        return !callbacks.isEmpty
    }
    init(task: URLSessionDataTask) {
        self.task = task
        mutableData = Data()
    }
    func addCallback(_ callback: TaskCallback) -> CancelToken {
        lock.lock()
        defer { lock.unlock() }
        callbacksStore[currentToken] = callback
        defer { currentToken += 1 }
        return currentToken
    }
    func removeCallback(_ token: CancelToken) -> TaskCallback? {
        lock.lock()
        defer { lock.unlock() }
        if let callback = callbacksStore[token] {
            callbacksStore[token] = nil
            return callback
        }
        return nil
    }
    func resume() {
        guard !started else { return }
        started = true
        task.resume()
    }
    func cancel(token: CancelToken) {
        guard let callback = removeCallback(token) else {
            return
        }
        if callbacksStore.count == 0 {
            task.cancel()
        }
        onCallbackCancelled.call((token, callback))
    }
    func forceCancel() {
        for token in callbacksStore.keys {
            cancel(token: token)
        }
    }
    func didReceiveData(_ data: Data) {
        mutableData.append(data)
    }
}
//
//  RedirectHandler.swift
//  Kingfisher
//
//  Created by Roman Maidanovych on 2018/12/10.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents and wraps a method for modifying request during an image download request redirection.
public protocol ImageDownloadRedirectHandler {
    /// The `ImageDownloadRedirectHandler` contained will be used to change the request before redirection.
    /// This is the posibility you can modify the image download request during redirection. You can modify the
    /// request for some customizing purpose, such as adding auth token to the header, do basic HTTP auth or
    /// something like url mapping.
    ///
    /// Usually, you pass an `ImageDownloadRedirectHandler` as the associated value of
    /// `KingfisherOptionsInfoItem.redirectHandler` and use it as the `options` parameter in related methods.
    ///
    /// If you do nothing with the input `request` and return it as is, a downloading process will redirect with it.
    ///
    /// - Parameters:
    ///   - task: The current `SessionDataTask` which triggers this redirect.
    ///   - response: The response received during redirection.
    ///   - newRequest: The request for redirection which can be modified.
    ///   - completionHandler: A closure for being called with modified request.
    func handleHTTPRedirection(
        for task: SessionDataTask,
        response: HTTPURLResponse,
        newRequest: URLRequest,
        completionHandler: @escaping (URLRequest?) -> Void)
}
/// A wrapper for creating an `ImageDownloadRedirectHandler` easier.
/// This type conforms to `ImageDownloadRedirectHandler` and wraps a redirect request modify block.
public struct AnyRedirectHandler: ImageDownloadRedirectHandler {
    
    let block: (SessionDataTask, HTTPURLResponse, URLRequest, (URLRequest?) -> Void) -> Void
    public func handleHTTPRedirection(
        for task: SessionDataTask,
        response: HTTPURLResponse,
        newRequest: URLRequest,
        completionHandler: @escaping (URLRequest?) -> Void)
    {
        block(task, response, newRequest, completionHandler)
    }
    
    /// Creates a value of `ImageDownloadRedirectHandler` which runs `modify` block.
    ///
    /// - Parameter modify: The request modifying block runs when a request modifying task comes.
    ///
    public init(handle: @escaping (SessionDataTask, HTTPURLResponse, URLRequest, (URLRequest?) -> Void) -> Void) {
        block = handle
    }
}
//
//  ImageDownloader.swift
//  Kingfisher
//
//  Created by Wei Wang on 15/4/6.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(macOS)
import AppKit
#else
import UIKit
#endif
/// Represents a success result of an image downloading progress.
public struct ImageLoadingResult {
    /// The downloaded image.
    public let image: KFCrossPlatformImage
    /// Original URL of the image request.
    public let url: URL?
    /// The raw data received from downloader.
    public let originalData: Data
}
/// Represents a task of an image downloading process.
public struct DownloadTask {
    /// The `SessionDataTask` object bounded to this download task. Multiple `DownloadTask`s could refer
    /// to a same `sessionTask`. This is an optimization in Kingfisher to prevent multiple downloading task
    /// for the same URL resource at the same time.
    ///
    /// When you `cancel` a `DownloadTask`, this `SessionDataTask` and its cancel token will be pass through.
    /// You can use them to identify the cancelled task.
    public let sessionTask: SessionDataTask
    /// The cancel token which is used to cancel the task. This is only for identify the task when it is cancelled.
    /// To cancel a `DownloadTask`, use `cancel` instead.
    public let cancelToken: SessionDataTask.CancelToken
    /// Cancel this task if it is running. It will do nothing if this task is not running.
    ///
    /// - Note:
    /// In Kingfisher, there is an optimization to prevent starting another download task if the target URL is being
    /// downloading. However, even when internally no new session task created, a `DownloadTask` will be still created
    /// and returned when you call related methods, but it will share the session downloading task with a previous task.
    /// In this case, if multiple `DownloadTask`s share a single session download task, cancelling a `DownloadTask`
    /// does not affect other `DownloadTask`s.
    ///
    /// If you need to cancel all `DownloadTask`s of a url, use `ImageDownloader.cancel(url:)`. If you need to cancel
    /// all downloading tasks of an `ImageDownloader`, use `ImageDownloader.cancelAll()`.
    public func cancel() {
        sessionTask.cancel(token: cancelToken)
    }
}
extension DownloadTask {
    enum WrappedTask {
        case download(DownloadTask)
        case dataProviding
        func cancel() {
            switch self {
            case .download(let task): task.cancel()
            case .dataProviding: break
            }
        }
        var value: DownloadTask? {
            switch self {
            case .download(let task): return task
            case .dataProviding: return nil
            }
        }
    }
}
/// Represents a downloading manager for requesting the image with a URL from server.
open class ImageDownloader {
    // MARK: Singleton
    /// The default downloader.
    public static let `default` = ImageDownloader(name: "default")
    // MARK: Public Properties
    /// The duration before the downloading is timeout. Default is 15 seconds.
    open var downloadTimeout: TimeInterval = 15.0
    
    /// A set of trusted hosts when receiving server trust challenges. A challenge with host name contained in this
    /// set will be ignored. You can use this set to specify the self-signed site. It only will be used if you don't
    /// specify the `authenticationChallengeResponder`.
    ///
    /// If `authenticationChallengeResponder` is set, this property will be ignored and the implementation of
    /// `authenticationChallengeResponder` will be used instead.
    open var trustedHosts: Set<String>?
    
    /// Use this to set supply a configuration for the downloader. By default,
    /// NSURLSessionConfiguration.ephemeralSessionConfiguration() will be used.
    ///
    /// You could change the configuration before a downloading task starts.
    /// A configuration without persistent storage for caches is requested for downloader working correctly.
    open var sessionConfiguration = URLSessionConfiguration.ephemeral {
        didSet {
            session.invalidateAndCancel()
            session = URLSession(configuration: sessionConfiguration, delegate: sessionDelegate, delegateQueue: nil)
        }
    }
    
    /// Whether the download requests should use pipeline or not. Default is false.
    open var requestsUsePipelining = false
    /// Delegate of this `ImageDownloader` object. See `ImageDownloaderDelegate` protocol for more.
    open weak var delegate: ImageDownloaderDelegate?
    
    /// A responder for authentication challenge. 
    /// Downloader will forward the received authentication challenge for the downloading session to this responder.
    open weak var authenticationChallengeResponder: AuthenticationChallengeResponsable?
    private let name: String
    private let sessionDelegate: SessionDelegate
    private var session: URLSession
    // MARK: Initializers
    /// Creates a downloader with name.
    ///
    /// - Parameter name: The name for the downloader. It should not be empty.
    public init(name: String) {
        if name.isEmpty {
            fatalError("[Kingfisher] You should specify a name for the downloader. "
                + "A downloader with empty name is not permitted.")
        }
        self.name = name
        sessionDelegate = SessionDelegate()
        session = URLSession(
            configuration: sessionConfiguration,
            delegate: sessionDelegate,
            delegateQueue: nil)
        authenticationChallengeResponder = self
        setupSessionHandler()
    }
    deinit { session.invalidateAndCancel() }
    private func setupSessionHandler() {
        sessionDelegate.onReceiveSessionChallenge.delegate(on: self) { (self, invoke) in
            self.authenticationChallengeResponder?.downloader(self, didReceive: invoke.1, completionHandler: invoke.2)
        }
        sessionDelegate.onReceiveSessionTaskChallenge.delegate(on: self) { (self, invoke) in
            self.authenticationChallengeResponder?.downloader(
                self, task: invoke.1, didReceive: invoke.2, completionHandler: invoke.3)
        }
        sessionDelegate.onValidStatusCode.delegate(on: self) { (self, code) in
            return (self.delegate ?? self).isValidStatusCode(code, for: self)
        }
        sessionDelegate.onDownloadingFinished.delegate(on: self) { (self, value) in
            let (url, result) = value
            do {
                let value = try result.get()
                self.delegate?.imageDownloader(self, didFinishDownloadingImageForURL: url, with: value, error: nil)
            } catch {
                self.delegate?.imageDownloader(self, didFinishDownloadingImageForURL: url, with: nil, error: error)
            }
        }
        sessionDelegate.onDidDownloadData.delegate(on: self) { (self, task) in
            guard let url = task.task.originalRequest?.url else {
                return task.mutableData
            }
            return (self.delegate ?? self).imageDownloader(self, didDownload: task.mutableData, for: url)
        }
    }
    // MARK: Dowloading Task
    /// Downloads an image with a URL and option. Invoked internally by Kingfisher. Subclasses must invoke super.
    ///
    /// - Parameters:
    ///   - url: Target URL.
    ///   - options: The options could control download behavior. See `KingfisherOptionsInfo`.
    ///   - completionHandler: Called when the download progress finishes. This block will be called in the queue
    ///                        defined in `.callbackQueue` in `options` parameter.
    /// - Returns: A downloading task. You could call `cancel` on it to stop the download task.
    @discardableResult
    open func downloadImage(
        with url: URL,
        options: KingfisherParsedOptionsInfo,
        completionHandler: ((Result<ImageLoadingResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        // Creates default request.
        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: downloadTimeout)
        request.httpShouldUsePipelining = requestsUsePipelining
        if let requestModifier = options.requestModifier {
            // Modifies request before sending.
            guard let r = requestModifier.modified(for: request) else {
                options.callbackQueue.execute {
                    completionHandler?(.failure(KingfisherError.requestError(reason: .emptyRequest)))
                }
                return nil
            }
            request = r
        }
        
        // There is a possibility that request modifier changed the url to `nil` or empty.
        // In this case, throw an error.
        guard let url = request.url, !url.absoluteString.isEmpty else {
            options.callbackQueue.execute {
                completionHandler?(.failure(KingfisherError.requestError(reason: .invalidURL(request: request))))
            }
            return nil
        }
        // Wraps `completionHandler` to `onCompleted` respectively.
        let onCompleted = completionHandler.map {
            block -> Delegate<Result<ImageLoadingResult, KingfisherError>, Void> in
            let delegate =  Delegate<Result<ImageLoadingResult, KingfisherError>, Void>()
            delegate.delegate(on: self) { (_, callback) in
                block(callback)
            }
            return delegate
        }
        // SessionDataTask.TaskCallback is a wrapper for `onCompleted` and `options` (for processor info)
        let callback = SessionDataTask.TaskCallback(
            onCompleted: onCompleted,
            options: options
        )
        // Ready to start download. Add it to session task manager (`sessionHandler`)
        let downloadTask: DownloadTask
        if let existingTask = sessionDelegate.task(for: url) {
            downloadTask = sessionDelegate.append(existingTask, url: url, callback: callback)
        } else {
            let sessionDataTask = session.dataTask(with: request)
            sessionDataTask.priority = options.downloadPriority
            downloadTask = sessionDelegate.add(sessionDataTask, url: url, callback: callback)
        }
        let sessionTask = downloadTask.sessionTask
        // Start the session task if not started yet.
        if !sessionTask.started {
            sessionTask.onTaskDone.delegate(on: self) { (self, done) in
                // Underlying downloading finishes.
                // result: Result<(Data, URLResponse?)>, callbacks: [TaskCallback]
                let (result, callbacks) = done
                // Before processing the downloaded data.
                do {
                    let value = try result.get()
                    self.delegate?.imageDownloader(
                        self,
                        didFinishDownloadingImageForURL: url,
                        with: value.1,
                        error: nil
                    )
                } catch {
                    self.delegate?.imageDownloader(
                        self,
                        didFinishDownloadingImageForURL: url,
                        with: nil,
                        error: error
                    )
                }
                switch result {
                // Download finished. Now process the data to an image.
                case .success(let (data, response)):
                    let processor = ImageDataProcessor(
                        data: data, callbacks: callbacks, processingQueue: options.processingQueue)
                    processor.onImageProcessed.delegate(on: self) { (self, result) in
                        // `onImageProcessed` will be called for `callbacks.count` times, with each
                        // `SessionDataTask.TaskCallback` as the input parameter.
                        // result: Result<Image>, callback: SessionDataTask.TaskCallback
                        let (result, callback) = result
                        if let image = try? result.get() {
                            self.delegate?.imageDownloader(self, didDownload: image, for: url, with: response)
                        }
                        let imageResult = result.map { ImageLoadingResult(image: $0, url: url, originalData: data) }
                        let queue = callback.options.callbackQueue
                        queue.execute { callback.onCompleted?.call(imageResult) }
                    }
                    processor.process()
                case .failure(let error):
                    callbacks.forEach { callback in
                        let queue = callback.options.callbackQueue
                        queue.execute { callback.onCompleted?.call(.failure(error)) }
                    }
                }
            }
            delegate?.imageDownloader(self, willDownloadImageForURL: url, with: request)
            sessionTask.resume()
        }
        return downloadTask
    }
    /// Downloads an image with a URL and option.
    ///
    /// - Parameters:
    ///   - url: Target URL.
    ///   - options: The options could control download behavior. See `KingfisherOptionsInfo`.
    ///   - progressBlock: Called when the download progress updated. This block will be always be called in main queue.
    ///   - completionHandler: Called when the download progress finishes. This block will be called in the queue
    ///                        defined in `.callbackQueue` in `options` parameter.
    /// - Returns: A downloading task. You could call `cancel` on it to stop the download task.
    @discardableResult
    open func downloadImage(
        with url: URL,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<ImageLoadingResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        var info = KingfisherParsedOptionsInfo(options)
        if let block = progressBlock {
            info.onDataReceived = (info.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        return downloadImage(
            with: url,
            options: info,
            completionHandler: completionHandler)
    }
}
// MARK: Cancelling Task
extension ImageDownloader {
    /// Cancel all downloading tasks for this `ImageDownloader`. It will trigger the completion handlers
    /// for all not-yet-finished downloading tasks.
    ///
    /// If you need to only cancel a certain task, call `cancel()` on the `DownloadTask`
    /// returned by the downloading methods. If you need to cancel all `DownloadTask`s of a certain url,
    /// use `ImageDownloader.cancel(url:)`.
    public func cancelAll() {
        sessionDelegate.cancelAll()
    }
    /// Cancel all downloading tasks for a given URL. It will trigger the completion handlers for
    /// all not-yet-finished downloading tasks for the URL.
    ///
    /// - Parameter url: The URL which you want to cancel downloading.
    public func cancel(url: URL) {
        sessionDelegate.cancel(url: url)
    }
}
// Use the default implementation from extension of `AuthenticationChallengeResponsable`.
extension ImageDownloader: AuthenticationChallengeResponsable {}
// Use the default implementation from extension of `ImageDownloaderDelegate`.
extension ImageDownloader: ImageDownloaderDelegate {}
//
//  AuthenticationChallengeResponsable.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/10/11.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Protocol indicates that an authentication challenge could be handled.
public protocol AuthenticationChallengeResponsable: AnyObject {
    /// Called when a session level authentication challenge is received.
    /// This method provide a chance to handle and response to the authentication
    /// challenge before downloading could start.
    ///
    /// - Parameters:
    ///   - downloader: The downloader which receives this challenge.
    ///   - challenge: An object that contains the request for authentication.
    ///   - completionHandler: A handler that your delegate method must call.
    ///
    /// - Note: This method is a forward from `URLSessionDelegate.urlSession(:didReceiveChallenge:completionHandler:)`.
    ///         Please refer to the document of it in `URLSessionDelegate`.
    func downloader(
        _ downloader: ImageDownloader,
        didReceive challenge: URLAuthenticationChallenge,
        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
    /// Called when a task level authentication challenge is received.
    /// This method provide a chance to handle and response to the authentication
    /// challenge before downloading could start.
    ///
    /// - Parameters:
    ///   - downloader: The downloader which receives this challenge.
    ///   - task: The task whose request requires authentication.
    ///   - challenge: An object that contains the request for authentication.
    ///   - completionHandler: A handler that your delegate method must call.
    func downloader(
        _ downloader: ImageDownloader,
        task: URLSessionTask,
        didReceive challenge: URLAuthenticationChallenge,
        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
}
extension AuthenticationChallengeResponsable {
    public func downloader(
        _ downloader: ImageDownloader,
        didReceive challenge: URLAuthenticationChallenge,
        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
    {
        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            if let trustedHosts = downloader.trustedHosts, trustedHosts.contains(challenge.protectionSpace.host) {
                let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)
                completionHandler(.useCredential, credential)
                return
            }
        }
        completionHandler(.performDefaultHandling, nil)
    }
    public func downloader(
        _ downloader: ImageDownloader,
        task: URLSessionTask,
        didReceive challenge: URLAuthenticationChallenge,
        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
    {
        completionHandler(.performDefaultHandling, nil)
    }
}
//
//  ImageModifier.swift
//  Kingfisher
//
//  Created by Ethan Gill on 2017/11/28.
//
//  Copyright (c) 2019 Ethan Gill <ethan.gill@me.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// An `ImageModifier` can be used to change properties on an image in between
/// cache serialization and use of the image. The modified returned image will be
/// only used for current rendering purpose, the serialization data will not contain
/// the changes applied by the `ImageModifier`.
public protocol ImageModifier {
    /// Modify an input `Image`.
    ///
    /// - parameter image:   Image which will be modified by `self`
    ///
    /// - returns: The modified image.
    ///
    /// - Note: The return value will be unmodified if modifying is not possible on
    ///         the current platform.
    /// - Note: Most modifiers support UIImage or NSImage, but not CGImage.
    func modify(_ image: KFCrossPlatformImage) -> KFCrossPlatformImage
}
/// A wrapper for creating an `ImageModifier` easier.
/// This type conforms to `ImageModifier` and wraps an image modify block.
/// If the `block` throws an error, the original image will be used.
public struct AnyImageModifier: ImageModifier {
    /// A block which modifies images, or returns the original image
    /// if modification cannot be performed with an error.
    let block: (KFCrossPlatformImage) throws -> KFCrossPlatformImage
    /// Creates an `AnyImageModifier` with a given `modify` block.
    public init(modify: @escaping (KFCrossPlatformImage) throws -> KFCrossPlatformImage) {
        block = modify
    }
    /// Modify an input `Image`. See `ImageModifier` protocol for more.
    public func modify(_ image: KFCrossPlatformImage) -> KFCrossPlatformImage {
        return (try? block(image)) ?? image
    }
}
#if os(iOS) || os(tvOS) || os(watchOS)
import UIKit
/// Modifier for setting the rendering mode of images.
public struct RenderingModeImageModifier: ImageModifier {
    /// The rendering mode to apply to the image.
    public let renderingMode: UIImage.RenderingMode
    /// Creates a `RenderingModeImageModifier`.
    ///
    /// - Parameter renderingMode: The rendering mode to apply to the image. Default is `.automatic`.
    public init(renderingMode: UIImage.RenderingMode = .automatic) {
        self.renderingMode = renderingMode
    }
    /// Modify an input `Image`. See `ImageModifier` protocol for more.
    public func modify(_ image: KFCrossPlatformImage) -> KFCrossPlatformImage {
        return image.withRenderingMode(renderingMode)
    }
}
/// Modifier for setting the `flipsForRightToLeftLayoutDirection` property of images.
public struct FlipsForRightToLeftLayoutDirectionImageModifier: ImageModifier {
    /// Creates a `FlipsForRightToLeftLayoutDirectionImageModifier`.
    public init() {}
    /// Modify an input `Image`. See `ImageModifier` protocol for more.
    public func modify(_ image: KFCrossPlatformImage) -> KFCrossPlatformImage {
        return image.imageFlippedForRightToLeftLayoutDirection()
    }
}
/// Modifier for setting the `alignmentRectInsets` property of images.
public struct AlignmentRectInsetsImageModifier: ImageModifier {
    /// The alignment insets to apply to the image
    public let alignmentInsets: UIEdgeInsets
    /// Creates an `AlignmentRectInsetsImageModifier`.
    public init(alignmentInsets: UIEdgeInsets) {
        self.alignmentInsets = alignmentInsets
    }
    /// Modify an input `Image`. See `ImageModifier` protocol for more.
    public func modify(_ image: KFCrossPlatformImage) -> KFCrossPlatformImage {
        return image.withAlignmentRectInsets(alignmentInsets)
    }
}
#endif
//
//  RetryStrategy.swift
//  Kingfisher
//
//  Created by onevcat on 2020/05/04.
//
//  Copyright (c) 2020 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents a retry context which could be used to determine the current retry status.
public class RetryContext {
    /// The source from which the target image should be retrieved.
    public let source: Source
    /// The last error which caused current retry behavior.
    public let error: KingfisherError
    /// The retried count before current retry happens. This value is `0` if the current retry is for the first time.
    public var retriedCount: Int
    /// A user set value for passing any other information during the retry. If you choose to use `RetryDecision.retry`
    /// as the retry decision for `RetryStrategy.retry(context:retryHandler:)`, the associated value of
    /// `RetryDecision.retry` will be delivered to you in the next retry.
    public internal(set) var userInfo: Any? = nil
    init(source: Source, error: KingfisherError) {
        self.source = source
        self.error = error
        self.retriedCount = 0
    }
    @discardableResult
    func increaseRetryCount() -> RetryContext {
        retriedCount += 1
        return self
    }
}
/// Represents decision of behavior on the current retry.
public enum RetryDecision {
    /// A retry should happen. The associated `userInfo` will be pass to the next retry in the `RetryContext` parameter.
    case retry(userInfo: Any?)
    /// There should be no more retry attempt. The image retrieving process will fail with an error.
    case stop
}
/// Defines a retry strategy can be applied to a `.retryStrategy` option.
public protocol RetryStrategy {
    /// Kingfisher calls this method if an error happens during the image retrieving process from a `KingfisherManager`.
    /// You implement this method to provide necessary logic based on the `context` parameter. Then you need to call
    /// `retryHandler` to pass the retry decision back to Kingfisher.
    ///
    /// - Parameters:
    ///   - context: The retry context containing information of current retry attempt.
    ///   - retryHandler: A block you need to call with a decision of whether the retry should happen or not.
    func retry(context: RetryContext, retryHandler: @escaping (RetryDecision) -> Void)
}
/// A retry strategy that guides Kingfisher to retry when a `.responseError` happens, with a specified max retry count
/// and a certain interval mechanism.
public struct DelayRetryStrategy: RetryStrategy {
    /// Represents the interval mechanism which used in a `DelayRetryStrategy`.
    public enum Interval {
        /// The next retry attempt should happen in fixed seconds. For example, if the associated value is 3, the
        /// attempts happens after 3 seconds after the previous decision is made.
        case seconds(TimeInterval)
        /// The next retry attempt should happen in an accumulated duration. For example, if the associated value is 3,
        /// the attempts happens with interval of 3, 6, 9, 12, ... seconds.
        case accumulated(TimeInterval)
        /// Uses a block to determine the next interval. The current retry count is given as a parameter.
        case custom(block: (_ retriedCount: Int) -> TimeInterval)
        func timeInterval(for retriedCount: Int) -> TimeInterval {
            let retryAfter: TimeInterval
            switch self {
            case .seconds(let interval):
                retryAfter = interval
            case .accumulated(let interval):
                retryAfter = Double(retriedCount + 1) * interval
            case .custom(let block):
                retryAfter = block(retriedCount)
            }
            return retryAfter
        }
    }
    /// The max retry count defined for the retry strategy
    public let maxRetryCount: Int
    /// The retry interval mechanism defined for the retry strategy.
    public let retryInterval: Interval
    /// Creates a delay retry strategy.
    /// - Parameters:
    ///   - maxRetryCount: The max retry count.
    ///   - retryInterval: The retry interval mechanism. By default, `.seconds(3)` is used to provide a constant retry
    ///   interval.
    public init(maxRetryCount: Int, retryInterval: Interval = .seconds(3)) {
        self.maxRetryCount = maxRetryCount
        self.retryInterval = retryInterval
    }
    public func retry(context: RetryContext, retryHandler: @escaping (RetryDecision) -> Void) {
        // Retry count exceeded.
        guard context.retriedCount < maxRetryCount else {
            retryHandler(.stop)
            return
        }
        // User cancel the task. No retry.
        guard !context.error.isTaskCancelled else {
            retryHandler(.stop)
            return
        }
        // Only retry for a response error.
        guard case KingfisherError.responseError = context.error else {
            retryHandler(.stop)
            return
        }
        let interval = retryInterval.timeInterval(for: context.retriedCount)
        if interval == 0 {
            retryHandler(.retry(userInfo: nil))
        } else {
            DispatchQueue.main.asyncAfter(deadline: .now() + interval) {
                retryHandler(.retry(userInfo: nil))
            }
        }
    }
}
//
//  SessionDelegate.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/11/1.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
// Represents the delegate object of downloader session. It also behave like a task manager for downloading.
@objc(KFSessionDelegate) // Fix for ObjC header name conflicting. https://github.com/onevcat/Kingfisher/issues/1530
class SessionDelegate: NSObject {
    typealias SessionChallengeFunc = (
        URLSession,
        URLAuthenticationChallenge,
        (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
    )
    typealias SessionTaskChallengeFunc = (
        URLSession,
        URLSessionTask,
        URLAuthenticationChallenge,
        (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
    )
    private var tasks: [URL: SessionDataTask] = [:]
    private let lock = NSLock()
    let onValidStatusCode = Delegate<Int, Bool>()
    let onDownloadingFinished = Delegate<(URL, Result<URLResponse, KingfisherError>), Void>()
    let onDidDownloadData = Delegate<SessionDataTask, Data?>()
    let onReceiveSessionChallenge = Delegate<SessionChallengeFunc, Void>()
    let onReceiveSessionTaskChallenge = Delegate<SessionTaskChallengeFunc, Void>()
    func add(
        _ dataTask: URLSessionDataTask,
        url: URL,
        callback: SessionDataTask.TaskCallback) -> DownloadTask
    {
        lock.lock()
        defer { lock.unlock() }
        // Create a new task if necessary.
        let task = SessionDataTask(task: dataTask)
        task.onCallbackCancelled.delegate(on: self) { [weak task] (self, value) in
            guard let task = task else { return }
            let (token, callback) = value
            let error = KingfisherError.requestError(reason: .taskCancelled(task: task, token: token))
            task.onTaskDone.call((.failure(error), [callback]))
            // No other callbacks waiting, we can clear the task now.
            if !task.containsCallbacks {
                let dataTask = task.task
                self.remove(dataTask)
            }
        }
        let token = task.addCallback(callback)
        tasks[url] = task
        return DownloadTask(sessionTask: task, cancelToken: token)
    }
    func append(
        _ task: SessionDataTask,
        url: URL,
        callback: SessionDataTask.TaskCallback) -> DownloadTask
    {
        let token = task.addCallback(callback)
        return DownloadTask(sessionTask: task, cancelToken: token)
    }
    private func remove(_ task: URLSessionTask) {
        guard let url = task.originalRequest?.url else {
            return
        }
        lock.lock()
        defer {lock.unlock()}
        tasks[url] = nil
    }
    private func task(for task: URLSessionTask) -> SessionDataTask? {
        guard let url = task.originalRequest?.url else {
            return nil
        }
        lock.lock()
        defer { lock.unlock() }
        guard let sessionTask = tasks[url] else {
            return nil
        }
        guard sessionTask.task.taskIdentifier == task.taskIdentifier else {
            return nil
        }
        return sessionTask
    }
    func task(for url: URL) -> SessionDataTask? {
        lock.lock()
        defer { lock.unlock() }
        return tasks[url]
    }
    func cancelAll() {
        lock.lock()
        let taskValues = tasks.values
        lock.unlock()
        for task in taskValues {
            task.forceCancel()
        }
    }
    func cancel(url: URL) {
        lock.lock()
        let task = tasks[url]
        lock.unlock()
        task?.forceCancel()
    }
}
extension SessionDelegate: URLSessionDataDelegate {
    func urlSession(
        _ session: URLSession,
        dataTask: URLSessionDataTask,
        didReceive response: URLResponse,
        completionHandler: @escaping (URLSession.ResponseDisposition) -> Void)
    {
        guard let httpResponse = response as? HTTPURLResponse else {
            let error = KingfisherError.responseError(reason: .invalidURLResponse(response: response))
            onCompleted(task: dataTask, result: .failure(error))
            completionHandler(.cancel)
            return
        }
        let httpStatusCode = httpResponse.statusCode
        guard onValidStatusCode.call(httpStatusCode) == true else {
            let error = KingfisherError.responseError(reason: .invalidHTTPStatusCode(response: httpResponse))
            onCompleted(task: dataTask, result: .failure(error))
            completionHandler(.cancel)
            return
        }
        completionHandler(.allow)
    }
    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
        guard let task = self.task(for: dataTask) else {
            return
        }
        
        task.didReceiveData(data)
        
        task.callbacks.forEach { callback in
            callback.options.onDataReceived?.forEach { sideEffect in
                sideEffect.onDataReceived(session, task: task, data: data)
            }
        }
    }
    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        guard let sessionTask = self.task(for: task) else { return }
        if let url = task.originalRequest?.url {
            let result: Result<URLResponse, KingfisherError>
            if let error = error {
                result = .failure(KingfisherError.responseError(reason: .URLSessionError(error: error)))
            } else if let response = task.response {
                result = .success(response)
            } else {
                result = .failure(KingfisherError.responseError(reason: .noURLResponse(task: sessionTask)))
            }
            onDownloadingFinished.call((url, result))
        }
        let result: Result<(Data, URLResponse?), KingfisherError>
        if let error = error {
            result = .failure(KingfisherError.responseError(reason: .URLSessionError(error: error)))
        } else {
            if let data = onDidDownloadData.call(sessionTask), let finalData = data {
                result = .success((finalData, task.response))
            } else {
                result = .failure(KingfisherError.responseError(reason: .dataModifyingFailed(task: sessionTask)))
            }
        }
        onCompleted(task: task, result: result)
    }
    func urlSession(
        _ session: URLSession,
        didReceive challenge: URLAuthenticationChallenge,
        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
    {
        onReceiveSessionChallenge.call((session, challenge, completionHandler))
    }
    func urlSession(
        _ session: URLSession,
        task: URLSessionTask,
        didReceive challenge: URLAuthenticationChallenge,
        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
    {
        onReceiveSessionTaskChallenge.call((session, task, challenge, completionHandler))
    }
    
    func urlSession(
        _ session: URLSession,
        task: URLSessionTask,
        willPerformHTTPRedirection response: HTTPURLResponse,
        newRequest request: URLRequest,
        completionHandler: @escaping (URLRequest?) -> Void)
    {
        guard let sessionDataTask = self.task(for: task),
              let redirectHandler = Array(sessionDataTask.callbacks).last?.options.redirectHandler else
        {
            completionHandler(request)
            return
        }
        
        redirectHandler.handleHTTPRedirection(
            for: sessionDataTask,
            response: response,
            newRequest: request,
            completionHandler: completionHandler)
    }
    private func onCompleted(task: URLSessionTask, result: Result<(Data, URLResponse?), KingfisherError>) {
        guard let sessionTask = self.task(for: task) else {
            return
        }
        remove(task)
        sessionTask.onTaskDone.call((result, sessionTask.callbacks))
    }
}
//
//  ImagePrefetcher.swift
//  Kingfisher
//
//  Created by Claire Knight <claire.knight@moggytech.co.uk> on 24/02/2016
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(macOS)
import AppKit
#else
import UIKit
#endif
/// Progress update block of prefetcher when initialized with a list of resources.
///
/// - `skippedResources`: An array of resources that are already cached before the prefetching starting.
/// - `failedResources`: An array of resources that fail to be downloaded. It could because of being cancelled while
///                      downloading, encountered an error when downloading or the download not being started at all.
/// - `completedResources`: An array of resources that are downloaded and cached successfully.
public typealias PrefetcherProgressBlock =
    ((_ skippedResources: [Resource], _ failedResources: [Resource], _ completedResources: [Resource]) -> Void)
/// Progress update block of prefetcher when initialized with a list of resources.
///
/// - `skippedSources`: An array of sources that are already cached before the prefetching starting.
/// - `failedSources`: An array of sources that fail to be fetched.
/// - `completedResources`: An array of sources that are fetched and cached successfully.
public typealias PrefetcherSourceProgressBlock =
    ((_ skippedSources: [Source], _ failedSources: [Source], _ completedSources: [Source]) -> Void)
/// Completion block of prefetcher when initialized with a list of sources.
///
/// - `skippedResources`: An array of resources that are already cached before the prefetching starting.
/// - `failedResources`: An array of resources that fail to be downloaded. It could because of being cancelled while
///                      downloading, encountered an error when downloading or the download not being started at all.
/// - `completedResources`: An array of resources that are downloaded and cached successfully.
public typealias PrefetcherCompletionHandler =
    ((_ skippedResources: [Resource], _ failedResources: [Resource], _ completedResources: [Resource]) -> Void)
/// Completion block of prefetcher when initialized with a list of sources.
///
/// - `skippedSources`: An array of sources that are already cached before the prefetching starting.
/// - `failedSources`: An array of sources that fail to be fetched.
/// - `completedSources`: An array of sources that are fetched and cached successfully.
public typealias PrefetcherSourceCompletionHandler =
    ((_ skippedSources: [Source], _ failedSources: [Source], _ completedSources: [Source]) -> Void)
/// `ImagePrefetcher` represents a downloading manager for requesting many images via URLs, then caching them.
/// This is useful when you know a list of image resources and want to download them before showing. It also works with
/// some Cocoa prefetching mechanism like table view or collection view `prefetchDataSource`, to start image downloading
/// and caching before they display on screen.
public class ImagePrefetcher: CustomStringConvertible {
    public var description: String {
        return "\(Unmanaged.passUnretained(self).toOpaque())"
    }
    
    /// The maximum concurrent downloads to use when prefetching images. Default is 5.
    public var maxConcurrentDownloads = 5
    private let prefetchSources: [Source]
    private let optionsInfo: KingfisherParsedOptionsInfo
    private var progressBlock: PrefetcherProgressBlock?
    private var completionHandler: PrefetcherCompletionHandler?
    private var progressSourceBlock: PrefetcherSourceProgressBlock?
    private var completionSourceHandler: PrefetcherSourceCompletionHandler?
    
    private var tasks = [String: DownloadTask.WrappedTask]()
    
    private var pendingSources: ArraySlice<Source>
    private var skippedSources = [Source]()
    private var completedSources = [Source]()
    private var failedSources = [Source]()
    
    private var stopped = false
    
    // A manager used for prefetching. We will use the helper methods in manager.
    private let manager: KingfisherManager
    private let pretchQueue = DispatchQueue(label: "com.onevcat.Kingfisher.ImagePrefetcher.pretchQueue")
    private static let requestingQueue = DispatchQueue(label: "com.onevcat.Kingfisher.ImagePrefetcher.requestingQueue")
    private var finished: Bool {
        let totalFinished: Int = failedSources.count + skippedSources.count + completedSources.count
        return totalFinished == prefetchSources.count && tasks.isEmpty
    }
    /// Creates an image prefetcher with an array of URLs.
    ///
    /// The prefetcher should be initiated with a list of prefetching targets. The URLs list is immutable.
    /// After you get a valid `ImagePrefetcher` object, you call `start()` on it to begin the prefetching process.
    /// The images which are already cached will be skipped without downloading again.
    ///
    /// - Parameters:
    ///   - urls: The URLs which should be prefetched.
    ///   - options: Options could control some behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called every time an resource is downloaded, skipped or cancelled.
    ///   - completionHandler: Called when the whole prefetching process finished.
    ///
    /// - Note:
    /// By default, the `ImageDownloader.defaultDownloader` and `ImageCache.defaultCache` will be used as
    /// the downloader and cache target respectively. You can specify another downloader or cache by using
    /// a customized `KingfisherOptionsInfo`. Both the progress and completion block will be invoked in
    /// main thread. The `.callbackQueue` value in `optionsInfo` will be ignored in this method.
    public convenience init(
        urls: [URL],
        options: KingfisherOptionsInfo? = nil,
        progressBlock: PrefetcherProgressBlock? = nil,
        completionHandler: PrefetcherCompletionHandler? = nil)
    {
        let resources: [Resource] = urls.map { $0 }
        self.init(
            resources: resources,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    /// Creates an image prefetcher with an array of resources.
    ///
    /// - Parameters:
    ///   - resources: The resources which should be prefetched. See `Resource` type for more.
    ///   - options: Options could control some behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called every time an resource is downloaded, skipped or cancelled.
    ///   - completionHandler: Called when the whole prefetching process finished.
    ///
    /// - Note:
    /// By default, the `ImageDownloader.defaultDownloader` and `ImageCache.defaultCache` will be used as
    /// the downloader and cache target respectively. You can specify another downloader or cache by using
    /// a customized `KingfisherOptionsInfo`. Both the progress and completion block will be invoked in
    /// main thread. The `.callbackQueue` value in `optionsInfo` will be ignored in this method.
    public convenience init(
        resources: [Resource],
        options: KingfisherOptionsInfo? = nil,
        progressBlock: PrefetcherProgressBlock? = nil,
        completionHandler: PrefetcherCompletionHandler? = nil)
    {
        self.init(sources: resources.map { $0.convertToSource() }, options: options)
        self.progressBlock = progressBlock
        self.completionHandler = completionHandler
    }
    /// Creates an image prefetcher with an array of sources.
    ///
    /// - Parameters:
    ///   - sources: The sources which should be prefetched. See `Source` type for more.
    ///   - options: Options could control some behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called every time an source fetching successes, fails, is skipped.
    ///   - completionHandler: Called when the whole prefetching process finished.
    ///
    /// - Note:
    /// By default, the `ImageDownloader.defaultDownloader` and `ImageCache.defaultCache` will be used as
    /// the downloader and cache target respectively. You can specify another downloader or cache by using
    /// a customized `KingfisherOptionsInfo`. Both the progress and completion block will be invoked in
    /// main thread. The `.callbackQueue` value in `optionsInfo` will be ignored in this method.
    public convenience init(sources: [Source],
        options: KingfisherOptionsInfo? = nil,
        progressBlock: PrefetcherSourceProgressBlock? = nil,
        completionHandler: PrefetcherSourceCompletionHandler? = nil)
    {
        self.init(sources: sources, options: options)
        self.progressSourceBlock = progressBlock
        self.completionSourceHandler = completionHandler
    }
    init(sources: [Source], options: KingfisherOptionsInfo?) {
        var options = KingfisherParsedOptionsInfo(options)
        prefetchSources = sources
        pendingSources = ArraySlice(sources)
        // We want all callbacks from our prefetch queue, so we should ignore the callback queue in options.
        // Add our own callback dispatch queue to make sure all internal callbacks are
        // coming back in our expected queue.
        options.callbackQueue = .dispatch(pretchQueue)
        optionsInfo = options
        let cache = optionsInfo.targetCache ?? .default
        let downloader = optionsInfo.downloader ?? .default
        manager = KingfisherManager(downloader: downloader, cache: cache)
    }
    /// Starts to download the resources and cache them. This can be useful for background downloading
    /// of assets that are required for later use in an app. This code will not try and update any UI
    /// with the results of the process.
    public func start() {
        pretchQueue.async {
            guard !self.stopped else {
                assertionFailure("You can not restart the same prefetcher. Try to create a new prefetcher.")
                self.handleComplete()
                return
            }
            guard self.maxConcurrentDownloads > 0 else {
                assertionFailure("There should be concurrent downloads value should be at least 1.")
                self.handleComplete()
                return
            }
            // Empty case.
            guard self.prefetchSources.count > 0 else {
                self.handleComplete()
                return
            }
            let initialConcurrentDownloads = min(self.prefetchSources.count, self.maxConcurrentDownloads)
            for _ in 0 ..< initialConcurrentDownloads {
                if let resource = self.pendingSources.popFirst() {
                    self.startPrefetching(resource)
                }
            }
        }
    }
    /// Stops current downloading progress, and cancel any future prefetching activity that might be occuring.
    public func stop() {
        pretchQueue.async {
            if self.finished { return }
            self.stopped = true
            self.tasks.values.forEach { $0.cancel() }
        }
    }
    
    private func downloadAndCache(_ source: Source) {
        let downloadTaskCompletionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void) = { result in
            self.tasks.removeValue(forKey: source.cacheKey)
            do {
                let _ = try result.get()
                self.completedSources.append(source)
            } catch {
                self.failedSources.append(source)
            }
            
            self.reportProgress()
            if self.stopped {
                if self.tasks.isEmpty {
                    self.failedSources.append(contentsOf: self.pendingSources)
                    self.handleComplete()
                }
            } else {
                self.reportCompletionOrStartNext()
            }
        }
        var downloadTask: DownloadTask.WrappedTask?
        ImagePrefetcher.requestingQueue.sync {
            let context = RetrievingContext(
                options: optionsInfo, originalSource: source
            )
            downloadTask = manager.loadAndCacheImage(
                source: source,
                context: context,
                completionHandler: downloadTaskCompletionHandler)
        }
        if let downloadTask = downloadTask {
            tasks[source.cacheKey] = downloadTask
        }
    }
    
    private func append(cached source: Source) {
        skippedSources.append(source)
 
        reportProgress()
        reportCompletionOrStartNext()
    }
    
    private func startPrefetching(_ source: Source)
    {
        if optionsInfo.forceRefresh {
            downloadAndCache(source)
            return
        }
        
        let cacheType = manager.cache.imageCachedType(
            forKey: source.cacheKey,
            processorIdentifier: optionsInfo.processor.identifier)
        switch cacheType {
        case .memory:
            append(cached: source)
        case .disk:
            if optionsInfo.alsoPrefetchToMemory {
                let context = RetrievingContext(options: optionsInfo, originalSource: source)
                _ = manager.retrieveImageFromCache(
                    source: source,
                    context: context)
                {
                    _ in
                    self.append(cached: source)
                }
            } else {
                append(cached: source)
            }
        case .none:
            downloadAndCache(source)
        }
    }
    
    private func reportProgress() {
        if progressBlock == nil && progressSourceBlock == nil {
            return
        }
        let skipped = self.skippedSources
        let failed = self.failedSources
        let completed = self.completedSources
        CallbackQueue.mainCurrentOrAsync.execute {
            self.progressSourceBlock?(skipped, failed, completed)
            self.progressBlock?(
                skipped.compactMap { $0.asResource },
                failed.compactMap { $0.asResource },
                completed.compactMap { $0.asResource }
            )
        }
    }
    
    private func reportCompletionOrStartNext() {
        if let resource = self.pendingSources.popFirst() {
            // Loose call stack for huge ammount of sources.
            pretchQueue.async { self.startPrefetching(resource) }
        } else {
            guard allFinished else { return }
            self.handleComplete()
        }
    }
    var allFinished: Bool {
        return skippedSources.count + failedSources.count + completedSources.count == prefetchSources.count
    }
    
    private func handleComplete() {
        if completionHandler == nil && completionSourceHandler == nil {
            return
        }
        
        // The completion handler should be called on the main thread
        CallbackQueue.mainCurrentOrAsync.execute {
            self.completionSourceHandler?(self.skippedSources, self.failedSources, self.completedSources)
            self.completionHandler?(
                self.skippedSources.compactMap { $0.asResource },
                self.failedSources.compactMap { $0.asResource },
                self.completedSources.compactMap { $0.asResource }
            )
            self.completionHandler = nil
            self.progressBlock = nil
        }
    }
}
//
//  ImageProgressive.swift
//  Kingfisher
//
//  Created by lixiang on 2019/5/10.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
import CoreGraphics
private let sharedProcessingQueue: CallbackQueue =
    .dispatch(DispatchQueue(label: "com.onevcat.Kingfisher.ImageDownloader.Process"))
public struct ImageProgressive {
    
    /// A default `ImageProgressive` could be used across.
    public static let `default` = ImageProgressive(
        isBlur: true,
        isFastestScan: true,
        scanInterval: 0
    )
    
    /// Whether to enable blur effect processing
    let isBlur: Bool
    /// Whether to enable the fastest scan
    let isFastestScan: Bool
    /// Minimum time interval for each scan
    let scanInterval: TimeInterval
    
    public init(isBlur: Bool,
                isFastestScan: Bool,
                scanInterval: TimeInterval) {
        self.isBlur = isBlur
        self.isFastestScan = isFastestScan
        self.scanInterval = scanInterval
    }
}
protocol ImageSettable: AnyObject {
    var image: KFCrossPlatformImage? { get set }
}
final class ImageProgressiveProvider: DataReceivingSideEffect {
    
    var onShouldApply: () -> Bool = { return true }
    
    func onDataReceived(_ session: URLSession, task: SessionDataTask, data: Data) {
        DispatchQueue.main.async {
            guard self.onShouldApply() else { return }
            self.update(data: task.mutableData, with: task.callbacks)
        }
    }
    private let option: ImageProgressive
    private let refresh: (KFCrossPlatformImage) -> Void
    
    private let decoder: ImageProgressiveDecoder
    private let queue = ImageProgressiveSerialQueue()
    
    init?(_ options: KingfisherParsedOptionsInfo,
          refresh: @escaping (KFCrossPlatformImage) -> Void) {
        guard let option = options.progressiveJPEG else { return nil }
        
        self.option = option
        self.refresh = refresh
        self.decoder = ImageProgressiveDecoder(
            option,
            processingQueue: options.processingQueue ?? sharedProcessingQueue,
            creatingOptions: options.imageCreatingOptions
        )
    }
    
    func update(data: Data, with callbacks: [SessionDataTask.TaskCallback]) {
        guard !data.isEmpty else { return }
        queue.add(minimum: option.scanInterval) { completion in
            func decode(_ data: Data) {
                self.decoder.decode(data, with: callbacks) { image in
                    defer { completion() }
                    guard self.onShouldApply() else { return }
                    guard let image = image else { return }
                    self.refresh(image)
                }
            }
            
            let semaphore = DispatchSemaphore(value: 0)
            var onShouldApply: Bool = false
            
            CallbackQueue.mainAsync.execute {
                onShouldApply = self.onShouldApply()
                semaphore.signal()
            }
            semaphore.wait()
            guard onShouldApply else {
                self.queue.clean()
                completion()
                return
            }
            if self.option.isFastestScan {
                decode(self.decoder.scanning(data) ?? Data())
            } else {
                self.decoder.scanning(data).forEach { decode($0) }
            }
        }
    }
}
private final class ImageProgressiveDecoder {
    
    private let option: ImageProgressive
    private let processingQueue: CallbackQueue
    private let creatingOptions: ImageCreatingOptions
    private(set) var scannedCount = 0
    private(set) var scannedIndex = -1
    
    init(_ option: ImageProgressive,
         processingQueue: CallbackQueue,
         creatingOptions: ImageCreatingOptions) {
        self.option = option
        self.processingQueue = processingQueue
        self.creatingOptions = creatingOptions
    }
    
    func scanning(_ data: Data) -> [Data] {
        guard data.kf.contains(jpeg: .SOF2) else {
            return []
        }
        guard scannedIndex + 1 < data.count else {
            return []
        }
        
        var datas: [Data] = []
        var index = scannedIndex + 1
        var count = scannedCount
        
        while index < data.count - 1 {
            scannedIndex = index
            // 0xFF, 0xDA - Start Of Scan
            let SOS = ImageFormat.JPEGMarker.SOS.bytes
            if data[index] == SOS[0], data[index + 1] == SOS[1] {
                if count > 0 {
                    datas.append(data[0 ..< index])
                }
                count += 1
            }
            index += 1
        }
        
        // Found more scans this the previous time
        guard count > scannedCount else { return [] }
        scannedCount = count
        
        // `> 1` checks that we've received a first scan (SOS) and then received
        // and also received a second scan (SOS). This way we know that we have
        // at least one full scan available.
        guard count > 1 else { return [] }
        return datas
    }
    
    func scanning(_ data: Data) -> Data? {
        guard data.kf.contains(jpeg: .SOF2) else {
            return nil
        }
        guard scannedIndex + 1 < data.count else {
            return nil
        }
        
        var index = scannedIndex + 1
        var count = scannedCount
        var lastSOSIndex = 0
        
        while index < data.count - 1 {
            scannedIndex = index
            // 0xFF, 0xDA - Start Of Scan
            let SOS = ImageFormat.JPEGMarker.SOS.bytes
            if data[index] == SOS[0], data[index + 1] == SOS[1] {
                lastSOSIndex = index
                count += 1
            }
            index += 1
        }
        
        // Found more scans this the previous time
        guard count > scannedCount else { return nil }
        scannedCount = count
        
        // `> 1` checks that we've received a first scan (SOS) and then received
        // and also received a second scan (SOS). This way we know that we have
        // at least one full scan available.
        guard count > 1 && lastSOSIndex > 0 else { return nil }
        return data[0 ..< lastSOSIndex]
    }
    
    func decode(_ data: Data,
                with callbacks: [SessionDataTask.TaskCallback],
                completion: @escaping (KFCrossPlatformImage?) -> Void) {
        guard data.kf.contains(jpeg: .SOF2) else {
            CallbackQueue.mainCurrentOrAsync.execute { completion(nil) }
            return
        }
        
        func processing(_ data: Data) {
            let processor = ImageDataProcessor(
                data: data,
                callbacks: callbacks,
                processingQueue: processingQueue
            )
            processor.onImageProcessed.delegate(on: self) { (self, result) in
                guard let image = try? result.0.get() else {
                    CallbackQueue.mainCurrentOrAsync.execute { completion(nil) }
                    return
                }
                
                CallbackQueue.mainCurrentOrAsync.execute { completion(image) }
            }
            processor.process()
        }
        
        // Blur partial images.
        let count = scannedCount
        
        if option.isBlur, count < 6 {
            processingQueue.execute {
                // Progressively reduce blur as we load more scans.
                let image = KingfisherWrapper<KFCrossPlatformImage>.image(
                    data: data,
                    options: self.creatingOptions
                )
                let radius = max(2, 14 - count * 4)
                let temp = image?.kf.blurred(withRadius: CGFloat(radius))
                processing(temp?.kf.data(format: .JPEG) ?? data)
            }
            
        } else {
            processing(data)
        }
    }
}
private final class ImageProgressiveSerialQueue {
    typealias ClosureCallback = ((@escaping () -> Void)) -> Void
    
    private let queue: DispatchQueue
    private var items: [DispatchWorkItem] = []
    private var notify: (() -> Void)?
    private var lastTime: TimeInterval?
    var count: Int { return items.count }
    init() {
        self.queue = DispatchQueue(label: "com.onevcat.Kingfisher.ImageProgressive.SerialQueue")
    }
    
    func add(minimum interval: TimeInterval, closure: @escaping ClosureCallback) {
        let completion = { [weak self] in
            guard let self = self else { return }
            
            self.queue.async { [weak self] in
                guard let self = self else { return }
                guard !self.items.isEmpty else { return }
                
                self.items.removeFirst()
                
                if let next = self.items.first {
                    self.queue.asyncAfter(
                        deadline: .now() + interval,
                        execute: next
                    )
                    
                } else {
                    self.lastTime = Date().timeIntervalSince1970
                    self.notify?()
                    self.notify = nil
                }
            }
        }
        
        queue.async { [weak self] in
            guard let self = self else { return }
            
            let item = DispatchWorkItem {
                closure(completion)
            }
            if self.items.isEmpty {
                let difference = Date().timeIntervalSince1970 - (self.lastTime ?? 0)
                let delay = difference < interval ? interval - difference : 0
                self.queue.asyncAfter(deadline: .now() + delay, execute: item)
            }
            self.items.append(item)
        }
    }
    
    func notify(_ closure: @escaping () -> Void) {
        self.notify = closure
    }
    
    func clean() {
        queue.async { [weak self] in
            guard let self = self else { return }
            self.items.forEach { $0.cancel() }
            self.items.removeAll()
        }
    }
}
//
//  Image.swift
//  Kingfisher
//
//  Created by Wei Wang on 16/1/6.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(macOS)
import AppKit
private var imagesKey: Void?
private var durationKey: Void?
#else
import UIKit
import MobileCoreServices
private var imageSourceKey: Void?
#endif
#if !os(watchOS)
import CoreImage
#endif
import CoreGraphics
import ImageIO
private var animatedImageDataKey: Void?
// MARK: - Image Properties
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    private(set) var animatedImageData: Data? {
        get { return getAssociatedObject(base, &animatedImageDataKey) }
        set { setRetainedAssociatedObject(base, &animatedImageDataKey, newValue) }
    }
    
    #if os(macOS)
    var cgImage: CGImage? {
        return base.cgImage(forProposedRect: nil, context: nil, hints: nil)
    }
    
    var scale: CGFloat {
        return 1.0
    }
    
    private(set) var images: [KFCrossPlatformImage]? {
        get { return getAssociatedObject(base, &imagesKey) }
        set { setRetainedAssociatedObject(base, &imagesKey, newValue) }
    }
    
    private(set) var duration: TimeInterval {
        get { return getAssociatedObject(base, &durationKey) ?? 0.0 }
        set { setRetainedAssociatedObject(base, &durationKey, newValue) }
    }
    
    var size: CGSize {
        return base.representations.reduce(.zero) { size, rep in
            let width = max(size.width, CGFloat(rep.pixelsWide))
            let height = max(size.height, CGFloat(rep.pixelsHigh))
            return CGSize(width: width, height: height)
        }
    }
    #else
    var cgImage: CGImage? { return base.cgImage }
    var scale: CGFloat { return base.scale }
    var images: [KFCrossPlatformImage]? { return base.images }
    var duration: TimeInterval { return base.duration }
    var size: CGSize { return base.size }
    
    private(set) var imageSource: CGImageSource? {
        get { return getAssociatedObject(base, &imageSourceKey) }
        set { setRetainedAssociatedObject(base, &imageSourceKey, newValue) }
    }
    #endif
    // Bitmap memory cost with bytes.
    var cost: Int {
        let pixel = Int(size.width * size.height * scale * scale)
        guard let cgImage = cgImage else {
            return pixel * 4
        }
        return pixel * cgImage.bitsPerPixel / 8
    }
}
// MARK: - Image Conversion
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    #if os(macOS)
    static func image(cgImage: CGImage, scale: CGFloat, refImage: KFCrossPlatformImage?) -> KFCrossPlatformImage {
        return KFCrossPlatformImage(cgImage: cgImage, size: .zero)
    }
    
    /// Normalize the image. This getter does nothing on macOS but return the image itself.
    public var normalized: KFCrossPlatformImage { return base }
    #else
    /// Creating an image from a give `CGImage` at scale and orientation for refImage. The method signature is for
    /// compatibility of macOS version.
    static func image(cgImage: CGImage, scale: CGFloat, refImage: KFCrossPlatformImage?) -> KFCrossPlatformImage {
        return KFCrossPlatformImage(cgImage: cgImage, scale: scale, orientation: refImage?.imageOrientation ?? .up)
    }
    
    /// Returns normalized image for current `base` image.
    /// This method will try to redraw an image with orientation and scale considered.
    public var normalized: KFCrossPlatformImage {
        // prevent animated image (GIF) lose it's images
        guard images == nil else { return base.copy() as! KFCrossPlatformImage }
        // No need to do anything if already up
        guard base.imageOrientation != .up else { return base.copy() as! KFCrossPlatformImage }
        return draw(to: size, inverting: true, refImage: KFCrossPlatformImage()) {
            fixOrientation(in: $0)
            return true
        }
    }
    func fixOrientation(in context: CGContext) {
        var transform = CGAffineTransform.identity
        let orientation = base.imageOrientation
        switch orientation {
        case .down, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: size.height)
            transform = transform.rotated(by: .pi)
        case .left, .leftMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.rotated(by: .pi / 2.0)
        case .right, .rightMirrored:
            transform = transform.translatedBy(x: 0, y: size.height)
            transform = transform.rotated(by: .pi / -2.0)
        case .up, .upMirrored:
            break
        #if compiler(>=5)
        @unknown default:
            break
        #endif
        }
        //Flip image one more time if needed to, this is to prevent flipped image
        switch orientation {
        case .upMirrored, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.scaledBy(x: -1, y: 1)
        case .leftMirrored, .rightMirrored:
            transform = transform.translatedBy(x: size.height, y: 0)
            transform = transform.scaledBy(x: -1, y: 1)
        case .up, .down, .left, .right:
            break
        #if compiler(>=5)
        @unknown default:
            break
        #endif
        }
        context.concatenate(transform)
        switch orientation {
        case .left, .leftMirrored, .right, .rightMirrored:
            context.draw(cgImage!, in: CGRect(x: 0, y: 0, width: size.height, height: size.width))
        default:
            context.draw(cgImage!, in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
        }
    }
    #endif
}
// MARK: - Image Representation
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    /// Returns PNG representation of `base` image.
    ///
    /// - Returns: PNG data of image.
    public func pngRepresentation() -> Data? {
        #if os(macOS)
            guard let cgImage = cgImage else {
                return nil
            }
            let rep = NSBitmapImageRep(cgImage: cgImage)
            return rep.representation(using: .png, properties: [:])
        #else
            #if swift(>=4.2)
            return base.pngData()
            #else
            return UIImagePNGRepresentation(base)
            #endif
        #endif
    }
    /// Returns JPEG representation of `base` image.
    ///
    /// - Parameter compressionQuality: The compression quality when converting image to JPEG data.
    /// - Returns: JPEG data of image.
    public func jpegRepresentation(compressionQuality: CGFloat) -> Data? {
        #if os(macOS)
            guard let cgImage = cgImage else {
                return nil
            }
            let rep = NSBitmapImageRep(cgImage: cgImage)
            return rep.representation(using:.jpeg, properties: [.compressionFactor: compressionQuality])
        #else
            #if swift(>=4.2)
            return base.jpegData(compressionQuality: compressionQuality)
            #else
            return UIImageJPEGRepresentation(base, compressionQuality)
            #endif
        #endif
    }
    /// Returns GIF representation of `base` image.
    ///
    /// - Returns: Original GIF data of image.
    public func gifRepresentation() -> Data? {
        return animatedImageData
    }
    /// Returns a data representation for `base` image, with the `format` as the format indicator.
    ///
    /// - Parameter format: The format in which the output data should be. If `unknown`, the `base` image will be
    ///                     converted in the PNG representation.
    ///
    /// - Returns: The output data representing.
    /// Returns a data representation for `base` image, with the `format` as the format indicator.
    /// - Parameters:
    ///   - format: The format in which the output data should be. If `unknown`, the `base` image will be
    ///   converted in the PNG representation.
    ///   - compressionQuality: The compression quality when converting image to a lossy format data.
    public func data(format: ImageFormat, compressionQuality: CGFloat = 1.0) -> Data? {
        return autoreleasepool { () -> Data? in
            let data: Data?
            switch format {
            case .PNG: data = pngRepresentation()
            case .JPEG: data = jpegRepresentation(compressionQuality: compressionQuality)
            case .GIF: data = gifRepresentation()
            case .unknown: data = normalized.kf.pngRepresentation()
            }
            
            return data
        }
    }
}
// MARK: - Creating Images
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    /// Creates an animated image from a given data and options. Currently only GIF data is supported.
    ///
    /// - Parameters:
    ///   - data: The animated image data.
    ///   - options: Options to use when creating the animated image.
    /// - Returns: An `Image` object represents the animated image. It is in form of an array of image frames with a
    ///            certain duration. `nil` if anything wrong when creating animated image.
    public static func animatedImage(data: Data, options: ImageCreatingOptions) -> KFCrossPlatformImage? {
        let info: [String: Any] = [
            kCGImageSourceShouldCache as String: true,
            kCGImageSourceTypeIdentifierHint as String: kUTTypeGIF
        ]
        
        guard let imageSource = CGImageSourceCreateWithData(data as CFData, info as CFDictionary) else {
            return nil
        }
        
        #if os(macOS)
        guard let animatedImage = GIFAnimatedImage(from: imageSource, for: info, options: options) else {
            return nil
        }
        var image: KFCrossPlatformImage?
        if options.onlyFirstFrame {
            image = animatedImage.images.first
        } else {
            image = KFCrossPlatformImage(data: data)
            var kf = image?.kf
            kf?.images = animatedImage.images
            kf?.duration = animatedImage.duration
        }
        image?.kf.animatedImageData = data
        return image
        #else
        
        var image: KFCrossPlatformImage?
        if options.preloadAll || options.onlyFirstFrame {
            // Use `images` image if you want to preload all animated data
            guard let animatedImage = GIFAnimatedImage(from: imageSource, for: info, options: options) else {
                return nil
            }
            if options.onlyFirstFrame {
                image = animatedImage.images.first
            } else {
                let duration = options.duration <= 0.0 ? animatedImage.duration : options.duration
                image = .animatedImage(with: animatedImage.images, duration: duration)
            }
            image?.kf.animatedImageData = data
        } else {
            image = KFCrossPlatformImage(data: data, scale: options.scale)
            var kf = image?.kf
            kf?.imageSource = imageSource
            kf?.animatedImageData = data
        }
        
        return image
        #endif
    }
    /// Creates an image from a given data and options. `.JPEG`, `.PNG` or `.GIF` is supported. For other
    /// image format, image initializer from system will be used. If no image object could be created from
    /// the given `data`, `nil` will be returned.
    ///
    /// - Parameters:
    ///   - data: The image data representation.
    ///   - options: Options to use when creating the image.
    /// - Returns: An `Image` object represents the image if created. If the `data` is invalid or not supported, `nil`
    ///            will be returned.
    public static func image(data: Data, options: ImageCreatingOptions) -> KFCrossPlatformImage? {
        var image: KFCrossPlatformImage?
        switch data.kf.imageFormat {
        case .JPEG:
            image = KFCrossPlatformImage(data: data, scale: options.scale)
        case .PNG:
            image = KFCrossPlatformImage(data: data, scale: options.scale)
        case .GIF:
            image = KingfisherWrapper.animatedImage(data: data, options: options)
        case .unknown:
            image = KFCrossPlatformImage(data: data, scale: options.scale)
        }
        return image
    }
    
    /// Creates a downsampled image from given data to a certain size and scale.
    ///
    /// - Parameters:
    ///   - data: The image data contains a JPEG or PNG image.
    ///   - pointSize: The target size in point to which the image should be downsampled.
    ///   - scale: The scale of result image.
    /// - Returns: A downsampled `Image` object following the input conditions.
    ///
    /// - Note:
    /// Different from image `resize` methods, downsampling will not render the original
    /// input image in pixel format. It does downsampling from the image data, so it is much
    /// more memory efficient and friendly. Choose to use downsampling as possible as you can.
    ///
    /// The input size should be smaller than the size of input image. If it is larger than the
    /// original image size, the result image will be the same size of input without downsampling.
    public static func downsampledImage(data: Data, to pointSize: CGSize, scale: CGFloat) -> KFCrossPlatformImage? {
        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary
        guard let imageSource = CGImageSourceCreateWithData(data as CFData, imageSourceOptions) else {
            return nil
        }
        
        let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale
        let downsampleOptions = [
            kCGImageSourceCreateThumbnailFromImageAlways: true,
            kCGImageSourceShouldCacheImmediately: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] as CFDictionary
        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else {
            return nil
        }
        return KingfisherWrapper.image(cgImage: downsampledImage, scale: scale, refImage: nil)
    }
}
//
//  ImageFormat.swift
//  Kingfisher
//
//  Created by onevcat on 2018/09/28.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents image format.
///
/// - unknown: The format cannot be recognized or not supported yet.
/// - PNG: PNG image format.
/// - JPEG: JPEG image format.
/// - GIF: GIF image format.
public enum ImageFormat {
    /// The format cannot be recognized or not supported yet.
    case unknown
    /// PNG image format.
    case PNG
    /// JPEG image format.
    case JPEG
    /// GIF image format.
    case GIF
    
    struct HeaderData {
        static var PNG: [UInt8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]
        static var JPEG_SOI: [UInt8] = [0xFF, 0xD8]
        static var JPEG_IF: [UInt8] = [0xFF]
        static var GIF: [UInt8] = [0x47, 0x49, 0x46]
    }
    
    /// https://en.wikipedia.org/wiki/JPEG
    public enum JPEGMarker {
        case SOF0           //baseline
        case SOF2           //progressive
        case DHT            //Huffman Table
        case DQT            //Quantization Table
        case DRI            //Restart Interval
        case SOS            //Start Of Scan
        case RSTn(UInt8)    //Restart
        case APPn           //Application-specific
        case COM            //Comment
        case EOI            //End Of Image
        
        var bytes: [UInt8] {
            switch self {
            case .SOF0:         return [0xFF, 0xC0]
            case .SOF2:         return [0xFF, 0xC2]
            case .DHT:          return [0xFF, 0xC4]
            case .DQT:          return [0xFF, 0xDB]
            case .DRI:          return [0xFF, 0xDD]
            case .SOS:          return [0xFF, 0xDA]
            case .RSTn(let n):  return [0xFF, 0xD0 + n]
            case .APPn:         return [0xFF, 0xE0]
            case .COM:          return [0xFF, 0xFE]
            case .EOI:          return [0xFF, 0xD9]
            }
        }
    }
}
extension Data: KingfisherCompatibleValue {}
// MARK: - Misc Helpers
extension KingfisherWrapper where Base == Data {
    /// Gets the image format corresponding to the data.
    public var imageFormat: ImageFormat {
        guard base.count > 8 else { return .unknown }
        
        var buffer = [UInt8](repeating: 0, count: 8)
        base.copyBytes(to: &buffer, count: 8)
        
        if buffer == ImageFormat.HeaderData.PNG {
            return .PNG
            
        } else if buffer[0] == ImageFormat.HeaderData.JPEG_SOI[0],
            buffer[1] == ImageFormat.HeaderData.JPEG_SOI[1],
            buffer[2] == ImageFormat.HeaderData.JPEG_IF[0]
        {
            return .JPEG
            
        } else if buffer[0] == ImageFormat.HeaderData.GIF[0],
            buffer[1] == ImageFormat.HeaderData.GIF[1],
            buffer[2] == ImageFormat.HeaderData.GIF[2]
        {
            return .GIF
        }
        
        return .unknown
    }
    
    public func contains(jpeg marker: ImageFormat.JPEGMarker) -> Bool {
        guard imageFormat == .JPEG else {
            return false
        }
        
        var buffer = [UInt8](repeating: 0, count: base.count)
        base.copyBytes(to: &buffer, count: base.count)
        for (index, item) in buffer.enumerated() {
            guard
                item == marker.bytes.first,
                buffer.count > index + 1,
                buffer[index + 1] == marker.bytes[1] else {
                continue
            }
            return true
        }
        return false
    }
}
//
//  ImageDrawing.swift
//  Kingfisher
//
//  Created by onevcat on 2018/09/28.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Accelerate
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
#endif
#if canImport(UIKit)
import UIKit
#endif
// MARK: - Image Transforming
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    // MARK: Blend Mode
    /// Create image from `base` image and apply blend mode.
    ///
    /// - parameter blendMode:       The blend mode of creating image.
    /// - parameter alpha:           The alpha should be used for image.
    /// - parameter backgroundColor: The background color for the output image.
    ///
    /// - returns: An image with blend mode applied.
    ///
    /// - Note: This method only works for CG-based image.
    #if !os(macOS)
    public func image(withBlendMode blendMode: CGBlendMode,
                      alpha: CGFloat = 1.0,
                      backgroundColor: KFCrossPlatformColor? = nil) -> KFCrossPlatformImage
    {
        guard let _ = cgImage else {
            assertionFailure("[Kingfisher] Blend mode image only works for CG-based image.")
            return base
        }
        
        let rect = CGRect(origin: .zero, size: size)
        return draw(to: rect.size) { _ in
            if let backgroundColor = backgroundColor {
                backgroundColor.setFill()
                UIRectFill(rect)
            }
            
            base.draw(in: rect, blendMode: blendMode, alpha: alpha)
            return false
        }
    }
    #endif
    
    #if os(macOS)
    // MARK: Compositing
    /// Creates image from `base` image and apply compositing operation.
    ///
    /// - Parameters:
    ///   - compositingOperation: The compositing operation of creating image.
    ///   - alpha: The alpha should be used for image.
    ///   - backgroundColor: The background color for the output image.
    /// - Returns: An image with compositing operation applied.
    ///
    /// - Note: This method only works for CG-based image. For any non-CG-based image, `base` itself is returned.
    public func image(withCompositingOperation compositingOperation: NSCompositingOperation,
                      alpha: CGFloat = 1.0,
                      backgroundColor: KFCrossPlatformColor? = nil) -> KFCrossPlatformImage
    {
        guard let _ = cgImage else {
            assertionFailure("[Kingfisher] Compositing Operation image only works for CG-based image.")
            return base
        }
        
        let rect = CGRect(origin: .zero, size: size)
        return draw(to: rect.size) { _ in
            if let backgroundColor = backgroundColor {
                backgroundColor.setFill()
                rect.fill()
            }
            base.draw(in: rect, from: .zero, operation: compositingOperation, fraction: alpha)
            return false
        }
    }
    #endif
    
    // MARK: Round Corner
    /// Creates a round corner image from on `base` image.
    ///
    /// - Parameters:
    ///   - radius: The round corner radius of creating image.
    ///   - size: The target size of creating image.
    ///   - corners: The target corners which will be applied rounding.
    ///   - backgroundColor: The background color for the output image
    /// - Returns: An image with round corner of `self`.
    ///
    /// - Note: This method only works for CG-based image. The current image scale is kept.
    ///         For any non-CG-based image, `base` itself is returned.
    public func image(withRoundRadius radius: CGFloat,
                      fit size: CGSize,
                      roundingCorners corners: RectCorner = .all,
                      backgroundColor: KFCrossPlatformColor? = nil) -> KFCrossPlatformImage
    {
        guard let _ = cgImage else {
            assertionFailure("[Kingfisher] Round corner image only works for CG-based image.")
            return base
        }
        
        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
        return draw(to: size) { _ in
            #if os(macOS)
            if let backgroundColor = backgroundColor {
                let rectPath = NSBezierPath(rect: rect)
                backgroundColor.setFill()
                rectPath.fill()
            }
            
            let path = NSBezierPath(roundedRect: rect, byRoundingCorners: corners, radius: radius)
            #if swift(>=4.2)
            path.windingRule = .evenOdd
            #else
            path.windingRule = .evenOddWindingRule
            #endif
            path.addClip()
            base.draw(in: rect)
            #else
            guard let context = UIGraphicsGetCurrentContext() else {
                assertionFailure("[Kingfisher] Failed to create CG context for image.")
                return false
            }
            
            if let backgroundColor = backgroundColor {
                let rectPath = UIBezierPath(rect: rect)
                backgroundColor.setFill()
                rectPath.fill()
            }
            
            let path = UIBezierPath(
                roundedRect: rect,
                byRoundingCorners: corners.uiRectCorner,
                cornerRadii: CGSize(width: radius, height: radius)
            )
            context.addPath(path.cgPath)
            context.clip()
            base.draw(in: rect)
            #endif
            return false
        }
    }
    
    #if os(iOS) || os(tvOS)
    func resize(to size: CGSize, for contentMode: UIView.ContentMode) -> KFCrossPlatformImage {
        switch contentMode {
        case .scaleAspectFit:
            return resize(to: size, for: .aspectFit)
        case .scaleAspectFill:
            return resize(to: size, for: .aspectFill)
        default:
            return resize(to: size)
        }
    }
    #endif
    
    // MARK: Resizing
    /// Resizes `base` image to an image with new size.
    ///
    /// - Parameter size: The target size in point.
    /// - Returns: An image with new size.
    /// - Note: This method only works for CG-based image. The current image scale is kept.
    ///         For any non-CG-based image, `base` itself is returned.
    public func resize(to size: CGSize) -> KFCrossPlatformImage {
        guard let _ = cgImage else {
            assertionFailure("[Kingfisher] Resize only works for CG-based image.")
            return base
        }
        
        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
        return draw(to: size) { _ in
            #if os(macOS)
            base.draw(in: rect, from: .zero, operation: .copy, fraction: 1.0)
            #else
            base.draw(in: rect)
            #endif
            return false
        }
    }
    
    /// Resizes `base` image to an image of new size, respecting the given content mode.
    ///
    /// - Parameters:
    ///   - targetSize: The target size in point.
    ///   - contentMode: Content mode of output image should be.
    /// - Returns: An image with new size.
    ///
    /// - Note: This method only works for CG-based image. The current image scale is kept.
    ///         For any non-CG-based image, `base` itself is returned.
    public func resize(to targetSize: CGSize, for contentMode: ContentMode) -> KFCrossPlatformImage {
        let newSize = size.kf.resize(to: targetSize, for: contentMode)
        return resize(to: newSize)
    }
    // MARK: Cropping
    /// Crops `base` image to a new size with a given anchor.
    ///
    /// - Parameters:
    ///   - size: The target size.
    ///   - anchor: The anchor point from which the size should be calculated.
    /// - Returns: An image with new size.
    ///
    /// - Note: This method only works for CG-based image. The current image scale is kept.
    ///         For any non-CG-based image, `base` itself is returned.
    public func crop(to size: CGSize, anchorOn anchor: CGPoint) -> KFCrossPlatformImage {
        guard let cgImage = cgImage else {
            assertionFailure("[Kingfisher] Crop only works for CG-based image.")
            return base
        }
        
        let rect = self.size.kf.constrainedRect(for: size, anchor: anchor)
        guard let image = cgImage.cropping(to: rect.scaled(scale)) else {
            assertionFailure("[Kingfisher] Cropping image failed.")
            return base
        }
        
        return KingfisherWrapper.image(cgImage: image, scale: scale, refImage: base)
    }
    
    // MARK: Blur
    /// Creates an image with blur effect based on `base` image.
    ///
    /// - Parameter radius: The blur radius should be used when creating blur effect.
    /// - Returns: An image with blur effect applied.
    ///
    /// - Note: This method only works for CG-based image. The current image scale is kept.
    ///         For any non-CG-based image, `base` itself is returned.
    public func blurred(withRadius radius: CGFloat) -> KFCrossPlatformImage {
        
        guard let cgImage = cgImage else {
            assertionFailure("[Kingfisher] Blur only works for CG-based image.")
            return base
        }
        
        // http://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement
        // let d = floor(s * 3*sqrt(2*pi)/4 + 0.5)
        // if d is odd, use three box-blurs of size 'd', centered on the output pixel.
        let s = max(radius, 2.0)
        // We will do blur on a resized image (*0.5), so the blur radius could be half as well.
        
        // Fix the slow compiling time for Swift 3.
        // See https://github.com/onevcat/Kingfisher/issues/611
        let pi2 = 2 * CGFloat.pi
        let sqrtPi2 = sqrt(pi2)
        var targetRadius = floor(s * 3.0 * sqrtPi2 / 4.0 + 0.5)
        
        if targetRadius.isEven { targetRadius += 1 }
        // Determine necessary iteration count by blur radius.
        let iterations: Int
        if radius < 0.5 {
            iterations = 1
        } else if radius < 1.5 {
            iterations = 2
        } else {
            iterations = 3
        }
        
        let w = Int(size.width)
        let h = Int(size.height)
        
        func createEffectBuffer(_ context: CGContext) -> vImage_Buffer {
            let data = context.data
            let width = vImagePixelCount(context.width)
            let height = vImagePixelCount(context.height)
            let rowBytes = context.bytesPerRow
            
            return vImage_Buffer(data: data, height: height, width: width, rowBytes: rowBytes)
        }
        
        guard let context = beginContext(size: size, scale: scale, inverting: true) else {
            assertionFailure("[Kingfisher] Failed to create CG context for blurring image.")
            return base
        }
        context.draw(cgImage, in: CGRect(x: 0, y: 0, width: w, height: h))
        endContext()
        
        var inBuffer = createEffectBuffer(context)
        
        guard let outContext = beginContext(size: size, scale: scale, inverting: true) else {
            assertionFailure("[Kingfisher] Failed to create CG context for blurring image.")
            return base
        }
        defer { endContext() }
        var outBuffer = createEffectBuffer(outContext)
        
        for _ in 0 ..< iterations {
            let flag = vImage_Flags(kvImageEdgeExtend)
            vImageBoxConvolve_ARGB8888(
                &inBuffer, &outBuffer, nil, 0, 0, UInt32(targetRadius), UInt32(targetRadius), nil, flag)
            // Next inBuffer should be the outButter of current iteration
            (inBuffer, outBuffer) = (outBuffer, inBuffer)
        }
        
        #if os(macOS)
        let result = outContext.makeImage().flatMap {
            fixedForRetinaPixel(cgImage: $0, to: size)
        }
        #else
        let result = outContext.makeImage().flatMap {
            KFCrossPlatformImage(cgImage: $0, scale: base.scale, orientation: base.imageOrientation)
        }
        #endif
        guard let blurredImage = result else {
            assertionFailure("[Kingfisher] Can not make an blurred image within this context.")
            return base
        }
        
        return blurredImage
    }
    
    // MARK: Overlay
    /// Creates an image from `base` image with a color overlay layer.
    ///
    /// - Parameters:
    ///   - color: The color should be use to overlay.
    ///   - fraction: Fraction of input color. From 0.0 to 1.0. 0.0 means solid color,
    ///               1.0 means transparent overlay.
    /// - Returns: An image with a color overlay applied.
    ///
    /// - Note: This method only works for CG-based image. The current image scale is kept.
    ///         For any non-CG-based image, `base` itself is returned.
    public func overlaying(with color: KFCrossPlatformColor, fraction: CGFloat) -> KFCrossPlatformImage {
        
        guard let _ = cgImage else {
            assertionFailure("[Kingfisher] Overlaying only works for CG-based image.")
            return base
        }
        
        let rect = CGRect(x: 0, y: 0, width: size.width, height: size.height)
        return draw(to: rect.size) { context in
            #if os(macOS)
            base.draw(in: rect)
            if fraction > 0 {
                color.withAlphaComponent(1 - fraction).set()
                rect.fill(using: .sourceAtop)
            }
            #else
            color.set()
            UIRectFill(rect)
            base.draw(in: rect, blendMode: .destinationIn, alpha: 1.0)
            
            if fraction > 0 {
                base.draw(in: rect, blendMode: .sourceAtop, alpha: fraction)
            }
            #endif
            return false
        }
    }
    
    // MARK: Tint
    /// Creates an image from `base` image with a color tint.
    ///
    /// - Parameter color: The color should be used to tint `base`
    /// - Returns: An image with a color tint applied.
    public func tinted(with color: KFCrossPlatformColor) -> KFCrossPlatformImage {
        #if os(watchOS)
        return base
        #else
        return apply(.tint(color))
        #endif
    }
    
    // MARK: Color Control
    
    /// Create an image from `self` with color control.
    ///
    /// - Parameters:
    ///   - brightness: Brightness changing to image.
    ///   - contrast: Contrast changing to image.
    ///   - saturation: Saturation changing to image.
    ///   - inputEV: InputEV changing to image.
    /// - Returns:  An image with color control applied.
    public func adjusted(brightness: CGFloat, contrast: CGFloat, saturation: CGFloat, inputEV: CGFloat) -> KFCrossPlatformImage {
        #if os(watchOS)
        return base
        #else
        return apply(.colorControl((brightness, contrast, saturation, inputEV)))
        #endif
    }
    
    /// Return an image with given scale.
    ///
    /// - Parameter scale: Target scale factor the new image should have.
    /// - Returns: The image with target scale. If the base image is already in the scale, `base` will be returned.
    public func scaled(to scale: CGFloat) -> KFCrossPlatformImage {
        guard scale != self.scale else {
            return base
        }
        guard let cgImage = cgImage else {
            assertionFailure("[Kingfisher] Scaling only works for CG-based image.")
            return base
        }
        return KingfisherWrapper.image(cgImage: cgImage, scale: scale, refImage: base)
    }
}
// MARK: - Decoding Image
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    
    /// Returns the decoded image of the `base` image. It will draw the image in a plain context and return the data
    /// from it. This could improve the drawing performance when an image is just created from data but not yet
    /// displayed for the first time.
    ///
    /// - Note: This method only works for CG-based image. The current image scale is kept.
    ///         For any non-CG-based image or animated image, `base` itself is returned.
    public var decoded: KFCrossPlatformImage { return decoded(scale: scale) }
    
    /// Returns decoded image of the `base` image at a given scale. It will draw the image in a plain context and
    /// return the data from it. This could improve the drawing performance when an image is just created from
    /// data but not yet displayed for the first time.
    ///
    /// - Parameter scale: The given scale of target image should be.
    /// - Returns: The decoded image ready to be displayed.
    ///
    /// - Note: This method only works for CG-based image. The current image scale is kept.
    ///         For any non-CG-based image or animated image, `base` itself is returned.
    public func decoded(scale: CGFloat) -> KFCrossPlatformImage {
        // Prevent animated image (GIF) losing it's images
        #if os(iOS)
        if imageSource != nil { return base }
        #else
        if images != nil { return base }
        #endif
        guard let imageRef = cgImage else {
            assertionFailure("[Kingfisher] Decoding only works for CG-based image.")
            return base
        }
        let size = CGSize(width: CGFloat(imageRef.width) / scale, height: CGFloat(imageRef.height) / scale)
        return draw(to: size, inverting: true, scale: scale) { context in
            context.draw(imageRef, in: CGRect(origin: .zero, size: size))
            return true
        }
    }
}
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    
    func beginContext(size: CGSize, scale: CGFloat, inverting: Bool = false) -> CGContext? {
        #if os(macOS)
        guard let rep = NSBitmapImageRep(
            bitmapDataPlanes: nil,
            pixelsWide: Int(size.width),
            pixelsHigh: Int(size.height),
            bitsPerSample: cgImage?.bitsPerComponent ?? 8,
            samplesPerPixel: 4,
            hasAlpha: true,
            isPlanar: false,
            colorSpaceName: .calibratedRGB,
            bytesPerRow: 0,
            bitsPerPixel: 0) else
        {
            assertionFailure("[Kingfisher] Image representation cannot be created.")
            return nil
        }
        rep.size = size
        NSGraphicsContext.saveGraphicsState()
        guard let context = NSGraphicsContext(bitmapImageRep: rep) else {
            assertionFailure("[Kingfisher] Image context cannot be created.")
            return nil
        }
        
        NSGraphicsContext.current = context
        return context.cgContext
        #else
        UIGraphicsBeginImageContextWithOptions(size, false, scale)
        guard let context = UIGraphicsGetCurrentContext() else { return nil }
        if inverting { // If drawing a CGImage, we need to make context flipped.
            context.scaleBy(x: 1.0, y: -1.0)
            context.translateBy(x: 0, y: -size.height)
        }
        return context
        #endif
    }
    
    func endContext() {
        #if os(macOS)
        NSGraphicsContext.restoreGraphicsState()
        #else
        UIGraphicsEndImageContext()
        #endif
    }
    
    func draw(
        to size: CGSize,
        inverting: Bool = false,
        scale: CGFloat? = nil,
        refImage: KFCrossPlatformImage? = nil,
        draw: (CGContext) -> Bool // Whether use the refImage (`true`) or ignore image orientation (`false`)
    ) -> KFCrossPlatformImage
    {
        let targetScale = scale ?? self.scale
        guard let context = beginContext(size: size, scale: targetScale, inverting: inverting) else {
            assertionFailure("[Kingfisher] Failed to create CG context for blurring image.")
            return base
        }
        defer { endContext() }
        let useRefImage = draw(context)
        guard let cgImage = context.makeImage() else {
            return base
        }
        let ref = useRefImage ? (refImage ?? base) : nil
        return KingfisherWrapper.image(cgImage: cgImage, scale: targetScale, refImage: ref)
    }
    
    #if os(macOS)
    func fixedForRetinaPixel(cgImage: CGImage, to size: CGSize) -> KFCrossPlatformImage {
        
        let image = KFCrossPlatformImage(cgImage: cgImage, size: base.size)
        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
        
        return draw(to: self.size) { context in
            image.draw(in: rect, from: .zero, operation: .copy, fraction: 1.0)
            return false
        }
    }
    #endif
}
//
//  ImageTransition.swift
//  Kingfisher
//
//  Created by Wei Wang on 15/9/18.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if os(iOS) || os(tvOS)
import UIKit
/// Transition effect which will be used when an image downloaded and set by `UIImageView`
/// extension API in Kingfisher. You can assign an enum value with transition duration as
/// an item in `KingfisherOptionsInfo` to enable the animation transition.
///
/// Apple's UIViewAnimationOptions is used under the hood.
/// For custom transition, you should specified your own transition options, animations and
/// completion handler as well.
///
/// - none: No animation transition.
/// - fade: Fade in the loaded image in a given duration.
/// - flipFromLeft: Flip from left transition.
/// - flipFromRight: Flip from right transition.
/// - flipFromTop: Flip from top transition.
/// - flipFromBottom: Flip from bottom transition.
/// - custom: Custom transition.
public enum ImageTransition {
    /// No animation transition.
    case none
    /// Fade in the loaded image in a given duration.
    case fade(TimeInterval)
    /// Flip from left transition.
    case flipFromLeft(TimeInterval)
    /// Flip from right transition.
    case flipFromRight(TimeInterval)
    /// Flip from top transition.
    case flipFromTop(TimeInterval)
    /// Flip from bottom transition.
    case flipFromBottom(TimeInterval)
    /// Custom transition defined by a general animation block.
    ///    - duration: The time duration of this custom transition.
    ///    - options: `UIView.AnimationOptions` should be used in the transition.
    ///    - animations: The animation block will be applied when setting image.
    ///    - completion: A block called when the transition animation finishes.
    case custom(duration: TimeInterval,
                 options: UIView.AnimationOptions,
              animations: ((UIImageView, UIImage) -> Void)?,
              completion: ((Bool) -> Void)?)
    
    var duration: TimeInterval {
        switch self {
        case .none:                          return 0
        case .fade(let duration):            return duration
            
        case .flipFromLeft(let duration):    return duration
        case .flipFromRight(let duration):   return duration
        case .flipFromTop(let duration):     return duration
        case .flipFromBottom(let duration):  return duration
            
        case .custom(let duration, _, _, _): return duration
        }
    }
    
    var animationOptions: UIView.AnimationOptions {
        switch self {
        case .none:                         return []
        case .fade:                         return .transitionCrossDissolve
            
        case .flipFromLeft:                 return .transitionFlipFromLeft
        case .flipFromRight:                return .transitionFlipFromRight
        case .flipFromTop:                  return .transitionFlipFromTop
        case .flipFromBottom:               return .transitionFlipFromBottom
            
        case .custom(_, let options, _, _): return options
        }
    }
    
    var animations: ((UIImageView, UIImage) -> Void)? {
        switch self {
        case .custom(_, _, let animations, _): return animations
        default: return { $0.image = $1 }
        }
    }
    
    var completion: ((Bool) -> Void)? {
        switch self {
        case .custom(_, _, _, let completion): return completion
        default: return nil
        }
    }
}
#else
// Just a placeholder for compiling on macOS.
public enum ImageTransition {
    case none
}
#endif
//
//  ImageProcessor.swift
//  Kingfisher
//
//  Created by Wei Wang on 2016/08/26.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
import CoreGraphics
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
#endif
/// Represents an item which could be processed by an `ImageProcessor`.
///
/// - image: Input image. The processor should provide a way to apply
///          processing on this `image` and return the result image.
/// - data:  Input data. The processor should provide a way to apply
///          processing on this `image` and return the result image.
public enum ImageProcessItem {
    
    /// Input image. The processor should provide a way to apply
    /// processing on this `image` and return the result image.
    case image(KFCrossPlatformImage)
    
    /// Input data. The processor should provide a way to apply
    /// processing on this `image` and return the result image.
    case data(Data)
}
/// An `ImageProcessor` would be used to convert some downloaded data to an image.
public protocol ImageProcessor {
    /// Identifier of the processor. It will be used to identify the processor when 
    /// caching and retrieving an image. You might want to make sure that processors with
    /// same properties/functionality have the same identifiers, so correct processed images
    /// could be retrieved with proper key.
    /// 
    /// - Note: Do not supply an empty string for a customized processor, which is already reserved by
    /// the `DefaultImageProcessor`. It is recommended to use a reverse domain name notation string of
    /// your own for the identifier.
    var identifier: String { get }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: The return value should be `nil` if processing failed while converting an input item to image.
    ///         If `nil` received by the processing caller, an error will be reported and the process flow stops.
    ///         If the processing flow is not critical for your flow, then when the input item is already an image
    ///         (`.image` case) and there is any errors in the processing, you could return the input image itself
    ///         to keep the processing pipeline continuing.
    /// - Note: Most processor only supports CG-based images. watchOS is not supported for processors containing
    ///         a filter, the input image will be returned directly on watchOS.
    /// - Note:
    /// This method is deprecated. Please implement the version with
    /// `KingfisherParsedOptionsInfo` as parameter instead.
    @available(*, deprecated,
    message: "Deprecated. Implement the method with same name but with `KingfisherParsedOptionsInfo` instead.")
    func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> KFCrossPlatformImage?
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: The parsed options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: The return value should be `nil` if processing failed while converting an input item to image.
    ///         If `nil` received by the processing caller, an error will be reported and the process flow stops.
    ///         If the processing flow is not critical for your flow, then when the input item is already an image
    ///         (`.image` case) and there is any errors in the processing, you could return the input image itself
    ///         to keep the processing pipeline continuing.
    /// - Note: Most processor only supports CG-based images. watchOS is not supported for processors containing
    ///         a filter, the input image will be returned directly on watchOS.
    func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage?
}
extension ImageProcessor {
    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> KFCrossPlatformImage? {
        return process(item: item, options: KingfisherParsedOptionsInfo(options))
    }
}
extension ImageProcessor {
    
    /// Appends an `ImageProcessor` to another. The identifier of the new `ImageProcessor`
    /// will be "\(self.identifier)|>\(another.identifier)".
    ///
    /// - Parameter another: An `ImageProcessor` you want to append to `self`.
    /// - Returns: The new `ImageProcessor` will process the image in the order
    ///            of the two processors concatenated.
    public func append(another: ImageProcessor) -> ImageProcessor {
        let newIdentifier = identifier.appending("|>\(another.identifier)")
        return GeneralProcessor(identifier: newIdentifier) {
            item, options in
            if let image = self.process(item: item, options: options) {
                return another.process(item: .image(image), options: options)
            } else {
                return nil
            }
        }
    }
}
func ==(left: ImageProcessor, right: ImageProcessor) -> Bool {
    return left.identifier == right.identifier
}
func !=(left: ImageProcessor, right: ImageProcessor) -> Bool {
    return !(left == right)
}
typealias ProcessorImp = ((ImageProcessItem, KingfisherParsedOptionsInfo) -> KFCrossPlatformImage?)
struct GeneralProcessor: ImageProcessor {
    let identifier: String
    let p: ProcessorImp
    func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        return p(item, options)
    }
}
/// The default processor. It converts the input data to a valid image.
/// Images of .PNG, .JPEG and .GIF format are supported.
/// If an image item is given as `.image` case, `DefaultImageProcessor` will
/// do nothing on it and return the associated image.
public struct DefaultImageProcessor: ImageProcessor {
    
    /// A default `DefaultImageProcessor` could be used across.
    public static let `default` = DefaultImageProcessor()
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier = ""
    
    /// Creates a `DefaultImageProcessor`. Use `DefaultImageProcessor.default` to get an instance,
    /// if you do not have a good reason to create your own `DefaultImageProcessor`.
    public init() {}
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.scaled(to: options.scaleFactor)
        case .data(let data):
            return KingfisherWrapper.image(data: data, options: options.imageCreatingOptions)
        }
    }
}
/// Represents the rect corner setting when processing a round corner image.
public struct RectCorner: OptionSet {
    
    /// Raw value of the rect corner.
    public let rawValue: Int
    
    /// Represents the top left corner.
    public static let topLeft = RectCorner(rawValue: 1 << 0)
    
    /// Represents the top right corner.
    public static let topRight = RectCorner(rawValue: 1 << 1)
    
    /// Represents the bottom left corner.
    public static let bottomLeft = RectCorner(rawValue: 1 << 2)
    
    /// Represents the bottom right corner.
    public static let bottomRight = RectCorner(rawValue: 1 << 3)
    
    /// Represents all corners.
    public static let all: RectCorner = [.topLeft, .topRight, .bottomLeft, .bottomRight]
    
    /// Creates a `RectCorner` option set with a given value.
    ///
    /// - Parameter rawValue: The value represents a certain corner option.
    public init(rawValue: Int) {
        self.rawValue = rawValue
    }
    
    var cornerIdentifier: String {
        if self == .all {
            return ""
        }
        return "_corner(\(rawValue))"
    }
}
#if !os(macOS)
/// Processor for adding an blend mode to images. Only CG-based images are supported.
public struct BlendImageProcessor: ImageProcessor {
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    /// Blend Mode will be used to blend the input image.
    public let blendMode: CGBlendMode
    /// Alpha will be used when blend image.
    public let alpha: CGFloat
    /// Background color of the output image. If `nil`, it will stay transparent.
    public let backgroundColor: KFCrossPlatformColor?
    /// Creates a `BlendImageProcessor`.
    ///
    /// - Parameters:
    ///   - blendMode: Blend Mode will be used to blend the input image.
    ///   - alpha: Alpha will be used when blend image. From 0.0 to 1.0. 1.0 means solid image,
    ///            0.0 means transparent image (not visible at all). Default is 1.0.
    ///   - backgroundColor: Background color to apply for the output image. Default is `nil`.
    public init(blendMode: CGBlendMode, alpha: CGFloat = 1.0, backgroundColor: KFCrossPlatformColor? = nil) {
        self.blendMode = blendMode
        self.alpha = alpha
        self.backgroundColor = backgroundColor
        var identifier = "com.onevcat.Kingfisher.BlendImageProcessor(\(blendMode.rawValue),\(alpha))"
        if let color = backgroundColor {
            identifier.append("_\(color.hex)")
        }
        self.identifier = identifier
    }
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.image(withBlendMode: blendMode, alpha: alpha, backgroundColor: backgroundColor)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
#endif
#if os(macOS)
/// Processor for adding an compositing operation to images. Only CG-based images are supported in macOS.
public struct CompositingImageProcessor: ImageProcessor {
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    /// Compositing operation will be used to the input image.
    public let compositingOperation: NSCompositingOperation
    /// Alpha will be used when compositing image.
    public let alpha: CGFloat
    /// Background color of the output image. If `nil`, it will stay transparent.
    public let backgroundColor: KFCrossPlatformColor?
    /// Creates a `CompositingImageProcessor`
    ///
    /// - Parameters:
    ///   - compositingOperation: Compositing operation will be used to the input image.
    ///   - alpha: Alpha will be used when compositing image.
    ///            From 0.0 to 1.0. 1.0 means solid image, 0.0 means transparent image.
    ///            Default is 1.0.
    ///   - backgroundColor: Background color to apply for the output image. Default is `nil`.
    public init(compositingOperation: NSCompositingOperation,
                alpha: CGFloat = 1.0,
                backgroundColor: KFCrossPlatformColor? = nil)
    {
        self.compositingOperation = compositingOperation
        self.alpha = alpha
        self.backgroundColor = backgroundColor
        var identifier = "com.onevcat.Kingfisher.CompositingImageProcessor(\(compositingOperation.rawValue),\(alpha))"
        if let color = backgroundColor {
            identifier.append("_\(color.hex)")
        }
        self.identifier = identifier
    }
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.image(
                            withCompositingOperation: compositingOperation,
                            alpha: alpha,
                            backgroundColor: backgroundColor)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
#endif
/// Processor for making round corner images. Only CG-based images are supported in macOS, 
/// if a non-CG image passed in, the processor will do nothing.
///
/// - Note: The input image will be rendered with round corner pixels removed. If the image itself does not contain
/// alpha channel (for example, a JPEG image), the processed image will contain an alpha channel in memory in order
/// to show correctly. However, when cached to disk, Kingfisher respects the original image format by default. That
/// means the alpha channel will be removed for these images. When you load the processed image from cache again, you
/// will lose transparent corner.
///
/// You could use `FormatIndicatedCacheSerializer.png` to force Kingfisher to serialize the image to PNG format in this
/// case.
///
public struct RoundCornerImageProcessor: ImageProcessor {
    /// Represents a radius specified in a `RoundCornerImageProcessor`.
    public enum Radius {
        /// The radius should be calculated as a fraction of the image width. Typically the associated value should be
        /// between 0 and 0.5, where 0 represents no radius and 0.5 represents using half of the image width.
        case widthFraction(CGFloat)
        /// The radius should be calculated as a fraction of the image height. Typically the associated value should be
        /// between 0 and 0.5, where 0 represents no radius and 0.5 represents using half of the image height.
        case heightFraction(CGFloat)
        /// Use a fixed point value as the round corner radius.
        case point(CGFloat)
        var radiusIdentifier: String {
            switch self {
            case .widthFraction(let f):
                return "w_frac_\(f)"
            case .heightFraction(let f):
                return "h_frac_\(f)"
            case .point(let p):
                return p.description
            }
        }
    }
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    /// Corner radius will be applied in processing. To provide backward compatibility, this property returns `0` unless
    /// `Radius.point` is specified.
    @available(*, deprecated, message: "Use `radius` property instead.")
    public var cornerRadius: CGFloat {
        switch radius {
        case .widthFraction, .heightFraction:
            return 0.0
        case .point(let value):
            return value
        }
    }
    /// The radius will be applied in processing. Specify a certain point value with `.point`, or a fraction of the
    /// target image with `.fraction`. `.fraction(0.5)` means use half of the
    public let radius: Radius
    
    /// The target corners which will be applied rounding.
    public let roundingCorners: RectCorner
    
    /// Target size of output image should be. If `nil`, the image will keep its original size after processing.
    public let targetSize: CGSize?
    /// Background color of the output image. If `nil`, it will use a transparent background.
    public let backgroundColor: KFCrossPlatformColor?
    /// Creates a `RoundCornerImageProcessor`.
    ///
    /// - Parameters:
    ///   - cornerRadius: Corner radius in point will be applied in processing.
    ///   - targetSize: Target size of output image should be. If `nil`,
    ///                 the image will keep its original size after processing.
    ///                 Default is `nil`.
    ///   - corners: The target corners which will be applied rounding. Default is `.all`.
    ///   - backgroundColor: Background color to apply for the output image. Default is `nil`.
    ///
    /// - Note:
    ///
    /// This initializer accepts a concrete point value for `cornerRadius`. If you do not know the image size, but still
    /// want to apply a full round-corner (making the final image a round one), or specify the corner radius as a
    /// fraction of one dimension of the target image, use the `Radius` version instead.
    ///
    public init(
        cornerRadius: CGFloat,
        targetSize: CGSize? = nil,
        roundingCorners corners: RectCorner = .all,
        backgroundColor: KFCrossPlatformColor? = nil
    )
    {
        let radius = Radius.point(cornerRadius)
        self.init(radius: radius, targetSize: targetSize, roundingCorners: corners, backgroundColor: backgroundColor)
    }
    /// Creates a `RoundCornerImageProcessor`.
    ///
    /// - Parameters:
    ///   - radius: The radius will be applied in processing.
    ///   - targetSize: Target size of output image should be. If `nil`,
    ///                 the image will keep its original size after processing.
    ///                 Default is `nil`.
    ///   - corners: The target corners which will be applied rounding. Default is `.all`.
    ///   - backgroundColor: Background color to apply for the output image. Default is `nil`.
    public init(
        radius: Radius,
        targetSize: CGSize? = nil,
        roundingCorners corners: RectCorner = .all,
        backgroundColor: KFCrossPlatformColor? = nil
    )
    {
        self.radius = radius
        self.targetSize = targetSize
        self.roundingCorners = corners
        self.backgroundColor = backgroundColor
        self.identifier = {
            var identifier = ""
            if let size = targetSize {
                identifier = "com.onevcat.Kingfisher.RoundCornerImageProcessor" +
                             "(\(radius.radiusIdentifier)_\(size)\(corners.cornerIdentifier))"
            } else {
                identifier = "com.onevcat.Kingfisher.RoundCornerImageProcessor" +
                             "(\(radius.radiusIdentifier)\(corners.cornerIdentifier))"
            }
            if let backgroundColor = backgroundColor {
                identifier += "_\(backgroundColor)"
            }
            return identifier
        }()
    }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            let size = targetSize ?? image.kf.size
            let cornerRadius: CGFloat
            switch radius {
            case .point(let point):
                cornerRadius = point
            case .widthFraction(let widthFraction):
                cornerRadius = size.width * widthFraction
            case .heightFraction(let heightFraction):
                cornerRadius = size.height * heightFraction
            }
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.image(
                            withRoundRadius: cornerRadius,
                            fit: size,
                            roundingCorners: roundingCorners,
                            backgroundColor: backgroundColor)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
/// Represents how a size adjusts itself to fit a target size.
///
/// - none: Not scale the content.
/// - aspectFit: Scales the content to fit the size of the view by maintaining the aspect ratio.
/// - aspectFill: Scales the content to fill the size of the view.
public enum ContentMode {
    /// Not scale the content.
    case none
    /// Scales the content to fit the size of the view by maintaining the aspect ratio.
    case aspectFit
    /// Scales the content to fill the size of the view.
    case aspectFill
}
/// Processor for resizing images.
/// If you need to resize a data represented image to a smaller size, use `DownsamplingImageProcessor`
/// instead, which is more efficient and takes less memory.
public struct ResizingImageProcessor: ImageProcessor {
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    
    /// The reference size for resizing operation in point.
    public let referenceSize: CGSize
    
    /// Target content mode of output image should be.
    /// Default is `.none`.
    public let targetContentMode: ContentMode
    
    /// Creates a `ResizingImageProcessor`.
    ///
    /// - Parameters:
    ///   - referenceSize: The reference size for resizing operation in point.
    ///   - mode: Target content mode of output image should be.
    ///
    /// - Note:
    ///   The instance of `ResizingImageProcessor` will follow its `mode` property
    ///   and try to resizing the input images to fit or fill the `referenceSize`.
    ///   That means if you are using a `mode` besides of `.none`, you may get an
    ///   image with its size not be the same as the `referenceSize`.
    ///
    ///   **Example**: With input image size: {100, 200}, 
    ///   `referenceSize`: {100, 100}, `mode`: `.aspectFit`,
    ///   you will get an output image with size of {50, 100}, which "fit"s
    ///   the `referenceSize`.
    ///
    ///   If you need an output image exactly to be a specified size, append or use
    ///   a `CroppingImageProcessor`.
    public init(referenceSize: CGSize, mode: ContentMode = .none) {
        self.referenceSize = referenceSize
        self.targetContentMode = mode
        
        if mode == .none {
            self.identifier = "com.onevcat.Kingfisher.ResizingImageProcessor(\(referenceSize))"
        } else {
            self.identifier = "com.onevcat.Kingfisher.ResizingImageProcessor(\(referenceSize), \(mode))"
        }
    }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.resize(to: referenceSize, for: targetContentMode)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
/// Processor for adding blur effect to images. `Accelerate.framework` is used underhood for 
/// a better performance. A simulated Gaussian blur with specified blur radius will be applied.
public struct BlurImageProcessor: ImageProcessor {
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    
    /// Blur radius for the simulated Gaussian blur.
    public let blurRadius: CGFloat
    /// Creates a `BlurImageProcessor`
    ///
    /// - parameter blurRadius: Blur radius for the simulated Gaussian blur.
    public init(blurRadius: CGFloat) {
        self.blurRadius = blurRadius
        self.identifier = "com.onevcat.Kingfisher.BlurImageProcessor(\(blurRadius))"
    }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            let radius = blurRadius * options.scaleFactor
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.blurred(withRadius: radius)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
/// Processor for adding an overlay to images. Only CG-based images are supported in macOS.
public struct OverlayImageProcessor: ImageProcessor {
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    
    /// Overlay color will be used to overlay the input image.
    public let overlay: KFCrossPlatformColor
    
    /// Fraction will be used when overlay the color to image.
    public let fraction: CGFloat
    
    /// Creates an `OverlayImageProcessor`
    ///
    /// - parameter overlay:  Overlay color will be used to overlay the input image.
    /// - parameter fraction: Fraction will be used when overlay the color to image. 
    ///                       From 0.0 to 1.0. 0.0 means solid color, 1.0 means transparent overlay.
    public init(overlay: KFCrossPlatformColor, fraction: CGFloat = 0.5) {
        self.overlay = overlay
        self.fraction = fraction
        self.identifier = "com.onevcat.Kingfisher.OverlayImageProcessor(\(overlay.hex)_\(fraction))"
    }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.overlaying(with: overlay, fraction: fraction)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
/// Processor for tint images with color. Only CG-based images are supported.
public struct TintImageProcessor: ImageProcessor {
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    
    /// Tint color will be used to tint the input image.
    public let tint: KFCrossPlatformColor
    
    /// Creates a `TintImageProcessor`
    ///
    /// - parameter tint: Tint color will be used to tint the input image.
    public init(tint: KFCrossPlatformColor) {
        self.tint = tint
        self.identifier = "com.onevcat.Kingfisher.TintImageProcessor(\(tint.hex))"
    }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.tinted(with: tint)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
/// Processor for applying some color control to images. Only CG-based images are supported.
/// watchOS is not supported.
public struct ColorControlsProcessor: ImageProcessor {
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    
    /// Brightness changing to image.
    public let brightness: CGFloat
    
    /// Contrast changing to image.
    public let contrast: CGFloat
    
    /// Saturation changing to image.
    public let saturation: CGFloat
    
    /// InputEV changing to image.
    public let inputEV: CGFloat
    
    /// Creates a `ColorControlsProcessor`
    ///
    /// - Parameters:
    ///   - brightness: Brightness changing to image.
    ///   - contrast: Contrast changing to image.
    ///   - saturation: Saturation changing to image.
    ///   - inputEV: InputEV changing to image.
    public init(brightness: CGFloat, contrast: CGFloat, saturation: CGFloat, inputEV: CGFloat) {
        self.brightness = brightness
        self.contrast = contrast
        self.saturation = saturation
        self.inputEV = inputEV
        self.identifier = "com.onevcat.Kingfisher.ColorControlsProcessor(\(brightness)_\(contrast)_\(saturation)_\(inputEV))"
    }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.adjusted(brightness: brightness, contrast: contrast, saturation: saturation, inputEV: inputEV)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
/// Processor for applying black and white effect to images. Only CG-based images are supported.
/// watchOS is not supported.
public struct BlackWhiteProcessor: ImageProcessor {
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier = "com.onevcat.Kingfisher.BlackWhiteProcessor"
    
    /// Creates a `BlackWhiteProcessor`
    public init() {}
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        return ColorControlsProcessor(brightness: 0.0, contrast: 1.0, saturation: 0.0, inputEV: 0.7)
            .process(item: item, options: options)
    }
}
/// Processor for cropping an image. Only CG-based images are supported.
/// watchOS is not supported.
public struct CroppingImageProcessor: ImageProcessor {
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    
    /// Target size of output image should be.
    public let size: CGSize
    
    /// Anchor point from which the output size should be calculate.
    /// The anchor point is consisted by two values between 0.0 and 1.0.
    /// It indicates a related point in current image. 
    /// See `CroppingImageProcessor.init(size:anchor:)` for more.
    public let anchor: CGPoint
    
    /// Creates a `CroppingImageProcessor`.
    ///
    /// - Parameters:
    ///   - size: Target size of output image should be.
    ///   - anchor: The anchor point from which the size should be calculated.
    ///             Default is `CGPoint(x: 0.5, y: 0.5)`, which means the center of input image.
    /// - Note:
    ///   The anchor point is consisted by two values between 0.0 and 1.0.
    ///   It indicates a related point in current image, eg: (0.0, 0.0) for top-left
    ///   corner, (0.5, 0.5) for center and (1.0, 1.0) for bottom-right corner.
    ///   The `size` property of `CroppingImageProcessor` will be used along with
    ///   `anchor` to calculate a target rectangle in the size of image.
    ///    
    ///   The target size will be automatically calculated with a reasonable behavior.
    ///   For example, when you have an image size of `CGSize(width: 100, height: 100)`,
    ///   and a target size of `CGSize(width: 20, height: 20)`: 
    ///   - with a (0.0, 0.0) anchor (top-left), the crop rect will be `{0, 0, 20, 20}`; 
    ///   - with a (0.5, 0.5) anchor (center), it will be `{40, 40, 20, 20}`
    ///   - while with a (1.0, 1.0) anchor (bottom-right), it will be `{80, 80, 20, 20}`
    public init(size: CGSize, anchor: CGPoint = CGPoint(x: 0.5, y: 0.5)) {
        self.size = size
        self.anchor = anchor
        self.identifier = "com.onevcat.Kingfisher.CroppingImageProcessor(\(size)_\(anchor))"
    }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.scaled(to: options.scaleFactor)
                        .kf.crop(to: size, anchorOn: anchor)
        case .data: return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
/// Processor for downsampling an image. Compared to `ResizingImageProcessor`, this processor
/// does not render the images to resize. Instead, it downsample the input data directly to an
/// image. It is a more efficient than `ResizingImageProcessor`.
///
/// Only CG-based images are supported. Animated images (like GIF) is not supported.
public struct DownsamplingImageProcessor: ImageProcessor {
    
    /// Target size of output image should be. It should be smaller than the size of
    /// input image. If it is larger, the result image will be the same size of input
    /// data without downsampling.
    public let size: CGSize
    
    /// Identifier of the processor.
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public let identifier: String
    
    /// Creates a `DownsamplingImageProcessor`.
    ///
    /// - Parameter size: The target size of the downsample operation.
    public init(size: CGSize) {
        self.size = size
        self.identifier = "com.onevcat.Kingfisher.DownsamplingImageProcessor(\(size))"
    }
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            guard let data = image.kf.data(format: .unknown) else {
                return nil
            }
            return KingfisherWrapper.downsampledImage(data: data, to: size, scale: options.scaleFactor)
        case .data(let data):
            return KingfisherWrapper.downsampledImage(data: data, to: size, scale: options.scaleFactor)
        }
    }
}
/// Concatenates two `ImageProcessor`s. `ImageProcessor.append(another:)` is used internally.
///
/// - Parameters:
///   - left: The first processor.
///   - right: The second processor.
/// - Returns: The concatenated processor.
@available(*, deprecated,
message: "Will be removed soon. Use `|>` instead.",
renamed: "|>")
public func >>(left: ImageProcessor, right: ImageProcessor) -> ImageProcessor {
    return left.append(another: right)
}
infix operator |>: AdditionPrecedence
public func |>(left: ImageProcessor, right: ImageProcessor) -> ImageProcessor {
    return left.append(another: right)
}
extension KFCrossPlatformColor {
    var hex: String {
        var r: CGFloat = 0
        var g: CGFloat = 0
        var b: CGFloat = 0
        var a: CGFloat = 0
        #if os(macOS)
        (usingColorSpace(.sRGB) ?? self).getRed(&r, green: &g, blue: &b, alpha: &a)
        #else
        getRed(&r, green: &g, blue: &b, alpha: &a)
        #endif
        let rInt = Int(r * 255) << 24
        let gInt = Int(g * 255) << 16
        let bInt = Int(b * 255) << 8
        let aInt = Int(a * 255)
        
        let rgba = rInt | gInt | bInt | aInt
        
        return String(format:"#%08x", rgba)
    }
}
//
//  Filter.swift
//  Kingfisher
//
//  Created by Wei Wang on 2016/08/31.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if !os(watchOS)
import CoreImage
// Reuse the same CI Context for all CI drawing.
private let ciContext = CIContext(options: nil)
/// Represents the type of transformer method, which will be used in to provide a `Filter`.
public typealias Transformer = (CIImage) -> CIImage?
/// Represents a processor based on a `CIImage` `Filter`.
/// It requires a filter to create an `ImageProcessor`.
public protocol CIImageProcessor: ImageProcessor {
    var filter: Filter { get }
}
extension CIImageProcessor {
    
    /// Processes the input `ImageProcessItem` with this processor.
    ///
    /// - Parameters:
    ///   - item: Input item which will be processed by `self`.
    ///   - options: Options when processing the item.
    /// - Returns: The processed image.
    ///
    /// - Note: See documentation of `ImageProcessor` protocol for more.
    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> KFCrossPlatformImage? {
        switch item {
        case .image(let image):
            return image.kf.apply(filter)
        case .data:
            return (DefaultImageProcessor.default |> self).process(item: item, options: options)
        }
    }
}
/// A wrapper struct for a `Transformer` of CIImage filters. A `Filter`
/// value could be used to create a `CIImage` processor.
public struct Filter {
    
    let transform: Transformer
    public init(transform: @escaping Transformer) {
        self.transform = transform
    }
    
    /// Tint filter which will apply a tint color to images.
    public static var tint: (KFCrossPlatformColor) -> Filter = {
        color in
        Filter {
            input in
            
            let colorFilter = CIFilter(name: "CIConstantColorGenerator")!
            colorFilter.setValue(CIColor(color: color), forKey: kCIInputColorKey)
            
            let filter = CIFilter(name: "CISourceOverCompositing")!
            
            let colorImage = colorFilter.outputImage
            filter.setValue(colorImage, forKey: kCIInputImageKey)
            filter.setValue(input, forKey: kCIInputBackgroundImageKey)
            
            return filter.outputImage?.cropped(to: input.extent)
        }
    }
    
    /// Represents color control elements. It is a tuple of
    /// `(brightness, contrast, saturation, inputEV)`
    public typealias ColorElement = (CGFloat, CGFloat, CGFloat, CGFloat)
    
    /// Color control filter which will apply color control change to images.
    public static var colorControl: (ColorElement) -> Filter = { arg -> Filter in
        let (brightness, contrast, saturation, inputEV) = arg
        return Filter { input in
            let paramsColor = [kCIInputBrightnessKey: brightness,
                               kCIInputContrastKey: contrast,
                               kCIInputSaturationKey: saturation]
            let blackAndWhite = input.applyingFilter("CIColorControls", parameters: paramsColor)
            let paramsExposure = [kCIInputEVKey: inputEV]
            return blackAndWhite.applyingFilter("CIExposureAdjust", parameters: paramsExposure)
        }
    }
}
extension KingfisherWrapper where Base: KFCrossPlatformImage {
    /// Applies a `Filter` containing `CIImage` transformer to `self`.
    ///
    /// - Parameter filter: The filter used to transform `self`.
    /// - Returns: A transformed image by input `Filter`.
    ///
    /// - Note:
    ///    Only CG-based images are supported. If any error happens
    ///    during transforming, `self` will be returned.
    public func apply(_ filter: Filter) -> KFCrossPlatformImage {
        
        guard let cgImage = cgImage else {
            assertionFailure("[Kingfisher] Tint image only works for CG-based image.")
            return base
        }
        
        let inputImage = CIImage(cgImage: cgImage)
        guard let outputImage = filter.transform(inputImage) else {
            return base
        }
        guard let result = ciContext.createCGImage(outputImage, from: outputImage.extent) else {
            assertionFailure("[Kingfisher] Can not make an tint image within context.")
            return base
        }
        
        #if os(macOS)
            return fixedForRetinaPixel(cgImage: result, to: size)
        #else
            return KFCrossPlatformImage(cgImage: result, scale: base.scale, orientation: base.imageOrientation)
        #endif
    }
}
#endif
//
//  Placeholder.swift
//  Kingfisher
//
//  Created by Tieme van Veen on 28/08/2017.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if !os(watchOS)
#if os(macOS)
import AppKit
#else
import UIKit
#endif
/// Represents a placeholder type which could be set while loading as well as
/// loading finished without getting an image.
public protocol Placeholder {
    
    /// How the placeholder should be added to a given image view.
    func add(to imageView: KFCrossPlatformImageView)
    
    /// How the placeholder should be removed from a given image view.
    func remove(from imageView: KFCrossPlatformImageView)
}
/// Default implementation of an image placeholder. The image will be set or
/// reset directly for `image` property of the image view.
extension KFCrossPlatformImage: Placeholder {
    /// How the placeholder should be added to a given image view.
    public func add(to imageView: KFCrossPlatformImageView) { imageView.image = self }
    /// How the placeholder should be removed from a given image view.
    public func remove(from imageView: KFCrossPlatformImageView) { imageView.image = nil }
}
/// Default implementation of an arbitrary view as placeholder. The view will be 
/// added as a subview when adding and be removed from its super view when removing.
///
/// To use your customize View type as placeholder, simply let it conforming to 
/// `Placeholder` by `extension MyView: Placeholder {}`.
extension Placeholder where Self: KFCrossPlatformView {
    
    /// How the placeholder should be added to a given image view.
    public func add(to imageView: KFCrossPlatformImageView) {
        imageView.addSubview(self)
        translatesAutoresizingMaskIntoConstraints = false
        centerXAnchor.constraint(equalTo: imageView.centerXAnchor).isActive = true
        centerYAnchor.constraint(equalTo: imageView.centerYAnchor).isActive = true
        heightAnchor.constraint(equalTo: imageView.heightAnchor).isActive = true
        widthAnchor.constraint(equalTo: imageView.widthAnchor).isActive = true
    }
    /// How the placeholder should be removed from a given image view.
    public func remove(from imageView: KFCrossPlatformImageView) {
        removeFromSuperview()
    }
}
#endif
//
//  AnimatedImage.swift
//  Kingfisher
//
//  Created by onevcat on 2018/09/26.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
import ImageIO
/// Represents a set of image creating options used in Kingfisher.
public struct ImageCreatingOptions {
    /// The target scale of image needs to be created.
    public let scale: CGFloat
    /// The expected animation duration if an animated image being created.
    public let duration: TimeInterval
    /// For an animated image, whether or not all frames should be loaded before displaying.
    public let preloadAll: Bool
    /// For an animated image, whether or not only the first image should be
    /// loaded as a static image. It is useful for preview purpose of an animated image.
    public let onlyFirstFrame: Bool
    
    /// Creates an `ImageCreatingOptions` object.
    ///
    /// - Parameters:
    ///   - scale: The target scale of image needs to be created. Default is `1.0`.
    ///   - duration: The expected animation duration if an animated image being created.
    ///               A value less or equal to `0.0` means the animated image duration will
    ///               be determined by the frame data. Default is `0.0`.
    ///   - preloadAll: For an animated image, whether or not all frames should be loaded before displaying.
    ///                 Default is `false`.
    ///   - onlyFirstFrame: For an animated image, whether or not only the first image should be
    ///                     loaded as a static image. It is useful for preview purpose of an animated image.
    ///                     Default is `false`.
    public init(
        scale: CGFloat = 1.0,
        duration: TimeInterval = 0.0,
        preloadAll: Bool = false,
        onlyFirstFrame: Bool = false)
    {
        self.scale = scale
        self.duration = duration
        self.preloadAll = preloadAll
        self.onlyFirstFrame = onlyFirstFrame
    }
}
// Represents the decoding for a GIF image. This class extracts frames from an `imageSource`, then
// hold the images for later use.
class GIFAnimatedImage {
    let images: [KFCrossPlatformImage]
    let duration: TimeInterval
    
    init?(from imageSource: CGImageSource, for info: [String: Any], options: ImageCreatingOptions) {
        let frameCount = CGImageSourceGetCount(imageSource)
        var images = [KFCrossPlatformImage]()
        var gifDuration = 0.0
        
        for i in 0 ..< frameCount {
            guard let imageRef = CGImageSourceCreateImageAtIndex(imageSource, i, info as CFDictionary) else {
                return nil
            }
            
            if frameCount == 1 {
                gifDuration = .infinity
            } else {
                // Get current animated GIF frame duration
                gifDuration += GIFAnimatedImage.getFrameDuration(from: imageSource, at: i)
            }
            images.append(KingfisherWrapper.image(cgImage: imageRef, scale: options.scale, refImage: nil))
            if options.onlyFirstFrame { break }
        }
        self.images = images
        self.duration = gifDuration
    }
    
    // Calculates frame duration for a gif frame out of the kCGImagePropertyGIFDictionary dictionary.
    static func getFrameDuration(from gifInfo: [String: Any]?) -> TimeInterval {
        let defaultFrameDuration = 0.1
        guard let gifInfo = gifInfo else { return defaultFrameDuration }
        
        let unclampedDelayTime = gifInfo[kCGImagePropertyGIFUnclampedDelayTime as String] as? NSNumber
        let delayTime = gifInfo[kCGImagePropertyGIFDelayTime as String] as? NSNumber
        let duration = unclampedDelayTime ?? delayTime
        
        guard let frameDuration = duration else { return defaultFrameDuration }
        return frameDuration.doubleValue > 0.011 ? frameDuration.doubleValue : defaultFrameDuration
    }
    // Calculates frame duration at a specific index for a gif from an `imageSource`.
    static func getFrameDuration(from imageSource: CGImageSource, at index: Int) -> TimeInterval {
        guard let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, index, nil)
            as? [String: Any] else { return 0.0 }
        let gifInfo = properties[kCGImagePropertyGIFDictionary as String] as? [String: Any]
        return getFrameDuration(from: gifInfo)
    }
}
//
//  ImageView+Kingfisher.swift
//  Kingfisher
//
//  Created by Wei Wang on 15/4/6.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if !os(watchOS)
#if os(macOS)
import AppKit
#else
import UIKit
#endif
extension KingfisherWrapper where Base: KFCrossPlatformImageView {
    // MARK: Setting Image
    /// Sets an image to the image view with a `Source`.
    ///
    /// - Parameters:
    ///   - source: The `Source` object defines data information from network or a data provider.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// This is the easiest way to use Kingfisher to boost the image setting process from a source. Since all parameters
    /// have a default value except the `source`, you can set an image from a certain URL to an image view like this:
    ///
    /// ```
    /// // Set image from a network source.
    /// let url = URL(string: "https://example.com/image.png")!
    /// imageView.kf.setImage(with: .network(url))
    ///
    /// // Or set image from a data provider.
    /// let provider = LocalFileImageDataProvider(fileURL: fileURL)
    /// imageView.kf.setImage(with: .provider(provider))
    /// ```
    ///
    /// For both `.network` and `.provider` source, there are corresponding view extension methods. So the code
    /// above is equivalent to:
    ///
    /// ```
    /// imageView.kf.setImage(with: url)
    /// imageView.kf.setImage(with: provider)
    /// ```
    ///
    /// Internally, this method will use `KingfisherManager` to get the source.
    /// Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with source: Source?,
        placeholder: Placeholder? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        var mutatingSelf = self
        guard let source = source else {
            mutatingSelf.placeholder = placeholder
            mutatingSelf.taskIdentifier = nil
            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
            return nil
        }
        var options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
        let isEmptyImage = base.image == nil && self.placeholder == nil
        if !options.keepCurrentImageWhileLoading || isEmptyImage {
            // Always set placeholder while there is no image/placeholder yet.
            mutatingSelf.placeholder = placeholder
        }
        let maybeIndicator = indicator
        maybeIndicator?.startAnimatingView()
        let issuedIdentifier = Source.Identifier.next()
        mutatingSelf.taskIdentifier = issuedIdentifier
        if base.shouldPreloadAllAnimation() {
            options.preloadAllAnimationData = true
        }
        if let block = progressBlock {
            options.onDataReceived = (options.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        if let provider = ImageProgressiveProvider(options, refresh: { image in
            self.base.image = image
        }) {
            options.onDataReceived = (options.onDataReceived ?? []) + [provider]
        }
        
        options.onDataReceived?.forEach {
            $0.onShouldApply = { issuedIdentifier == self.taskIdentifier }
        }
        let task = KingfisherManager.shared.retrieveImage(
            with: source,
            options: options,
            downloadTaskUpdated: { mutatingSelf.imageTask = $0 },
            completionHandler: { result in
                CallbackQueue.mainCurrentOrAsync.execute {
                    maybeIndicator?.stopAnimatingView()
                    guard issuedIdentifier == self.taskIdentifier else {
                        let reason: KingfisherError.ImageSettingErrorReason
                        do {
                            let value = try result.get()
                            reason = .notCurrentSourceTask(result: value, error: nil, source: source)
                        } catch {
                            reason = .notCurrentSourceTask(result: nil, error: error, source: source)
                        }
                        let error = KingfisherError.imageSettingError(reason: reason)
                        completionHandler?(.failure(error))
                        return
                    }
                    
                    mutatingSelf.imageTask = nil
                    mutatingSelf.taskIdentifier = nil
                    
                    switch result {
                    case .success(let value):
                        guard self.needsTransition(options: options, cacheType: value.cacheType) else {
                            mutatingSelf.placeholder = nil
                            self.base.image = value.image
                            completionHandler?(result)
                            return
                        }
                        
                        self.makeTransition(image: value.image, transition: options.transition) {
                            completionHandler?(result)
                        }
                        
                    case .failure:
                        if let image = options.onFailureImage {
                            self.base.image = image
                        }
                        completionHandler?(result)
                    }
                }
            }
        )
        mutatingSelf.imageTask = task
        return task
    }
    /// Sets an image to the image view with a requested resource.
    ///
    /// - Parameters:
    ///   - resource: The `Resource` object contains information about the resource.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// This is the easiest way to use Kingfisher to boost the image setting process from network. Since all parameters
    /// have a default value except the `resource`, you can set an image from a certain URL to an image view like this:
    ///
    /// ```
    /// let url = URL(string: "https://example.com/image.png")!
    /// imageView.kf.setImage(with: url)
    /// ```
    ///
    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
    /// or network. Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with resource: Resource?,
        placeholder: Placeholder? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        return setImage(
            with: resource?.convertToSource(),
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    /// Sets an image to the image view with a data provider.
    ///
    /// - Parameters:
    ///   - provider: The `ImageDataProvider` object contains information about the data.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// Internally, this method will use `KingfisherManager` to get the image data, from either cache
    /// or the data provider. Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with provider: ImageDataProvider?,
        placeholder: Placeholder? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        return setImage(
            with: provider.map { .provider($0) },
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    // MARK: Cancelling Downloading Task
    /// Cancels the image download task of the image view if it is running.
    /// Nothing will happen if the downloading has already finished.
    public func cancelDownloadTask() {
        imageTask?.cancel()
    }
    private func needsTransition(options: KingfisherParsedOptionsInfo, cacheType: CacheType) -> Bool {
        switch options.transition {
        case .none:
            return false
        #if !os(macOS)
        default:
            if options.forceTransition { return true }
            if cacheType == .none { return true }
            return false
        #endif
        }
    }
    private func makeTransition(image: KFCrossPlatformImage, transition: ImageTransition, done: @escaping () -> Void) {
        #if !os(macOS)
        // Force hiding the indicator without transition first.
        UIView.transition(
            with: self.base,
            duration: 0.0,
            options: [],
            animations: { self.indicator?.stopAnimatingView() },
            completion: { _ in
                var mutatingSelf = self
                mutatingSelf.placeholder = nil
                UIView.transition(
                    with: self.base,
                    duration: transition.duration,
                    options: [transition.animationOptions, .allowUserInteraction],
                    animations: { transition.animations?(self.base, image) },
                    completion: { finished in
                        transition.completion?(finished)
                        done()
                    }
                )
            }
        )
        #else
        done()
        #endif
    }
}
// MARK: - Associated Object
private var taskIdentifierKey: Void?
private var indicatorKey: Void?
private var indicatorTypeKey: Void?
private var placeholderKey: Void?
private var imageTaskKey: Void?
extension KingfisherWrapper where Base: KFCrossPlatformImageView {
    // MARK: Properties
    public private(set) var taskIdentifier: Source.Identifier.Value? {
        get {
            let box: Box<Source.Identifier.Value>? = getAssociatedObject(base, &taskIdentifierKey)
            return box?.value
        }
        set {
            let box = newValue.map { Box($0) }
            setRetainedAssociatedObject(base, &taskIdentifierKey, box)
        }
    }
    /// Holds which indicator type is going to be used.
    /// Default is `.none`, means no indicator will be shown while downloading.
    public var indicatorType: IndicatorType {
        get {
            return getAssociatedObject(base, &indicatorTypeKey) ?? .none
        }
        
        set {
            switch newValue {
            case .none: indicator = nil
            case .activity: indicator = ActivityIndicator()
            case .image(let data): indicator = ImageIndicator(imageData: data)
            case .custom(let anIndicator): indicator = anIndicator
            }
            setRetainedAssociatedObject(base, &indicatorTypeKey, newValue)
        }
    }
    
    /// Holds any type that conforms to the protocol `Indicator`.
    /// The protocol `Indicator` has a `view` property that will be shown when loading an image.
    /// It will be `nil` if `indicatorType` is `.none`.
    public private(set) var indicator: Indicator? {
        get {
            let box: Box<Indicator>? = getAssociatedObject(base, &indicatorKey)
            return box?.value
        }
        
        set {
            // Remove previous
            if let previousIndicator = indicator {
                previousIndicator.view.removeFromSuperview()
            }
            
            // Add new
            if let newIndicator = newValue {
                // Set default indicator layout
                let view = newIndicator.view
                
                base.addSubview(view)
                view.translatesAutoresizingMaskIntoConstraints = false
                view.centerXAnchor.constraint(
                    equalTo: base.centerXAnchor, constant: newIndicator.centerOffset.x).isActive = true
                view.centerYAnchor.constraint(
                    equalTo: base.centerYAnchor, constant: newIndicator.centerOffset.y).isActive = true
                switch newIndicator.sizeStrategy(in: base) {
                case .intrinsicSize:
                    break
                case .full:
                    view.heightAnchor.constraint(equalTo: base.heightAnchor, constant: 0).isActive = true
                    view.widthAnchor.constraint(equalTo: base.widthAnchor, constant: 0).isActive = true
                case .size(let size):
                    view.heightAnchor.constraint(equalToConstant: size.height).isActive = true
                    view.widthAnchor.constraint(equalToConstant: size.width).isActive = true
                }
                
                newIndicator.view.isHidden = true
            }
            // Save in associated object
            // Wrap newValue with Box to workaround an issue that Swift does not recognize
            // and casting protocol for associate object correctly. https://github.com/onevcat/Kingfisher/issues/872
            setRetainedAssociatedObject(base, &indicatorKey, newValue.map(Box.init))
        }
    }
    
    private var imageTask: DownloadTask? {
        get { return getAssociatedObject(base, &imageTaskKey) }
        set { setRetainedAssociatedObject(base, &imageTaskKey, newValue)}
    }
    /// Represents the `Placeholder` used for this image view. A `Placeholder` will be shown in the view while
    /// it is downloading an image.
    public private(set) var placeholder: Placeholder? {
        get { return getAssociatedObject(base, &placeholderKey) }
        set {
            if let previousPlaceholder = placeholder {
                previousPlaceholder.remove(from: base)
            }
            
            if let newPlaceholder = newValue {
                newPlaceholder.add(to: base)
            } else {
                base.image = nil
            }
            setRetainedAssociatedObject(base, &placeholderKey, newValue)
        }
    }
}
extension KFCrossPlatformImageView {
    @objc func shouldPreloadAllAnimation() -> Bool { return true }
}
extension KingfisherWrapper where Base: KFCrossPlatformImageView {
    /// Gets the image URL bound to this image view.
    @available(*, deprecated, message: "Use `taskIdentifier` instead to identify a setting task.")
    public private(set) var webURL: URL? {
        get { return nil }
        set { }
    }
}
#endif
//
//  NSButton+Kingfisher.swift
//  Kingfisher
//
//  Created by Jie Zhang on 14/04/2016.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
extension KingfisherWrapper where Base: NSButton {
    // MARK: Setting Image
    /// Sets an image to the button with a source.
    ///
    /// - Parameters:
    ///   - source: The `Source` object contains information about how to get the image.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// Internally, this method will use `KingfisherManager` to get the requested source.
    /// Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with source: Source?,
        placeholder: KFCrossPlatformImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        var mutatingSelf = self
        guard let source = source else {
            base.image = placeholder
            mutatingSelf.taskIdentifier = nil
            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
            return nil
        }
        var options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
        if !options.keepCurrentImageWhileLoading {
            base.image = placeholder
        }
        let issuedIdentifier = Source.Identifier.next()
        mutatingSelf.taskIdentifier = issuedIdentifier
        
        if let block = progressBlock {
            options.onDataReceived = (options.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        
        if let provider = ImageProgressiveProvider(options, refresh: { image in
            self.base.image = image
        }) {
            options.onDataReceived = (options.onDataReceived ?? []) + [provider]
        }
        
        options.onDataReceived?.forEach {
            $0.onShouldApply = { issuedIdentifier == self.taskIdentifier }
        }
        
        let task = KingfisherManager.shared.retrieveImage(
            with: source,
            options: options,
            downloadTaskUpdated: { mutatingSelf.imageTask = $0 },
            completionHandler: { result in
                CallbackQueue.mainCurrentOrAsync.execute {
                    guard issuedIdentifier == self.taskIdentifier else {
                        let reason: KingfisherError.ImageSettingErrorReason
                        do {
                            let value = try result.get()
                            reason = .notCurrentSourceTask(result: value, error: nil, source: source)
                        } catch {
                            reason = .notCurrentSourceTask(result: nil, error: error, source: source)
                        }
                        let error = KingfisherError.imageSettingError(reason: reason)
                        completionHandler?(.failure(error))
                        return
                    }
                    
                    mutatingSelf.imageTask = nil
                    mutatingSelf.taskIdentifier = nil
                    
                    switch result {
                    case .success(let value):
                        self.base.image = value.image
                        completionHandler?(result)
                        
                    case .failure:
                        if let image = options.onFailureImage {
                            self.base.image = image
                        }
                        completionHandler?(result)
                    }
                }
            }
        )
        mutatingSelf.imageTask = task
        return task
    }
    /// Sets an image to the button with a requested resource.
    ///
    /// - Parameters:
    ///   - resource: The `Resource` object contains information about the resource.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
    /// or network. Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with resource: Resource?,
        placeholder: KFCrossPlatformImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        return setImage(
            with: resource?.convertToSource(),
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    // MARK: Cancelling Downloading Task
    /// Cancels the image download task of the button if it is running.
    /// Nothing will happen if the downloading has already finished.
    public func cancelImageDownloadTask() {
        imageTask?.cancel()
    }
    // MARK: Setting Alternate Image
    @discardableResult
    public func setAlternateImage(
        with source: Source?,
        placeholder: KFCrossPlatformImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        var mutatingSelf = self
        guard let source = source else {
            base.alternateImage = placeholder
            mutatingSelf.alternateTaskIdentifier = nil
            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
            return nil
        }
        var options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
        if !options.keepCurrentImageWhileLoading {
            base.alternateImage = placeholder
        }
        let issuedIdentifier = Source.Identifier.next()
        mutatingSelf.alternateTaskIdentifier = issuedIdentifier
        
        if let block = progressBlock {
            options.onDataReceived = (options.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        
        if let provider = ImageProgressiveProvider(options, refresh: { image in
            self.base.alternateImage = image
        }) {
            options.onDataReceived = (options.onDataReceived ?? []) + [provider]
        }
        
        options.onDataReceived?.forEach {
            $0.onShouldApply = { issuedIdentifier == self.alternateTaskIdentifier }
        }
        
        let task = KingfisherManager.shared.retrieveImage(
            with: source,
            options: options,
            downloadTaskUpdated: { mutatingSelf.alternateImageTask = $0 },
            completionHandler: { result in
                CallbackQueue.mainCurrentOrAsync.execute {
                    guard issuedIdentifier == self.alternateTaskIdentifier else {
                        let reason: KingfisherError.ImageSettingErrorReason
                        do {
                            let value = try result.get()
                            reason = .notCurrentSourceTask(result: value, error: nil, source: source)
                        } catch {
                            reason = .notCurrentSourceTask(result: nil, error: error, source: source)
                        }
                        let error = KingfisherError.imageSettingError(reason: reason)
                        completionHandler?(.failure(error))
                        return
                    }
                    
                    mutatingSelf.alternateImageTask = nil
                    mutatingSelf.alternateTaskIdentifier = nil
                    
                    switch result {
                    case .success(let value):
                        self.base.alternateImage = value.image
                        completionHandler?(result)
                        
                    case .failure:
                        if let image = options.onFailureImage {
                            self.base.alternateImage = image
                        }
                        completionHandler?(result)
                    }
                }
            }
        )
        mutatingSelf.alternateImageTask = task
        return task
    }
    /// Sets an alternate image to the button with a requested resource.
    ///
    /// - Parameters:
    ///   - resource: The `Resource` object contains information about the resource.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
    /// or network. Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setAlternateImage(
        with resource: Resource?,
        placeholder: KFCrossPlatformImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        return setAlternateImage(
            with: resource?.convertToSource(),
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    // MARK: Cancelling Alternate Image Downloading Task
    /// Cancels the alternate image download task of the button if it is running.
    /// Nothing will happen if the downloading has already finished.
    public func cancelAlternateImageDownloadTask() {
        alternateImageTask?.cancel()
    }
}
// MARK: - Associated Object
private var taskIdentifierKey: Void?
private var imageTaskKey: Void?
private var alternateTaskIdentifierKey: Void?
private var alternateImageTaskKey: Void?
extension KingfisherWrapper where Base: NSButton {
    // MARK: Properties
    
    public private(set) var taskIdentifier: Source.Identifier.Value? {
        get {
            let box: Box<Source.Identifier.Value>? = getAssociatedObject(base, &taskIdentifierKey)
            return box?.value
        }
        set {
            let box = newValue.map { Box($0) }
            setRetainedAssociatedObject(base, &taskIdentifierKey, box)
        }
    }
    
    private var imageTask: DownloadTask? {
        get { return getAssociatedObject(base, &imageTaskKey) }
        set { setRetainedAssociatedObject(base, &imageTaskKey, newValue)}
    }
    public private(set) var alternateTaskIdentifier: Source.Identifier.Value? {
        get {
            let box: Box<Source.Identifier.Value>? = getAssociatedObject(base, &alternateTaskIdentifierKey)
            return box?.value
        }
        set {
            let box = newValue.map { Box($0) }
            setRetainedAssociatedObject(base, &alternateTaskIdentifierKey, box)
        }
    }
    private var alternateImageTask: DownloadTask? {
        get { return getAssociatedObject(base, &alternateImageTaskKey) }
        set { setRetainedAssociatedObject(base, &alternateImageTaskKey, newValue)}
    }
}
extension KingfisherWrapper where Base: NSButton {
    /// Gets the image URL bound to this button.
    @available(*, deprecated, message: "Use `taskIdentifier` instead to identify a setting task.")
    public private(set) var webURL: URL? {
        get { return nil }
        set { }
    }
    /// Gets the image URL bound to this button.
    @available(*, deprecated, message: "Use `alternateTaskIdentifier` instead to identify a setting task.")
    public private(set) var alternateWebURL: URL? {
        get { return nil }
        set { }
    }
}
#endif
//
//  UIButton+Kingfisher.swift
//  Kingfisher
//
//  Created by Wei Wang on 15/4/13.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if !os(watchOS)
#if canImport(UIKit)
import UIKit
extension KingfisherWrapper where Base: UIButton {
    // MARK: Setting Image
    /// Sets an image to the button for a specified state with a source.
    ///
    /// - Parameters:
    ///   - source: The `Source` object contains information about the image.
    ///   - state: The button state to which the image should be set.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// Internally, this method will use `KingfisherManager` to get the requested source, from either cache
    /// or network. Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with source: Source?,
        for state: UIControl.State,
        placeholder: UIImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        guard let source = source else {
            base.setImage(placeholder, for: state)
            setTaskIdentifier(nil, for: state)
            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
            return nil
        }
        
        var options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
        if !options.keepCurrentImageWhileLoading {
            base.setImage(placeholder, for: state)
        }
        
        var mutatingSelf = self
        let issuedIdentifier = Source.Identifier.next()
        setTaskIdentifier(issuedIdentifier, for: state)
        
        if let block = progressBlock {
            options.onDataReceived = (options.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        
        if let provider = ImageProgressiveProvider(options, refresh: { image in
            self.base.setImage(image, for: state)
        }) {
            options.onDataReceived = (options.onDataReceived ?? []) + [provider]
        }
        
        options.onDataReceived?.forEach {
            $0.onShouldApply = { issuedIdentifier == self.taskIdentifier(for: state) }
        }
        
        let task = KingfisherManager.shared.retrieveImage(
            with: source,
            options: options,
            downloadTaskUpdated: { mutatingSelf.imageTask = $0 },
            completionHandler: { result in
                CallbackQueue.mainCurrentOrAsync.execute {
                    guard issuedIdentifier == self.taskIdentifier(for: state) else {
                        let reason: KingfisherError.ImageSettingErrorReason
                        do {
                            let value = try result.get()
                            reason = .notCurrentSourceTask(result: value, error: nil, source: source)
                        } catch {
                            reason = .notCurrentSourceTask(result: nil, error: error, source: source)
                        }
                        let error = KingfisherError.imageSettingError(reason: reason)
                        completionHandler?(.failure(error))
                        return
                    }
                    
                    mutatingSelf.imageTask = nil
                    mutatingSelf.setTaskIdentifier(nil, for: state)
                    
                    switch result {
                    case .success(let value):
                        self.base.setImage(value.image, for: state)
                        completionHandler?(result)
                        
                    case .failure:
                        if let image = options.onFailureImage {
                            self.base.setImage(image, for: state)
                        }
                        completionHandler?(result)
                    }
                }
            }
        )
        
        mutatingSelf.imageTask = task
        return task
    }
    
    /// Sets an image to the button for a specified state with a requested resource.
    ///
    /// - Parameters:
    ///   - resource: The `Resource` object contains information about the resource.
    ///   - state: The button state to which the image should be set.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
    /// or network. Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with resource: Resource?,
        for state: UIControl.State,
        placeholder: UIImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        return setImage(
            with: resource?.convertToSource(),
            for: state,
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    // MARK: Cancelling Downloading Task
    
    /// Cancels the image download task of the button if it is running.
    /// Nothing will happen if the downloading has already finished.
    public func cancelImageDownloadTask() {
        imageTask?.cancel()
    }
    // MARK: Setting Background Image
    /// Sets a background image to the button for a specified state with a source.
    ///
    /// - Parameters:
    ///   - source: The `Source` object contains information about the image.
    ///   - state: The button state to which the image should be set.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// Internally, this method will use `KingfisherManager` to get the requested source
    /// Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setBackgroundImage(
        with source: Source?,
        for state: UIControl.State,
        placeholder: UIImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        guard let source = source else {
            base.setBackgroundImage(placeholder, for: state)
            setBackgroundTaskIdentifier(nil, for: state)
            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
            return nil
        }
        var options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
        if !options.keepCurrentImageWhileLoading {
            base.setBackgroundImage(placeholder, for: state)
        }
        
        var mutatingSelf = self
        let issuedIdentifier = Source.Identifier.next()
        setBackgroundTaskIdentifier(issuedIdentifier, for: state)
        
        if let block = progressBlock {
            options.onDataReceived = (options.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        
        if let provider = ImageProgressiveProvider(options, refresh: { image in
            self.base.setBackgroundImage(image, for: state)
        }) {
            options.onDataReceived = (options.onDataReceived ?? []) + [provider]
        }
        
        options.onDataReceived?.forEach {
            $0.onShouldApply = { issuedIdentifier == self.backgroundTaskIdentifier(for: state) }
        }
        
        let task = KingfisherManager.shared.retrieveImage(
            with: source,
            options: options,
            downloadTaskUpdated: { mutatingSelf.backgroundImageTask = $0 },
            completionHandler: { result in
                CallbackQueue.mainCurrentOrAsync.execute {
                    guard issuedIdentifier == self.backgroundTaskIdentifier(for: state) else {
                        let reason: KingfisherError.ImageSettingErrorReason
                        do {
                            let value = try result.get()
                            reason = .notCurrentSourceTask(result: value, error: nil, source: source)
                        } catch {
                            reason = .notCurrentSourceTask(result: nil, error: error, source: source)
                        }
                        let error = KingfisherError.imageSettingError(reason: reason)
                        completionHandler?(.failure(error))
                        return
                    }
                    
                    mutatingSelf.backgroundImageTask = nil
                    mutatingSelf.setBackgroundTaskIdentifier(nil, for: state)
                    
                    switch result {
                    case .success(let value):
                        self.base.setBackgroundImage(value.image, for: state)
                        completionHandler?(result)
                        
                    case .failure:
                        if let image = options.onFailureImage {
                            self.base.setBackgroundImage(image, for: state)
                        }
                        completionHandler?(result)
                    }
                }
            }
        )
        mutatingSelf.backgroundImageTask = task
        return task
    }
    /// Sets a background image to the button for a specified state with a requested resource.
    ///
    /// - Parameters:
    ///   - resource: The `Resource` object contains information about the resource.
    ///   - state: The button state to which the image should be set.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
    /// or network. Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setBackgroundImage(
        with resource: Resource?,
        for state: UIControl.State,
        placeholder: UIImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        return setBackgroundImage(
            with: resource?.convertToSource(),
            for: state,
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    // MARK: Cancelling Background Downloading Task
    
    /// Cancels the background image download task of the button if it is running.
    /// Nothing will happen if the downloading has already finished.
    public func cancelBackgroundImageDownloadTask() {
        backgroundImageTask?.cancel()
    }
}
// MARK: - Associated Object
private var taskIdentifierKey: Void?
private var imageTaskKey: Void?
// MARK: Properties
extension KingfisherWrapper where Base: UIButton {
    private typealias TaskIdentifier = Box<[UInt: Source.Identifier.Value]>
    
    public func taskIdentifier(for state: UIControl.State) -> Source.Identifier.Value? {
        return taskIdentifierInfo.value[state.rawValue]
    }
    private func setTaskIdentifier(_ identifier: Source.Identifier.Value?, for state: UIControl.State) {
        taskIdentifierInfo.value[state.rawValue] = identifier
    }
    
    private var taskIdentifierInfo: TaskIdentifier {
        return  getAssociatedObject(base, &taskIdentifierKey) ?? {
            setRetainedAssociatedObject(base, &taskIdentifierKey, $0)
            return $0
        } (TaskIdentifier([:]))
    }
    
    private var imageTask: DownloadTask? {
        get { return getAssociatedObject(base, &imageTaskKey) }
        set { setRetainedAssociatedObject(base, &imageTaskKey, newValue)}
    }
}
private var backgroundTaskIdentifierKey: Void?
private var backgroundImageTaskKey: Void?
// MARK: Background Properties
extension KingfisherWrapper where Base: UIButton {
    
    public func backgroundTaskIdentifier(for state: UIControl.State) -> Source.Identifier.Value? {
        return backgroundTaskIdentifierInfo.value[state.rawValue]
    }
    
    private func setBackgroundTaskIdentifier(_ identifier: Source.Identifier.Value?, for state: UIControl.State) {
        backgroundTaskIdentifierInfo.value[state.rawValue] = identifier
    }
    
    private var backgroundTaskIdentifierInfo: TaskIdentifier {
        return  getAssociatedObject(base, &backgroundTaskIdentifierKey) ?? {
            setRetainedAssociatedObject(base, &backgroundTaskIdentifierKey, $0)
            return $0
        } (TaskIdentifier([:]))
    }
    
    private var backgroundImageTask: DownloadTask? {
        get { return getAssociatedObject(base, &backgroundImageTaskKey) }
        mutating set { setRetainedAssociatedObject(base, &backgroundImageTaskKey, newValue) }
    }
}
extension KingfisherWrapper where Base: UIButton {
    /// Gets the image URL of this button for a specified state.
    ///
    /// - Parameter state: The state that uses the specified image.
    /// - Returns: Current URL for image.
    @available(*, deprecated, message: "Use `taskIdentifier` instead to identify a setting task.")
    public func webURL(for state: UIControl.State) -> URL? {
        return nil
    }
    /// Gets the background image URL of this button for a specified state.
    ///
    /// - Parameter state: The state that uses the specified background image.
    /// - Returns: Current URL for image.
    @available(*, deprecated, message: "Use `backgroundTaskIdentifier` instead to identify a setting task.")
    public func backgroundWebURL(for state: UIControl.State) -> URL? {
        return nil
    }
}
#endif
#endif
//
//  WKInterfaceImage+Kingfisher.swift
//  Kingfisher
//
//  Created by Rodrigo Borges Soares on 04/05/18.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if canImport(WatchKit)
import WatchKit
extension KingfisherWrapper where Base: WKInterfaceImage {
    // MARK: Setting Image
    /// Sets an image to the image view with a source.
    ///
    /// - Parameters:
    ///   - source: The `Source` object contains information about the image.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    ///
    /// Internally, this method will use `KingfisherManager` to get the requested source
    /// Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with source: Source?,
        placeholder: KFCrossPlatformImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        var mutatingSelf = self
        guard let source = source else {
            base.setImage(placeholder)
            mutatingSelf.taskIdentifier = nil
            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
            return nil
        }
        
        var options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
        if !options.keepCurrentImageWhileLoading {
            base.setImage(placeholder)
        }
        
        let issuedIdentifier = Source.Identifier.next()
        mutatingSelf.taskIdentifier = issuedIdentifier
        
        if let block = progressBlock {
            options.onDataReceived = (options.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        
        if let provider = ImageProgressiveProvider(options, refresh: { image in
            self.base.setImage(image)
        }) {
            options.onDataReceived = (options.onDataReceived ?? []) + [provider]
        }
        
        options.onDataReceived?.forEach {
            $0.onShouldApply = { issuedIdentifier == self.taskIdentifier }
        }
        
        let task = KingfisherManager.shared.retrieveImage(
            with: source,
            options: options,
            downloadTaskUpdated: { mutatingSelf.imageTask = $0 },
            completionHandler: { result in
                CallbackQueue.mainCurrentOrAsync.execute {
                    guard issuedIdentifier == self.taskIdentifier else {
                        let reason: KingfisherError.ImageSettingErrorReason
                        do {
                            let value = try result.get()
                            reason = .notCurrentSourceTask(result: value, error: nil, source: source)
                        } catch {
                            reason = .notCurrentSourceTask(result: nil, error: error, source: source)
                        }
                        let error = KingfisherError.imageSettingError(reason: reason)
                        completionHandler?(.failure(error))
                        return
                    }
                    
                    mutatingSelf.imageTask = nil
                    mutatingSelf.taskIdentifier = nil
                    
                    switch result {
                    case .success(let value):
                        self.base.setImage(value.image)
                        completionHandler?(result)
                        
                    case .failure:
                        if let image = options.onFailureImage {
                            self.base.setImage(image)
                        }
                        completionHandler?(result)
                    }
                }
            }
        )
        
        mutatingSelf.imageTask = task
        return task
    }
    
    /// Sets an image to the image view with a requested resource.
    ///
    /// - Parameters:
    ///   - resource: The `Resource` object contains information about the image.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    ///
    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
    /// or network. Since this method will perform UI changes, you must call it from the main thread.
    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
    ///
    @discardableResult
    public func setImage(
        with resource: Resource?,
        placeholder: KFCrossPlatformImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        return setImage(
            with: resource?.convertToSource(),
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    // MARK: Cancelling Image
    /// Cancel the image download task bounded to the image view if it is running.
    /// Nothing will happen if the downloading has already finished.
    public func cancelDownloadTask() {
        imageTask?.cancel()
    }
}
private var taskIdentifierKey: Void?
private var imageTaskKey: Void?
// MARK: Properties
extension KingfisherWrapper where Base: WKInterfaceImage {
    
    public private(set) var taskIdentifier: Source.Identifier.Value? {
        get {
            let box: Box<Source.Identifier.Value>? = getAssociatedObject(base, &taskIdentifierKey)
            return box?.value
        }
        set {
            let box = newValue.map { Box($0) }
            setRetainedAssociatedObject(base, &taskIdentifierKey, box)
        }
    }
    private var imageTask: DownloadTask? {
        get { return getAssociatedObject(base, &imageTaskKey) }
        set { setRetainedAssociatedObject(base, &imageTaskKey, newValue)}
    }
}
extension KingfisherWrapper where Base: WKInterfaceImage {
    /// Gets the image URL bound to this image view.
    @available(*, deprecated, message: "Use `taskIdentifier` instead to identify a setting task.")
    public private(set) var webURL: URL? {
        get { return nil }
        set { }
    }
}
#endif
//
//  NSTextAttachment+Kingfisher.swift
//  Kingfisher
//
//  Created by Benjamin Briggs on 22/07/2019.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if !os(watchOS)
#if os(macOS)
import AppKit
#else
import UIKit
#endif
extension KingfisherWrapper where Base: NSTextAttachment {
    // MARK: Setting Image
    /// Sets an image to the text attachment with a source.
    ///
    /// - Parameters:
    ///   - source: The `Source` object defines data information from network or a data provider.
    ///   - attributedView: The owner of the attributed string which this `NSTextAttachment` is added.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    ///
    /// Internally, this method will use `KingfisherManager` to get the requested source
    /// Since this method will perform UI changes, you must call it from the main thread.
    ///
    /// The retrieved image will be set to `NSTextAttachment.image` property. Because it is not an image view based
    /// rendering, options related to view, such as `.transition`, are not supported.
    ///
    /// Kingfisher will call `setNeedsDisplay` on the `attributedView` when the image task done. It gives the view a
    /// chance to render the attributed string again for displaying the downloaded image. For example, if you set an
    /// attributed with this `NSTextAttachment` to a `UILabel` object, pass it as the `attributedView` parameter.
    ///
    /// Here is a typical use case:
    ///
    /// ```swift
    /// let attributedText = NSMutableAttributedString(string: "Hello World")
    /// let textAttachment = NSTextAttachment()
    ///
    /// textAttachment.kf.setImage(
    ///     with: URL(string: "https://onevcat.com/assets/images/avatar.jpg")!,
    ///     attributedView: label,
    ///     options: [
    ///        .processor(
    ///            ResizingImageProcessor(referenceSize: .init(width: 30, height: 30))
    ///            |> RoundCornerImageProcessor(cornerRadius: 15))
    ///     ]
    /// )
    /// attributedText.replaceCharacters(in: NSRange(), with: NSAttributedString(attachment: textAttachment))
    /// label.attributedText = attributedText
    /// ```
    ///
    @discardableResult
    public func setImage(
        with source: Source?,
        attributedView: KFCrossPlatformView,
        placeholder: KFCrossPlatformImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        var mutatingSelf = self
        guard let source = source else {
            base.image = placeholder
            mutatingSelf.taskIdentifier = nil
            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
            return nil
        }
        var options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
        if !options.keepCurrentImageWhileLoading {
            base.image = placeholder
        }
        let issuedIdentifier = Source.Identifier.next()
        mutatingSelf.taskIdentifier = issuedIdentifier
        if let block = progressBlock {
            options.onDataReceived = (options.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
        }
        if let provider = ImageProgressiveProvider(options, refresh: { image in
            self.base.image = image
        }) {
            options.onDataReceived = (options.onDataReceived ?? []) + [provider]
        }
        options.onDataReceived?.forEach {
            $0.onShouldApply = { issuedIdentifier == self.taskIdentifier }
        }
        let task = KingfisherManager.shared.retrieveImage(
            with: source,
            options: options,
            completionHandler: { result in
                CallbackQueue.mainCurrentOrAsync.execute {
                    guard issuedIdentifier == self.taskIdentifier else {
                        let reason: KingfisherError.ImageSettingErrorReason
                        do {
                            let value = try result.get()
                            reason = .notCurrentSourceTask(result: value, error: nil, source: source)
                        } catch {
                            reason = .notCurrentSourceTask(result: nil, error: error, source: source)
                        }
                        let error = KingfisherError.imageSettingError(reason: reason)
                        completionHandler?(.failure(error))
                        return
                    }
                    mutatingSelf.imageTask = nil
                    mutatingSelf.taskIdentifier = nil
                    switch result {
                    case .success(let value):
                        self.base.image = value.image
                        #if canImport(UIKit)
                        attributedView.setNeedsDisplay()
                        #else
                        attributedView.setNeedsDisplay(attributedView.bounds)
                        #endif
                    case .failure:
                        if let image = options.onFailureImage {
                            self.base.image = image
                        }
                    }
                    completionHandler?(result)
                }
        }
        )
        mutatingSelf.imageTask = task
        return task
    }
    /// Sets an image to the text attachment with a source.
    ///
    /// - Parameters:
    ///   - resource: The `Resource` object contains information about the resource.
    ///   - attributedView: The owner of the attributed string which this `NSTextAttachment` is added.
    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
    ///                    `expectedContentLength`, this block will not be called.
    ///   - completionHandler: Called when the image retrieved and set finished.
    /// - Returns: A task represents the image downloading.
    ///
    /// - Note:
    ///
    /// Internally, this method will use `KingfisherManager` to get the requested source
    /// Since this method will perform UI changes, you must call it from the main thread.
    ///
    /// The retrieved image will be set to `NSTextAttachment.image` property. Because it is not an image view based
    /// rendering, options related to view, such as `.transition`, are not supported.
    ///
    /// Kingfisher will call `setNeedsDisplay` on the `attributedView` when the image task done. It gives the view a
    /// chance to render the attributed string again for displaying the downloaded image. For example, if you set an
    /// attributed with this `NSTextAttachment` to a `UILabel` object, pass it as the `attributedView` parameter.
    ///
    /// Here is a typical use case:
    ///
    /// ```swift
    /// let attributedText = NSMutableAttributedString(string: "Hello World")
    /// let textAttachment = NSTextAttachment()
    ///
    /// textAttachment.kf.setImage(
    ///     with: URL(string: "https://onevcat.com/assets/images/avatar.jpg")!,
    ///     attributedView: label,
    ///     options: [
    ///        .processor(
    ///            ResizingImageProcessor(referenceSize: .init(width: 30, height: 30))
    ///            |> RoundCornerImageProcessor(cornerRadius: 15))
    ///     ]
    /// )
    /// attributedText.replaceCharacters(in: NSRange(), with: NSAttributedString(attachment: textAttachment))
    /// label.attributedText = attributedText
    /// ```
    ///
    @discardableResult
    public func setImage(
        with resource: Resource?,
        attributedView: KFCrossPlatformView,
        placeholder: KFCrossPlatformImage? = nil,
        options: KingfisherOptionsInfo? = nil,
        progressBlock: DownloadProgressBlock? = nil,
        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
    {
        return setImage(
            with: resource.map { .network($0) },
            attributedView: attributedView,
            placeholder: placeholder,
            options: options,
            progressBlock: progressBlock,
            completionHandler: completionHandler)
    }
    // MARK: Cancelling Image
    /// Cancel the image download task bounded to the text attachment if it is running.
    /// Nothing will happen if the downloading has already finished.
    public func cancelDownloadTask() {
        imageTask?.cancel()
    }
}
private var taskIdentifierKey: Void?
private var imageTaskKey: Void?
// MARK: Properties
extension KingfisherWrapper where Base: NSTextAttachment {
    public private(set) var taskIdentifier: Source.Identifier.Value? {
        get {
            let box: Box<Source.Identifier.Value>? = getAssociatedObject(base, &taskIdentifierKey)
            return box?.value
        }
        set {
            let box = newValue.map { Box($0) }
            setRetainedAssociatedObject(base, &taskIdentifierKey, box)
        }
    }
    private var imageTask: DownloadTask? {
        get { return getAssociatedObject(base, &imageTaskKey) }
        set { setRetainedAssociatedObject(base, &imageTaskKey, newValue)}
    }
}
#endif
//
//  Indicator.swift
//  Kingfisher
//
//  Created by João D. Moreira on 30/08/16.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if !os(watchOS)
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
public typealias IndicatorView = NSView
#else
import UIKit
public typealias IndicatorView = UIView
#endif
/// Represents the activity indicator type which should be added to
/// an image view when an image is being downloaded.
///
/// - none: No indicator.
/// - activity: Uses the system activity indicator.
/// - image: Uses an image as indicator. GIF is supported.
/// - custom: Uses a custom indicator. The type of associated value should conform to the `Indicator` protocol.
public enum IndicatorType {
    /// No indicator.
    case none
    /// Uses the system activity indicator.
    case activity
    /// Uses an image as indicator. GIF is supported.
    case image(imageData: Data)
    /// Uses a custom indicator. The type of associated value should conform to the `Indicator` protocol.
    case custom(indicator: Indicator)
}
/// An indicator type which can be used to show the download task is in progress.
public protocol Indicator {
    
    /// Called when the indicator should start animating.
    func startAnimatingView()
    
    /// Called when the indicator should stop animating.
    func stopAnimatingView()
    /// Center offset of the indicator. Kingfisher will use this value to determine the position of
    /// indicator in the super view.
    var centerOffset: CGPoint { get }
    
    /// The indicator view which would be added to the super view.
    var view: IndicatorView { get }
    /// The size strategy used when adding the indicator to image view.
    /// - Parameter imageView: The super view of indicator.
    func sizeStrategy(in imageView: KFCrossPlatformImageView) -> IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
    case intrinsicSize
    case full
    case size(CGSize)
}
extension Indicator {
    
    /// Default implementation of `centerOffset` of `Indicator`. The default value is `.zero`, means that there is
    /// no offset for the indicator view.
    public var centerOffset: CGPoint { return .zero }
    /// Default implementation of `centerOffset` of `Indicator`. The default value is `.full`, means that the indicator
    /// will pin to the same height and width as the image view.
    public func sizeStrategy(in imageView: KFCrossPlatformImageView) -> IndicatorSizeStrategy {
        return .full
    }
}
// Displays a NSProgressIndicator / UIActivityIndicatorView
final class ActivityIndicator: Indicator {
    #if os(macOS)
    private let activityIndicatorView: NSProgressIndicator
    #else
    private let activityIndicatorView: UIActivityIndicatorView
    #endif
    private var animatingCount = 0
    var view: IndicatorView {
        return activityIndicatorView
    }
    func startAnimatingView() {
        if animatingCount == 0 {
            #if os(macOS)
            activityIndicatorView.startAnimation(nil)
            #else
            activityIndicatorView.startAnimating()
            #endif
            activityIndicatorView.isHidden = false
        }
        animatingCount += 1
    }
    func stopAnimatingView() {
        animatingCount = max(animatingCount - 1, 0)
        if animatingCount == 0 {
            #if os(macOS)
                activityIndicatorView.stopAnimation(nil)
            #else
                activityIndicatorView.stopAnimating()
            #endif
            activityIndicatorView.isHidden = true
        }
    }
    func sizeStrategy(in imageView: KFCrossPlatformImageView) -> IndicatorSizeStrategy {
        return .intrinsicSize
    }
    init() {
        #if os(macOS)
            activityIndicatorView = NSProgressIndicator(frame: CGRect(x: 0, y: 0, width: 16, height: 16))
            activityIndicatorView.controlSize = .small
            activityIndicatorView.style = .spinning
        #else
            let indicatorStyle: UIActivityIndicatorView.Style
            #if os(tvOS)
            if #available(tvOS 13.0, *) {
                indicatorStyle = UIActivityIndicatorView.Style.large
            } else {
                indicatorStyle = UIActivityIndicatorView.Style.white
            }
            #else
            if #available(iOS 13.0, * ) {
                indicatorStyle = UIActivityIndicatorView.Style.medium
            } else {
                indicatorStyle = UIActivityIndicatorView.Style.gray
            }
            #endif
            #if swift(>=4.2)
            activityIndicatorView = UIActivityIndicatorView(style: indicatorStyle)
            #else
            activityIndicatorView = UIActivityIndicatorView(activityIndicatorStyle: indicatorStyle)
            #endif
        #endif
    }
}
#if canImport(UIKit)
extension UIActivityIndicatorView.Style {
    #if compiler(>=5.1)
    #else
    static let large = UIActivityIndicatorView.Style.white
    #if !os(tvOS)
    static let medium = UIActivityIndicatorView.Style.gray
    #endif
    #endif
}
#endif
// MARK: - ImageIndicator
// Displays an ImageView. Supports gif
final class ImageIndicator: Indicator {
    private let animatedImageIndicatorView: KFCrossPlatformImageView
    var view: IndicatorView {
        return animatedImageIndicatorView
    }
    init?(
        imageData data: Data,
        processor: ImageProcessor = DefaultImageProcessor.default,
        options: KingfisherParsedOptionsInfo? = nil)
    {
        var options = options ?? KingfisherParsedOptionsInfo(nil)
        // Use normal image view to show animations, so we need to preload all animation data.
        if !options.preloadAllAnimationData {
            options.preloadAllAnimationData = true
        }
        
        guard let image = processor.process(item: .data(data), options: options) else {
            return nil
        }
        animatedImageIndicatorView = KFCrossPlatformImageView()
        animatedImageIndicatorView.image = image
        
        #if os(macOS)
            // Need for gif to animate on macOS
            animatedImageIndicatorView.imageScaling = .scaleNone
            animatedImageIndicatorView.canDrawSubviewsIntoLayer = true
        #else
            animatedImageIndicatorView.contentMode = .center
        #endif
    }
    func startAnimatingView() {
        #if os(macOS)
            animatedImageIndicatorView.animates = true
        #else
            animatedImageIndicatorView.startAnimating()
        #endif
        animatedImageIndicatorView.isHidden = false
    }
    func stopAnimatingView() {
        #if os(macOS)
            animatedImageIndicatorView.animates = false
        #else
            animatedImageIndicatorView.stopAnimating()
        #endif
        animatedImageIndicatorView.isHidden = true
    }
}
#endif
//
//  AnimatableImageView.swift
//  Kingfisher
//
//  Created by bl4ckra1sond3tre on 4/22/16.
//
//  The AnimatableImageView, AnimatedFrame and Animator is a modified version of 
//  some classes from kaishin's Gifu project (https://github.com/kaishin/Gifu)
//
//  The MIT License (MIT)
//
//  Copyright (c) 2019 Reda Lemeden.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  the Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//  The name and characters used in the demo of this software are property of their
//  respective owners.
#if !os(watchOS)
#if canImport(UIKit)
import UIKit
import ImageIO
/// Protocol of `AnimatedImageView`.
public protocol AnimatedImageViewDelegate: AnyObject {
    /// Called after the animatedImageView has finished each animation loop.
    ///
    /// - Parameters:
    ///   - imageView: The `AnimatedImageView` that is being animated.
    ///   - count: The looped count.
    func animatedImageView(_ imageView: AnimatedImageView, didPlayAnimationLoops count: UInt)
    /// Called after the `AnimatedImageView` has reached the max repeat count.
    ///
    /// - Parameter imageView: The `AnimatedImageView` that is being animated.
    func animatedImageViewDidFinishAnimating(_ imageView: AnimatedImageView)
}
extension AnimatedImageViewDelegate {
    public func animatedImageView(_ imageView: AnimatedImageView, didPlayAnimationLoops count: UInt) {}
    public func animatedImageViewDidFinishAnimating(_ imageView: AnimatedImageView) {}
}
#if swift(>=4.2)
let KFRunLoopModeCommon = RunLoop.Mode.common
#else
let KFRunLoopModeCommon = RunLoopMode.commonModes
#endif
/// Represents a subclass of `UIImageView` for displaying animated image.
/// Different from showing animated image in a normal `UIImageView` (which load all frames at one time),
/// `AnimatedImageView` only tries to load several frames (defined by `framePreloadCount`) to reduce memory usage.
/// It provides a tradeoff between memory usage and CPU time. If you have a memory issue when using a normal image
/// view to load GIF data, you could give this class a try.
///
/// Kingfisher supports setting GIF animated data to either `UIImageView` and `AnimatedImageView` out of box. So
/// it would be fairly easy to switch between them.
open class AnimatedImageView: UIImageView {
    
    /// Proxy object for preventing a reference cycle between the `CADDisplayLink` and `AnimatedImageView`.
    class TargetProxy {
        private weak var target: AnimatedImageView?
        
        init(target: AnimatedImageView) {
            self.target = target
        }
        
        @objc func onScreenUpdate() {
            target?.updateFrameIfNeeded()
        }
    }
    /// Enumeration that specifies repeat count of GIF
    public enum RepeatCount: Equatable {
        case once
        case finite(count: UInt)
        case infinite
        public static func ==(lhs: RepeatCount, rhs: RepeatCount) -> Bool {
            switch (lhs, rhs) {
            case let (.finite(l), .finite(r)):
                return l == r
            case (.once, .once),
                 (.infinite, .infinite):
                return true
            case (.once, .finite(let count)),
                 (.finite(let count), .once):
                return count == 1
            case (.once, _),
                 (.infinite, _),
                 (.finite, _):
                return false
            }
        }
    }
    
    // MARK: - Public property
    /// Whether automatically play the animation when the view become visible. Default is `true`.
    public var autoPlayAnimatedImage = true
    
    /// The count of the frames should be preloaded before shown.
    public var framePreloadCount = 10
    
    /// Specifies whether the GIF frames should be pre-scaled to the image view's size or not.
    /// If the downloaded image is larger than the image view's size, it will help to reduce some memory use.
    /// Default is `true`.
    public var needsPrescaling = true
    /// Decode the GIF frames in background thread before using. It will decode frames data and do a off-screen
    /// rendering to extract pixel information in background. This can reduce the main thread CPU usage.
    public var backgroundDecode = true
    /// The animation timer's run loop mode. Default is `RunLoop.Mode.common`.
    /// Set this property to `RunLoop.Mode.default` will make the animation pause during UIScrollView scrolling.
    public var runLoopMode = KFRunLoopModeCommon {
        willSet {
            guard runLoopMode != newValue else { return }
            stopAnimating()
            displayLink.remove(from: .main, forMode: runLoopMode)
            displayLink.add(to: .main, forMode: newValue)
            startAnimating()
        }
    }
    
    /// The repeat count. The animated image will keep animate until it the loop count reaches this value.
    /// Setting this value to another one will reset current animation.
    ///
    /// Default is `.infinite`, which means the animation will last forever.
    public var repeatCount = RepeatCount.infinite {
        didSet {
            if oldValue != repeatCount {
                reset()
                setNeedsDisplay()
                layer.setNeedsDisplay()
            }
        }
    }
    /// Delegate of this `AnimatedImageView` object. See `AnimatedImageViewDelegate` protocol for more.
    public weak var delegate: AnimatedImageViewDelegate?
    
    // MARK: - Private property
    /// `Animator` instance that holds the frames of a specific image in memory.
    private var animator: Animator?
    // Dispatch queue used for preloading images.
    private lazy var preloadQueue: DispatchQueue = {
        return DispatchQueue(label: "com.onevcat.Kingfisher.Animator.preloadQueue")
    }()
    
    // A flag to avoid invalidating the displayLink on deinit if it was never created, because displayLink is so lazy.
    private var isDisplayLinkInitialized: Bool = false
    
    // A display link that keeps calling the `updateFrame` method on every screen refresh.
    private lazy var displayLink: CADisplayLink = {
        isDisplayLinkInitialized = true
        let displayLink = CADisplayLink(
            target: TargetProxy(target: self), selector: #selector(TargetProxy.onScreenUpdate))
        displayLink.add(to: .main, forMode: runLoopMode)
        displayLink.isPaused = true
        return displayLink
    }()
    
    // MARK: - Override
    override open var image: KFCrossPlatformImage? {
        didSet {
            if image != oldValue {
                reset()
            }
            setNeedsDisplay()
            layer.setNeedsDisplay()
        }
    }
    
    deinit {
        if isDisplayLinkInitialized {
            displayLink.invalidate()
        }
    }
    
    override open var isAnimating: Bool {
        if isDisplayLinkInitialized {
            return !displayLink.isPaused
        } else {
            return super.isAnimating
        }
    }
    
    /// Starts the animation.
    override open func startAnimating() {
        guard !isAnimating else { return }
        guard let animator = animator else { return }
        guard !animator.isReachMaxRepeatCount else { return }
        displayLink.isPaused = false
    }
    
    /// Stops the animation.
    override open func stopAnimating() {
        super.stopAnimating()
        if isDisplayLinkInitialized {
            displayLink.isPaused = true
        }
    }
    
    override open func display(_ layer: CALayer) {
        if let currentFrame = animator?.currentFrameImage {
            layer.contents = currentFrame.cgImage
        } else {
            layer.contents = image?.cgImage
        }
    }
    
    override open func didMoveToWindow() {
        super.didMoveToWindow()
        didMove()
    }
    
    override open func didMoveToSuperview() {
        super.didMoveToSuperview()
        didMove()
    }
    // This is for back compatibility that using regular `UIImageView` to show animated image.
    override func shouldPreloadAllAnimation() -> Bool {
        return false
    }
    // Reset the animator.
    private func reset() {
        animator = nil
        if let imageSource = image?.kf.imageSource {
            let targetSize = bounds.scaled(UIScreen.main.scale).size
            let animator = Animator(
                imageSource: imageSource,
                contentMode: contentMode,
                size: targetSize,
                framePreloadCount: framePreloadCount,
                repeatCount: repeatCount,
                preloadQueue: preloadQueue)
            animator.delegate = self
            animator.needsPrescaling = needsPrescaling
            animator.backgroundDecode = backgroundDecode
            animator.prepareFramesAsynchronously()
            self.animator = animator
        }
        didMove()
    }
    
    private func didMove() {
        if autoPlayAnimatedImage && animator != nil {
            if let _ = superview, let _ = window {
                startAnimating()
            } else {
                stopAnimating()
            }
        }
    }
    
    /// Update the current frame with the displayLink duration.
    private func updateFrameIfNeeded() {
        guard let animator = animator else {
            return
        }
        guard !animator.isFinished else {
            stopAnimating()
            delegate?.animatedImageViewDidFinishAnimating(self)
            return
        }
        let duration: CFTimeInterval
        // CA based display link is opt-out from ProMotion by default.
        // So the duration and its FPS might not match. 
        // See [#718](https://github.com/onevcat/Kingfisher/issues/718)
        // By setting CADisableMinimumFrameDuration to YES in Info.plist may
        // cause the preferredFramesPerSecond being 0
        let preferredFramesPerSecond = displayLink.preferredFramesPerSecond
        if preferredFramesPerSecond == 0 {
            duration = displayLink.duration
        } else {
            // Some devices (like iPad Pro 10.5) will have a different FPS.
            duration = 1.0 / TimeInterval(preferredFramesPerSecond)
        }
        animator.shouldChangeFrame(with: duration) { [weak self] hasNewFrame in
            if hasNewFrame {
                self?.layer.setNeedsDisplay()
            }
        }
    }
}
protocol AnimatorDelegate: AnyObject {
    func animator(_ animator: AnimatedImageView.Animator, didPlayAnimationLoops count: UInt)
}
extension AnimatedImageView: AnimatorDelegate {
    func animator(_ animator: Animator, didPlayAnimationLoops count: UInt) {
        delegate?.animatedImageView(self, didPlayAnimationLoops: count)
    }
}
extension AnimatedImageView {
    // Represents a single frame in a GIF.
    struct AnimatedFrame {
        // The image to display for this frame. Its value is nil when the frame is removed from the buffer.
        let image: UIImage?
        // The duration that this frame should remain active.
        let duration: TimeInterval
        // A placeholder frame with no image assigned.
        // Used to replace frames that are no longer needed in the animation.
        var placeholderFrame: AnimatedFrame {
            return AnimatedFrame(image: nil, duration: duration)
        }
        // Whether this frame instance contains an image or not.
        var isPlaceholder: Bool {
            return image == nil
        }
        // Returns a new instance from an optional image.
        //
        // - parameter image: An optional `UIImage` instance to be assigned to the new frame.
        // - returns: An `AnimatedFrame` instance.
        func makeAnimatedFrame(image: UIImage?) -> AnimatedFrame {
            return AnimatedFrame(image: image, duration: duration)
        }
    }
}
extension AnimatedImageView {
    // MARK: - Animator
    class Animator {
        private let size: CGSize
        private let maxFrameCount: Int
        private let imageSource: CGImageSource
        private let maxRepeatCount: RepeatCount
        private let maxTimeStep: TimeInterval = 1.0
        private let animatedFrames = SafeArray<AnimatedFrame>()
        private var frameCount = 0
        private var timeSinceLastFrameChange: TimeInterval = 0.0
        private var currentRepeatCount: UInt = 0
        var isFinished: Bool = false
        var needsPrescaling = true
        var backgroundDecode = true
        weak var delegate: AnimatorDelegate?
        // Total duration of one animation loop
        var loopDuration: TimeInterval = 0
        // Current active frame image
        var currentFrameImage: UIImage? {
            return frame(at: currentFrameIndex)
        }
        // Current active frame duration
        var currentFrameDuration: TimeInterval {
            return duration(at: currentFrameIndex)
        }
        // The index of the current GIF frame.
        var currentFrameIndex = 0 {
            didSet {
                previousFrameIndex = oldValue
            }
        }
        var previousFrameIndex = 0 {
            didSet {
                preloadQueue.async {
                    self.updatePreloadedFrames()
                }
            }
        }
        var isReachMaxRepeatCount: Bool {
            switch maxRepeatCount {
            case .once:
                return currentRepeatCount >= 1
            case .finite(let maxCount):
                return currentRepeatCount >= maxCount
            case .infinite:
                return false
            }
        }
        var isLastFrame: Bool {
            return currentFrameIndex == frameCount - 1
        }
        var preloadingIsNeeded: Bool {
            return maxFrameCount < frameCount - 1
        }
        var contentMode = UIView.ContentMode.scaleToFill
        private lazy var preloadQueue: DispatchQueue = {
            return DispatchQueue(label: "com.onevcat.Kingfisher.Animator.preloadQueue")
        }()
        /// Creates an animator with image source reference.
        ///
        /// - Parameters:
        ///   - source: The reference of animated image.
        ///   - mode: Content mode of the `AnimatedImageView`.
        ///   - size: Size of the `AnimatedImageView`.
        ///   - count: Count of frames needed to be preloaded.
        ///   - repeatCount: The repeat count should this animator uses.
        init(imageSource source: CGImageSource,
             contentMode mode: UIView.ContentMode,
             size: CGSize,
             framePreloadCount count: Int,
             repeatCount: RepeatCount,
             preloadQueue: DispatchQueue) {
            self.imageSource = source
            self.contentMode = mode
            self.size = size
            self.maxFrameCount = count
            self.maxRepeatCount = repeatCount
            self.preloadQueue = preloadQueue
        }
        func frame(at index: Int) -> KFCrossPlatformImage? {
            return animatedFrames[index]?.image
        }
        func duration(at index: Int) -> TimeInterval {
            return animatedFrames[index]?.duration  ?? .infinity
        }
        func prepareFramesAsynchronously() {
            frameCount = Int(CGImageSourceGetCount(imageSource))
            animatedFrames.reserveCapacity(frameCount)
            preloadQueue.async { [weak self] in
                self?.setupAnimatedFrames()
            }
        }
        func shouldChangeFrame(with duration: CFTimeInterval, handler: (Bool) -> Void) {
            incrementTimeSinceLastFrameChange(with: duration)
            if currentFrameDuration > timeSinceLastFrameChange {
                handler(false)
            } else {
                resetTimeSinceLastFrameChange()
                incrementCurrentFrameIndex()
                handler(true)
            }
        }
        private func setupAnimatedFrames() {
            resetAnimatedFrames()
            var duration: TimeInterval = 0
            (0..<frameCount).forEach { index in
                let frameDuration = GIFAnimatedImage.getFrameDuration(from: imageSource, at: index)
                duration += min(frameDuration, maxTimeStep)
                animatedFrames.append(AnimatedFrame(image: nil, duration: frameDuration))
                if index > maxFrameCount { return }
                animatedFrames[index] = animatedFrames[index]?.makeAnimatedFrame(image: loadFrame(at: index))
            }
            self.loopDuration = duration
        }
        private func resetAnimatedFrames() {
            animatedFrames.removeAll()
        }
        private func loadFrame(at index: Int) -> UIImage? {
            let options: [CFString: Any] = [
                kCGImageSourceCreateThumbnailFromImageIfAbsent: true,
                kCGImageSourceCreateThumbnailWithTransform: true,
                kCGImageSourceShouldCacheImmediately: true,
                kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height)
            ]
            let resize = needsPrescaling && size != .zero
            guard let cgImage = CGImageSourceCreateImageAtIndex(imageSource,
                                                                index,
                                                                resize ? options as CFDictionary : nil) else {
                return nil
            }
            let image = KFCrossPlatformImage(cgImage: cgImage)
            return backgroundDecode ? image.kf.decoded : image
        }
        
        private func updatePreloadedFrames() {
            guard preloadingIsNeeded else {
                return
            }
            animatedFrames[previousFrameIndex] = animatedFrames[previousFrameIndex]?.placeholderFrame
            preloadIndexes(start: currentFrameIndex).forEach { index in
                guard let currentAnimatedFrame = animatedFrames[index] else { return }
                if !currentAnimatedFrame.isPlaceholder { return }
                animatedFrames[index] = currentAnimatedFrame.makeAnimatedFrame(image: loadFrame(at: index))
            }
        }
        private func incrementCurrentFrameIndex() {
            currentFrameIndex = increment(frameIndex: currentFrameIndex)
            if isLastFrame {
                currentRepeatCount += 1
                if isReachMaxRepeatCount {
                    isFinished = true
                }
                delegate?.animator(self, didPlayAnimationLoops: currentRepeatCount)
            }
        }
        private func incrementTimeSinceLastFrameChange(with duration: TimeInterval) {
            timeSinceLastFrameChange += min(maxTimeStep, duration)
        }
        private func resetTimeSinceLastFrameChange() {
            timeSinceLastFrameChange -= currentFrameDuration
        }
        private func increment(frameIndex: Int, by value: Int = 1) -> Int {
            return (frameIndex + value) % frameCount
        }
        private func preloadIndexes(start index: Int) -> [Int] {
            let nextIndex = increment(frameIndex: index)
            let lastIndex = increment(frameIndex: index, by: maxFrameCount)
            if lastIndex >= nextIndex {
                return [Int](nextIndex...lastIndex)
            } else {
                return [Int](nextIndex..<frameCount) + [Int](0...lastIndex)
            }
        }
    }
}
class SafeArray<Element> {
    private var array: Array<Element> = []
    private let lock = NSLock()
    
    subscript(index: Int) -> Element? {
        get {
            lock.lock()
            defer { lock.unlock() }
            return array.indices ~= index ? array[index] : nil
        }
        
        set {
            lock.lock()
            defer { lock.unlock() }
            if let newValue = newValue, array.indices ~= index {
                array[index] = newValue
            }
        }
    }
    
    var count : Int {
        lock.lock()
        defer { lock.unlock() }
        return array.count
    }
    
    func reserveCapacity(_ count: Int) {
        lock.lock()
        defer { lock.unlock() }
        array.reserveCapacity(count)
    }
    
    func append(_ element: Element) {
        lock.lock()
        defer { lock.unlock() }
        array += [element]
    }
    
    func removeAll() {
        lock.lock()
        defer { lock.unlock() }
        array = []
    }
}
#endif
#endif
//
//  ImageBinder.swift
//  Kingfisher
//
//  Created by onevcat on 2019/06/27.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if canImport(SwiftUI) && canImport(Combine)
import Combine
import SwiftUI
#if !KingfisherCocoaPods
import Kingfisher
#endif
@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
extension KFImage {
    /// Represents a binder for `KFImage`. It takes responsibility as an `ObjectBinding` and performs
    /// image downloading and progress reporting based on `KingfisherManager`.
    public class ImageBinder: ObservableObject {
        let source: Source?
        let options: KingfisherOptionsInfo?
        var downloadTask: DownloadTask?
        var loadingOrSuccessed: Bool = false
        let onFailureDelegate = Delegate<KingfisherError, Void>()
        let onSuccessDelegate = Delegate<RetrieveImageResult, Void>()
        let onProgressDelegate = Delegate<(Int64, Int64), Void>()
        var isLoaded: Binding<Bool>
        @Published var image: KFCrossPlatformImage?
        init(source: Source?, options: KingfisherOptionsInfo?, isLoaded: Binding<Bool>) {
            self.source = source
            self.options = options
            self.isLoaded = isLoaded
            self.image = nil
        }
        func start() {
            guard !loadingOrSuccessed else { return }
            loadingOrSuccessed = true
            guard let source = source else {
                DispatchQueue.main.async {
                    self.onFailureDelegate.call(KingfisherError.imageSettingError(reason: .emptySource))
                }
                return
            }
            downloadTask = KingfisherManager.shared
                .retrieveImage(
                    with: source,
                    options: options,
                    progressBlock: { size, total in
                        self.onProgressDelegate.call((size, total))
                    },
                    completionHandler: { [weak self] result in
                        guard let self = self else { return }
                        self.downloadTask = nil
                        switch result {
                        case .success(let value):
                            // The normalized version of image is used to solve #1395
                            // It should be not necessary if SwiftUI.Image can handle resizing correctly when created
                            // by `Image.init(uiImage:)`. (The orientation information should be already contained in
                            // a `UIImage`)
                            // https://github.com/onevcat/Kingfisher/issues/1395
                            let image = value.image.kf.normalized
                            DispatchQueue.main.async {
                                self.image = image
                                self.isLoaded.wrappedValue = true
                                self.onSuccessDelegate.call(value)
                            }
                        case .failure(let error):
                            self.loadingOrSuccessed = false
                            DispatchQueue.main.async {
                                self.onFailureDelegate.call(error)
                            }
                        }
                })
        }
        /// Cancels the download task if it is in progress.
        public func cancel() {
            downloadTask?.cancel()
        }
        func setOnFailure(perform action: ((KingfisherError) -> Void)?) {
            onFailureDelegate.delegate(on: self) { (self, error) in
                action?(error)
            }
        }
        func setOnSuccess(perform action: ((RetrieveImageResult) -> Void)?) {
            onSuccessDelegate.delegate(on: self) { (self, result) in
                action?(result)
            }
        }
        func setOnProgress(perform action: ((Int64, Int64) -> Void)?) {
            onProgressDelegate.delegate(on: self) { (self, result) in
                action?(result.0, result.1)
            }
        }
    }
}
#endif
//
//  KFImage.swift
//  Kingfisher
//
//  Created by onevcat on 2019/06/26.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
#if canImport(SwiftUI) && canImport(Combine)
import Combine
import SwiftUI
#if !KingfisherCocoaPods
import Kingfisher
#endif
@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
extension SwiftUI.Image {
    // Creates an SwiftUI.Image with either UIImage or NSImage.
    init(crossPlatformImage: KFCrossPlatformImage) {
        #if canImport(UIKit)
        self.init(uiImage: crossPlatformImage)
        #elseif canImport(AppKit)
        self.init(nsImage: crossPlatformImage)
        #endif
    }
}
/// A Kingfisher compatible SwiftUI `View` to load an image from a `Source`.
/// Declaring a `KFImage` in a `View`'s body to trigger loading from the given `Source`.
@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
public struct KFImage: SwiftUI.View {
    /// An image binder that manages loading and cancelling image related task.
    @ObservedObject public private(set) var binder: ImageBinder
    // Acts as a placeholder when loading an image.
    var placeholder: AnyView?
    // Whether the download task should be cancelled when the view disappears.
    var cancelOnDisappear: Bool = false
    // Configurations should be performed on the image.
    var configurations: [(SwiftUI.Image) -> SwiftUI.Image]
    /// Creates a Kingfisher compatible image view to load image from the given `Source`.
    /// - Parameter source: The image `Source` defining where to load the target image.
    /// - Parameter options: The options should be applied when loading the image.
    ///                      Some UIKit related options (such as `ImageTransition.flip`) are not supported.
    /// - Parameter isLoaded: Whether the image is loaded or not. This provides a way to inspect the internal loading
    ///                       state. `true` if the image is loaded successfully. Otherwise, `false`. Do not set the
    ///                       wrapped value from outside.
    public init(source: Source?, options: KingfisherOptionsInfo? = nil, isLoaded: Binding<Bool> = .constant(false)) {
        binder = ImageBinder(source: source, options: options, isLoaded: isLoaded)
        configurations = []
        binder.start()
    }
    /// Creates a Kingfisher compatible image view to load image from the given `Source`.
    /// - Parameter url: The image URL from where to load the target image.
    /// - Parameter options: The options should be applied when loading the image.
    ///                      Some UIKit related options (such as `ImageTransition.flip`) are not supported.
    /// - Parameter isLoaded: Whether the image is loaded or not. This provides a way to inspect the internal loading
    ///                       state. `true` if the image is loaded successfully. Otherwise, `false`. Do not set the
    ///                       wrapped value from outside.
    public init(_ url: URL?, options: KingfisherOptionsInfo? = nil, isLoaded: Binding<Bool> = .constant(false)) {
        self.init(source: url?.convertToSource(), options: options, isLoaded: isLoaded)
    }
    /// Declares the content and behavior of this view.
    public var body: some SwiftUI.View {
        Group {
            if binder.image != nil {
                configurations
                    .reduce(SwiftUI.Image(crossPlatformImage: binder.image!)) {
                        current, config in config(current)
                    }
            } else {
                Group {
                    if placeholder != nil {
                        placeholder
                    } else {
                        SwiftUI.Image(crossPlatformImage: .init())
                    }
                }
                .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)
                .onAppear { [weak binder = self.binder] in
                    guard let binder = binder else {
                        return
                    }
                    if !binder.loadingOrSuccessed {
                        binder.start()
                    }
                }
                .onDisappear { [weak binder = self.binder] in
                    guard let binder = binder else {
                        return
                    }
                    if self.cancelOnDisappear {
                        binder.cancel()
                    }
                }
            }
        }
    }
}
@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
extension KFImage {
    /// Configures current image with a `block`. This block will be lazily applied when creating the final `Image`.
    /// - Parameter block: The block applies to loaded image.
    /// - Returns: A `KFImage` view that configures internal `Image` with `block`.
    public func configure(_ block: @escaping (SwiftUI.Image) -> SwiftUI.Image) -> KFImage {
        var result = self
        result.configurations.append(block)
        return result
    }
    public func resizable(
        capInsets: EdgeInsets = EdgeInsets(),
        resizingMode: SwiftUI.Image.ResizingMode = .stretch) -> KFImage
    {
        configure { $0.resizable(capInsets: capInsets, resizingMode: resizingMode) }
    }
    public func renderingMode(_ renderingMode: SwiftUI.Image.TemplateRenderingMode?) -> KFImage {
        configure { $0.renderingMode(renderingMode) }
    }
    public func interpolation(_ interpolation: SwiftUI.Image.Interpolation) -> KFImage {
        configure { $0.interpolation(interpolation) }
    }
    public func antialiased(_ isAntialiased: Bool) -> KFImage {
        configure { $0.antialiased(isAntialiased) }
    }
    /// Sets a placeholder `View` which shows when loading the image.
    /// - Parameter content: A view that describes the placeholder.
    /// - Returns: A `KFImage` view that contains `content` as its placeholder.
    public func placeholder<Content: SwiftUI.View>(@ViewBuilder _ content: () -> Content) -> KFImage {
        let v = content()
        var result = self
        result.placeholder = AnyView(v)
        return result
    }
    /// Sets cancelling the download task bound to `self` when the view disappearing.
    /// - Parameter flag: Whether cancel the task or not.
    /// - Returns: A `KFImage` view that cancels downloading task when disappears.
    public func cancelOnDisappear(_ flag: Bool) -> KFImage {
        var result = self
        result.cancelOnDisappear = flag
        return result
    }
}
@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
extension KFImage {
    /// Sets the action to perform when the image setting fails.
    /// - Parameter action: The action to perform. If `action` is `nil`, the
    ///   call has no effect.
    /// - Returns: A `KFImage` view that triggers `action` when setting image fails.
    public func onFailure(perform action: ((KingfisherError) -> Void)?) -> KFImage {
        binder.setOnFailure(perform: action)
        return self
    }
    /// Sets the action to perform when the image setting successes.
    /// - Parameter action: The action to perform. If `action` is `nil`, the
    ///   call has no effect.
    /// - Returns: A `KFImage` view that triggers `action` when setting image successes.
    public func onSuccess(perform action: ((RetrieveImageResult) -> Void)?) -> KFImage {
        binder.setOnSuccess(perform: action)
        return self
    }
    /// Sets the action to perform when the image downloading progress receiving new data.
    /// - Parameter action: The action to perform. If `action` is `nil`, the
    ///   call has no effect.
    /// - Returns: A `KFImage` view that triggers `action` when new data arrives when downloading.
    public func onProgress(perform action: ((Int64, Int64) -> Void)?) -> KFImage {
        binder.setOnProgress(perform: action)
        return self
    }
}
#if DEBUG
@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
struct KFImage_Previews : PreviewProvider {
    static var previews: some SwiftUI.View {
        Group {
            KFImage(URL(string: "https://raw.githubusercontent.com/onevcat/Kingfisher/master/images/logo.png")!)
                .onSuccess { r in
                    print(r)
                }
                .resizable()
                .aspectRatio(contentMode: .fit)
                .padding()
        }
    }
}
#endif
#endif
//
//  Runtime.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/10/12.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
func getAssociatedObject<T>(_ object: Any, _ key: UnsafeRawPointer) -> T? {
    return objc_getAssociatedObject(object, key) as? T
}
func setRetainedAssociatedObject<T>(_ object: Any, _ key: UnsafeRawPointer, _ value: T) {
    objc_setAssociatedObject(object, key, value, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
}
//
//  CallbackQueue.swift
//  Kingfisher
//
//  Created by onevcat on 2018/10/15.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// Represents callback queue behaviors when an calling of closure be dispatched.
///
/// - asyncMain: Dispatch the calling to `DispatchQueue.main` with an `async` behavior.
/// - currentMainOrAsync: Dispatch the calling to `DispatchQueue.main` with an `async` behavior if current queue is not
///                       `.main`. Otherwise, call the closure immediately in current main queue.
/// - untouch: Do not change the calling queue for closure.
/// - dispatch: Dispatches to a specified `DispatchQueue`.
public enum CallbackQueue {
    /// Dispatch the calling to `DispatchQueue.main` with an `async` behavior.
    case mainAsync
    /// Dispatch the calling to `DispatchQueue.main` with an `async` behavior if current queue is not
    /// `.main`. Otherwise, call the closure immediately in current main queue.
    case mainCurrentOrAsync
    /// Do not change the calling queue for closure.
    case untouch
    /// Dispatches to a specified `DispatchQueue`.
    case dispatch(DispatchQueue)
    
    public func execute(_ block: @escaping () -> Void) {
        switch self {
        case .mainAsync:
            DispatchQueue.main.async { block() }
        case .mainCurrentOrAsync:
            DispatchQueue.main.safeAsync { block() }
        case .untouch:
            block()
        case .dispatch(let queue):
            queue.async { block() }
        }
    }
    var queue: DispatchQueue {
        switch self {
        case .mainAsync: return .main
        case .mainCurrentOrAsync: return .main
        case .untouch: return OperationQueue.current?.underlyingQueue ?? .main
        case .dispatch(let queue): return queue
        }
    }
}
extension DispatchQueue {
    // This method will dispatch the `block` to self.
    // If `self` is the main queue, and current thread is main thread, the block
    // will be invoked immediately instead of being dispatched.
    func safeAsync(_ block: @escaping ()->()) {
        if self === DispatchQueue.main && Thread.isMainThread {
            block()
        } else {
            async { block() }
        }
    }
}
//
//  Delegate.swift
//  Kingfisher
//
//  Created by onevcat on 2018/10/10.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
/// A delegate helper type to "shadow" weak `self`, to prevent creating an unexpected retain cycle.
class Delegate<Input, Output> {
    init() {}
    
    private var block: ((Input) -> Output?)?
    
    func delegate<T: AnyObject>(on target: T, block: ((T, Input) -> Output)?) {
        // The `target` is weak inside block, so you do not need to worry about it in the caller side.
        self.block = { [weak target] input in
            guard let target = target else { return nil }
            return block?(target, input)
        }
    }
    
    func call(_ input: Input) -> Output? {
        return block?(input)
    }
}
extension Delegate where Input == Void {
    // To make syntax better for `Void` input.
    func call() -> Output? {
        return call(())
    }
}
//
//  ExtensionHelpers.swift
//  Kingfisher
//
//  Created by onevcat on 2018/09/28.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
extension CGFloat {
    var isEven: Bool {
        return truncatingRemainder(dividingBy: 2.0) == 0
    }
}
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
extension NSBezierPath {
    convenience init(roundedRect rect: NSRect, topLeftRadius: CGFloat, topRightRadius: CGFloat,
                     bottomLeftRadius: CGFloat, bottomRightRadius: CGFloat)
    {
        self.init()
        
        let maxCorner = min(rect.width, rect.height) / 2
        
        let radiusTopLeft = min(maxCorner, max(0, topLeftRadius))
        let radiusTopRight = min(maxCorner, max(0, topRightRadius))
        let radiusBottomLeft = min(maxCorner, max(0, bottomLeftRadius))
        let radiusBottomRight = min(maxCorner, max(0, bottomRightRadius))
        
        guard !rect.isEmpty else {
            return
        }
        
        let topLeft = NSPoint(x: rect.minX, y: rect.maxY)
        let topRight = NSPoint(x: rect.maxX, y: rect.maxY)
        let bottomRight = NSPoint(x: rect.maxX, y: rect.minY)
        
        move(to: NSPoint(x: rect.midX, y: rect.maxY))
        appendArc(from: topLeft, to: rect.origin, radius: radiusTopLeft)
        appendArc(from: rect.origin, to: bottomRight, radius: radiusBottomLeft)
        appendArc(from: bottomRight, to: topRight, radius: radiusBottomRight)
        appendArc(from: topRight, to: topLeft, radius: radiusTopRight)
        close()
    }
    
    convenience init(roundedRect rect: NSRect, byRoundingCorners corners: RectCorner, radius: CGFloat) {
        let radiusTopLeft = corners.contains(.topLeft) ? radius : 0
        let radiusTopRight = corners.contains(.topRight) ? radius : 0
        let radiusBottomLeft = corners.contains(.bottomLeft) ? radius : 0
        let radiusBottomRight = corners.contains(.bottomRight) ? radius : 0
        
        self.init(roundedRect: rect, topLeftRadius: radiusTopLeft, topRightRadius: radiusTopRight,
                  bottomLeftRadius: radiusBottomLeft, bottomRightRadius: radiusBottomRight)
    }
}
extension KFCrossPlatformImage {
    // macOS does not support scale. This is just for code compatibility across platforms.
    convenience init?(data: Data, scale: CGFloat) {
        self.init(data: data)
    }
}
#endif
#if canImport(UIKit)
import UIKit
extension RectCorner {
    var uiRectCorner: UIRectCorner {
        
        var result: UIRectCorner = []
        
        if contains(.topLeft) { result.insert(.topLeft) }
        if contains(.topRight) { result.insert(.topRight) }
        if contains(.bottomLeft) { result.insert(.bottomLeft) }
        if contains(.bottomRight) { result.insert(.bottomRight) }
        
        return result
    }
}
#endif
extension Date {
    var isPast: Bool {
        return isPast(referenceDate: Date())
    }
    var isFuture: Bool {
        return !isPast
    }
    func isPast(referenceDate: Date) -> Bool {
        return timeIntervalSince(referenceDate) <= 0
    }
    func isFuture(referenceDate: Date) -> Bool {
        return !isPast(referenceDate: referenceDate)
    }
    // `Date` in memory is a wrap for `TimeInterval`. But in file attribute it can only accept `Int` number.
    // By default the system will `round` it. But it is not friendly for testing purpose.
    // So we always `ceil` the value when used for file attributes.
    var fileAttributeDate: Date {
        return Date(timeIntervalSince1970: ceil(timeIntervalSince1970))
    }
}
//
//  Result.swift
//  Kingfisher
//
//  Created by onevcat on 2018/09/22.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
#if swift(>=4.3)
/// Result type already built-in
#else
/// A value that represents either a success or failure, capturing associated
/// values in both cases.
public enum Result<Success, Failure> {
    /// A success, storing a `Value`.
    case success(Success)
    /// A failure, storing an `Error`.
    case failure(Failure)
    /// Evaluates the given transform closure when this `Result` instance is
    /// `.success`, passing the value as a parameter.
    ///
    /// Use the `map` method with a closure that returns a non-`Result` value.
    ///
    /// - Parameter transform: A closure that takes the successful value of the
    ///   instance.
    /// - Returns: A new `Result` instance with the result of the transform, if
    ///   it was applied.
    public func map<NewSuccess>(
        _ transform: (Success) -> NewSuccess
        ) -> Result<NewSuccess, Failure> {
        switch self {
        case let .success(success):
            return .success(transform(success))
        case let .failure(failure):
            return .failure(failure)
        }
    }
    /// Evaluates the given transform closure when this `Result` instance is
    /// `.failure`, passing the error as a parameter.
    ///
    /// Use the `mapError` method with a closure that returns a non-`Result`
    /// value.
    ///
    /// - Parameter transform: A closure that takes the failure value of the
    ///   instance.
    /// - Returns: A new `Result` instance with the result of the transform, if
    ///   it was applied.
    public func mapError<NewFailure>(
        _ transform: (Failure) -> NewFailure
        ) -> Result<Success, NewFailure> {
        switch self {
        case let .success(success):
            return .success(success)
        case let .failure(failure):
            return .failure(transform(failure))
        }
    }
    /// Evaluates the given transform closure when this `Result` instance is
    /// `.success`, passing the value as a parameter and flattening the result.
    ///
    /// - Parameter transform: A closure that takes the successful value of the
    ///   instance.
    /// - Returns: A new `Result` instance, either from the transform or from
    ///   the previous error value.
    public func flatMap<NewSuccess>(
        _ transform: (Success) -> Result<NewSuccess, Failure>
        ) -> Result<NewSuccess, Failure> {
        switch self {
        case let .success(success):
            return transform(success)
        case let .failure(failure):
            return .failure(failure)
        }
    }
    /// Evaluates the given transform closure when this `Result` instance is
    /// `.failure`, passing the error as a parameter and flattening the result.
    ///
    /// - Parameter transform: A closure that takes the error value of the
    ///   instance.
    /// - Returns: A new `Result` instance, either from the transform or from
    ///   the previous success value.
    public func flatMapError<NewFailure>(
        _ transform: (Failure) -> Result<Success, NewFailure>
        ) -> Result<Success, NewFailure> {
        switch self {
        case let .success(success):
            return .success(success)
        case let .failure(failure):
            return transform(failure)
        }
    }
}
extension Result where Failure: Error {
    /// Returns the success value as a throwing expression.
    ///
    /// Use this method to retrieve the value of this result if it represents a
    /// success, or to catch the value if it represents a failure.
    ///
    ///     let integerResult: Result<Int, Error> = .success(5)
    ///     do {
    ///         let value = try integerResult.get()
    ///         print("The value is \(value).")
    ///     } catch error {
    ///         print("Error retrieving the value: \(error)")
    ///     }
    ///     // Prints "The value is 5."
    ///
    /// - Returns: The success value, if the instance represents a success.
    /// - Throws: The failure value, if the instance represents a failure.
    public func get() throws -> Success {
        switch self {
        case let .success(success):
            return success
        case let .failure(failure):
            throw failure
        }
    }
    /// Unwraps the `Result` into a throwing expression.
    ///
    /// - Returns: The success value, if the instance is a success.
    /// - Throws:  The error value, if the instance is a failure.
    @available(*, deprecated, message: "This method will be removed soon. Use `get() throws -> Success` instead.")
    public func unwrapped() throws -> Success {
        switch self {
        case let .success(value):
            return value
        case let .failure(error):
            throw error
        }
    }
}
extension Result where Failure == Swift.Error {
    /// Creates a new result by evaluating a throwing closure, capturing the
    /// returned value as a success, or any thrown error as a failure.
    ///
    /// - Parameter body: A throwing closure to evaluate.
    @_transparent
    public init(catching body: () throws -> Success) {
        do {
            self = .success(try body())
        } catch {
            self = .failure(error)
        }
    }
}
extension Result : Equatable where Success : Equatable, Failure: Equatable { }
extension Result : Hashable where Success : Hashable, Failure : Hashable { }
extension Result : CustomDebugStringConvertible {
    public var debugDescription: String {
        var output = "Result."
        switch self {
        case let .success(value):
            output += "success("
            debugPrint(value, terminator: "", to: &output)
        case let .failure(error):
            output += "failure("
            debugPrint(error, terminator: "", to: &output)
        }
        output += ")"
        return output
    }
}
#endif
// These helper methods are not public since we do not want them to be exposed or cause any conflicting.
// However, they are just wrapper of `ResultUtil` static methods.
extension Result where Failure: Error {
    /// Evaluates the given transform closures to create a single output value.
    ///
    /// - Parameters:
    ///   - onSuccess: A closure that transforms the success value.
    ///   - onFailure: A closure that transforms the error value.
    /// - Returns: A single `Output` value.
    func match<Output>(
        onSuccess: (Success) -> Output,
        onFailure: (Failure) -> Output) -> Output
    {
        switch self {
        case let .success(value):
            return onSuccess(value)
        case let .failure(error):
            return onFailure(error)
        }
    }
    func matchSuccess<Output>(with folder: (Success?) -> Output) -> Output {
        return match(
            onSuccess: { value in return folder(value) },
            onFailure: { _ in return folder(nil) }
        )
    }
    func matchFailure<Output>(with folder: (Error?) -> Output) -> Output {
        return match(
            onSuccess: { _ in return folder(nil) },
            onFailure: { error in return folder(error) }
        )
    }
    func match<Output>(with folder: (Success?, Error?) -> Output) -> Output {
        return match(
            onSuccess: { return folder($0, nil) },
            onFailure: { return folder(nil, $0) }
        )
    }
}
//
//  SizeExtensions.swift
//  Kingfisher
//
//  Created by onevcat on 2018/09/28.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import CoreGraphics
extension CGSize: KingfisherCompatibleValue {}
extension KingfisherWrapper where Base == CGSize {
    
    /// Returns a size by resizing the `base` size to a target size under a given content mode.
    ///
    /// - Parameters:
    ///   - size: The target size to resize to.
    ///   - contentMode: Content mode of the target size should be when resizing.
    /// - Returns: The resized size under the given `ContentMode`.
    public func resize(to size: CGSize, for contentMode: ContentMode) -> CGSize {
        switch contentMode {
        case .aspectFit:
            return constrained(size)
        case .aspectFill:
            return filling(size)
        case .none:
            return size
        }
    }
    
    /// Returns a size by resizing the `base` size by making it aspect fitting the given `size`.
    ///
    /// - Parameter size: The size in which the `base` should fit in.
    /// - Returns: The size fitted in by the input `size`, while keeps `base` aspect.
    public func constrained(_ size: CGSize) -> CGSize {
        let aspectWidth = round(aspectRatio * size.height)
        let aspectHeight = round(size.width / aspectRatio)
        
        return aspectWidth > size.width ?
            CGSize(width: size.width, height: aspectHeight) :
            CGSize(width: aspectWidth, height: size.height)
    }
    
    /// Returns a size by resizing the `base` size by making it aspect filling the given `size`.
    ///
    /// - Parameter size: The size in which the `base` should fill.
    /// - Returns: The size be filled by the input `size`, while keeps `base` aspect.
    public func filling(_ size: CGSize) -> CGSize {
        let aspectWidth = round(aspectRatio * size.height)
        let aspectHeight = round(size.width / aspectRatio)
        
        return aspectWidth < size.width ?
            CGSize(width: size.width, height: aspectHeight) :
            CGSize(width: aspectWidth, height: size.height)
    }
    
    /// Returns a `CGRect` for which the `base` size is constrained to an input `size` at a given `anchor` point.
    ///
    /// - Parameters:
    ///   - size: The size in which the `base` should be constrained to.
    ///   - anchor: An anchor point in which the size constraint should happen.
    /// - Returns: The result `CGRect` for the constraint operation.
    public func constrainedRect(for size: CGSize, anchor: CGPoint) -> CGRect {
        
        let unifiedAnchor = CGPoint(x: anchor.x.clamped(to: 0.0...1.0),
                                    y: anchor.y.clamped(to: 0.0...1.0))
        
        let x = unifiedAnchor.x * base.width - unifiedAnchor.x * size.width
        let y = unifiedAnchor.y * base.height - unifiedAnchor.y * size.height
        let r = CGRect(x: x, y: y, width: size.width, height: size.height)
        
        let ori = CGRect(origin: .zero, size: base)
        return ori.intersection(r)
    }
    
    private var aspectRatio: CGFloat {
        return base.height == 0.0 ? 1.0 : base.width / base.height
    }
}
extension CGRect {
    func scaled(_ scale: CGFloat) -> CGRect {
        return CGRect(x: origin.x * scale, y: origin.y * scale,
                      width: size.width * scale, height: size.height * scale)
    }
}
extension Comparable {
    func clamped(to limits: ClosedRange<Self>) -> Self {
        return min(max(self, limits.lowerBound), limits.upperBound)
    }
}
//
//  Box.swift
//  Kingfisher
//
//  Created by Wei Wang on 2018/3/17.
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
class Box<T> {
    var value: T
    
    init(_ value: T) {
        self.value = value
    }
}
//
//  String+MD5.swift
//  Kingfisher
//
//  Created by Wei Wang on 18/09/25.
//
//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
import Foundation
import CommonCrypto
extension String: KingfisherCompatibleValue { }
extension KingfisherWrapper where Base == String {
    var md5: String {
        guard let data = base.data(using: .utf8) else {
            return base
        }
        #if swift(>=5.0)
        let message = data.withUnsafeBytes { (bytes: UnsafeRawBufferPointer) in
            return [UInt8](bytes)
        }
        #else
        let message = data.withUnsafeBytes { bytes in
            return [UInt8](UnsafeBufferPointer(start: bytes, count: data.count))
        }
        #endif
        let MD5Calculator = MD5(message)
        let MD5Data = MD5Calculator.calculate()
        var MD5String = String()
        for c in MD5Data {
            MD5String += String(format: "%02x", c)
        }
        return MD5String
    }
}
// array of bytes, little-endian representation
func arrayOfBytes<T>(_ value: T, length: Int? = nil) -> [UInt8] {
    let totalBytes = length ?? (MemoryLayout<T>.size * 8)
    let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
    valuePointer.pointee = value
    let bytes = valuePointer.withMemoryRebound(to: UInt8.self, capacity: totalBytes) { (bytesPointer) -> [UInt8] in
        var bytes = [UInt8](repeating: 0, count: totalBytes)
        for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
            bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
        }
        return bytes
    }
    #if swift(>=4.1)
    valuePointer.deinitialize(count: 1)
    valuePointer.deallocate()
    #else
    valuePointer.deinitialize()
    valuePointer.deallocate(capacity: 1)
    #endif
    return bytes
}
extension Int {
    // Array of bytes with optional padding (little-endian)
    func bytes(_ totalBytes: Int = MemoryLayout<Int>.size) -> [UInt8] {
        return arrayOfBytes(self, length: totalBytes)
    }
}
extension NSMutableData {
    // Convenient way to append bytes
    func appendBytes(_ arrayOfBytes: [UInt8]) {
        append(arrayOfBytes, length: arrayOfBytes.count)
    }
}
protocol HashProtocol {
    var message: [UInt8] { get }
    // Common part for hash calculation. Prepare header data.
    func prepare(_ len: Int) -> [UInt8]
}
extension HashProtocol {
    func prepare(_ len: Int) -> [UInt8] {
        var tmpMessage = message
        // Step 1. Append Padding Bits
        tmpMessage.append(0x80) // append one bit (UInt8 with one bit) to message
        // append "0" bit until message length in bits ≡ 448 (mod 512)
        var msgLength = tmpMessage.count
        var counter = 0
        while msgLength % len != (len - 8) {
            counter += 1
            msgLength += 1
        }
        tmpMessage += [UInt8](repeating: 0, count: counter)
        return tmpMessage
    }
}
func toUInt32Array(_ slice: ArraySlice<UInt8>) -> [UInt32] {
    var result = [UInt32]()
    result.reserveCapacity(16)
    for idx in stride(from: slice.startIndex, to: slice.endIndex, by: MemoryLayout<UInt32>.size) {
        let d0 = UInt32(slice[idx.advanced(by: 3)]) << 24
        let d1 = UInt32(slice[idx.advanced(by: 2)]) << 16
        let d2 = UInt32(slice[idx.advanced(by: 1)]) << 8
        let d3 = UInt32(slice[idx])
        let val: UInt32 = d0 | d1 | d2 | d3
        result.append(val)
    }
    return result
}
struct BytesIterator: IteratorProtocol {
    let chunkSize: Int
    let data: [UInt8]
    init(chunkSize: Int, data: [UInt8]) {
        self.chunkSize = chunkSize
        self.data = data
    }
    var offset = 0
    mutating func next() -> ArraySlice<UInt8>? {
        let end = min(chunkSize, data.count - offset)
        let result = data[offset..<offset + end]
        offset += result.count
        return result.count > 0 ? result : nil
    }
}
struct BytesSequence: Sequence {
    let chunkSize: Int
    let data: [UInt8]
    func makeIterator() -> BytesIterator {
        return BytesIterator(chunkSize: chunkSize, data: data)
    }
}
func rotateLeft(_ value: UInt32, bits: UInt32) -> UInt32 {
    return ((value << bits) & 0xFFFFFFFF) | (value >> (32 - bits))
}
class MD5: HashProtocol {
    static let size = 16 // 128 / 8
    let message: [UInt8]
    init (_ message: [UInt8]) {
        self.message = message
    }
    // specifies the per-round shift amounts
    private let shifts: [UInt32] = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
                                    5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
                                    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
                                    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
    // binary integer part of the sines of integers (Radians)
    private let sines: [UInt32] = [0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
                                   0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
                                   0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
                                   0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
                                   0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
                                   0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
                                   0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
                                   0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
                                   0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
                                   0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
                                   0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05,
                                   0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
                                   0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
                                   0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
                                   0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
                                   0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391]
    private let hashes: [UInt32] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]
    func calculate() -> [UInt8] {
        var tmpMessage = prepare(64)
        tmpMessage.reserveCapacity(tmpMessage.count + 4)
        // hash values
        var hh = hashes
        // Step 2. Append Length a 64-bit representation of lengthInBits
        let lengthInBits = (message.count * 8)
        let lengthBytes = lengthInBits.bytes(64 / 8)
        tmpMessage += lengthBytes.reversed()
        // Process the message in successive 512-bit chunks:
        let chunkSizeBytes = 512 / 8 // 64
        for chunk in BytesSequence(chunkSize: chunkSizeBytes, data: tmpMessage) {
            // break chunk into sixteen 32-bit words M[j], 0 ≤ j ≤ 15
            let M = toUInt32Array(chunk)
            assert(M.count == 16, "Invalid array")
            // Initialize hash value for this chunk:
            var A: UInt32 = hh[0]
            var B: UInt32 = hh[1]
            var C: UInt32 = hh[2]
            var D: UInt32 = hh[3]
            var dTemp: UInt32 = 0
            // Main loop
            for j in 0 ..< sines.count {
                var g = 0
                var F: UInt32 = 0
                switch j {
                case 0...15:
                    F = (B & C) | ((~B) & D)
                    g = j
                    break
                case 16...31:
                    F = (D & B) | (~D & C)
                    g = (5 * j + 1) % 16
                    break
                case 32...47:
                    F = B ^ C ^ D
                    g = (3 * j + 5) % 16
                    break
                case 48...63:
                    F = C ^ (B | (~D))
                    g = (7 * j) % 16
                    break
                default:
                    break
                }
                dTemp = D
                D = C
                C = B
                B = B &+ rotateLeft((A &+ F &+ sines[j] &+ M[g]), bits: shifts[j])
                A = dTemp
            }
            hh[0] = hh[0] &+ A
            hh[1] = hh[1] &+ B
            hh[2] = hh[2] &+ C
            hh[3] = hh[3] &+ D
        }
        var result = [UInt8]()
        result.reserveCapacity(hh.count / 4)
        hh.forEach {
            let itemLE = $0.littleEndian
            let r1 = UInt8(itemLE & 0xff)
            let r2 = UInt8((itemLE >> 8) & 0xff)
            let r3 = UInt8((itemLE >> 16) & 0xff)
            let r4 = UInt8((itemLE >> 24) & 0xff)
            result += [r1, r2, r3, r4]
        }
        return result
    }
}
